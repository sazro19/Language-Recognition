<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Модифицируем процесс загрузки с помощью утилиты make-initrd / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/aktiv-company\/blog\/582606\/"},"headline":"Модифицируем процесс загрузки с помощью утилиты make-initrd","datePublished":"2021-10-11T15:01:33+03:00","dateModified":"2021-10-11T17:07:27+03:00","author":{"@type":"Person","name":"lo1ol"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по р...","url":"https:\/\/habr.com\/ru\/company\/aktiv-company\/blog\/582606\/#post-content-body","about":["c_aktiv-company","h_linux","h_infosecurity","h_sys_admin","f_develop","f_admin"],"image":["https:\/\/habr.com\/share\/publication\/582606\/a9931e7c6ed9df8b58c4045e0db40ef2\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/761\/2c6\/b7b\/7612c6b7bda35317dcd727d03f80bd6a.jpg"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Модифицируем процесс загрузки с помощью утилиты make-initrd" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Модифицируем процесс загрузки с помощью утилиты make-initrd" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Модифицируем процесс загрузки с помощью утилиты make-initrd" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/7bd/643/ff5/7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/7bd/643/ff5/7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/7bd/643/ff5/7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/7bd/643/ff5/7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/7bd/643/ff5/7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="582606" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-11T12:01:33.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/582606/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/aktiv-company/blog/582606/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/7bd/643/ff5/7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/582606/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="aktiv-company" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/aktiv-company/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/5da/5f8/38c/5da5f838c6b92a1684f90014cb7ca73d.png" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">94.12</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/aktiv-company/profile/" class="tm-company-card__name">
        «Актив»
      </a> <div class="tm-company-card__description"></div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/lo1ol/" title="lo1ol" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/e2c/f05/9eb/e2cf059eb3b4bbe410f9c12ba2125dfc.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/lo1ol/" class="tm-user-info__username">
      lo1ol
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-11T12:01:33.000Z" title="2021-10-11, 15:01">11  октября   в 15:01</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Модифицируем процесс загрузки с помощью утилиты make-initrd</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/aktiv-company/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании «Актив»</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/linux/" class="tm-article-snippet__hubs-item-link"><span>Настройка Linux</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/infosecurity/" class="tm-article-snippet__hubs-item-link"><span>Информационная безопасность</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/sys_admin/" class="tm-article-snippet__hubs-item-link"><span>Системное администрирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Tutorial
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>Модифицируем процесс загрузки с помощью утилиты make-initrd</p><p>В этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки Linux, а также познакомить с удобным и быстрым генератором initramfs образов - make-initrd.</p><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/761/2c6/b7b/7612c6b7bda35317dcd727d03f80bd6a.jpg" width="4364" height="2914" data-src="https://habrastorage.org/getpro/habr/upload_files/761/2c6/b7b/7612c6b7bda35317dcd727d03f80bd6a.jpg" data-blurred="true"/><figcaption></figcaption></figure><h2>Упрощенный процесс загрузки ОС Linux</h2><p>Загрузка ОС на устройстве с UEFI обычно проходит по следующему сценарию:</p><ol><li><p>Инициализация оборудования;</p></li><li><p>Размещение в оперативной памяти EFI загрузчика (например, grub) и передача управления ему;</p></li><li><p>EFI загрузчик записывает образ ядра в оперативную память и вызывает функцию start_kernel;</p></li><li><p>Ядро инициализирует себя, монтирует корень файловой системы и запускает процесс init, лежащий на корне (/init, /sbin/init или другой). Этим процессом может быть systemd, System V и другие;</p></li><li><p>Процесс init запускает сервисы и уже подготавливает систему для работы с пользователем.</p></li></ol><p>Такая схема является вполне работоспособной. Но что, если мы хотим усложнить сценарий загрузки? Например, загрузиться с зашифрованного раздела или сетевого диска или, элементарно, проверить файловую систему перед загрузкой. На помощь приходит initramfs!</p><h2>Что такое initramfs?</h2><p><strong>Initramfs (Initial ram file system)</strong> – образ файловой системы, загружаемый в оперативную память вместе с ядром. Основные задачи этого образа: монтирование реального корня файловой системы и запуск процесса init лежащего на нем.</p><p>При загрузке с initramfs ядро передает управление программе <code>/init</code>, лежащей в этом образе, а не в реальном корне. Разные initramfs образы могут иметь разную архитектуру: некоторые отрабатывают по фиксированному сценарию, а некоторые создают сложную инфраструктуру сервисов, работающих параллельно и взаимодействующие между собой.</p><p>Многие современные дистрибутивы Linux используют initramfs образы для загрузки системы. Вы можете убедиться в этом сами, найдя файл <code>/boot/{initrd,initramfs}*</code> в своем любимом дистрибутиве.</p><h2>Возможные сценарии использования initramfs</h2><p>Внутри initramfs образа могут реализовываться разнообразные сценарии загрузки ОС. Все они ограничены лишь возможностями Linux, характеристиками устройства и вашей фантазией.</p><p>Достаточно популярными и широко используемыми сценариями являются:</p><ul><li><p>Вывод приветственной картинки на экран;</p></li><li><p>Проверка целостности корневой файловой системы;</p></li><li><p>Загрузка с нестандартных файловых систем;</p></li><li><p>Загрузка с LVM;</p></li><li><p>Загрузка с RAID.</p></li></ul><p>К экзотическим можно отнести:</p><ul><li><p>Загрузку с образа корня, лежащего в интернете;</p></li><li><p>Загрузку с зашифрованного раздела;</p></li><li><p>Загрузку другой ОС с помощью системного вызова kexec.</p></li></ul><h2>Утилиты для создания initramfs образов</h2><p>Разные дистрибутивы используют разные утилиты для создания initrd образов. Debian обычно используют для этого initramfs-tools, Red Hat – Dracut. Но в этой статье я хочу представить другую, менее известную утилиту – make-initrd.</p><h2>Почему make-initrd?</h2><p><a href="https://github.com/osboot/make-initrd">make-initrd</a> – утилита для создания initramfs образов,  разрабатываемая нашим соотечественником Алексеем Гладковым. Сейчас она используется как основной сборщик initramfs в дистрибутиве ALT Linux.</p><p>Этот проект обладает рядом преимуществ:</p><ul><li><p><em>Имеет модульную структуру</em>. Разные логические части образа создаются разными модулями, именуемыми <strong>Features (фичами)</strong>. Например, есть фича luks, отвечающая за внедрение сценария загрузки с зашифрованных разделов LUKS.</p></li><li><p><em>Создаваемые initramfs образы имеют простое внутреннее устройство.</em></p></li><li><p><em>Удобен для использования конечным пользователем</em>. Многие части конфигурации определяются автоматически. Это достигается за счет отдельного модуля <strong>guess</strong>.</p></li><li><p><em>Утилита показала свою работоспособность на множестве различных дистрибутивов</em>. Нам лично удавалось собрать и использовать эту утилиту на Ubuntu, Fedora, ALT Linux, Red OS, Astra Linux.</p></li><li><p><em>Генерируемые initramfs образы имеют относительно небольшой размер, а их сборка происходит достаточно быстро</em> Для сравнения: initramfs-tools на моей машине генерирует образы размером 51Мб за 24 секунды. Образы же make-initrd весят всего 5Мб и создаются 10 секунд!</p></li><li><p><em>Проект продолжает активно развиваться</em>. Со временем появляются новые фичи, улучшается архитектура утилиты и архитектура initramfs образов. Разработчик идет на контакт и всегда рад вашим патчам и предложениям:)</p></li></ul><p>К сожалению, у make-initrd есть и недостатки:</p><ul><li><p><em>Не самая полная и достоверная </em><a href="https://github.com/osboot/make-initrd/tree/master/Documentation"><em>документация</em></a>;</p></li><li><p>Проект тестируется лишь на Fedora, Ubuntu и Alt Linux. И, хотя нам удавалось использовать его на других дистрибутивах, <em>нет гарантии, что все будет работать гладко и везде</em>.</p></li></ul><h2>Устройство initramfs образов, генерируемых make-initrd</h2><p>В этом разделе описаны основные сведения по архитектуре образов, генерируемых make-initrd.</p><h3>Сервисы</h3><p>Создаваемые образы имеют сервисно-ориентированную архитектуру. При передаче управления программе <code>/init</code> порождается дерево сервисов, которые в дальнейшем взаимодействуют между собой. Последовательность их запуска и завершения определяется в процессе сборки образа и настраивается с помощью конфигурационных файлов <a href="https://wiki.debian.org/LSBInitScripts">LSB</a>.</p><p>В системе есть несколько основных сервисов, на которых базируется основная логика работы:</p><ul><li><p><strong>udevd</strong> – <em>обработчик событий ядра об изменении состояния устройств</em>. При изменении состояния любого устройства он <strong>параллельно</strong> запускает <em>фильтры</em> (скрипты), добавляющие пользовательские события в очередь. Этот демон используется во многих дистрибутивах Linux.</p></li><li><p><strong>ueventd</strong> – <em>обработчик пользовательских событий</em>. Этот демон запускает обработчики пользовательских событий. События внутри одной очереди обрабатываются <strong>последовательно</strong>, а сами очереди – параллельно.</p></li><li><p><strong>polld</strong> – <em>демон, ожидающий выполнения условий загрузки системы</em>. Все, что он делает – один раз в заданное время проверяет условия запуска системы. Если они удовлетворены, запускается некоторый экшен. Скрипты проверки условий и экшена зависят от <em>метода загрузки</em>. Тем не менее, зачастую, их задача – проверить, что корень найден и переключить <em>runlevel</em> на второй уровень.</p></li></ul><h3>Runlevel</h3><p><strong>Runlevel</strong> определяет уровень запуска системы. Эти уровни отличаются от тех, что <a href="https://en.wikipedia.org/wiki/Runlevel#Linux_Standard_Base_specification">стандартно используются в Linux</a>. В make-initrd номер уровня зависит от состояния загрузки системы. А от номера уровня, в свою очередь, зависит то, какие сервисы будут активны в текущий момент. В make-initrd предусмотрено всего 3 уровня:</p><ul><li><p><strong>Уровень 3</strong> – означает, что <em>реальный корень системы еще не примонтирован</em>. На этом уровне происходит запуск и работа большинства сервисов.</p></li><li><p><strong>Уровень 2</strong> – означает, что <em>реальный корень системы уже примонтирован</em>. На этом происходит завершение большинства сервисов.</p></li><li><p><strong>Уровень 9</strong> – специальный уровень, на котором происходит <em>подмена корня системы на реальный и запуск </em><code>/sbin/init</code> на нем.</p></li></ul><p>Разберем пример загрузки с жесткого диска.</p><ol><li><p>После запуска <code>/init</code>, произойдет инициализация окружения: примонтируется файловая система <code>procfs</code> и установится <em>runlevel=3</em>;</p></li><li><p>Последовательно запускаются различные сервисы, среди которых будут <em>udevd</em>, <em>ueventd</em> и <em>polld</em>;</p></li><li><p>После обнаружения устройства жесткого диска ядро сгенерирует соответствующее событие для демона <em>udevd</em>;</p></li><li><p><em>udevd</em> просмотрит список своих правил. При нахождении правила на добавление блочного устройства запустится соответствующий обработчик (в make-initrd они называются фильтрами);</p></li><li><p>Внутри фильтра произойдет проверка, что устройство описано в <code>/etc/fstab</code>. Если это так, сгенерируется пользовательское событие на примонтирование этого устройства;</p></li><li><p>В какой-то момент <em>ueventd</em> запустит обработчик этого пользовательского события. Обработчик примонтирует жесткий диск;</p></li><li><p>Демон <em>polld</em> в очередной раз запустит скрипт проверки наличия корня. После его обнаружения запустится экшен, переключающий <em>runlevel на второй уровень</em>;</p></li><li><p>После переключения runlevel произойдет отключение большинства сервисов. Далее запустится сервис <em>runinit</em>, который установит <em>runlevel на девятый уровень</em>;</p></li><li><p>Процесс init произведет подмену корня и запустит <code>/sbin/init</code>;</p></li></ol><h3>Устройство файловой системы initramfs образов</h3><p>Initramfs образ, генерируемый make-initrd, имеет строгую структуру файловой системы. Поэтому при добавлении собственной фичи важно понимать, что и где должно лежать:</p><ul><li><p><code>/init</code> – программа, которой передается управление после инициализации ядра;</p></li><li><p><code>/bin/</code>, <code>/usr/bin/</code> – директории программ;</p></li><li><p><code>/sbin/</code>, <code>/usr/sbin/</code> – директории сервисов;</p></li><li><p><code>/etc/</code> – директория конфигураций;</p></li><li><p><code>/etc/rc.d/init.d/</code> – директория LSB конфигураций сервисов;</p></li><li><p><code>/etc/udev/rules.d/</code> – директория правил <em>udevd</em>;</p></li><li><p><code>/etc/initrd/method</code> – файл содержащий текущий метод загрузки;</p></li><li><p><code>/etc/initrd/cmdline.d/</code> – директория описаний аргументов ядра;</p></li><li><p><code>/lib/</code>, <code>/usr/lib/</code> – директории библиотек;</p></li><li><p><code>/lib/uevent/filters/</code> – директория фильтров <em>uevent</em> событий;</p></li><li><p><code>/lib/uevent/handler/</code> – директория обработчиков <em>uevent</em> событий;</p></li><li><p><code>/lib/initrd/boot/method/</code> – директория скриптов методов загрузки;</p></li><li><p><code>/lib/initrd/boot/method/*/check</code> – скрипт проверки условии активации метода загрузки;</p></li><li><p><code>/lib/initrd/boot/method/*/action</code> – скрипт активации метода загрузки;</p></li><li><p><code>/lib/initrd/boot/scripts/</code> – директория подскриптов проверки условий метода загрузки;</p></li><li><p><code>/.initrd/</code> – директория, которую могут использовать сервисы и программы для внутренней работы;</p></li><li><p><code>/tmp/</code> – директория временных файлов.</p></li></ul><h2>Устройство генератора initramfs образов</h2><p>Для организации действий по созданию initramfs образов make-initrd использует <code>make</code>. Поэтому весь процесс создания можно представить в виде последовательности выполняемых целей. Основными целями при создании образа являются:</p><ul><li><p><strong>process-config</strong> – Считывание конфигурационного файла. Во время ее выполнения происходит последовательный запуск целей guess и genimage;</p></li><li><p><strong>guess</strong> – Угадывание конфигурационного файла;</p></li><li><p><strong>create</strong> – Наполнение корня initramfs образа;</p></li><li><p><strong>pack</strong> – Сортировка сервисов и упаковка initramfs образа в cpio архив. Зависит от create;</p></li><li><p><strong>install</strong> – Установка образа в загрузочную директорию. Зависит от pack;</p></li><li><p><strong>genimage</strong> – Вывод информационного сообщения о сборке образа. Зависит от install.</p></li></ul><p>Процесс выполнения этих целей можно разбить на два больших этапа:</p><p>1. <em>Угадывание</em> дополнения к конфигурации (цель <em>guess</em>);</p><p>2. <em>Сборка</em> образа (цели <em>create – genimage</em>)</p><h3>Этап угадывания конфигурации</h3><p>Ручная конфигурация make-initrd - достаточно сложный процесс. Например, вам нужно указать модули ядра устройств, которые вы хотите использовать в initramfs. Также немаловажно правильно задать список используемых фич.</p><p>Неправильное задание конфигурации грозит тем, что initramfs образ может оказаться излишне "тяжелым", а загрузка ОС будет происходить медленнее или не происходить вовсе. Например, если вы активировали фичу <em>network</em>, но не используете сеть в процессе загрузки, это грозит вам лишними секундами на настройку сетевых интерфейсов.</p><p>Именно для решения этих проблем в make-initrd был добавлен модуль guess. Он помогает оптимально сгенерировать или дополнить существующую конфигурацию, основываясь на окружении компьютера.</p><p>Guess использует разные модули для определения разных сфер образа. Например:</p><ul><li><p><strong>device</strong> – определяет модули ядра устройств;</p></li><li><p><strong>keyboard</strong> – определяет модули ядра для работы с клавиатурой;</p></li><li><p><strong>net</strong> – определяет модули ядра сетевых устройств;</p></li><li><p><strong>root</strong> – определяет какие разделы нужно примонтировать, а также модули ядра для работы с ними;</p></li><li><p><strong>smart-card</strong> – определяет конфигурацию фичи smart-card;</p></li><li><p><strong>common</strong> – простой универсальный модуль, который может быть использован внутри фич.</p></li></ul><p>Этот список не является исчерпывающим: описание остальных модулей можно посмотреть в <code>README.md</code> файлах <a href="https://github.com/osboot/make-initrd/tree/master/guess">модулей guess</a>.</p><h3>Этап сборки initramfs образа</h3><p>Во время выполнения цели <em>create</em> создается временная директория, в которой заполняется корень initramfs образа. Корень заполняется в соответствии с переданной конфигурацией. Туда кладется все необходимое: приложения, библиотеки, файлы конфигурации и т.д. Но это еще не все: на последующих шагах корень еще будет дополняться.</p><p>Во время выполнения цели <em>pack</em> происходит определение порядка запуска и остановки сервисов. Этот порядок будет отражен в именах файлов директории <code>/etc/rc{0,1,2,3,4,5,6}.d</code>. Например, сервис /etc/rc3.d/S08:udev будет запущен восьмым при переходе в runlevel=3. Далее сформированная директория с корнем упаковывается в cpio архив, в который дополнительно помещаются специальные файлы: <code>/dev/ram</code>, <code>/dev/null</code>, <code>/dev/zero</code> и т.д.</p><p>Во время выполнения цели <em>install</em> полученный архив установится в директорию <code>/boot</code>.</p><p>Этап сборки образа может сколь угодно расширяться с помощью фич. Например, если активирована фича <em>compress</em>, то cpio архив будет дополнительно сжат с помощью одного из методов: gzip, lzma, bzip2 и т.п.</p><h3>Фичи</h3><p><strong>Фича</strong> – это независимый модуль сборщика initramfs образов. Фичи могут воздействовать практически на любой этап сборки образа. Например:</p><ul><li><p>фича <em>compress</em> позволяет сжимать итоговый образ;</p></li><li><p>фича <em>luks</em> добавляет в initramfs утилиты и модули для работы с luks;</p></li><li><p>фича <em>clean</em> – очищает после себя рабочую директорию.</p></li></ul><p>Такая высокая модульность достигается за счет того, что make-initrd для организации своих действий использует <code>make</code>.</p><h3>Структура проекта make-initrd</h3><p>Выгрузим проект make-initrd из репозитория и посмотрим на его содержимое</p><pre><code class="bash"># Выгружаем исходники
git clone https://github.com/osboot/make-initrd --recursive</code></pre><p>Проект make-initrd очень хорошо структурирован. Давайте опишем, за что отвечают различные файлы и директории в проекте:</p><ul><li><p><code>data/</code> – постоянная часть корня initramfs образа. Файлы, находящиеся в ней, будут присутствовать внутри почти всех образов;</p></li><li><p><code>datasrc/</code> – исходники утилит, устанавливаемые внутрь образа;</p></li><li><p><code>mk/config.mk</code> – Makefile c постоянной частью конфигурации make-initrd (переменные путей и т.п.);</p></li><li><p><code>mk/functions.mk</code> – Makefile с вспомогательными функциями make;</p></li><li><p><code>mk/make-initrd.mk</code> – основной Makefile описывающий правила сборки initramfs образа;</p></li><li><p><code>tools/</code> – внутренние утилиты make-initrd;</p></li><li><p><code>utils/</code> – исходники внешних утилит make-initrd;</p></li><li><p><code>guess/</code> – директория guess модулей;</p></li><li><p><code>guess/*/config.mk</code> – Makefile с описанием конфигурации guess модуля (переменные модуля, правила его активации). Он подключается вне зависимости от того, активен ли guess модуль или нет;</p></li><li><p><code>guess/*/rules.mk</code> – Makefile с описанием правил отработки guess модуля. Он подключается, только если guess модуль активен;</p></li><li><p><code>features/</code> – директория фич;</p></li><li><p><code>features/*/data/</code> – часть корня initramfs образа, предоставляемая фичей;</p></li><li><p><code>features/*/datasrc/</code> – исходники утилит фичи, устанавливаемые внутрь initramfs;</p></li><li><p><code>features/*/guess/</code> – подскрипты модулей guess;</p></li><li><p><code>features/*/bin/</code> – вспомогательный утилиты сборки initramfs образа;</p></li><li><p><code>features/*/config.mk</code> – Makefile с конфигурацией фичи (описание зависимых фич, переменных и т.п.). Он подключается вне зависимости от того, активна ли фича или нет;</p></li><li><p><code>features/*/rules.mk</code> – Makefile с правилами сборки фичи. Он подключается только в случае, если фича активна.</p></li></ul><h2>Установка make-initrd</h2><pre><code class="bash"># Установим зависимые пакеты
sudo apt-get install make automake pkg-config udev libkmod-dev libz-dev libbz2-dev liblzma-dev libzstd-dev libelf-dev libtirpc-dev libcrypt-dev help2man gcc opensc pcscd libpcsclite1

# Соберем проект
./autogen.sh
./configure
make
# Установим его
sudo make install</code></pre><h2>Сборка initramfs и запуск на реальной машине</h2><blockquote><p><strong>ПРЕДУПРЕЖДЕНИЕ</strong> Перед генерацией initramfs образа обязательно сделайте backup. </p><p>Если система перестанет загружаться, откройте раздел с <code>/boot</code> на другой системе (например, через загрузочную флешку) и верните backup на место. Если вы не сделали backup, попробуйте загрузиться с помощью другого ядра. Это может сработать, так как по-умолчанию make-initrd собирает initramfs только для текущего ядра.</p></blockquote><pre><code class="bash"># Backup текущего initramfs образа
cp /boot/initrd.img-$(uname-r) /media/flash/initrd.backup
# Запуск сборки
sudo make-intird</code></pre><p>Перезапустим систему и попробуем загрузиться c ядра, для которого мы сгенерировали initramfs образ.</p><h2>Добавление собственной фичи</h2><p>Чтобы лучше разобраться с тем, как устроены фичи, давайте напишем свою – hello-usb.</p><h3>Фича Hello USB</h3><blockquote><p><strong>Примечание</strong> Исходный код фичи hello-usb можно взять <a href="https://github.com/lo1ol/make-initrd/tree/hello-usb/features/hello-usb">здесь</a>.</p></blockquote><p>Напишем фичу hello-usb, добавляющую в initramfs функционал вывода сообщения “Hello USB!” при нахождении USB-устройства. Также добавим возможность указывать имя производителя устройства, для которого выводится сообщение.</p><p>Внутренняя логика работы нашей фичи, следующая:</p><ol><li><p>Контроль добавления нового USB-устройства осуществляется с помощью udev правила <code>/etc/udev/rules.d/99-hello-usb.rules</code>: при добавлении любого USB-устройства вызывается фильтр <code>/lib/uevent/filter/hello-usb</code></p></li><li><p>Внутри фильтра создается uevent событие hello-usb</p></li><li><p>Это событие обрабатывает специальный обработчик <code>/lib/uevent/handler/hello-usb</code>, который выводит в консоль сообщение "Hello USB!". Вывод происходит, только если производитель устройства совпал с тем, что передан в аргументе ядра <strong>usb-vendor</strong>.</p></li></ol><p>Дерево файлов фичи следующее:</p><pre><code class="bash">feature/hello-usb/config.mk
feature/hello-usb/rules.mk
feature/hello-usb/data/etc/initrd/cmdline.d/hello-usb
feature/hello-usb/data/etc/udev/rules.d/99-hello-usb.rules
feature/hello-usb/data/lib/uevent/filters/hello-usb
feature/hello-usb/data/lib/uevent/handlers/060-hello-usb</code></pre><p><code>config.mk</code> содержит описание фичи:</p><pre><code class="bash"># Зависимость от фичи usb
$(call feature-requires,usb)

# Путь до директории корневых данных фичи hello-usb
HELLO_USB_DATADIR   ?= $(FEATURESDIR)/hello-usb/data</code></pre><p>Через функцию <code>feature-requires</code> можно указывать зависимые фичи. Мы хотели получить модули ядра и udev-правила для работы с USB-устройствами, поэтому добавили в зависимости фичу usb.</p><p><code>rules.mk</code> содержит правила сборки фичи:</p><pre><code class="bash"># Вывод сообщения
hello-usb-show-info:
    @$(MSG) "Hello USB feature is activated ..."

# Вывод сообщения происходит перед упаковкой образа 
pack: hello-usb-show-info

# Запоминаем директорию, которую хотим использовать, как часть корня
PUT_FEATURE_DIRS  += $(HELLO_USB_DATADIR)
# Также в initrd можность класть программы, библиотеки, директории и файлы с помощью PUT_FEATURE_PROGS, PUT_FEATURE_LIBS, PUT_FEATURE_FILES, соответственно</code></pre><p><code>feature/hello-usb/etc/initrd/cmdline.d/hello-usb</code> – регистрирует опцию ядра <strong>usb-vendor</strong>:</p><pre><code class="bash">register_parameter string USB_VENDOR</code></pre><p>Помимо регистрации единичного аргумента можно зарегистрировать массив (<code>register_array</code>). Допустимо использовать аргументы типа: <code>string</code>, <code>bool</code>, <code>number</code>.</p><p><code>feature/hello-usb/etc/udev/rules.d/99-hello-usb.rules</code> – udev правило, запускающее фильтр. Число в начале имени нужно для задания порядка его обработки. В нашем случае было важно, чтобы правило hello-usb отработало позже, чем 60-fido-id (т.к. оно выставляет тег <code>security-device</code>). Поэтому мы выставили любое число больше 60 – это 99.</p><pre><code class="bash">SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", ACTION=="add", RUN+="/lib/uevent/filters/hello-usb"</code></pre><p>Подробнее о udev правилах можно прочитать <a href="https://www.arccomm.ru/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-udev">здесь</a>.</p><p><code>feature/hello-usb/data/lib/uevent/filters/hello-usb</code> – фильтр:</p><pre><code class="bash">#!/bin/bash
. uevent-sh-functions

# Создаем событие добавления USB-устройства
event="$(make_event)"
# Событие -- это файл хранящий переменные внутри себя
echo "VENDOR=$ID_VENDOR" >> "$event"
release_event hello-usb "$event"</code></pre><p>Обратите внимание на простоту этого скрипта. Это связано с тем, что udev может запустить несколько таких скриптов одновременно, а это может привести к состоянию гонки. Именно поэтому логика большинства фильтров крайне проста – передать событие uevent, который обработает его последовательно.</p><p><code>feature/hello-usb/lib/uevent/handlers/060-hello-usb</code> – обработчик события hello-usb. Uevent передает управление обработчикам в соотвествии с их номером. В нашем случае порядок обработки нашего события не важен, и мы выставили случайный номер – 60.</p><pre><code class="bash">#!/bin/bash

. /.initrd/initenv
. uevent-sh-functions
. initrd-sh-functions
. rdshell-sh-functions

# функция обработки вставки USB-устройства
handler() {
	# проверяем совпадение имени производителя, если оно задано
	[ -n "$USB_VENDOR" ] &amp;&amp; [ "$VENDOR" != "$USB_VENDOR" ] &amp;&amp; return 0

	echo "Hello USB!"

	return 0
}

# Заблокируем вывод в консоль другим приложениям
while ! console_lock; do
	sleep 0.5
done

# Перенаправим I/O обработчика в консоль
exec 0&lt;/dev/console >/dev/console 2>&amp;1

rc=0
# Отфильтровываем события hello-usb
for e in "$eventdir"/hello-usb.*; do
	[ -f "$e" ] || break
	r=0
	# Запускаем функцию-обработчик с заданным окружением
	( . "$e"; handler; ) || r="$?"
	case "$r" in
		# Событие остается в очереди
		1) rc=1 ;;
        	# Удаляем событие из очереди
        	0) done_event "$e" ;;
	esac
done

# Открываем доступ к консоли
console_unlock
exit $rc
```

Соберем make-initrd с добавленной фичей:
```bash
make &amp;&amp; sudo make install</code></pre><p>Соберем make-initrd с добавленной фичей:</p><pre><code class="bash">make &amp;&amp; sudo make install</code></pre><h2>Настройка и генерация initrd образа</h2><p>Сконфигурировать make-initrd можно через файл <code>/etc/intird.mk</code>. При генерации образа вы можете изменить путь до файла с конфигурацией, запустив make-initrd с опцией <code>-с</code>:</p><pre><code class="bash">sudo make-initrd -c /path/to/config</code></pre><p>Обычно файл с конфигурацией выглядит следующим образом:</p><pre><code class="bash">$ cat /etc/initrd.mk
# trying to detect modules and features to access to root volume
AUTODETECT = all</code></pre><p>Здесь написано, что вся конфигурация будет определена автоматически. Увидеть "угаданную" конфигурацию можно с помощью команды:</p><pre><code class="bash">sudo make-initrd guess-config</code></pre><p>Вы можете попросить make-initrd запускать только определенные guess модули. Например, можно попросить "угадывать" только модули ядра и фичи необходимые для монтирования корня и работы с клавиатурой:</p><pre><code class="bash">AUTODETECT = root keyboard</code></pre><p>Попробуем теперь собрать intird образ вместе с фичей <strong>hello-usb</strong>. Подправим конфигурацию</p><pre><code class="bash">AUTODETECT = all
FEATURES += hello-usb</code></pre><p>И запустим сборку образа:</p><pre><code class="bash">$ sudo make-initrd
> # Считывается конфигурация
> [00:00:00] Config file: /etc/initrd.mk
> # Запускается guess модуль. Определяются недостающие части конфигурации
> [00:00:01] Guessing config ...
> [00:00:01] Generating module dependencies on host ...
> [00:00:04] Guessing is complete
> # Переход к шагу genimage
> [00:00:04] Creating initrd image ...
> [00:00:06] Putting udev rules ...
> [00:00:06] Putting modules ...
> [00:00:06] Generating module dependencies in image …
> # Выполнение rules.mk фичи hello-usb
> [00:00:07] hello-usb feature is activated ...
> # Определяется порядок запуска и остановки сервисов
> [00:00:07] Sorting sysvinit services …
> # Упаковка образа в архив
> [00:00:08] Packing image to archive ...
> [00:00:08] Writing build info files …
> # Сжатие архива
> [00:00:08] Compressing image ...
> [00:00:19] Adding CPU microcode …
> # Список активированных фич
> [00:00:19] Used features: add-modules add-udev-rules buildinfo cleanup compress depmod-image hello-usb network rdshell rootfs system-glibc ucode usb
> # Список используемых модулей ядра
> [00:00:19] Packed modules: ahci cqhci evbug hid hid-apple hid-generic input-leds libahci mac_hid sdhci sdhci-pci serio_raw uas usbhid usb-storage xhci-pci xhci-pci-renesas
> # Установка образа в директорию /boot
> [00:00:19] Installing image ...
> [00:00:19] Unpacked size: 47M
> [00:00:19] Image size: 14M
> [00:00:19] Removing work directory ...
> [00:00:19] Image is saved as /boot/initrd.img-5.11.0-31-generic</code></pre><p>Перейдем к проверке нашего образа на виртуальной машине.</p><h2>Запуск в qemu</h2><p>Проверку образа будем производить с помощью qemu. Установим необходимые пакеты:</p><pre><code class="bash">sudo apt-get install qemu-system-x86 qemu-kvm</code></pre><p>В процессе работы мы планируем пробрасывать USB-устройство на виртуальную машину. Чтобы это сделать, необходимо узнать его адрес на USB-шине:</p><pre><code class="bash">$ lsusb -t
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/6p, 5000M
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/12p, 480M
    |__ Port 1: Dev 2, If 0, Class=Chip/SmartCard, Driver=, 480M
    |__ Port 2: Dev 14, If 0, Class=Mass Storage, Driver=usb-storage, 480M
    |__ Port 3: Dev 29, If 0, Class=Vendor Specific Class, Driver=r8152, 480M
    |__ Port 5: Dev 4, If 0, Class=Video, Driver=uvcvideo, 480M
    |__ Port 5: Dev 4, If 1, Class=Video, Driver=uvcvideo, 480M
    |__ Port 8: Dev 5, If 1, Class=Wireless, Driver=btusb, 12M
    |__ Port 8: Dev 5, If 0, Class=Wireless, Driver=btusb, 12M</code></pre><p>Мы хотим пробросить устройство, имеющее класс <code>Mass Storage</code> (флешку). В нашем случае оно находится на первой шине и втором порту.</p><p>Перейдем к запуску:</p><pre><code class="bash"># Указываем путь до ядра
# Указываем путь до initramfs образа
# Указываем Размер оперативной памяти виртуальной машины в мегабайтах
# Включаем KVM
# Добавляем эмуляцию USB-контроллера
# Указываем протокол работы контроллера (ehci. Для xhci передаем "-device qemu-xhci")
# Указываем путь до пробрасываемемого устройства
sudo qemu-system-x86_64 -kernel /boot/vmlinuz-$(uname -r) \
    -initrd /boot/initrd.img-$(uname -r) \
    -m 1024 \
    -cpu host \
    -enable-kvm \
    -usb \
    -device usb-ehci,id=ehci \
    -device usb-host,hostbus=1,hostport=2</code></pre><p>После запуска системы сначала отобразится вывод ядра, а затем вывод самого initrd. Если вы все сделали правильно, в какой-то момент увидите вывод обработчика событий hello-usb:</p><pre><code class="bash">[    1.461950] Run /init as init process
[    1.325924] INITRAMFS: version 2.22.0
[    1.340645] INIT: Entering runlevel: 3
[    1.357308] Starting shell service:                      [ DONE ]
[    1.430040] Parsing cmdline arguments:                   [ DONE ]
[    1.489825] Creating /etc/fstab:                         [ DONE ]
[    1.524020] Mounting filesystem [/dev]:                  [ DONE ]
[    1.554917] Mounting filesystem [/sys]:                  [ DONE ]
[    1.601215] Mounting filesystem [/run]:                  [ DONE ]
[    1.674068] Starting polld service:                      [ DONE ]
[    1.745135] Setting kernel runtime parameters:           [ DONE ]
[    1.786626] Loading modules:                             [ DONE ]
[    1.824191] Starting udevd service:                      [ DONE ]
[    2.545714] Starting ueventd service:                    [ DONE ]
[    3.067812] Network up (lo):                 `           [ DONE ]
Hello USB!
Hello USB!
Hello USB!
Hello USB!</code></pre><p>На этом, увы, ваша система зависнет:) Это связано с тем, что initramfs будет продолжать искать устройство с корнем, но оно не проброшено в qemu. К счастью, есть возможность экстренно перейти в rescue консоль: для этого надо нажать клавиши ** + **.</p><p>В ней можно изучить окружение initramfs образа:</p><p>* Убедитесь, что файловая структура, описанная ранее, соответствует действительности;</p><p>* Изучите список активных процессов;</p><p>* Посмотрите логи в <code>/var/log/</code>;</p><p>* Посмотрите содержимое других файлов.</p><p>Вы всегда можете запустить rescue консоль, если имеются какие-либо проблемы при запуске. В ней возможно:</p><ul><li><p>Изучить логи сервисов;</p></li><li><p>Примонтировать корень вручную и запуститься с него;</p></li><li><p>Запустить отладчик (если добавлена фича debug-tools).</p></li></ul><h2>Передача аргументов ядра</h2><p>Для передачи аргументов ядра в qemu есть специальная опция <code>-append</code>. Укажем с помощью нее имя производителя USB-устройства, для которого мы хотим вывести сообщение “Hello USB!”. Его можно получить так:</p><pre><code class="bash"># Узнаем номер USB-устройства -- значение  Dev
$ lsusb -t
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/6p, 5000M
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/12p, 480M
    |__ Port 1: Dev 2, If 0, Class=Chip/SmartCard, Driver=, 480M
    |__ Port 2: Dev 14, If 0, Class=Mass Storage, Driver=usb-storage, 480M
    |__ Port 3: Dev 29, If 0, Class=Vendor Specific Class, Driver=r8152, 480M
    |__ Port 5: Dev 4, If 0, Class=Video, Driver=uvcvideo, 480M
    |__ Port 5: Dev 4, If 1, Class=Video, Driver=uvcvideo, 480M
    |__ Port 8: Dev 5, If 1, Class=Wireless, Driver=btusb, 12M
    |__ Port 8: Dev 5, If 0, Class=Wireless, Driver=btusb, 12M

# Номер шины
$ BUS=001
# Номер устройства
$ DEV=014
$ udevadm info --name /dev/bus/usb/${BUS}/${DEV} | grep "ID_VENDOR="
E: ID_VENDOR=Aktiv</code></pre><p>Запустим qemu с аргументом ядра usb-vendor</p><pre><code class="bash">sudo qemu-system-x86_64 -kernel /boot/vmlinuz-$(uname -r) \
    -initrd /boot/initrd.img-$(uname -r) \
    -m 1024 \
    -cpu host \
    -enable-kvm \
    -usb \
    -device usb-ehci,id=ehci \
    -device usb-host,hostbus=1,hostport=2 \
    -append "usb-vendor=Aktiv"</code></pre><p>Заметьте, если указать другое имя производителя, то в лог может ничего не вывестись.</p><p>Популярные опции ядра, которые поддерживает initramfs можно посмотреть <a href="https://github.com/lo1ol/make-initrd/blob/master/Documentation/BootParameters.md">здесь</a></p><h2>Проверка на реальной машине</h2><p>После того, как вы убедились, что initramfs образ работает в qemu, можно проверить его на реальной машине. Но здесь могут возникнуть некоторые нюансы.</p><p>Дело в том, что аргументы ядра, которые мы передавали в qemu с помощью опции <code>-append</code>, на реальной машине передаются не так просто. Обычно этим занимается UEFI загрузчик (GRUB, LILO rEFInd, nsh скрипт для UEFI Shell и т.д.) и настройка передаваемых опций ядра для каждого загрузчика производится по-разному.</p><p>Мы покажем, как это сделать, на примере GRUB.</p><h3>Настройка аргументов ядра в GRUB</h3><p>GRUB использует двухуровневую конфигурацию. Первый уровень – это файл <code>/etc/default/grub</code> (путь до этого файла дистрибутивозависим). На основании этого файла генерируется конфигурация второго уровня – <code>/boot/grub/</code>, которую и используется непосредственно grub.</p><p>Откроем файл /etc/default/grub. Его содержимое выглядит примерно следующим образом:</p><pre><code class="bash"># Номер пункта в меню загрузки, загружаемый по-умолчанию
GRUB_DEFAULT=0
# Что выводить во время обратного отсчета
GRUB_TIMEOUT_STYLE=hidden
# Количество секунд перед загрузкой по-умолчанию
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
# Аргументы ядра используемые при нормальной загрузке
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
# Аргументы ядра, используемые при нормальной загрузке и в recovery mode
GRUB_CMDLINE_LINUX=""</code></pre><p>Подробнее об опциях grub можно прочитать <a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Simple-configuration">здесь</a></p><p>Для генерации конфигурации второго уровня выполним команду:</p><pre><code class="bash">sudo update-grub</code></pre><p>Разбор полученной конфигурации является уже более сложной задачей и выходит за рамки этой статьи. Тем не менее посмотреть на файл <code>/boot/grub/grub.cfg</code> все равно будет полезно:) Подробную информацию о его конфигурации grub можно найти <a href="https://www.gnu.org/software/grub/manual/grub/grub.html">здесь</a>.</p><p>Добавим в аргументы ядра, параметр <em>usb-vendor</em>. Для этого зададим в файле <code>/etc/default/grub</code> переменную <code>GRUB_CMDLINE_LINUX_DEFAULT</code>:</p><pre><code class="bash">GRUB_CMDLINE_LINUX_DEFAULT="nosplash usb-vendor=Aktiv"</code></pre><p>И снова обновим конфигурацию:</p><pre><code class="bash">sudo update-grub</code></pre><p>Перезапустите систему и посмотрите на результат.</p><h2>Вывод</h2><p>Естественно, фича <code>hello-usb</code> не раскрывает всю мощь использования make-initrd. Если вы хотите рассмотреть более живые примеры фич, посмотрите исходники фич:</p><ul><li><p><a href="https://github.com/osboot/make-initrd/tree/master/features/sshfsroot">sshfsroot</a>. – фича для загрузки с сетевых дисков по протоколу ssh;</p></li><li><p><a href="https://github.com/osboot/make-initrd/tree/master/features/luks">luks</a> – фича для загрузки с зашифрованных разделов;</p></li><li><p><a href="https://github.com/osboot/make-initrd/tree/master/features/raid/data/lib/uevent/handlers">raid</a> – фича для загрузки с raid разделов.</p></li></ul><p>В первые две, кстати, мы недавно добавили возможность для аутентификации по смарт-карте.</p><p>Обратите внимание насколько архитектура этих фичей совпадает с той, что мы реализовывали в hello-usb. Такая структурированность упрощает процесс разработки, и вы можете опираться на нее.</p><p>Make-initrd также удобен и для конечного использования. Такая крупная ОС, как ALT Linux, использует его в своих дистрибутивах в качестве основного генератора initramfs образов, в частности на таких продуктах, как “Альт Рабочая станция” и “Альт Сервер”. Это ли не показывает его широкую направленность? </p><p>На десктопных платформах вы можете добиться желаемого с помощью пары строк в конфигурационном файле, а порой полностью автоматически. Хотите добавить загрузку c сетевого раздела, используя sshfs? Просто напишите <code>FEATURE += sshfsroot</code> в файле конфигурации, а в опциях ядра укажите адрес сервера. Хотите добавить загрузку с RAID или LVM разделов? Ничего делать не надо! Если ваш корень лежит на таком разделе, make-initrd автоматически подберет правильную конфигурацию.</p><p>На серверных решениях вы можете добиться быстрой загрузки за счет высокой конфигурируемости образов. Вы всегда можете отключить любые ненужные вам фичи, тормозящие загрузку вашей системы. За счет обилия имеющегося функционала можно реализовать загрузку практически любой сложности. А если какого-то функционала будет не хавать, можно быстро реализовать его самостоятельно.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0%20linux%5D" class="tm-tags-list__link">загрузка linux</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Binitrd%5D" class="tm-tags-list__link">initrd</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Binitramfs%5D" class="tm-tags-list__link">initramfs</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bbash%5D" class="tm-tags-list__link">bash</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bmake%5D" class="tm-tags-list__link">make</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Blinux%5D" class="tm-tags-list__link">linux</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C%5D" class="tm-tags-list__link">безопасность</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/aktiv-company/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании «Актив»
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/linux/" class="tm-hubs-list__link">
    Настройка Linux
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/infosecurity/" class="tm-hubs-list__link">
    Информационная безопасность
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/sys_admin/" class="tm-hubs-list__link">
    Системное администрирование
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 10: ↑10 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 10: ↑10 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+10</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">3.3K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    49
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/aktiv-company/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/5da/5f8/38c/5da5f838c6b92a1684f90014cb7ca73d.png" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/aktiv-company/profile/" class="tm-company-snippet__title">«Актив»</a> <div class="tm-company-snippet__description">Компания</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <!----> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/lo1ol/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/e2c/f05/9eb/e2cf059eb3b4bbe410f9c12ba2125dfc.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 16 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    14
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">10</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/lo1ol/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @lo1ol
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/aktiv-company/blog/582606/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 4 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><span>
      1994
    </span></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://aktiv-company.ru/" target="_blank" class="tm-company-basic-info__link">
      aktiv-company.ru
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    101–200 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2011-12-14T11:48:34.000Z" title="2011-12-14, 15:48">14  декабря  2011</time></dd></dl> <!----></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/aktiv-company/blog/582606/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/aktiv-company/blog/582606/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"582606":{"id":"582606","timePublished":"2021-10-11T12:01:33+00:00","isCorporative":true,"lang":"ru","titleHtml":"Модифицируем процесс загрузки с помощью утилиты make-initrd","leadData":{"textHtml":"\u003Cp\u003EВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки Linux, а также познакомить с удобным и быстрым генератором initramfs образов - make-initrd.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7bd\u002F643\u002Fff5\u002F7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7bd\u002F643\u002Fff5\u002F7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg","fit":"cover","positionY":100,"positionX":0.64102564102564}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":14,"votesCount":16},"rating":10,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2105529","alias":"lo1ol","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fe2c\u002Ff05\u002F9eb\u002Fe2cf059eb3b4bbe410f9c12ba2125dfc.jpg","speciality":"Пользователь"},"statistics":{"commentsCount":4,"favoritesCount":49,"readingCount":3269,"score":10,"votesCount":10},"hubs":[{"relatedData":null,"id":"17446","alias":"aktiv-company","type":"corporative","title":"Блог компании «Актив»","titleHtml":"Блог компании «Актив»","isProfiled":false},{"relatedData":null,"id":"36","alias":"linux","type":"collective","title":"Настройка Linux","titleHtml":"Настройка Linux","isProfiled":true},{"relatedData":null,"id":"50","alias":"infosecurity","type":"collective","title":"Информационная безопасность","titleHtml":"Информационная безопасность","isProfiled":true},{"relatedData":null,"id":"221","alias":"sys_admin","type":"collective","title":"Системное администрирование","titleHtml":"Системное администрирование","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EМодифицируем процесс загрузки с помощью утилиты make-initrd\u003C\u002Fp\u003E\u003Cp\u003EВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки Linux, а также познакомить с удобным и быстрым генератором initramfs образов - make-initrd.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F761\u002F2c6\u002Fb7b\u002F7612c6b7bda35317dcd727d03f80bd6a.jpg\" width=\"4364\" height=\"2914\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F761\u002F2c6\u002Fb7b\u002F7612c6b7bda35317dcd727d03f80bd6a.jpg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Ch2\u003EУпрощенный процесс загрузки ОС Linux\u003C\u002Fh2\u003E\u003Cp\u003EЗагрузка ОС на устройстве с UEFI обычно проходит по следующему сценарию:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EИнициализация оборудования;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EРазмещение в оперативной памяти EFI загрузчика (например, grub) и передача управления ему;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EEFI загрузчик записывает образ ядра в оперативную память и вызывает функцию start_kernel;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЯдро инициализирует себя, монтирует корень файловой системы и запускает процесс init, лежащий на корне (\u002Finit, \u002Fsbin\u002Finit или другой). Этим процессом может быть systemd, System V и другие;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПроцесс init запускает сервисы и уже подготавливает систему для работы с пользователем.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EТакая схема является вполне работоспособной. Но что, если мы хотим усложнить сценарий загрузки? Например, загрузиться с зашифрованного раздела или сетевого диска или, элементарно, проверить файловую систему перед загрузкой. На помощь приходит initramfs!\u003C\u002Fp\u003E\u003Ch2\u003EЧто такое initramfs?\u003C\u002Fh2\u003E\u003Cp\u003E\u003Cstrong\u003EInitramfs (Initial ram file system)\u003C\u002Fstrong\u003E – образ файловой системы, загружаемый в оперативную память вместе с ядром. Основные задачи этого образа: монтирование реального корня файловой системы и запуск процесса init лежащего на нем.\u003C\u002Fp\u003E\u003Cp\u003EПри загрузке с initramfs ядро передает управление программе \u003Ccode\u003E\u002Finit\u003C\u002Fcode\u003E, лежащей в этом образе, а не в реальном корне. Разные initramfs образы могут иметь разную архитектуру: некоторые отрабатывают по фиксированному сценарию, а некоторые создают сложную инфраструктуру сервисов, работающих параллельно и взаимодействующие между собой.\u003C\u002Fp\u003E\u003Cp\u003EМногие современные дистрибутивы Linux используют initramfs образы для загрузки системы. Вы можете убедиться в этом сами, найдя файл \u003Ccode\u003E\u002Fboot\u002F{initrd,initramfs}*\u003C\u002Fcode\u003E в своем любимом дистрибутиве.\u003C\u002Fp\u003E\u003Ch2\u003EВозможные сценарии использования initramfs\u003C\u002Fh2\u003E\u003Cp\u003EВнутри initramfs образа могут реализовываться разнообразные сценарии загрузки ОС. Все они ограничены лишь возможностями Linux, характеристиками устройства и вашей фантазией.\u003C\u002Fp\u003E\u003Cp\u003EДостаточно популярными и широко используемыми сценариями являются:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EВывод приветственной картинки на экран;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПроверка целостности корневой файловой системы;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗагрузка с нестандартных файловых систем;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗагрузка с LVM;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗагрузка с RAID.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EК экзотическим можно отнести:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EЗагрузку с образа корня, лежащего в интернете;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗагрузку с зашифрованного раздела;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗагрузку другой ОС с помощью системного вызова kexec.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EУтилиты для создания initramfs образов\u003C\u002Fh2\u003E\u003Cp\u003EРазные дистрибутивы используют разные утилиты для создания initrd образов. Debian обычно используют для этого initramfs-tools, Red Hat – Dracut. Но в этой статье я хочу представить другую, менее известную утилиту – make-initrd.\u003C\u002Fp\u003E\u003Ch2\u003EПочему make-initrd?\u003C\u002Fh2\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fosboot\u002Fmake-initrd\"\u003Emake-initrd\u003C\u002Fa\u003E – утилита для создания initramfs образов,  разрабатываемая нашим соотечественником Алексеем Гладковым. Сейчас она используется как основной сборщик initramfs в дистрибутиве ALT Linux.\u003C\u002Fp\u003E\u003Cp\u003EЭтот проект обладает рядом преимуществ:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EИмеет модульную структуру\u003C\u002Fem\u003E. Разные логические части образа создаются разными модулями, именуемыми \u003Cstrong\u003EFeatures (фичами)\u003C\u002Fstrong\u003E. Например, есть фича luks, отвечающая за внедрение сценария загрузки с зашифрованных разделов LUKS.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EСоздаваемые initramfs образы имеют простое внутреннее устройство.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EУдобен для использования конечным пользователем\u003C\u002Fem\u003E. Многие части конфигурации определяются автоматически. Это достигается за счет отдельного модуля \u003Cstrong\u003Eguess\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EУтилита показала свою работоспособность на множестве различных дистрибутивов\u003C\u002Fem\u003E. Нам лично удавалось собрать и использовать эту утилиту на Ubuntu, Fedora, ALT Linux, Red OS, Astra Linux.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EГенерируемые initramfs образы имеют относительно небольшой размер, а их сборка происходит достаточно быстро\u003C\u002Fem\u003E Для сравнения: initramfs-tools на моей машине генерирует образы размером 51Мб за 24 секунды. Образы же make-initrd весят всего 5Мб и создаются 10 секунд!\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EПроект продолжает активно развиваться\u003C\u002Fem\u003E. Со временем появляются новые фичи, улучшается архитектура утилиты и архитектура initramfs образов. Разработчик идет на контакт и всегда рад вашим патчам и предложениям:)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EК сожалению, у make-initrd есть и недостатки:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EНе самая полная и достоверная \u003C\u002Fem\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fosboot\u002Fmake-initrd\u002Ftree\u002Fmaster\u002FDocumentation\"\u003E\u003Cem\u003Eдокументация\u003C\u002Fem\u003E\u003C\u002Fa\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПроект тестируется лишь на Fedora, Ubuntu и Alt Linux. И, хотя нам удавалось использовать его на других дистрибутивах, \u003Cem\u003Eнет гарантии, что все будет работать гладко и везде\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EУстройство initramfs образов, генерируемых make-initrd\u003C\u002Fh2\u003E\u003Cp\u003EВ этом разделе описаны основные сведения по архитектуре образов, генерируемых make-initrd.\u003C\u002Fp\u003E\u003Ch3\u003EСервисы\u003C\u002Fh3\u003E\u003Cp\u003EСоздаваемые образы имеют сервисно-ориентированную архитектуру. При передаче управления программе \u003Ccode\u003E\u002Finit\u003C\u002Fcode\u003E порождается дерево сервисов, которые в дальнейшем взаимодействуют между собой. Последовательность их запуска и завершения определяется в процессе сборки образа и настраивается с помощью конфигурационных файлов \u003Ca href=\"https:\u002F\u002Fwiki.debian.org\u002FLSBInitScripts\"\u003ELSB\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВ системе есть несколько основных сервисов, на которых базируется основная логика работы:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eudevd\u003C\u002Fstrong\u003E – \u003Cem\u003Eобработчик событий ядра об изменении состояния устройств\u003C\u002Fem\u003E. При изменении состояния любого устройства он \u003Cstrong\u003Eпараллельно\u003C\u002Fstrong\u003E запускает \u003Cem\u003Eфильтры\u003C\u002Fem\u003E (скрипты), добавляющие пользовательские события в очередь. Этот демон используется во многих дистрибутивах Linux.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eueventd\u003C\u002Fstrong\u003E – \u003Cem\u003Eобработчик пользовательских событий\u003C\u002Fem\u003E. Этот демон запускает обработчики пользовательских событий. События внутри одной очереди обрабатываются \u003Cstrong\u003Eпоследовательно\u003C\u002Fstrong\u003E, а сами очереди – параллельно.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Epolld\u003C\u002Fstrong\u003E – \u003Cem\u003Eдемон, ожидающий выполнения условий загрузки системы\u003C\u002Fem\u003E. Все, что он делает – один раз в заданное время проверяет условия запуска системы. Если они удовлетворены, запускается некоторый экшен. Скрипты проверки условий и экшена зависят от \u003Cem\u003Eметода загрузки\u003C\u002Fem\u003E. Тем не менее, зачастую, их задача – проверить, что корень найден и переключить \u003Cem\u003Erunlevel\u003C\u002Fem\u003E на второй уровень.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch3\u003ERunlevel\u003C\u002Fh3\u003E\u003Cp\u003E\u003Cstrong\u003ERunlevel\u003C\u002Fstrong\u003E определяет уровень запуска системы. Эти уровни отличаются от тех, что \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRunlevel#Linux_Standard_Base_specification\"\u003Eстандартно используются в Linux\u003C\u002Fa\u003E. В make-initrd номер уровня зависит от состояния загрузки системы. А от номера уровня, в свою очередь, зависит то, какие сервисы будут активны в текущий момент. В make-initrd предусмотрено всего 3 уровня:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EУровень 3\u003C\u002Fstrong\u003E – означает, что \u003Cem\u003Eреальный корень системы еще не примонтирован\u003C\u002Fem\u003E. На этом уровне происходит запуск и работа большинства сервисов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EУровень 2\u003C\u002Fstrong\u003E – означает, что \u003Cem\u003Eреальный корень системы уже примонтирован\u003C\u002Fem\u003E. На этом происходит завершение большинства сервисов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EУровень 9\u003C\u002Fstrong\u003E – специальный уровень, на котором происходит \u003Cem\u003Eподмена корня системы на реальный и запуск \u003C\u002Fem\u003E\u003Ccode\u003E\u002Fsbin\u002Finit\u003C\u002Fcode\u003E на нем.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EРазберем пример загрузки с жесткого диска.\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EПосле запуска \u003Ccode\u003E\u002Finit\u003C\u002Fcode\u003E, произойдет инициализация окружения: примонтируется файловая система \u003Ccode\u003Eprocfs\u003C\u002Fcode\u003E и установится \u003Cem\u003Erunlevel=3\u003C\u002Fem\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПоследовательно запускаются различные сервисы, среди которых будут \u003Cem\u003Eudevd\u003C\u002Fem\u003E, \u003Cem\u003Eueventd\u003C\u002Fem\u003E и \u003Cem\u003Epolld\u003C\u002Fem\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПосле обнаружения устройства жесткого диска ядро сгенерирует соответствующее событие для демона \u003Cem\u003Eudevd\u003C\u002Fem\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003Eudevd\u003C\u002Fem\u003E просмотрит список своих правил. При нахождении правила на добавление блочного устройства запустится соответствующий обработчик (в make-initrd они называются фильтрами);\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВнутри фильтра произойдет проверка, что устройство описано в \u003Ccode\u003E\u002Fetc\u002Ffstab\u003C\u002Fcode\u003E. Если это так, сгенерируется пользовательское событие на примонтирование этого устройства;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ какой-то момент \u003Cem\u003Eueventd\u003C\u002Fem\u003E запустит обработчик этого пользовательского события. Обработчик примонтирует жесткий диск;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EДемон \u003Cem\u003Epolld\u003C\u002Fem\u003E в очередной раз запустит скрипт проверки наличия корня. После его обнаружения запустится экшен, переключающий \u003Cem\u003Erunlevel на второй уровень\u003C\u002Fem\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПосле переключения runlevel произойдет отключение большинства сервисов. Далее запустится сервис \u003Cem\u003Eruninit\u003C\u002Fem\u003E, который установит \u003Cem\u003Erunlevel на девятый уровень\u003C\u002Fem\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПроцесс init произведет подмену корня и запустит \u003Ccode\u003E\u002Fsbin\u002Finit\u003C\u002Fcode\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Ch3\u003EУстройство файловой системы initramfs образов\u003C\u002Fh3\u003E\u003Cp\u003EInitramfs образ, генерируемый make-initrd, имеет строгую структуру файловой системы. Поэтому при добавлении собственной фичи важно понимать, что и где должно лежать:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Finit\u003C\u002Fcode\u003E – программа, которой передается управление после инициализации ядра;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Fbin\u002F\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fusr\u002Fbin\u002F\u003C\u002Fcode\u003E – директории программ;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Fsbin\u002F\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fusr\u002Fsbin\u002F\u003C\u002Fcode\u003E – директории сервисов;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Fetc\u002F\u003C\u002Fcode\u003E – директория конфигураций;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Fetc\u002Frc.d\u002Finit.d\u002F\u003C\u002Fcode\u003E – директория LSB конфигураций сервисов;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Fetc\u002Fudev\u002Frules.d\u002F\u003C\u002Fcode\u003E – директория правил \u003Cem\u003Eudevd\u003C\u002Fem\u003E;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Fetc\u002Finitrd\u002Fmethod\u003C\u002Fcode\u003E – файл содержащий текущий метод загрузки;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Fetc\u002Finitrd\u002Fcmdline.d\u002F\u003C\u002Fcode\u003E – директория описаний аргументов ядра;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Flib\u002F\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fusr\u002Flib\u002F\u003C\u002Fcode\u003E – директории библиотек;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Flib\u002Fuevent\u002Ffilters\u002F\u003C\u002Fcode\u003E – директория фильтров \u003Cem\u003Euevent\u003C\u002Fem\u003E событий;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Flib\u002Fuevent\u002Fhandler\u002F\u003C\u002Fcode\u003E – директория обработчиков \u003Cem\u003Euevent\u003C\u002Fem\u003E событий;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Flib\u002Finitrd\u002Fboot\u002Fmethod\u002F\u003C\u002Fcode\u003E – директория скриптов методов загрузки;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Flib\u002Finitrd\u002Fboot\u002Fmethod\u002F*\u002Fcheck\u003C\u002Fcode\u003E – скрипт проверки условии активации метода загрузки;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Flib\u002Finitrd\u002Fboot\u002Fmethod\u002F*\u002Faction\u003C\u002Fcode\u003E – скрипт активации метода загрузки;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Flib\u002Finitrd\u002Fboot\u002Fscripts\u002F\u003C\u002Fcode\u003E – директория подскриптов проверки условий метода загрузки;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002F.initrd\u002F\u003C\u002Fcode\u003E – директория, которую могут использовать сервисы и программы для внутренней работы;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003E\u002Ftmp\u002F\u003C\u002Fcode\u003E – директория временных файлов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EУстройство генератора initramfs образов\u003C\u002Fh2\u003E\u003Cp\u003EДля организации действий по созданию initramfs образов make-initrd использует \u003Ccode\u003Emake\u003C\u002Fcode\u003E. Поэтому весь процесс создания можно представить в виде последовательности выполняемых целей. Основными целями при создании образа являются:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eprocess-config\u003C\u002Fstrong\u003E – Считывание конфигурационного файла. Во время ее выполнения происходит последовательный запуск целей guess и genimage;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eguess\u003C\u002Fstrong\u003E – Угадывание конфигурационного файла;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Ecreate\u003C\u002Fstrong\u003E – Наполнение корня initramfs образа;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Epack\u003C\u002Fstrong\u003E – Сортировка сервисов и упаковка initramfs образа в cpio архив. Зависит от create;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Einstall\u003C\u002Fstrong\u003E – Установка образа в загрузочную директорию. Зависит от pack;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Egenimage\u003C\u002Fstrong\u003E – Вывод информационного сообщения о сборке образа. Зависит от install.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EПроцесс выполнения этих целей можно разбить на два больших этапа:\u003C\u002Fp\u003E\u003Cp\u003E1. \u003Cem\u003EУгадывание\u003C\u002Fem\u003E дополнения к конфигурации (цель \u003Cem\u003Eguess\u003C\u002Fem\u003E);\u003C\u002Fp\u003E\u003Cp\u003E2. \u003Cem\u003EСборка\u003C\u002Fem\u003E образа (цели \u003Cem\u003Ecreate – genimage\u003C\u002Fem\u003E)\u003C\u002Fp\u003E\u003Ch3\u003EЭтап угадывания конфигурации\u003C\u002Fh3\u003E\u003Cp\u003EРучная конфигурация make-initrd - достаточно сложный процесс. Например, вам нужно указать модули ядра устройств, которые вы хотите использовать в initramfs. Также немаловажно правильно задать список используемых фич.\u003C\u002Fp\u003E\u003Cp\u003EНеправильное задание конфигурации грозит тем, что initramfs образ может оказаться излишне \"тяжелым\", а загрузка ОС будет происходить медленнее или не происходить вовсе. Например, если вы активировали фичу \u003Cem\u003Enetwork\u003C\u002Fem\u003E, но не используете сеть в процессе загрузки, это грозит вам лишними секундами на настройку сетевых интерфейсов.\u003C\u002Fp\u003E\u003Cp\u003EИменно для решения этих проблем в make-initrd был добавлен модуль guess. Он помогает оптимально сгенерировать или дополнить существующую конфигурацию, основываясь на окружении компьютера.\u003C\u002Fp\u003E\u003Cp\u003EGuess использует разные модули для определения разных сфер образа. Например:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Edevice\u003C\u002Fstrong\u003E – определяет модули ядра устройств;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Ekeyboard\u003C\u002Fstrong\u003E – определяет модули ядра для работы с клавиатурой;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Enet\u003C\u002Fstrong\u003E – определяет модули ядра сетевых устройств;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eroot\u003C\u002Fstrong\u003E – определяет какие разделы нужно примонтировать, а также модули ядра для работы с ними;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Esmart-card\u003C\u002Fstrong\u003E – определяет конфигурацию фичи smart-card;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Ecommon\u003C\u002Fstrong\u003E – простой универсальный модуль, который может быть использован внутри фич.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EЭтот список не является исчерпывающим: описание остальных модулей можно посмотреть в \u003Ccode\u003EREADME.md\u003C\u002Fcode\u003E файлах \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fosboot\u002Fmake-initrd\u002Ftree\u002Fmaster\u002Fguess\"\u003Eмодулей guess\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Ch3\u003EЭтап сборки initramfs образа\u003C\u002Fh3\u003E\u003Cp\u003EВо время выполнения цели \u003Cem\u003Ecreate\u003C\u002Fem\u003E создается временная директория, в которой заполняется корень initramfs образа. Корень заполняется в соответствии с переданной конфигурацией. Туда кладется все необходимое: приложения, библиотеки, файлы конфигурации и т.д. Но это еще не все: на последующих шагах корень еще будет дополняться.\u003C\u002Fp\u003E\u003Cp\u003EВо время выполнения цели \u003Cem\u003Epack\u003C\u002Fem\u003E происходит определение порядка запуска и остановки сервисов. Этот порядок будет отражен в именах файлов директории \u003Ccode\u003E\u002Fetc\u002Frc{0,1,2,3,4,5,6}.d\u003C\u002Fcode\u003E. Например, сервис \u002Fetc\u002Frc3.d\u002FS08:udev будет запущен восьмым при переходе в runlevel=3. Далее сформированная директория с корнем упаковывается в cpio архив, в который дополнительно помещаются специальные файлы: \u003Ccode\u003E\u002Fdev\u002Fram\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fdev\u002Fnull\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fdev\u002Fzero\u003C\u002Fcode\u003E и т.д.\u003C\u002Fp\u003E\u003Cp\u003EВо время выполнения цели \u003Cem\u003Einstall\u003C\u002Fem\u003E полученный архив установится в директорию \u003Ccode\u003E\u002Fboot\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЭтап сборки образа может сколь угодно расширяться с помощью фич. Например, если активирована фича \u003Cem\u003Ecompress\u003C\u002Fem\u003E, то cpio архив будет дополнительно сжат с помощью одного из методов: gzip, lzma, bzip2 и т.п.\u003C\u002Fp\u003E\u003Ch3\u003EФичи\u003C\u002Fh3\u003E\u003Cp\u003E\u003Cstrong\u003EФича\u003C\u002Fstrong\u003E – это независимый модуль сборщика initramfs образов. Фичи могут воздействовать практически на любой этап сборки образа. Например:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003Eфича \u003Cem\u003Ecompress\u003C\u002Fem\u003E позволяет сжимать итоговый образ;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eфича \u003Cem\u003Eluks\u003C\u002Fem\u003E добавляет в initramfs утилиты и модули для работы с luks;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eфича \u003Cem\u003Eclean\u003C\u002Fem\u003E – очищает после себя рабочую директорию.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EТакая высокая модульность достигается за счет того, что make-initrd для организации своих действий использует \u003Ccode\u003Emake\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Ch3\u003EСтруктура проекта make-initrd\u003C\u002Fh3\u003E\u003Cp\u003EВыгрузим проект make-initrd из репозитория и посмотрим на его содержимое\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Выгружаем исходники\ngit clone https:\u002F\u002Fgithub.com\u002Fosboot\u002Fmake-initrd --recursive\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПроект make-initrd очень хорошо структурирован. Давайте опишем, за что отвечают различные файлы и директории в проекте:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Edata\u002F\u003C\u002Fcode\u003E – постоянная часть корня initramfs образа. Файлы, находящиеся в ней, будут присутствовать внутри почти всех образов;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Edatasrc\u002F\u003C\u002Fcode\u003E – исходники утилит, устанавливаемые внутрь образа;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Emk\u002Fconfig.mk\u003C\u002Fcode\u003E – Makefile c постоянной частью конфигурации make-initrd (переменные путей и т.п.);\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Emk\u002Ffunctions.mk\u003C\u002Fcode\u003E – Makefile с вспомогательными функциями make;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Emk\u002Fmake-initrd.mk\u003C\u002Fcode\u003E – основной Makefile описывающий правила сборки initramfs образа;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Etools\u002F\u003C\u002Fcode\u003E – внутренние утилиты make-initrd;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Eutils\u002F\u003C\u002Fcode\u003E – исходники внешних утилит make-initrd;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Eguess\u002F\u003C\u002Fcode\u003E – директория guess модулей;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Eguess\u002F*\u002Fconfig.mk\u003C\u002Fcode\u003E – Makefile с описанием конфигурации guess модуля (переменные модуля, правила его активации). Он подключается вне зависимости от того, активен ли guess модуль или нет;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Eguess\u002F*\u002Frules.mk\u003C\u002Fcode\u003E – Makefile с описанием правил отработки guess модуля. Он подключается, только если guess модуль активен;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efeatures\u002F\u003C\u002Fcode\u003E – директория фич;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efeatures\u002F*\u002Fdata\u002F\u003C\u002Fcode\u003E – часть корня initramfs образа, предоставляемая фичей;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efeatures\u002F*\u002Fdatasrc\u002F\u003C\u002Fcode\u003E – исходники утилит фичи, устанавливаемые внутрь initramfs;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efeatures\u002F*\u002Fguess\u002F\u003C\u002Fcode\u003E – подскрипты модулей guess;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efeatures\u002F*\u002Fbin\u002F\u003C\u002Fcode\u003E – вспомогательный утилиты сборки initramfs образа;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efeatures\u002F*\u002Fconfig.mk\u003C\u002Fcode\u003E – Makefile с конфигурацией фичи (описание зависимых фич, переменных и т.п.). Он подключается вне зависимости от того, активна ли фича или нет;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efeatures\u002F*\u002Frules.mk\u003C\u002Fcode\u003E – Makefile с правилами сборки фичи. Он подключается только в случае, если фича активна.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EУстановка make-initrd\u003C\u002Fh2\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Установим зависимые пакеты\nsudo apt-get install make automake pkg-config udev libkmod-dev libz-dev libbz2-dev liblzma-dev libzstd-dev libelf-dev libtirpc-dev libcrypt-dev help2man gcc opensc pcscd libpcsclite1\n\n# Соберем проект\n.\u002Fautogen.sh\n.\u002Fconfigure\nmake\n# Установим его\nsudo make install\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003EСборка initramfs и запуск на реальной машине\u003C\u002Fh2\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003Cstrong\u003EПРЕДУПРЕЖДЕНИЕ\u003C\u002Fstrong\u003E Перед генерацией initramfs образа обязательно сделайте backup. \u003C\u002Fp\u003E\u003Cp\u003EЕсли система перестанет загружаться, откройте раздел с \u003Ccode\u003E\u002Fboot\u003C\u002Fcode\u003E на другой системе (например, через загрузочную флешку) и верните backup на место. Если вы не сделали backup, попробуйте загрузиться с помощью другого ядра. Это может сработать, так как по-умолчанию make-initrd собирает initramfs только для текущего ядра.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Backup текущего initramfs образа\ncp \u002Fboot\u002Finitrd.img-$(uname-r) \u002Fmedia\u002Fflash\u002Finitrd.backup\n# Запуск сборки\nsudo make-intird\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПерезапустим систему и попробуем загрузиться c ядра, для которого мы сгенерировали initramfs образ.\u003C\u002Fp\u003E\u003Ch2\u003EДобавление собственной фичи\u003C\u002Fh2\u003E\u003Cp\u003EЧтобы лучше разобраться с тем, как устроены фичи, давайте напишем свою – hello-usb.\u003C\u002Fp\u003E\u003Ch3\u003EФича Hello USB\u003C\u002Fh3\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003Cstrong\u003EПримечание\u003C\u002Fstrong\u003E Исходный код фичи hello-usb можно взять \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flo1ol\u002Fmake-initrd\u002Ftree\u002Fhello-usb\u002Ffeatures\u002Fhello-usb\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EНапишем фичу hello-usb, добавляющую в initramfs функционал вывода сообщения “Hello USB!” при нахождении USB-устройства. Также добавим возможность указывать имя производителя устройства, для которого выводится сообщение.\u003C\u002Fp\u003E\u003Cp\u003EВнутренняя логика работы нашей фичи, следующая:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EКонтроль добавления нового USB-устройства осуществляется с помощью udev правила \u003Ccode\u003E\u002Fetc\u002Fudev\u002Frules.d\u002F99-hello-usb.rules\u003C\u002Fcode\u003E: при добавлении любого USB-устройства вызывается фильтр \u003Ccode\u003E\u002Flib\u002Fuevent\u002Ffilter\u002Fhello-usb\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВнутри фильтра создается uevent событие hello-usb\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЭто событие обрабатывает специальный обработчик \u003Ccode\u003E\u002Flib\u002Fuevent\u002Fhandler\u002Fhello-usb\u003C\u002Fcode\u003E, который выводит в консоль сообщение \"Hello USB!\". Вывод происходит, только если производитель устройства совпал с тем, что передан в аргументе ядра \u003Cstrong\u003Eusb-vendor\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EДерево файлов фичи следующее:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Efeature\u002Fhello-usb\u002Fconfig.mk\nfeature\u002Fhello-usb\u002Frules.mk\nfeature\u002Fhello-usb\u002Fdata\u002Fetc\u002Finitrd\u002Fcmdline.d\u002Fhello-usb\nfeature\u002Fhello-usb\u002Fdata\u002Fetc\u002Fudev\u002Frules.d\u002F99-hello-usb.rules\nfeature\u002Fhello-usb\u002Fdata\u002Flib\u002Fuevent\u002Ffilters\u002Fhello-usb\nfeature\u002Fhello-usb\u002Fdata\u002Flib\u002Fuevent\u002Fhandlers\u002F060-hello-usb\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ccode\u003Econfig.mk\u003C\u002Fcode\u003E содержит описание фичи:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Зависимость от фичи usb\n$(call feature-requires,usb)\n\n# Путь до директории корневых данных фичи hello-usb\nHELLO_USB_DATADIR   ?= $(FEATURESDIR)\u002Fhello-usb\u002Fdata\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЧерез функцию \u003Ccode\u003Efeature-requires\u003C\u002Fcode\u003E можно указывать зависимые фичи. Мы хотели получить модули ядра и udev-правила для работы с USB-устройствами, поэтому добавили в зависимости фичу usb.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Erules.mk\u003C\u002Fcode\u003E содержит правила сборки фичи:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Вывод сообщения\nhello-usb-show-info:\n    @$(MSG) \"Hello USB feature is activated ...\"\n\n# Вывод сообщения происходит перед упаковкой образа \npack: hello-usb-show-info\n\n# Запоминаем директорию, которую хотим использовать, как часть корня\nPUT_FEATURE_DIRS  += $(HELLO_USB_DATADIR)\n# Также в initrd можность класть программы, библиотеки, директории и файлы с помощью PUT_FEATURE_PROGS, PUT_FEATURE_LIBS, PUT_FEATURE_FILES, соответственно\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ccode\u003Efeature\u002Fhello-usb\u002Fetc\u002Finitrd\u002Fcmdline.d\u002Fhello-usb\u003C\u002Fcode\u003E – регистрирует опцию ядра \u003Cstrong\u003Eusb-vendor\u003C\u002Fstrong\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Eregister_parameter string USB_VENDOR\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПомимо регистрации единичного аргумента можно зарегистрировать массив (\u003Ccode\u003Eregister_array\u003C\u002Fcode\u003E). Допустимо использовать аргументы типа: \u003Ccode\u003Estring\u003C\u002Fcode\u003E, \u003Ccode\u003Ebool\u003C\u002Fcode\u003E, \u003Ccode\u003Enumber\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efeature\u002Fhello-usb\u002Fetc\u002Fudev\u002Frules.d\u002F99-hello-usb.rules\u003C\u002Fcode\u003E – udev правило, запускающее фильтр. Число в начале имени нужно для задания порядка его обработки. В нашем случае было важно, чтобы правило hello-usb отработало позже, чем 60-fido-id (т.к. оно выставляет тег \u003Ccode\u003Esecurity-device\u003C\u002Fcode\u003E). Поэтому мы выставили любое число больше 60 – это 99.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003ESUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ACTION==\"add\", RUN+=\"\u002Flib\u002Fuevent\u002Ffilters\u002Fhello-usb\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПодробнее о udev правилах можно прочитать \u003Ca href=\"https:\u002F\u002Fwww.arccomm.ru\u002F%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-udev\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efeature\u002Fhello-usb\u002Fdata\u002Flib\u002Fuevent\u002Ffilters\u002Fhello-usb\u003C\u002Fcode\u003E – фильтр:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E#!\u002Fbin\u002Fbash\n. uevent-sh-functions\n\n# Создаем событие добавления USB-устройства\nevent=\"$(make_event)\"\n# Событие -- это файл хранящий переменные внутри себя\necho \"VENDOR=$ID_VENDOR\" \u003E\u003E \"$event\"\nrelease_event hello-usb \"$event\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОбратите внимание на простоту этого скрипта. Это связано с тем, что udev может запустить несколько таких скриптов одновременно, а это может привести к состоянию гонки. Именно поэтому логика большинства фильтров крайне проста – передать событие uevent, который обработает его последовательно.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efeature\u002Fhello-usb\u002Flib\u002Fuevent\u002Fhandlers\u002F060-hello-usb\u003C\u002Fcode\u003E – обработчик события hello-usb. Uevent передает управление обработчикам в соотвествии с их номером. В нашем случае порядок обработки нашего события не важен, и мы выставили случайный номер – 60.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E#!\u002Fbin\u002Fbash\n\n. \u002F.initrd\u002Finitenv\n. uevent-sh-functions\n. initrd-sh-functions\n. rdshell-sh-functions\n\n# функция обработки вставки USB-устройства\nhandler() {\n\t# проверяем совпадение имени производителя, если оно задано\n\t[ -n \"$USB_VENDOR\" ] &amp;&amp; [ \"$VENDOR\" != \"$USB_VENDOR\" ] &amp;&amp; return 0\n\n\techo \"Hello USB!\"\n\n\treturn 0\n}\n\n# Заблокируем вывод в консоль другим приложениям\nwhile ! console_lock; do\n\tsleep 0.5\ndone\n\n# Перенаправим I\u002FO обработчика в консоль\nexec 0&lt;\u002Fdev\u002Fconsole \u003E\u002Fdev\u002Fconsole 2\u003E&amp;1\n\nrc=0\n# Отфильтровываем события hello-usb\nfor e in \"$eventdir\"\u002Fhello-usb.*; do\n\t[ -f \"$e\" ] || break\n\tr=0\n\t# Запускаем функцию-обработчик с заданным окружением\n\t( . \"$e\"; handler; ) || r=\"$?\"\n\tcase \"$r\" in\n\t\t# Событие остается в очереди\n\t\t1) rc=1 ;;\n        \t# Удаляем событие из очереди\n        \t0) done_event \"$e\" ;;\n\tesac\ndone\n\n# Открываем доступ к консоли\nconsole_unlock\nexit $rc\n```\n\nСоберем make-initrd с добавленной фичей:\n```bash\nmake &amp;&amp; sudo make install\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EСоберем make-initrd с добавленной фичей:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Emake &amp;&amp; sudo make install\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003EНастройка и генерация initrd образа\u003C\u002Fh2\u003E\u003Cp\u003EСконфигурировать make-initrd можно через файл \u003Ccode\u003E\u002Fetc\u002Fintird.mk\u003C\u002Fcode\u003E. При генерации образа вы можете изменить путь до файла с конфигурацией, запустив make-initrd с опцией \u003Ccode\u003E-с\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Esudo make-initrd -c \u002Fpath\u002Fto\u002Fconfig\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОбычно файл с конфигурацией выглядит следующим образом:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E$ cat \u002Fetc\u002Finitrd.mk\n# trying to detect modules and features to access to root volume\nAUTODETECT = all\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗдесь написано, что вся конфигурация будет определена автоматически. Увидеть \"угаданную\" конфигурацию можно с помощью команды:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Esudo make-initrd guess-config\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВы можете попросить make-initrd запускать только определенные guess модули. Например, можно попросить \"угадывать\" только модули ядра и фичи необходимые для монтирования корня и работы с клавиатурой:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003EAUTODETECT = root keyboard\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПопробуем теперь собрать intird образ вместе с фичей \u003Cstrong\u003Ehello-usb\u003C\u002Fstrong\u003E. Подправим конфигурацию\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003EAUTODETECT = all\nFEATURES += hello-usb\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ запустим сборку образа:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E$ sudo make-initrd\n\u003E # Считывается конфигурация\n\u003E [00:00:00] Config file: \u002Fetc\u002Finitrd.mk\n\u003E # Запускается guess модуль. Определяются недостающие части конфигурации\n\u003E [00:00:01] Guessing config ...\n\u003E [00:00:01] Generating module dependencies on host ...\n\u003E [00:00:04] Guessing is complete\n\u003E # Переход к шагу genimage\n\u003E [00:00:04] Creating initrd image ...\n\u003E [00:00:06] Putting udev rules ...\n\u003E [00:00:06] Putting modules ...\n\u003E [00:00:06] Generating module dependencies in image …\n\u003E # Выполнение rules.mk фичи hello-usb\n\u003E [00:00:07] hello-usb feature is activated ...\n\u003E # Определяется порядок запуска и остановки сервисов\n\u003E [00:00:07] Sorting sysvinit services …\n\u003E # Упаковка образа в архив\n\u003E [00:00:08] Packing image to archive ...\n\u003E [00:00:08] Writing build info files …\n\u003E # Сжатие архива\n\u003E [00:00:08] Compressing image ...\n\u003E [00:00:19] Adding CPU microcode …\n\u003E # Список активированных фич\n\u003E [00:00:19] Used features: add-modules add-udev-rules buildinfo cleanup compress depmod-image hello-usb network rdshell rootfs system-glibc ucode usb\n\u003E # Список используемых модулей ядра\n\u003E [00:00:19] Packed modules: ahci cqhci evbug hid hid-apple hid-generic input-leds libahci mac_hid sdhci sdhci-pci serio_raw uas usbhid usb-storage xhci-pci xhci-pci-renesas\n\u003E # Установка образа в директорию \u002Fboot\n\u003E [00:00:19] Installing image ...\n\u003E [00:00:19] Unpacked size: 47M\n\u003E [00:00:19] Image size: 14M\n\u003E [00:00:19] Removing work directory ...\n\u003E [00:00:19] Image is saved as \u002Fboot\u002Finitrd.img-5.11.0-31-generic\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПерейдем к проверке нашего образа на виртуальной машине.\u003C\u002Fp\u003E\u003Ch2\u003EЗапуск в qemu\u003C\u002Fh2\u003E\u003Cp\u003EПроверку образа будем производить с помощью qemu. Установим необходимые пакеты:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Esudo apt-get install qemu-system-x86 qemu-kvm\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ процессе работы мы планируем пробрасывать USB-устройство на виртуальную машину. Чтобы это сделать, необходимо узнать его адрес на USB-шине:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E$ lsusb -t\n\u002F:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd\u002F6p, 5000M\n\u002F:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd\u002F12p, 480M\n    |__ Port 1: Dev 2, If 0, Class=Chip\u002FSmartCard, Driver=, 480M\n    |__ Port 2: Dev 14, If 0, Class=Mass Storage, Driver=usb-storage, 480M\n    |__ Port 3: Dev 29, If 0, Class=Vendor Specific Class, Driver=r8152, 480M\n    |__ Port 5: Dev 4, If 0, Class=Video, Driver=uvcvideo, 480M\n    |__ Port 5: Dev 4, If 1, Class=Video, Driver=uvcvideo, 480M\n    |__ Port 8: Dev 5, If 1, Class=Wireless, Driver=btusb, 12M\n    |__ Port 8: Dev 5, If 0, Class=Wireless, Driver=btusb, 12M\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМы хотим пробросить устройство, имеющее класс \u003Ccode\u003EMass Storage\u003C\u002Fcode\u003E (флешку). В нашем случае оно находится на первой шине и втором порту.\u003C\u002Fp\u003E\u003Cp\u003EПерейдем к запуску:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Указываем путь до ядра\n# Указываем путь до initramfs образа\n# Указываем Размер оперативной памяти виртуальной машины в мегабайтах\n# Включаем KVM\n# Добавляем эмуляцию USB-контроллера\n# Указываем протокол работы контроллера (ehci. Для xhci передаем \"-device qemu-xhci\")\n# Указываем путь до пробрасываемемого устройства\nsudo qemu-system-x86_64 -kernel \u002Fboot\u002Fvmlinuz-$(uname -r) \\\n    -initrd \u002Fboot\u002Finitrd.img-$(uname -r) \\\n    -m 1024 \\\n    -cpu host \\\n    -enable-kvm \\\n    -usb \\\n    -device usb-ehci,id=ehci \\\n    -device usb-host,hostbus=1,hostport=2\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПосле запуска системы сначала отобразится вывод ядра, а затем вывод самого initrd. Если вы все сделали правильно, в какой-то момент увидите вывод обработчика событий hello-usb:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E[    1.461950] Run \u002Finit as init process\n[    1.325924] INITRAMFS: version 2.22.0\n[    1.340645] INIT: Entering runlevel: 3\n[    1.357308] Starting shell service:                      [ DONE ]\n[    1.430040] Parsing cmdline arguments:                   [ DONE ]\n[    1.489825] Creating \u002Fetc\u002Ffstab:                         [ DONE ]\n[    1.524020] Mounting filesystem [\u002Fdev]:                  [ DONE ]\n[    1.554917] Mounting filesystem [\u002Fsys]:                  [ DONE ]\n[    1.601215] Mounting filesystem [\u002Frun]:                  [ DONE ]\n[    1.674068] Starting polld service:                      [ DONE ]\n[    1.745135] Setting kernel runtime parameters:           [ DONE ]\n[    1.786626] Loading modules:                             [ DONE ]\n[    1.824191] Starting udevd service:                      [ DONE ]\n[    2.545714] Starting ueventd service:                    [ DONE ]\n[    3.067812] Network up (lo):                 `           [ DONE ]\nHello USB!\nHello USB!\nHello USB!\nHello USB!\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНа этом, увы, ваша система зависнет:) Это связано с тем, что initramfs будет продолжать искать устройство с корнем, но оно не проброшено в qemu. К счастью, есть возможность экстренно перейти в rescue консоль: для этого надо нажать клавиши ** + **.\u003C\u002Fp\u003E\u003Cp\u003EВ ней можно изучить окружение initramfs образа:\u003C\u002Fp\u003E\u003Cp\u003E* Убедитесь, что файловая структура, описанная ранее, соответствует действительности;\u003C\u002Fp\u003E\u003Cp\u003E* Изучите список активных процессов;\u003C\u002Fp\u003E\u003Cp\u003E* Посмотрите логи в \u003Ccode\u003E\u002Fvar\u002Flog\u002F\u003C\u002Fcode\u003E;\u003C\u002Fp\u003E\u003Cp\u003E* Посмотрите содержимое других файлов.\u003C\u002Fp\u003E\u003Cp\u003EВы всегда можете запустить rescue консоль, если имеются какие-либо проблемы при запуске. В ней возможно:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EИзучить логи сервисов;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПримонтировать корень вручную и запуститься с него;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗапустить отладчик (если добавлена фича debug-tools).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EПередача аргументов ядра\u003C\u002Fh2\u003E\u003Cp\u003EДля передачи аргументов ядра в qemu есть специальная опция \u003Ccode\u003E-append\u003C\u002Fcode\u003E. Укажем с помощью нее имя производителя USB-устройства, для которого мы хотим вывести сообщение “Hello USB!”. Его можно получить так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Узнаем номер USB-устройства -- значение  Dev\n$ lsusb -t\n\u002F:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd\u002F6p, 5000M\n\u002F:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd\u002F12p, 480M\n    |__ Port 1: Dev 2, If 0, Class=Chip\u002FSmartCard, Driver=, 480M\n    |__ Port 2: Dev 14, If 0, Class=Mass Storage, Driver=usb-storage, 480M\n    |__ Port 3: Dev 29, If 0, Class=Vendor Specific Class, Driver=r8152, 480M\n    |__ Port 5: Dev 4, If 0, Class=Video, Driver=uvcvideo, 480M\n    |__ Port 5: Dev 4, If 1, Class=Video, Driver=uvcvideo, 480M\n    |__ Port 8: Dev 5, If 1, Class=Wireless, Driver=btusb, 12M\n    |__ Port 8: Dev 5, If 0, Class=Wireless, Driver=btusb, 12M\n\n# Номер шины\n$ BUS=001\n# Номер устройства\n$ DEV=014\n$ udevadm info --name \u002Fdev\u002Fbus\u002Fusb\u002F${BUS}\u002F${DEV} | grep \"ID_VENDOR=\"\nE: ID_VENDOR=Aktiv\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗапустим qemu с аргументом ядра usb-vendor\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Esudo qemu-system-x86_64 -kernel \u002Fboot\u002Fvmlinuz-$(uname -r) \\\n    -initrd \u002Fboot\u002Finitrd.img-$(uname -r) \\\n    -m 1024 \\\n    -cpu host \\\n    -enable-kvm \\\n    -usb \\\n    -device usb-ehci,id=ehci \\\n    -device usb-host,hostbus=1,hostport=2 \\\n    -append \"usb-vendor=Aktiv\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗаметьте, если указать другое имя производителя, то в лог может ничего не вывестись.\u003C\u002Fp\u003E\u003Cp\u003EПопулярные опции ядра, которые поддерживает initramfs можно посмотреть \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flo1ol\u002Fmake-initrd\u002Fblob\u002Fmaster\u002FDocumentation\u002FBootParameters.md\"\u003Eздесь\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Ch2\u003EПроверка на реальной машине\u003C\u002Fh2\u003E\u003Cp\u003EПосле того, как вы убедились, что initramfs образ работает в qemu, можно проверить его на реальной машине. Но здесь могут возникнуть некоторые нюансы.\u003C\u002Fp\u003E\u003Cp\u003EДело в том, что аргументы ядра, которые мы передавали в qemu с помощью опции \u003Ccode\u003E-append\u003C\u002Fcode\u003E, на реальной машине передаются не так просто. Обычно этим занимается UEFI загрузчик (GRUB, LILO rEFInd, nsh скрипт для UEFI Shell и т.д.) и настройка передаваемых опций ядра для каждого загрузчика производится по-разному.\u003C\u002Fp\u003E\u003Cp\u003EМы покажем, как это сделать, на примере GRUB.\u003C\u002Fp\u003E\u003Ch3\u003EНастройка аргументов ядра в GRUB\u003C\u002Fh3\u003E\u003Cp\u003EGRUB использует двухуровневую конфигурацию. Первый уровень – это файл \u003Ccode\u003E\u002Fetc\u002Fdefault\u002Fgrub\u003C\u002Fcode\u003E (путь до этого файла дистрибутивозависим). На основании этого файла генерируется конфигурация второго уровня – \u003Ccode\u003E\u002Fboot\u002Fgrub\u002F\u003C\u002Fcode\u003E, которую и используется непосредственно grub.\u003C\u002Fp\u003E\u003Cp\u003EОткроем файл \u002Fetc\u002Fdefault\u002Fgrub. Его содержимое выглядит примерно следующим образом:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Номер пункта в меню загрузки, загружаемый по-умолчанию\nGRUB_DEFAULT=0\n# Что выводить во время обратного отсчета\nGRUB_TIMEOUT_STYLE=hidden\n# Количество секунд перед загрузкой по-умолчанию\nGRUB_TIMEOUT=10\nGRUB_DISTRIBUTOR=`lsb_release -i -s 2\u003E \u002Fdev\u002Fnull || echo Debian`\n# Аргументы ядра используемые при нормальной загрузке\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\"\n# Аргументы ядра, используемые при нормальной загрузке и в recovery mode\nGRUB_CMDLINE_LINUX=\"\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПодробнее об опциях grub можно прочитать \u003Ca href=\"https:\u002F\u002Fwww.gnu.org\u002Fsoftware\u002Fgrub\u002Fmanual\u002Fgrub\u002Fgrub.html#Simple-configuration\"\u003Eздесь\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003EДля генерации конфигурации второго уровня выполним команду:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Esudo update-grub\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EРазбор полученной конфигурации является уже более сложной задачей и выходит за рамки этой статьи. Тем не менее посмотреть на файл \u003Ccode\u003E\u002Fboot\u002Fgrub\u002Fgrub.cfg\u003C\u002Fcode\u003E все равно будет полезно:) Подробную информацию о его конфигурации grub можно найти \u003Ca href=\"https:\u002F\u002Fwww.gnu.org\u002Fsoftware\u002Fgrub\u002Fmanual\u002Fgrub\u002Fgrub.html\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EДобавим в аргументы ядра, параметр \u003Cem\u003Eusb-vendor\u003C\u002Fem\u003E. Для этого зададим в файле \u003Ccode\u003E\u002Fetc\u002Fdefault\u002Fgrub\u003C\u002Fcode\u003E переменную \u003Ccode\u003EGRUB_CMDLINE_LINUX_DEFAULT\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003EGRUB_CMDLINE_LINUX_DEFAULT=\"nosplash usb-vendor=Aktiv\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ снова обновим конфигурацию:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Esudo update-grub\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПерезапустите систему и посмотрите на результат.\u003C\u002Fp\u003E\u003Ch2\u003EВывод\u003C\u002Fh2\u003E\u003Cp\u003EЕстественно, фича \u003Ccode\u003Ehello-usb\u003C\u002Fcode\u003E не раскрывает всю мощь использования make-initrd. Если вы хотите рассмотреть более живые примеры фич, посмотрите исходники фич:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fosboot\u002Fmake-initrd\u002Ftree\u002Fmaster\u002Ffeatures\u002Fsshfsroot\"\u003Esshfsroot\u003C\u002Fa\u003E. – фича для загрузки с сетевых дисков по протоколу ssh;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fosboot\u002Fmake-initrd\u002Ftree\u002Fmaster\u002Ffeatures\u002Fluks\"\u003Eluks\u003C\u002Fa\u003E – фича для загрузки с зашифрованных разделов;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fosboot\u002Fmake-initrd\u002Ftree\u002Fmaster\u002Ffeatures\u002Fraid\u002Fdata\u002Flib\u002Fuevent\u002Fhandlers\"\u003Eraid\u003C\u002Fa\u003E – фича для загрузки с raid разделов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВ первые две, кстати, мы недавно добавили возможность для аутентификации по смарт-карте.\u003C\u002Fp\u003E\u003Cp\u003EОбратите внимание насколько архитектура этих фичей совпадает с той, что мы реализовывали в hello-usb. Такая структурированность упрощает процесс разработки, и вы можете опираться на нее.\u003C\u002Fp\u003E\u003Cp\u003EMake-initrd также удобен и для конечного использования. Такая крупная ОС, как ALT Linux, использует его в своих дистрибутивах в качестве основного генератора initramfs образов, в частности на таких продуктах, как “Альт Рабочая станция” и “Альт Сервер”. Это ли не показывает его широкую направленность? \u003C\u002Fp\u003E\u003Cp\u003EНа десктопных платформах вы можете добиться желаемого с помощью пары строк в конфигурационном файле, а порой полностью автоматически. Хотите добавить загрузку c сетевого раздела, используя sshfs? Просто напишите \u003Ccode\u003EFEATURE += sshfsroot\u003C\u002Fcode\u003E в файле конфигурации, а в опциях ядра укажите адрес сервера. Хотите добавить загрузку с RAID или LVM разделов? Ничего делать не надо! Если ваш корень лежит на таком разделе, make-initrd автоматически подберет правильную конфигурацию.\u003C\u002Fp\u003E\u003Cp\u003EНа серверных решениях вы можете добиться быстрой загрузки за счет высокой конфигурируемости образов. Вы всегда можете отключить любые ненужные вам фичи, тормозящие загрузку вашей системы. За счет обилия имеющегося функционала можно реализовать загрузку практически любой сложности. А если какого-то функционала будет не хавать, можно быстро реализовать его самостоятельно.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"загрузка linux"},{"titleHtml":"initrd"},{"titleHtml":"initramfs"},{"titleHtml":"bash"},{"titleHtml":"make"},{"titleHtml":"linux"},{"titleHtml":"безопасность"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7bd\u002F643\u002Fff5\u002F7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7bd\u002F643\u002Fff5\u002F7bd643ff58bcf2ff7804bcd74ca4f1dd.jpg","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Faktiv-company\\\u002Fblog\\\u002F582606\\\u002F\"},\"headline\":\"Модифицируем процесс загрузки с помощью утилиты make-initrd\",\"datePublished\":\"2021-10-11T15:01:33+03:00\",\"dateModified\":\"2021-10-11T17:07:27+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"lo1ol\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по р...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Faktiv-company\\\u002Fblog\\\u002F582606\\\u002F#post-content-body\",\"about\":[\"c_aktiv-company\",\"h_linux\",\"h_infosecurity\",\"h_sys_admin\",\"f_develop\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F582606\\\u002Fa9931e7c6ed9df8b58c4045e0db40ef2\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F761\\\u002F2c6\\\u002Fb7b\\\u002F7612c6b7bda35317dcd727d03f80bd6a.jpg\"]}","metaDescription":"Модифицируем процесс загрузки с помощью утилиты make-initrdВ этой статье мы хотим помочь глубже разобраться, как устроен процесс загрузки Linux, дать советы по реализации сложных сценариев загрузки...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"aktiv-company":{"alias":"aktiv-company","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F5da\u002F5f8\u002F38c\u002F5da5f838c6b92a1684f90014cb7ca73d.png","titleHtml":"«Актив»","descriptionHtml":null,"relatedData":null,"statistics":{"postsCount":66,"newsCount":0,"vacanciesCount":0,"employeesCount":15,"careerRating":null,"subscribersCount":28893,"rating":94.12,"invest":null},"foundationDate":{"year":"1994","month":null,"day":null},"location":{"city":{"id":"447159","title":"Москва"},"region":{"id":"1885","title":"Москва и Московская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"http:\u002F\u002Faktiv-company.ru\u002F","staffNumber":"101–200 человек","registrationDate":"2011-12-14T11:48:34+00:00","representativeUser":null,"contacts":[],"settings":{"analyticsSettings":[{"type":"ga","trackingId":"UA-104555245-1"}],"branding":null,"status":"active"},"metadata":{"titleHtml":"«Актив», Москва -  с 1994 год","title":"«Актив», Москва -  с 1994 год","keywords":["Информационная безопасность","Анализ и проектирование систем","Работа с видео","Подготовка технической документации","C"],"descriptionHtml":"66 статей от авторов компании «Актив»","description":"66 статей от авторов компании «Актив»"},"aDeskSettings":null,"careerAlias":"aktiv","maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
