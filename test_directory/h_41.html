<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Заметки о дельта-роботе. Часть 4. Скорости приводов / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/585260\/"},"headline":"Заметки о дельта-роботе. Часть 4. Скорости приводов","datePublished":"2021-10-25T09:33:43+03:00","dateModified":"2021-10-25T12:37:25+03:00","author":{"@type":"Person","name":"multiengineer"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&nbsp;или устройство, кото...","url":"https:\/\/habr.com\/ru\/post\/585260\/#post-content-body","about":["h_robo_dev","h_matlab","h_robot","f_develop","f_popsci"],"image":["https:\/\/habr.com\/share\/publication\/585260\/4c2db03fb1ca9fead965ef0965dd4e47\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/117\/ed3\/d8d\/117ed3d8dd520d081b2837af45333c2e.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/25d\/5b8\/6b2\/25d5b86b27d2e4e9d9b0a6ef830af6f3.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/542\/073\/577\/542073577e66745d23eb2c9ed8ae5da4.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/cb7\/cda\/6a2\/cb7cda6a2b0eed2c7a53b992b2640d3a.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/bc5\/2e9\/013\/bc52e9013c258c0ed9cab0fc1a1188e1.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/fdf\/683\/30c\/fdf68330c23827d04efa905a28b04101.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/25c\/dc2\/297\/25cdc229743da28f6735fe56f9625269.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/949\/d54\/9bd\/949d549bdf871f579ea600da8578eb8f.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/312\/5a8\/6f0\/3125a86f0856ab24d3862cacfe51ecfb.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/4c6\/8b2\/5e9\/4c68b25e9c1c4a3b537212840f559022.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/f09\/9ca\/080\/f099ca08040c2df47dcad4749b9f0837.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/7f6\/aeb\/a1c\/7f6aeba1c4257bc99a8e7b0d769ae037.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/827\/487\/8e9\/8274878e93a51a9785797ffdb54fe0ee.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/ba0\/e0e\/bdb\/ba0e0ebdb5869714330ebd7c96265c07.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d89\/f35\/735\/d89f357359dcec601bf4e47e7dabeffb.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2fe\/c02\/7ab\/2fec027ab212c360c23c57d0b52a50c3.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/e58\/24d\/71d\/e5824d71d1bea791e0e9718837902e47.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/6f1\/92d\/0a8\/6f192d0a83573df1aa2234f0eb7c7d46.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/172\/a3e\/156\/172a3e15671941abdde098d3a1ef7807.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/804\/d17\/04d\/804d1704d56a0a64ab096a962a0473e5.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/c4c\/619\/d51\/c4c619d513df5e428d5ffd7aa97cecd6.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/840\/a98\/9b1\/840a989b12a2e0cc3480b1b4f72e81d6.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/eba\/2d2\/94e\/eba2d294e40058ffa5725dae580c4358.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/78c\/20f\/aab\/78c20faab8b6a1388a30644e03e6097f.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b23\/61f\/7ae\/b2361f7aed7360b89d52e779e50526a5.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/e58\/938\/49a\/e5893849a04b5c2feb04190096735764.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/57d\/cb6\/5af\/57dcb65afd234783bbb32410bc697510.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/181\/2f6\/552\/1812f65526b7fcf01ff059447135b0fb.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/ccd\/cfc\/a48\/ccdcfca4877a29fd983d34ea86fbf1cb.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/25f\/d54\/956\/25fd54956d08e2de06cf1a25df71e295.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/fde\/40f\/820\/fde40f8201f59f2d37bc0f2f8663f931.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/86c\/d03\/a43\/86cd03a432546c6d3c9b3f293af46182.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/8d4\/4f1\/cc9\/8d44f1cc956b38982fe32e8cecb732e1.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/baf\/71c\/aff\/baf71caff9f7d2d1767e675458dc9d56.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/55f\/538\/4f6\/55f5384f63d30cc95fb66f7aa829cd3f.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/f05\/0b6\/a59\/f050b6a59ca007309a692e1ddb365f51.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/cf2\/018\/7bd\/cf20187bdaccc2f8c478a4fbecf9b026.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/0c1\/a38\/e47\/0c1a38e47e22a2aa349d33e290dfce26.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/41c\/d5e\/e19\/41cd5ee19f9e5b946df608b37401c285.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/7b4\/ad2\/afb\/7b4ad2afbb83bc3550e84b0eef4656b4.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/f71\/516\/561\/f71516561d286513a9a3e00734ef2a2e.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/464\/a68\/745\/464a6874597bb5af5e8d75a021d4757c.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/187\/6e6\/9de\/1876e69de443d7f95ee37d2d3de384df.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/cc2\/97c\/2fe\/cc297c2fed641c2d28835534aeae8ffc.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/eee\/37e\/cc1\/eee37ecc14ec3b5b437a23e54d43ca3b.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/e91\/59e\/73c\/e9159e73cd6c48e8708b80eb9d692010.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/120\/e8e\/3f3\/120e8e3f3f1b049fb73364ef95f45a98.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/43c\/9b3\/7b6\/43c9b37b6fcb18228b5dd4cdc032b570.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/eaa\/9e8\/13d\/eaa9e813dd1d93dd999c2f0b1c26f21d.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/4e8\/86f\/f26\/4e886ff26b17f73e8f68936b713fe4d3.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/f1b\/e98\/1d5\/f1be981d546af1152206731e3024c0a3.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d1f\/16e\/ded\/d1f16eded9a11be087bb4412c6bccbdd.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b9c\/519\/5c1\/b9c5195c10d2b934761c7c038612f762.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/e81\/c43\/d75\/e81c43d75f5b64cdcb4fae926ee89c96.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/66f\/e80\/43e\/66fe8043ed0af18f2f71473c5b054c31.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/eed\/d4c\/9b5\/eedd4c9b5a699f5b9914e20396cf40d9.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/3ba\/a92\/036\/3baa9203634113af41b0cf205ed2dcfb.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/777\/604\/fd9\/777604fd997588fdcbfc84eb4d1be94a.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/383\/433\/185\/383433185e315366aeb94b94821bba0d.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/5b7\/f4b\/024\/5b7f4b024eb83478e8f18cd186b3b9d5.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/8f1\/2e0\/60a\/8f12e060a50ee99510915c8468b73f0f.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/0ef\/4ae\/92c\/0ef4ae92cddb16b4b745b2059dcfa4a4.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/9c7\/df4\/b8a\/9c7df4b8ade97abc8f1d1ffb668ea385.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/75d\/c7c\/2ce\/75dc7c2cec0bc10fc1e38e415bd0ef7c.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/6cc\/9e5\/d95\/6cc9e5d959a33f415fd423c5121df60a.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/441\/063\/b5e\/441063b5e30e6c8ba76b2db2b5a69410.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/86b\/b8f\/215\/86bb8f215472353bd255e2b97eab9101.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2b4\/fc8\/2a3\/2b4fc82a32d9e35f52580256cb1926f7.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/0cd\/dfa\/291\/0cddfa29179f461116b7cfe0bbdeb050.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/217\/bc4\/458\/217bc44585bf135b4454167cbcd8787f.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/82f\/d20\/380\/82fd20380c237a72b37872b04d4fe392.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/65d\/ed0\/316\/65ded031693ee418111811f565844a8c.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/403\/9b5\/072\/4039b50728315b5dca8dd48b90e8b8c7.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/351\/743\/51c\/35174351c301b18b2e1d9b63774b2b89.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/e75\/b8c\/137\/e75b8c137ff6baff167898ad05293c26.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/861\/a08\/2d7\/861a082d71814fd1fae1959bb4febf02.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/6b0\/027\/27e\/6b002727ebacd87a3d5be2857a006c6b.PNG","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d75\/cd3\/8dd\/d75cd38ddb9963f2390c47b2fb43608a.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/37d\/792\/c45\/37d792c45d18f954e12cdfe3eefc429c.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b3e\/d4d\/0c1\/b3ed4d0c11dc17d917bd5cc297fb0467.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d68\/488\/889\/d684888890c1af01836a509b6b2c0ede.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2ca\/dfd\/d8f\/2cadfdd8f7de8cbedd729ee41a3ee9af.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/ec2\/115\/55b\/ec211555b92acf08ac92682a20b335a0.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/9c0\/c9a\/d20\/9c0c9ad20a1a70ddc325cb369cf11eae.svg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/010\/300\/bbb\/010300bbbb4c94915c5831ee1a229990.gif","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/ffe\/048\/8b3\/ffe0488b35a8b553b20bae13499a6327.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2d8\/e0d\/ae4\/2d8e0dae43754cfc255f92b04e696006.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/a72\/050\/779\/a72050779709c38824a7736c40dc889b.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/7ca\/ea0\/908\/7caea0908d0c51bd140a49f6d06f9103.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Заметки о дельта-роботе. Часть 4. Скорости приводов" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Заметки о дельта-роботе. Часть 4. Скорости приводов" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Заметки о дельта-роботе. Часть 4. Скорости приводов" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&amp;nbsp;или устройство, которое вращает входные звенья..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&amp;nbsp;или устройство, которое вращает входные звенья..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&amp;nbsp;или устройство, которое вращает входные звенья..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&amp;nbsp;или устройство, которое вращает входные звенья..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&amp;nbsp;или устройство, которое вращает входные звенья..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/639/455/31e/63945531ecbdb184f05a5eb394af7c9f.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/639/455/31e/63945531ecbdb184f05a5eb394af7c9f.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/639/455/31e/63945531ecbdb184f05a5eb394af7c9f.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/639/455/31e/63945531ecbdb184f05a5eb394af7c9f.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/639/455/31e/63945531ecbdb184f05a5eb394af7c9f.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="585260" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-25T06:33:43.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/585260/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/585260/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/639/455/31e/63945531ecbdb184f05a5eb394af7c9f.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/585260/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/multiengineer/" title="multiengineer" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="/ru/users/multiengineer/" class="tm-user-info__username">
      multiengineer
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-25T06:33:43.000Z" title="2021-10-25, 09:33">сегодня в 09:33</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Заметки о дельта-роботе. Часть 4. Скорости приводов</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/robo_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка робототехники</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/matlab/" class="tm-article-snippet__hubs-item-link"><span>Matlab</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/robot/" class="tm-article-snippet__hubs-item-link"><span>Робототехника</span> <!----></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод, или устройство, которое вращает входные звенья (рычаги), имеет две главные характеристики – максимальную частоту вращения и максимальный крутящий момент. Если говорить более обстоятельно, то максимальный крутящий момент зависит ещё и от частоты вращения и нам стоит подбирать привод так, чтобы его момент был во всём диапазоне скоростей больше того, который может возникнуть в разрабатываемом роботе. Помимо этого, у привода есть параметры, характеризующие его точность. Основной упор сегодня  будет на нахождение максимальной частоты вращения. Как всегда, дам все алгоритмы, реализованные в MATLAB.</p><details class="spoiler"><summary>Список обозначений</summary><div class="spoiler__content"><p>Теперь я не буду дублировать содержание этого списка из предыдущих статей, а занесу сюда лишь пояснения новых символов. </p><p><img class="formula inline" source="\omega_1, \omega_2, \omega_3" alt="\omega_1, \omega_2, \omega_3" src="https://habrastorage.org/getpro/habr/upload_files/117/ed3/d8d/117ed3d8dd520d081b2837af45333c2e.svg"/> – угловые скорости первого, второго и третьего приводов (рычагов) соответственно;</p><p><img class="formula inline" source="v_{VX}, v_{VY}, v_{VZ} " alt="v_{VX}, v_{VY}, v_{VZ} " src="https://habrastorage.org/getpro/habr/upload_files/25d/5b8/6b2/25d5b86b27d2e4e9d9b0a6ef830af6f3.svg"/> – координаты вектора скорости рабочего органа;</p><p><img class="formula inline" source="J" alt="J" src="https://habrastorage.org/getpro/habr/upload_files/542/073/577/542073577e66745d23eb2c9ed8ae5da4.svg"/> – матрица Якоби; <img class="formula inline" source="J^{-1}" alt="J^{-1}" src="https://habrastorage.org/getpro/habr/upload_files/cb7/cda/6a2/cb7cda6a2b0eed2c7a53b992b2640d3a.svg"/> – обратная матрица Якоби;</p><p><img class="formula inline" source="j_i^{-1}" alt="j_i^{-1}" src="https://habrastorage.org/getpro/habr/upload_files/bc5/2e9/013/bc52e9013c258c0ed9cab0fc1a1188e1.svg"/> – вектор строка обратной матрицы Якоби.</p></div></details><p>Иначе, задача, в которой мы находим скорость вращения входных звеньев при известных скорости и положении выходного звена, называется <em>задачей о скоростях</em>. Иногда ещё полученные зависимости называют <em>кинематическими характеристиками</em>.</p><p>Поиск этих характеристик может понадобиться не только для правильного выбора приводов, но и для синтеза системы управления.</p><p>Намеченную задачу мы сегодня решим при помощи аж четырёх подходов.</p><p>Первым делом повторим ещё раз, что мы хотим. Мы хотим найти максимальную частоту вращения приводов, которая может возникнуть при движении выходного звена в пределах рабочей зоны с максимальной заданной линейной скоростью. При расчётах считаем, что нам известны текущие координаты подвижной платформы и вектор её скорости. Для меня было немного неожиданным, что скорость входного звена зависит не только от скорости выходного, но и от его положения, но так бывает, наверное, почти всегда, когда мы переходим с декартовой кинематики (портальные роботы), на какую-то иную сложную кинематику (дельта-робот).</p><h2>Подход 1. Дифференцирование функций положения (ФП)</h2><p><a href="https://habr.com/ru/post/580970/" rel="noopener noreferrer nofollow">Ранее</a> мы рассмотрели два варианта аналитического решения обратной кинематической задачи (это и есть функция положения). Воспользуемся вторым из них (формула (13)). Для поиска первой производной по времени запишем все подготовительные вычисления (формулы (9)-(12)) в итоговую формулу (13) и с помощью пакета прикладных программ MATLAB и встроенного в него модуля символьных вычислений найдём первую производную по времени. Ведь слева в этой формуле у нас <em><img class="formula inline" source="θ_1" alt="θ_1" src="https://habrastorage.org/getpro/habr/upload_files/fdf/683/30c/fdf68330c23827d04efa905a28b04101.svg"/>, </em>а если быть точнее то <img class="formula inline" source="θ_1(t)" alt="θ_1(t)" src="https://habrastorage.org/getpro/habr/upload_files/25c/dc2/297/25cdc229743da28f6735fe56f9625269.svg"/>. Производная по времени от этой функции <img class="formula inline" source="dθ_1/dt=w_1(t)" alt="dθ_1/dt=w_1(t)" src="https://habrastorage.org/getpro/habr/upload_files/949/d54/9bd/949d549bdf871f579ea600da8578eb8f.svg"/>как раз и будет скоростью входного звена.</p><details class="spoiler"><summary>Скрипт для нахождения производной в символьном виде в MATLAB</summary><div class="spoiler__content"><pre><code class="matlab">%Объявляем символьные переменные
syms Tetta_1(t) X_V(t) Y_V(t) Z_V(t)
syms OQ VM R_l R_r F f X_0 Y_0 Z_0
syms omega_1(t) v_VX(t) v_VY(t) v_VZ(t)
%Записываем функцию порложения, как уравнение
NL = sqrt(R_r^2-X_V^2);
y_M = -VM + Y_V;
y_Q = -OQ;
const_1 = y_M - y_Q;
NQ = sqrt(const_1^2 + Z_V^2);
Eq1 = Tetta_1 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ)) - acos(const_1/NQ);
%Дифференцируем его
Eq2 = diff(Eq1, t);
%Подставляем вместо производных координат по времени скорости
Eq2 = subs(Eq2, [diff(Tetta_1(t), t), diff(X_V(t), t), diff(Y_V(t), t), diff(Z_V(t), t)], [omega_1 v_VX v_VY v_VZ ]);
%"Собираем" уравнение вокруг v_VX, v_VY и v_VZ
col2 = collect(Eq2, [v_VX v_VY v_VZ])</code></pre><p>Я рекомендую для запуска это кода использовать <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="33" data-src="https://habrastorage.org/getpro/habr/upload_files/312/5a8/6f0/3125a86f0856ab24d3862cacfe51ecfb.png" data-width="121"/>. Тогда после запуска вы сразу увидите это:</p><figure class="full-width "><img src="/img/image-loader.svg" height="542" data-src="https://habrastorage.org/getpro/habr/upload_files/4c6/8b2/5e9/4c68b25e9c1c4a3b537212840f559022.png" data-width="910"/><figcaption></figcaption></figure><p>В последних версиях MATLAB появилась возможность даже копировать это в Word, что экономит кучу времени при наборе формул.</p></div></details><p>Как итог, получим формулу:</p><figure class=""><img src="/img/image-loader.svg" alt="(1)" title="(1)" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/f09/9ca/080/f099ca08040c2df47dcad4749b9f0837.png" data-width="318"/><figcaption>(1)</figcaption></figure><p>где <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/7f6/aeb/a1c/7f6aeba1c4257bc99a8e7b0d769ae037.png" data-width="126"/>– угловая скорость первого рычага;</p><p><img inline="true" class="image image-inline" src="/img/image-loader.svg" height="21" data-src="https://habrastorage.org/getpro/habr/upload_files/827/487/8e9/8274878e93a51a9785797ffdb54fe0ee.png" data-width="352"/>– составляющие скорости точки <em>V</em>, направленные вдоль осей <em>X</em>, <em>Y</em>, <em>Z</em> соответственно;</p><p><img inline="true" class="image image-inline" src="/img/image-loader.svg" height="17" data-src="https://habrastorage.org/getpro/habr/upload_files/ba0/e0e/bdb/ba0e0ebdb5869714330ebd7c96265c07.png" data-width="66"/>– функции, зависящие от <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="20" data-src="https://habrastorage.org/getpro/habr/upload_files/d89/f35/735/d89f357359dcec601bf4e47e7dabeffb.png" data-width="157"/>.</p><p>Функции <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="17" data-src="https://habrastorage.org/getpro/habr/upload_files/2fe/c02/7ab/2fec027ab212c360c23c57d0b52a50c3.png" data-width="66"/> определяют следующие формулы:</p><figure class=""><img src="/img/image-loader.svg" alt="(2)" title="(2)" height="233" data-src="https://habrastorage.org/getpro/habr/upload_files/e58/24d/71d/e5824d71d1bea791e0e9718837902e47.png" data-width="356"/><figcaption>(2)</figcaption></figure><p>где </p><figure class=""><img src="/img/image-loader.svg" height="302" data-src="https://habrastorage.org/getpro/habr/upload_files/6f1/92d/0a8/6f192d0a83573df1aa2234f0eb7c7d46.png" data-width="321"/><figcaption></figcaption></figure><details class="spoiler"><summary>Код функции, для нахождения угловых скоростей дифференцированием ФП</summary><div class="spoiler__content"><pre><code class="matlab">%Находит решение задачи о скоростях методом дифференцирования функций пооложения
function [w_1, w_2, w_3] = OZK_v(X_V, Y_V, Z_V, v_VX, v_VY, v_VZ)
%Расчёт координат точки V в системах координат, повёрнутых на 120° и 240°
%по часовой стрелке относительно основной
global R_l R_r cos120 sin120 cos240 sin240 VM OQ
X_V_120 = X_V*cos120 - Y_V*sin120;
Y_V_120 = X_V*sin120 + Y_V*cos120;
    X_V_240 = X_V*cos240 - Y_V*sin240;
    Y_V_240 = X_V*sin240 + Y_V*cos240;
%Расчёт векторов скоростей точки V в системах координат, повёрнутых на 120° и 240°
%по часовой стрелке относительно основной
v_VX_120 = v_VX*cos120 - v_VY*sin120;
v_VY_120 = v_VX*sin120 + v_VY*cos120;
    v_VX_240 = v_VX*cos240 - v_VY*sin240;
    v_VY_240 = X_V*sin240 + v_VY*cos240;
        Z_V_120 = Z_V;
        Z_V_240 = Z_V;
            v_VZ_120 = v_VZ;
            v_VZ_240 = v_VZ;
%Расчёт углов поворота рычагов в соответствующих системах координат
w_1 = (v_VY/(Z_V^2 + (OQ - VM + Y_V)^2)^(1/2) - ((2*v_VY*(OQ - VM + Y_V) + 2*v_VZ*Z_V)*(OQ - VM + Y_V))/(2*(Z_V^2 + (OQ - VM + Y_V)^2)^(3/2)))/(1 - (OQ - VM + Y_V)^2/(Z_V^2 + (OQ - VM + Y_V)^2))^(1/2) + ((2*v_VY*(OQ - VM + Y_V) + 2*v_VX*X_V + 2*v_VZ*Z_V)/(2*R_l*(Z_V^2 + (OQ - VM + Y_V)^2)^(1/2)) - ((2*v_VY*(OQ - VM + Y_V) + 2*v_VZ*Z_V)*(X_V^2 + Z_V^2 + (OQ - VM + Y_V)^2 + R_l^2 - R_r^2))/(4*R_l*(Z_V^2 + (OQ - VM + Y_V)^2)^(3/2)))/(1 - (X_V^2 + Z_V^2 + (OQ - VM + Y_V)^2 + R_l^2 - R_r^2)^2/(4*R_l^2*(Z_V^2 + (OQ - VM + Y_V)^2)))^(1/2);
w_2 = (v_VY_120/(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(1/2) - ((2*v_VY_120*(OQ - VM + Y_V_120) + 2*v_VZ_120*Z_V_120)*(OQ - VM + Y_V_120))/(2*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(3/2)))/(1 - (OQ - VM + Y_V_120)^2/(Z_V_120^2 + (OQ - VM + Y_V_120)^2))^(1/2) + ((2*v_VY_120*(OQ - VM + Y_V_120) + 2*v_VX_120*X_V_120 + 2*v_VZ_120*Z_V_120)/(2*R_l*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(1/2)) - ((2*v_VY_120*(OQ - VM + Y_V_120) + 2*v_VZ_120*Z_V_120)*(X_V_120^2 + Z_V_120^2 + (OQ - VM + Y_V_120)^2 + R_l^2 - R_r^2))/(4*R_l*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(3/2)))/(1 - (X_V_120^2 + Z_V_120^2 + (OQ - VM + Y_V_120)^2 + R_l^2 - R_r^2)^2/(4*R_l^2*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)))^(1/2);
w_3 = (v_VY_240/(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(1/2) - ((2*v_VY_240*(OQ - VM + Y_V_240) + 2*v_VZ_240*Z_V_240)*(OQ - VM + Y_V_240))/(2*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(3/2)))/(1 - (OQ - VM + Y_V_240)^2/(Z_V_240^2 + (OQ - VM + Y_V_240)^2))^(1/2) + ((2*v_VY_240*(OQ - VM + Y_V_240) + 2*v_VX_240*X_V_240 + 2*v_VZ_240*Z_V_240)/(2*R_l*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(1/2)) - ((2*v_VY_240*(OQ - VM + Y_V_240) + 2*v_VZ_240*Z_V_240)*(X_V_240^2 + Z_V_240^2 + (OQ - VM + Y_V_240)^2 + R_l^2 - R_r^2))/(4*R_l*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(3/2)))/(1 - (X_V_240^2 + Z_V_240^2 + (OQ - VM + Y_V_240)^2 + R_l^2 - R_r^2)^2/(4*R_l^2*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)))^(1/2);
end</code></pre></div></details><p>Громоздко, не правда ли? На самом деле ещё нет. Вот если мы ещё раз продифференцируем, чтобы найти угловое ускорение, вот тогда будет по-настоящему громоздко. Но всё же, можно ли формулы покороче получить?</p><h3>Подход 2. Метод планов скоростей</h3><p>В умных книжках <abbr title="Теория механизмов и машин Тимофеев Г. А. 3-ие издание (книжка есть в моей библиотеке, ссылку давал в первой статье)">🕮</abbr> по теории механизмов и машин всегда рассказывают о методе планов скоростей. По идее, это графический метод решения нужной нам задачи, но считать то мы будем всё равно в MATLAB-е. Поэтому я бы не сказал, что он менее точный.</p><p>Рассмотрим его. Вообще, с этим методом лучше знакомится на примере плоской задачи.   Но я расскажу сразу на примере пространственного механизма – дельта-робота, подразумевая, что вы с ним заранее ознакомились. Начнём.</p><figure class="full-width "><img src="/img/image-loader.svg" height="775" data-src="https://habrastorage.org/getpro/habr/upload_files/172/a3e/156/172a3e15671941abdde098d3a1ef7807.png" data-width="1462"/><figcaption></figcaption></figure><p>Пугаться этой картинки не стоит. Сейчас я поясню всё, что на ней изображено.</p><p>Первым шагом введём новую систему координат <em>X'Y'Z'</em> с началом координат <img class="formula inline" source="p_V" alt="p_V" src="https://habrastorage.org/getpro/habr/upload_files/804/d17/04d/804d1704d56a0a64ab096a962a0473e5.svg"/>. <img class="formula inline" source="p_V" alt="p_V" src="https://habrastorage.org/getpro/habr/upload_files/c4c/619/d51/c4c619d513df5e428d5ffd7aa97cecd6.svg"/>– это полюс скоростей, если говорить "книжно". Систему координат можно располагать как угодно (например, как и основную), но мне показалась удобным именно так.</p><p>В этой системе координат необходимо построить вектор скорости подвижной платформы. Нам он известен по условию. Вектор найдем как сумму векторов его компонент по осям <em>X</em>, <em>Y</em>, и <em>Z</em>. Не забудем перевести эти компоненты в новую систему координат. Этот вектор будет совпадать с векторами скоростей точек <em>V</em> и <em>M</em>, так как это точки одного звена (платформы). Таким образом мы получим вектор <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="22" data-src="https://habrastorage.org/getpro/habr/upload_files/840/a98/9b1/840a989b12a2e0cc3480b1b4f72e81d6.png" data-width="25"/>.</p><p>Скорость точки <em>L</em>, будет направлена по касательной к окружности с центром в точке <em>Q</em>. То есть скорость точки <em>L</em> будет направлена перпендикулярно звену <em>QL</em> и, как и это звено, всегда будет лежать в плоскости <img class="formula inline" source="X'p_VY'" alt="X'p_VY'" src="https://habrastorage.org/getpro/habr/upload_files/eba/2d2/94e/eba2d294e40058ffa5725dae580c4358.svg"/>. Направление этого вектора мы зададим прямой <img class="formula inline" source="a" alt="a" src="https://habrastorage.org/getpro/habr/upload_files/78c/20f/aab/78c20faab8b6a1388a30644e03e6097f.svg"/>, а саму прямую легко можем построить, так как знаем координаты точек <em>L</em> и <em>Q</em>. </p><p>Данный подход предполагает, что мы сначала решаем обратную задачу кинематики и, благодаря полученному решению, можем найти координаты точек <em>Q</em>, <em>L</em> и <em>M</em>. </p><p>Вектор <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="22" data-src="https://habrastorage.org/getpro/habr/upload_files/b23/61f/7ae/b2361f7aed7360b89d52e779e50526a5.png" data-width="25"/>начинается из полюса скоростей, то есть как бы из неподвижной точки. Вектор <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/e58/938/49a/e5893849a04b5c2feb04190096735764.png" data-width="20"/>тоже будет начинаться как бы из неподвижной точки, то есть полюса скоростей.  Вектор <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/57d/cb6/5af/57dcb65afd234783bbb32410bc697510.png" data-width="29"/> – это вектор скорости точки <em>L</em> относительно точки <em>M</em>. И его начало уже неподвижным считать нельзя. Он должен начинаться из конца вектора <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="22" data-src="https://habrastorage.org/getpro/habr/upload_files/181/2f6/552/1812f65526b7fcf01ff059447135b0fb.png" data-width="25"/>.  </p><p>Мы знаем, что точка <em>L</em> относительно точки <em>M </em>будет двигаться в направлении перпендикулярном звену <em>LM</em> (по касательной к сфере с центром в точке <em>M </em>и радиусом LM). Тогда мы можем построить плоскость <img class="formula inline" source="γ" alt="γ" src="https://habrastorage.org/getpro/habr/upload_files/ccd/cfc/a48/ccdcfca4877a29fd983d34ea86fbf1cb.svg"/>, которая будет перпендикулярна звену <em>LM </em>(или прямой <img class="formula inline" source="b" alt="b" src="https://habrastorage.org/getpro/habr/upload_files/25f/d54/956/25fd54956d08e2de06cf1a25df71e295.svg"/>) и проходить через точку <em>M'</em> на плане скоростей. Пересечение этой плоскости с прямой <img class="formula inline" source="a" alt="a" src="https://habrastorage.org/getpro/habr/upload_files/fde/40f/820/fde40f8201f59f2d37bc0f2f8663f931.svg"/>определит координаты точки <em>L'</em> на плане скоростей, что позволит найти вектор <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/86c/d03/a43/86cd03a432546c6d3c9b3f293af46182.png" data-width="20"/>. Зная координаты <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="25" data-src="https://habrastorage.org/getpro/habr/upload_files/8d4/4f1/cc9/8d44f1cc956b38982fe32e8cecb732e1.png" data-width="95"/> вектора <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/baf/71c/aff/baf71caff9f7d2d1767e675458dc9d56.png" data-width="20"/> мы можем найти его длину по формуле:</p><figure class=""><img src="/img/image-loader.svg" alt="(3)" title="(3)" height="28" data-src="https://habrastorage.org/getpro/habr/upload_files/55f/538/4f6/55f5384f63d30cc95fb66f7aa829cd3f.png" data-width="180"/><figcaption>(3)</figcaption></figure><p>А зная длину этого вектора, то есть линейную скорость, легко найдём угловую скорость звена <em>QL</em> по формуле:</p><figure class=""><img src="/img/image-loader.svg" alt="(4)" title="(4)" height="47" data-src="https://habrastorage.org/getpro/habr/upload_files/f05/0b6/a59/f050b6a59ca007309a692e1ddb365f51.png" data-width="66"/><figcaption>(4)</figcaption></figure><p>Таким образом, чтобы найти угловую скорость первого рычага, нужно найти координаты <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="25" data-src="https://habrastorage.org/getpro/habr/upload_files/cf2/018/7bd/cf20187bdaccc2f8c478a4fbecf9b026.png" data-width="95"/>, как пресечение плоскости <img class="formula inline" source="γ" alt="γ" src="https://habrastorage.org/getpro/habr/upload_files/0c1/a38/e47/0c1a38e47e22a2aa349d33e290dfce26.svg"/> и прямой <img class="formula inline" source="a" alt="a" src="https://habrastorage.org/getpro/habr/upload_files/41c/d5e/e19/41cd5ee19f9e5b946df608b37401c285.svg"/>.</p><p>Уравнение плоскости, перпендикулярной прямой (прямой <img class="formula inline" source="b" alt="b" src="https://habrastorage.org/getpro/habr/upload_files/7b4/ad2/afb/7b4ad2afbb83bc3550e84b0eef4656b4.svg"/> в нашем случае) имеет вид:</p><figure class=""><img src="/img/image-loader.svg" alt="(5)" title="(5)" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/f71/516/561/f71516561d286513a9a3e00734ef2a2e.png" data-width="256"/><figcaption>(5)</figcaption></figure><p>где <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/464/a68/745/464a6874597bb5af5e8d75a021d4757c.png" data-width="67"/> – координаты точки, через которую проходит плоскость;</p><p><img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/187/6e6/9de/1876e69de443d7f95ee37d2d3de384df.png" data-width="46"/> – координаты направляющего вектора.</p><p><img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/cc2/97c/2fe/cc297c2fed641c2d28835534aeae8ffc.png" data-width="67"/> на плане скоростей – это и есть координаты вектора <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="22" data-src="https://habrastorage.org/getpro/habr/upload_files/eee/37e/cc1/eee37ecc14ec3b5b437a23e54d43ca3b.png" data-width="25"/>. Координаты направляющего вектора найдём путём вычитания координат точки <em>L</em> из координат точки <em>M</em>. Тогда уравнение плоскости <img class="formula inline" source="\gamma" alt="\gamma" src="https://habrastorage.org/getpro/habr/upload_files/e91/59e/73c/e9159e73cd6c48e8708b80eb9d692010.svg"/> в введённой нами системе координат примет вид:</p><figure class=""><img src="/img/image-loader.svg" alt="(6)" title="(6)" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/120/e8e/3f3/120e8e3f3f1b049fb73364ef95f45a98.png" data-width="457"/><figcaption>(6)</figcaption></figure><p>Далее запишем уравнение прямой <img class="formula inline" source="a" alt="a" src="https://habrastorage.org/getpro/habr/upload_files/43c/9b3/7b6/43c9b37b6fcb18228b5dd4cdc032b570.svg"/>:</p><figure class=""><img src="/img/image-loader.svg" alt="(7)" title="(7)" height="49" data-src="https://habrastorage.org/getpro/habr/upload_files/eaa/9e8/13d/eaa9e813dd1d93dd999c2f0b1c26f21d.png" data-width="100"/><figcaption>(7)</figcaption></figure><p>Помимо этого, мы знаем, что точка пересечения плоскости и прямой <img class="formula inline" source="a" alt="a" src="https://habrastorage.org/getpro/habr/upload_files/4e8/86f/f26/4e886ff26b17f73e8f68936b713fe4d3.svg"/>лежит в плоскости <img class="formula inline" source="X'p_VY'" alt="X'p_VY'" src="https://habrastorage.org/getpro/habr/upload_files/f1b/e98/1d5/f1be981d546af1152206731e3024c0a3.svg"/>:</p><figure class=""><img src="/img/image-loader.svg" alt="(8)" title="(8)" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/d1f/16e/ded/d1f16eded9a11be087bb4412c6bccbdd.png" data-width="43"/><figcaption>(8)</figcaption></figure><p>Тогда решение системы из этих трёх уравнений (6, 7, 8) и будет искомой точкой, а <img class="formula inline" source="x, y" alt="x, y" src="https://habrastorage.org/getpro/habr/upload_files/b9c/519/5c1/b9c5195c10d2b934761c7c038612f762.svg"/> и <img class="formula inline" source="z" alt="z" src="https://habrastorage.org/getpro/habr/upload_files/e81/c43/d75/e81c43d75f5b64cdcb4fae926ee89c96.svg"/> будут координатами <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/66f/e80/43e/66fe8043ed0af18f2f71473c5b054c31.png" data-width="61"/> и <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/eed/d4c/9b5/eedd4c9b5a699f5b9914e20396cf40d9.png" data-width="26"/>.</p><p>Я слишком стар, чтобы подставить второе и третье уравнение в первое и выразить <img class="formula inline" source="x" alt="x" src="https://habrastorage.org/getpro/habr/upload_files/3ba/a92/036/3baa9203634113af41b0cf205ed2dcfb.svg"/> самостоятельно. Поэтому даже здесь я заставил работать MATLAB:</p><pre><code class="matlab">syms X_Q1 Y_Q1 Z_Q1 X_L1 Y_L1 Z_L1 X_M1 Y_M1 Z_M1
syms x y z
syms v_VX v_VY v_VZ
y = (Y_Q1-Y_L1)/(Z_Q1-Z_L1)*x;
z = 0;
Eq3 = (-Y_L1+Y_M1)*(x+v_VY)+(Z_L1-Z_M1)*((Y_Q1-Y_L1)/(Z_Q1-Z_L1)*x-v_VZ)...
    +(-X_L1+X_M1)*(0+v_VX) == 0
solve(Eq3, x)  </code></pre><p>А он мне выдал:</p><figure class=""><img src="/img/image-loader.svg" height="94" data-src="https://habrastorage.org/getpro/habr/upload_files/777/604/fd9/777604fd997588fdcbfc84eb4d1be94a.png" data-width="415"/><figcaption></figcaption></figure><p>Стоит отметить ещё необходимость проверки направления получившегося вектора, так как последнее влияет на знак угловой скорости <img class="formula inline" source="\omega_1" alt="\omega_1" src="https://habrastorage.org/getpro/habr/upload_files/383/433/185/383433185e315366aeb94b94821bba0d.svg"/>. Благодаря тому, что мы заранее ограничиваем угол поворота рычага от 90° до 270°, условие проверки упрощается до проверки знака <img class="formula inline" source="y" alt="y" src="https://habrastorage.org/getpro/habr/upload_files/5b7/f4b/024/5b7f4b024eb83478e8f18cd186b3b9d5.svg"/>. Если <img class="formula inline" source="y>0" alt="y>0" src="https://habrastorage.org/getpro/habr/upload_files/8f1/2e0/60a/8f12e060a50ee99510915c8468b73f0f.svg"/>, то знак у <img class="formula inline" source="\omega_1" alt="\omega_1" src="https://habrastorage.org/getpro/habr/upload_files/0ef/4ae/92c/0ef4ae92cddb16b4b745b2059dcfa4a4.svg"/>-, иначе +.</p><details class="spoiler"><summary>Код функции, для нахождения угловых скоростей методом планов</summary><div class="spoiler__content"><pre><code class="matlab">%Находит решение задачи о скоростях методом планов
function [w_1, w_2, w_3] = OZK_v_pv(X_V, Y_V, Z_V, v_VX, v_VY, v_VZ)
global R_l VM OQ cos120 sin120 cos240 sin240 %Размеры и константы
%Расчёт углов поворота рычагов в соответствующих системах координат
[vectTheta] = OZK(X_V, Y_V, Z_V);
Theta1 = vectTheta(1); Theta2 = vectTheta(2); Theta3 = vectTheta(3);
            %Вычисляем координаты точек в системах координат XOY,
            %X120Y120Z120 и X240Y240Z240
            Y_Q1 = -OQ;
            Z_Q1 = 0;
            X_L1 = 0;
            Y_L1 = -(OQ + R_l*sind(Theta1-90));
            Z_L1 =  R_l*cosd(Theta1-90);
            X_M1 = X_V;
            Y_M1 = Y_V - VM;
            Z_M1 = Z_V;
                X_V_120 = X_V*cos120 - Y_V*sin120;
                Y_V_120 = X_V*sin120 + Y_V*cos120;
                Z_V_120 = Z_V;
                Y_Q2_120 = -OQ;
                Z_Q2_120 = 0;
                X_L2_120 = 0;
                Y_L2_120 = -(OQ + R_l*sind(Theta2-90));
                Z_L2_120 =  R_l*cosd(Theta2-90);
                X_M2_120 = X_V_120;
                Y_M2_120 = Y_V_120 - VM;
                Z_M2_120 = Z_V_120;
                    X_V_240 = X_V*cos240 - Y_V*sin240;
                    Y_V_240 = X_V*sin240 + Y_V*cos240;
                    Z_V_240 = Z_V;
                    Y_Q3_240 = -OQ;
                    Z_Q3_240 = 0;
                    X_L3_240 = 0;
                    Y_L3_240 = -(OQ + R_l*sind(Theta3-90));
                    Z_L3_240 =  R_l*cosd(Theta3-90);
                    X_M3_240 = X_V_240;
                    Y_M3_240 = Y_V_240 - VM;
                    Z_M3_240 = Z_V_240;
                        v_VX_120 = v_VX*cos120 - v_VY*sin120;
                        v_VY_120 = v_VX*sin120 + v_VY*cos120;
                        v_VZ_120 = v_VZ;
                            v_VX_240 = v_VX*cos240 - v_VY*sin240;
                            v_VY_240 = v_VX*sin240 + v_VY*cos240;
                            v_VZ_240 = v_VZ;



x = (v_VX*(X_L1 - X_M1) + v_VY*(Y_L1 - Y_M1) + v_VZ*(Z_L1 - Z_M1))/(Y_M1 - Y_L1 + ((Y_L1 - Y_Q1)*(Z_L1 - Z_M1))/(Z_L1 - Z_Q1));
y = (Y_Q1-Y_L1)/(Z_Q1-Z_L1)*x;
v_L1 = sqrt(x^2+y^2);
if y>0
    znak = -1;
else
    znak = 1;
end
w_1 = znak*v_L1/R_l;
    x = (v_VX_120*(X_L2_120 - X_M2_120) + v_VY_120*(Y_L2_120 - Y_M2_120) + v_VZ_120*(Z_L2_120 - Z_M2_120))/(Y_M2_120 - Y_L2_120 + ((Y_L2_120 - Y_Q2_120)*(Z_L2_120 - Z_M2_120))/(Z_L2_120 - Z_Q2_120));
    y = (Y_Q2_120-Y_L2_120)/(Z_Q2_120-Z_L2_120)*x;
    v_L2_120 = sqrt(x^2+y^2);
    if y>0
        znak = -1;
    else
        znak = 1;
    end
    w_2 = znak*v_L2_120/R_l;
        x = (v_VX_240*(X_L3_240 - X_M3_240) + v_VY_240*(Y_L3_240 - Y_M3_240) + v_VZ_240*(Z_L3_240 - Z_M3_240))/(Y_M3_240 - Y_L3_240 + ((Y_L3_240 - Y_Q3_240)*(Z_L3_240 - Z_M3_240))/(Z_L3_240 - Z_Q3_240));
        y = (Y_Q3_240-Y_L3_240)/(Z_Q3_240-Z_L3_240)*x;
        v_L3_240 = sqrt(x^2+y^2);
        if y>0
            znak = -1;
        else
            znak = 1;
        end
        w_3 = znak*v_L3_240/R_l;
end</code></pre></div></details><h2>Подход 3. Матричный метод</h2><p>А вот и настало время для зловещего матричного метода. В статьях, посвящённых дельта-роботу часто можно встретить матричное исчисление. Попробуем и мы применить его, а также скажем, чем этот метод хорош.</p><p>По ходу повествования я буду опираться на вот эти <abbr title="ОЦЕНКА БЛИЗОСТИ К ОСОБЫМ ПОЛОЖЕНИЯМ МЕХАНИЗМОВ ПАРАЛЛЕЛЬНОЙ СТРУКТУРЫ ПУТЕМ ДИФФЕРЕНЦИРОВАНИЯ УРАВНЕНИЙ СВЯЗИ П.А. Ларюшкин">🕮</abbr>, <abbr title="РАЗРАБОТКА И ИССЛЕДОВАНИЕ ПРОСТРАНСТВЕННЫХ МЕХАНИЗМОВ ПАРАЛЛЕЛЬНОЙ СТРУКТУРЫ С ШАРНИРНЫМИ ПАРАЛЛЕЛОГРАММАМИ С РАЗЛИЧНЫМ ЧИСЛОМ СТЕПЕНЕЙ СВОБОДЫ Носова Н. Ю.">🕮</abbr>, <abbr title="РАЗРАБОТКА НАУЧНЫХ ОСНОВ СОЗДАНИЯ МАНИПУЛЯЦИОННЫХ МЕХАНИЗМОВ ПАРАЛЛЕЛЬНОЙ СТРУКТУРЫ ДЛЯ РОБОТОТЕХНИЧЕСКИХ СИСТЕМ ПРЕДПРИЯТИЙ ТЕКСТИЛЬНОЙ И ЛЕГКОЙ ПРОМЫШЛЕННОСТИ Хейло С. В.">🕮</abbr> источники. С автором первого источника я лично знаком и походу написания этого раздела активно закидывал его вопросами, чтобы совсем уж дичь тут вам не писать.</p><p>Первое, что следует сделать – следует записать уравнения связи. Уравнение связи (первое) для дельта-робота это не что иное, как функция положения (формула (13) <a href="https://habr.com/ru/post/580970/" rel="noopener noreferrer nofollow">этой</a> работы), у которой после знака = мы оставим 0, а потом вместо 0 запишем <img class="formula inline" source="F_1" alt="F_1" src="https://habrastorage.org/getpro/habr/upload_files/9c7/df4/b8a/9c7df4b8ade97abc8f1d1ffb668ea385.svg"/>:</p><figure class=""><img src="/img/image-loader.svg" alt="(9)" title="(9)" height="52" data-src="https://habrastorage.org/getpro/habr/upload_files/75d/c7c/2ce/75dc7c2cec0bc10fc1e38e415bd0ef7c.png" data-width="470"/><figcaption>(9)</figcaption></figure><p>Или, что тоже самое:</p><figure class=""><img src="/img/image-loader.svg" alt="(10)" title="(10)" height="50" data-src="https://habrastorage.org/getpro/habr/upload_files/6cc/9e5/d95/6cc9e5d959a33f415fd423c5121df60a.png" data-width="379"/><figcaption>(10)</figcaption></figure><p>Заметим, что последнее уравнение записано не в явном виде, то есть <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="21" data-src="https://habrastorage.org/getpro/habr/upload_files/441/063/b5e/441063b5e30e6c8ba76b2db2b5a69410.png" data-width="19"/> не выражено, через координаты рабочего органа (если мы снова уберём <img class="formula inline" source="F_1" alt="F_1" src="https://habrastorage.org/getpro/habr/upload_files/86b/b8f/215/86bb8f215472353bd255e2b97eab9101.svg"/>). Это первое преимущество метода – можно написать более простую неявную функцию.</p><p>Далее, используя эти уравнения связи можно составить матрицы:</p><figure class=""><img src="/img/image-loader.svg" alt="(11)" title="(11)" height="145" data-src="https://habrastorage.org/getpro/habr/upload_files/2b4/fc8/2a3/2b4fc82a32d9e35f52580256cb1926f7.png" data-width="421"/><figcaption>(11)</figcaption></figure><p>Элементы матриц представляют собой не что иное, как частные производные функций положения по входным или выходным координатам. </p><p>Далее мы можем записать следующее матричное уравнение:</p><figure class=""><img src="/img/image-loader.svg" alt="(12)" title="(12)" height="60" data-src="https://habrastorage.org/getpro/habr/upload_files/0cd/dfa/291/0cddfa29179f461116b7cfe0bbdeb050.png" data-width="181"/><figcaption>(12)</figcaption></figure><p>Решая его относительно вектора скоростей приводов, получим:</p><figure class=""><img src="/img/image-loader.svg" alt="(13)" title="(13)" height="60" data-src="https://habrastorage.org/getpro/habr/upload_files/217/bc4/458/217bc44585bf135b4454167cbcd8787f.png" data-width="301"/><figcaption>(13)</figcaption></figure><p><img class="formula inline" source="J" alt="J" src="https://habrastorage.org/getpro/habr/upload_files/82f/d20/380/82fd20380c237a72b37872b04d4fe392.svg"/> – это, так называемая, матрица Якоби (или Якобиан), то есть матрица, связывающая входные <img class="formula inline" source="\omega_1, \omega_2, \omega_3" alt="\omega_1, \omega_2, \omega_3" src="https://habrastorage.org/getpro/habr/upload_files/65d/ed0/316/65ded031693ee418111811f565844a8c.svg"/> и выходные <img class="formula inline" source="v_{VX}, v_{VY}, v_{VZ}" alt="v_{VX}, v_{VY}, v_{VZ}" src="https://habrastorage.org/getpro/habr/upload_files/403/9b5/072/4039b50728315b5dca8dd48b90e8b8c7.svg"/> скорости.</p><p>Таким образом, знаю эту матрицу, можно легко найти скорости рычагов, зная скорость и положение выходного звена.</p><p>Второе преимущество такого подхода заключается в том, что мы можем быстренько переписать это матричное уравнение вот так:</p><figure class=""><img src="/img/image-loader.svg" alt="(14)" title="(14)" height="60" data-src="https://habrastorage.org/getpro/habr/upload_files/351/743/51c/35174351c301b18b2e1d9b63774b2b89.png" data-width="139"/><figcaption>(14)</figcaption></figure><p>То есть, зная Якобиан, можно решить и прямую задачу о скоростях.</p><p>Здесь сразу стоит отметить, что если мы составляем уравнение связи из явных функций, то можно сразу решать матричное уравнение и находить скорости входных звеньев. Если же мы составляем их из неявной функции, то сначала потребуется решить задачу о положениях, так как в матрице <img class="formula inline" source="B" alt="B" src="https://habrastorage.org/getpro/habr/upload_files/e75/b8c/137/e75b8c137ff6baff167898ad05293c26.svg"/> у нас будут присутствовать входные координаты, которые мы без решения ОЗК не знаем:</p><figure class=""><img src="/img/image-loader.svg" alt="(15)" title="(15)" height="65" data-src="https://habrastorage.org/getpro/habr/upload_files/861/a08/2d7/861a082d71814fd1fae1959bb4febf02.png" data-width="265"/><figcaption>(15)</figcaption></figure><p>Если уж быть совсем честным, то в конечном счёте, при вычислении угловых скоростей матричным способом мы придём к уравнениям вида (1), о которых говорили в первом подходе. Та что все рассмотренные способы очень близки.</p><p>Ну и последним преимуществом матричного метода я бы назвал удобство последующего анализа. То есть математически формализуя таким образом решение, мы легко можем узнать, например, скорость входного звена при наихудшем направлении скорости выходного звена. Об этом будет сказано ниже. Помимо этого, можно достаточно легко найти, так называемые, особые положения и много чего ещё.</p><p>Чуть не забыл про алгоритмы.</p><details class="spoiler"><summary>Скрипт для нахождения обратной матрицы Якоби</summary><div class="spoiler__content"><pre><code class="matlab">%Задаём символьные переменные
syms Tetta_1 Tetta_2 Tetta_3 X_V Y_V Z_V
syms OQ VM R_l R_r F f X_0 Y_0 Z_0
syms omega_1(t) v_VX(t) v_VY(t) v_VZ(t)
syms epsilon_1 a_VX a_VY a_VZ
syms v_VX v_VY v_VZ
%Записываем решение обратной кинематической задачи в аналитическом виде
NL = sqrt(R_r^2-X_V^2);
y_M = -VM + Y_V;
y_Q = -OQ;
const_1 = y_M - y_Q;
NQ = sqrt(const_1^2 + Z_V^2);
Eq1 = Tetta_1 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ))...
    - acos(const_1/NQ);
%Формируем уравнение связи
F_1 = 2*pi - acos((R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ))...
    - acos(const_1/NQ) - Tetta_1;
% F_1 = - (R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ)...
%     - const_1/NQ+cos(2*pi - Tetta_1);
    %Проделываем те же операции для 2-го плеча
    X_V_120 = X_V*cos(2*pi/3) - Y_V*sin(2*pi/3);
    Y_V_120 = X_V*sin(2*pi/3) + Y_V*cos(2*pi/3);
    Z_V_120 = Z_V;
    NL = sqrt(R_r^2-X_V_120^2);
    y_M = -VM + Y_V_120;
    y_Q = -OQ;
    const_1 = y_M - y_Q;
    NQ = sqrt(const_1^2 + Z_V_120^2);
    Eq2 = Tetta_2 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ))...
        - acos(const_1/NQ);
    F_2 = 2*pi - acos((R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ))...
        - acos(const_1/NQ) - Tetta_2;
%     F_2 = - (R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ)...
%         - const_1/NQ + cos(2*pi - Tetta_2);
        %Для 3-го плеча
        X_V_240 = X_V*cos(4*pi/3) - Y_V*sin(4*pi/3);
        Y_V_240 = X_V*sin(4*pi/3) + Y_V*cos(4*pi/3);
        Z_V_240 = Z_V;
        NL = sqrt(R_r^2-X_V_240^2);
        y_M = -VM + Y_V_240;
        y_Q = -OQ;
        const_1 = y_M - y_Q;
        NQ = sqrt(const_1^2 + Z_V_240^2);
        Eq3 = Tetta_3 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ))...
            - acos(const_1/NQ);
        F_3 = 2*pi - acos((R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ))...
            - acos(const_1/NQ) - Tetta_3;
%                 F_3 = - (R_l^2 + NQ^2 - NL^2)/(2*R_l*NQ)...
%             - const_1/NQ + cos(2*pi - Tetta_3);

%Составляем матрицы А и В
A = [diff(F_1, X_V), diff(F_1, Y_V), diff(F_1, Z_V);
     diff(F_2, X_V), diff(F_2, Y_V), diff(F_2, Z_V);
     diff(F_3, X_V), diff(F_3, Y_V), diff(F_3, Z_V)];
B = [diff(F_1, Tetta_1), 0, 0;
     0, diff(F_2, Tetta_2), 0;
     0, 0, diff(F_3, Tetta_3)];
J = -A*inv(B)

%Подставляем конкретные значения (для проверки)
J_ch = double(subs(J, [X_V, Y_V, Z_V, OQ, VM, R_l, R_r, F, f],...
  [70.7107, 0, -325, 77.9423, 31.7543, 170, 320, 270, 110]));

%Вычисляем скорости в тестовой точке
v = [-0.4381; 139.3182; 787.7755];
w = J_ch*v
%Ответ [-3.1503; -3.3611; -4.4766]</code></pre><p>На эту матрицу в символьном виде смотреть, конечно, страшно:</p><figure class="full-width "><img src="https://habrastorage.org/getpro/habr/upload_files/6b0/027/27e/6b002727ebacd87a3d5be2857a006c6b.PNG" width="1230" height="329"/><figcaption></figcaption></figure><p>Стрелочки указывают на полосы прокрутки. Можно представить сколько дополнительных констант MATLAB там нагенерировал.</p></div></details><h2>Проверка. Движение по заданной траектории с максимальной скоростью. Подход 4. Графическое дифференцирование</h2><p>После формирования алгоритма для нахождения скоростей входных звеньев следует убедиться в правильности работы полученных скриптов. Я решил проверить сразу всё.</p><p>Для проверки мы синтезируем траекторию (массив точек), по которым будет (виртуально) перемещаться подвижная платформа с максимальной скоростью. Я выбрал вот такую траекторию:</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Синус, &quot;намотанный&quot; на цилиндр" title="Синус, &quot;намотанный&quot; на цилиндр" height="607" data-src="https://habrastorage.org/getpro/habr/upload_files/d75/cd3/8dd/d75cd38ddb9963f2390c47b2fb43608a.png" data-width="1185"/><figcaption>Синус, "намотанный" на цилиндр</figcaption></figure><p>Далее для каждой точки траектории нужно найти вектор скорости. Направлен он будет к следующей точке.</p><p>В результате работы алгоритма хотелось бы получить четыре графика, на которых будут показаны зависимости скорости первого рычага от времени, рассчитываемые всеми четырьмя методами. </p><p>Тут появляется время. Вектор времени можно найти, зная, сколько должно занимать перемещение от одной точки до другой с максимальной скоростью. Между точками у нас расстояние постоянно меняется, поэтому тут придётся его считать для всей траектории.</p><p>Ну а потом, итоговый вектор времени можно получить используя функцию <em>cumsum</em>, которая создаёт новый вектор, суммируя для каждого значения все предшествующие значения исходного вектора.</p><p>В общем, не буду томить. Всё совпало <s>с 101-го раза</s>:</p><figure class="full-width "><img src="/img/image-loader.svg" height="777" data-src="https://habrastorage.org/getpro/habr/upload_files/37d/792/c45/37d792c45d18f954e12cdfe3eefc429c.png" data-width="1316"/><figcaption></figcaption></figure><p>Последний 4-ый подход (на графике он первый) я использовал исключительно для проверки первых трёх.</p><p>Его суть заключается в следующем – мы уже умеем решать обратную задачу кинематики. Вот и решим её для каждой точки. То есть найдём зависимость <img inline="true" class="image image-inline" src="/img/image-loader.svg" height="23" data-src="https://habrastorage.org/getpro/habr/upload_files/b3e/d4d/0c1/b3ed4d0c11dc17d917bd5cc297fb0467.png" data-width="41"/>.</p><p>А теперь просто можно найти производную численно, так как у нас есть вектора (здесь под векторами я подразумеваю массивы) <img class="formula inline" source="dt" alt="dt" src="https://habrastorage.org/getpro/habr/upload_files/d68/488/889/d684888890c1af01836a509b6b2c0ede.svg"/> и <img class="formula inline" source="dθ_1" alt="dθ_1" src="https://habrastorage.org/getpro/habr/upload_files/2ca/dfd/d8f/2cadfdd8f7de8cbedd729ee41a3ee9af.svg"/>:</p><figure class=""><img src="/img/image-loader.svg" alt="(16)" title="(16)" height="44" data-src="https://habrastorage.org/getpro/habr/upload_files/ec2/115/55b/ec211555b92acf08ac92682a20b335a0.png" data-width="97"/><figcaption>(16)</figcaption></figure><p>И так для каждой точки.</p><p>Так как мы проверили ОЗК и, наверняка, правильно вычислили вектор значений <img class="formula inline" source="dt" alt="dt" src="https://habrastorage.org/getpro/habr/upload_files/9c0/c9a/d20/9c0c9ad20a1a70ddc325cb369cf11eae.svg"/>, то и полученный график тоже должен быть правильным.</p><p>Вот рабочий скрипт:</p><details class="spoiler"><summary>Скрипт, который находит скорость первого рычага всеми методами</summary><div class="spoiler__content"><pre><code class="matlab">clear all
%Входные данные
BOX = [200, 100]; %Ширина и высота рабочей зоны (квадратный параллелепипед)
Z0BOX = -375; %Координата дна рабочей зоны
v_max = 800; %Максимальная требуемая линейная скорость [мм/с]
%Подгружаем константы и итоговые конструктивные размеры
InputConstant;

%Параметры дискретизации пространственных траекторий
Diskr = 1000; %Число точек, в которых вычизляем значение пространственной кривой

%Подготовительные вычисления
R_BOX = BOX(1)*sqrt(2)/2; % Радиус описанного цилиндра рабочей области

%Формируем траекторию для исследования скоростных характеристик
fi1 = linspace(0, 2*pi, Diskr);
fi2 = linspace(0, 8*2*pi, Diskr);
X_V = R_BOX*0.5*cos(fi1);
Y_V = R_BOX*0.5*sin(fi1);
Z_V = Z0BOX + BOX(2)/2 + BOX(2)/2*sin(fi2);
hold on;
plot3(X_V, Y_V, Z_V, 'LineWidth', 1.5);
hold off;
axis equal;
xlabel('x, мм');
ylabel('y, мм');
zlabel('z, мм');
title('Рассматриваемая траектория движения');
grid on;
view([-25, 20]);


%Вычисляем вектор скорости в каждой точке каждой траектории
dX = X_V([2:Diskr, 1])-X_V(1:Diskr);
dY = Y_V([2:Diskr, 1])-Y_V(1:Diskr);
dZ = Z_V([2:Diskr, 1])-Z_V(1:Diskr);
dL = sqrt(dX.^2 + dY.^2 + dZ.^2);
v_VX = dX*v_max./dL;
v_VY = dY*v_max./dL;
v_VZ = dZ*v_max./dL;

%v_vect=sqrt(v_VX.^2 + v_VY.^2 + v_VZ.^2)
%quiver3(X_V, Y_V, Z_V, v_VX*0.07, v_VY*0.07, v_VZ*0.07, 'AutoScale', 'off');

%Задаём вектор скорости рычага 1
w1 = [];
%Вычисляем скорость рычагов в каждой точке траектории
for k=1:Diskr
    [w_1, w_2, w_3] = OZK_v(X_V(k), Y_V(k), Z_V(k), v_VX(k), v_VY(k), v_VZ(k));
    w1 = [w1, w_1];
end

%Вычисляем вектор времени
dTime = dL/v_max;
Time = cumsum(dTime);

%Вычисляем скорости методом планов
for k=1:Diskr
    [Tetta1, Tetta2, Tetta3] = OZK(X_V(k), Y_V(k), Z_V(k));
    Tetta1_vect(k)=Tetta1;
    Y_L1 = -(OQ + R_l*sind(Tetta1-90));
    Z_L1 =  R_l*cosd(Tetta1-90);
    Y_M1 = Y_V(k) - VM;
    Z_M1 = Z_V(k);
    Y_Q1 = -OQ;
    Z_Q1 = 0;
    X_L1 = 0;
    X_M1 = X_V(k);
    x = (v_VX(k)*(X_L1 - X_M1) + v_VY(k)*(Y_L1 - Y_M1) + v_VZ(k)*(Z_L1 - Z_M1))/(Y_M1 - Y_L1 + ((Y_L1 - Y_Q1)*(Z_L1 - Z_M1))/(Z_L1 - Z_Q1));
    y = (Y_Q1-Y_L1)/(Z_Q1-Z_L1)*x;
    v_L1 = sqrt(x^2+y^2);
    if y>0
        znak = -1;
    else
        znak = 1;
    end
    w1_pv(k) = znak*v_L1/R_l;
end

%Вычисляем скорости матричным методом
for k=1:Diskr
    J = [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          X_V(k)/(R_l*(1 - ((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2)^2/(4*R_l^2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)))^(1/2)*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1/2)),                                                                                                                                                                                                                                                                                                   ((2*OQ - 2*VM + 2*Y_V(k))/(2*R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1/2)) - ((2*OQ - 2*VM + 2*Y_V(k))*((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2))/(4*R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3/2)))/(1 - ((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2)^2/(4*R_l^2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)))^(1/2) + (1/((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1/2) - ((2*OQ - 2*VM + 2*Y_V(k))*(OQ - VM + Y_V(k)))/(2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3/2)))/(1 - (OQ - VM + Y_V(k))^2/((OQ - VM + Y_V(k))^2 + Z_V(k)^2))^(1/2),                                                                                                                                                                                                                                 (Z_V(k)/(R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1/2)) - (Z_V(k)*((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2))/(2*R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3/2)))/(1 - ((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2)^2/(4*R_l^2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)))^(1/2) - (Z_V(k)*(OQ - VM + Y_V(k)))/(((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3/2)*(1 - (OQ - VM + Y_V(k))^2/((OQ - VM + Y_V(k))^2 + Z_V(k)^2))^(1/2));
    (3^(1/2)/(2*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) - (3^(1/2)*(OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2)/(2*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2))^(1/2) + ((X_V(k)/2 + (3^(1/2)*Y_V(k))/2 + 3^(1/2)*(OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2))/(2*R_l*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) - (3^(1/2)*(OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)*((X_V(k)/2 + (3^(1/2)*Y_V(k))/2)^2 + (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))/(4*R_l*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - ((X_V(k)/2 + (3^(1/2)*Y_V(k))/2)^2 + (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2/(4*R_l^2*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)))^(1/2), ((VM - OQ + Y_V(k)/2 - (3^(1/2)*X_V(k))/2 + 3^(1/2)*(X_V(k)/2 + (3^(1/2)*Y_V(k))/2))/(2*R_l*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) + ((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)*((X_V(k)/2 + (3^(1/2)*Y_V(k))/2)^2 + (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))/(4*R_l*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - ((X_V(k)/2 + (3^(1/2)*Y_V(k))/2)^2 + (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2/(4*R_l^2*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)))^(1/2) + ((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/(2*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)) - 1/(2*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)))/(1 - (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2))^(1/2), (Z_V(k)/(R_l*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) - (Z_V(k)*((X_V(k)/2 + (3^(1/2)*Y_V(k))/2)^2 + (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))/(2*R_l*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - ((X_V(k)/2 + (3^(1/2)*Y_V(k))/2)^2 + (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2/(4*R_l^2*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)))^(1/2) - (Z_V(k)*(OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2))/((1 - (OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2))^(1/2)*((OQ - VM - Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2));
    ((X_V(k)/2 - (3^(1/2)*Y_V(k))/2 + 3^(1/2)*(VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2))/(2*R_l*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) - (3^(1/2)*(VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)*((X_V(k)/2 - (3^(1/2)*Y_V(k))/2)^2 + (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))/(4*R_l*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - ((X_V(k)/2 - (3^(1/2)*Y_V(k))/2)^2 + (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2/(4*R_l^2*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)))^(1/2) - (3^(1/2)/(2*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) - (3^(1/2)*(VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2)/(2*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2))^(1/2), ((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2 - 3^(1/2)*(X_V(k)/2 - (3^(1/2)*Y_V(k))/2))/(2*R_l*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) - ((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)*((X_V(k)/2 - (3^(1/2)*Y_V(k))/2)^2 + (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))/(4*R_l*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - ((X_V(k)/2 - (3^(1/2)*Y_V(k))/2)^2 + (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2/(4*R_l^2*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)))^(1/2) + ((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/(2*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)) - 1/(2*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)))/(1 - (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2))^(1/2), (Z_V(k)/(R_l*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(1/2)) - (Z_V(k)*((X_V(k)/2 - (3^(1/2)*Y_V(k))/2)^2 + (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))/(2*R_l*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2)))/(1 - ((X_V(k)/2 - (3^(1/2)*Y_V(k))/2)^2 + (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2/(4*R_l^2*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)))^(1/2) + (Z_V(k)*(VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2))/((1 - (VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2/((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2))^(1/2)*((VM - OQ + Y_V(k)/2 + (3^(1/2)*X_V(k))/2)^2 + Z_V(k)^2)^(3/2))];
v_V = [v_VX(k); v_VY(k); v_VZ(k)];
w = J*v_V;
w1_mat(k) = w(1);
end

%Находим производную Tetta1_vect графически
%Перевод в радианы
Tetta1_vect = Tetta1_vect*pi/180;
w1_der = diff([Tetta1_vect, Tetta1_vect(1)])./dTime;
%Отображаем скорость первого рычага на графиках
figure
hold on;
subplot(2, 2, 1);
plot(Time, w1_der*30/pi);
grid on;
xlabel('t, c');
ylabel('\omega, об/мин');
title('Грифическое дифференцирование');
axis([0, 2.1, -55, 55]);
subplot(2, 2, 2);
plot(Time, w1*30/pi);
grid on;
xlabel('t, c');
ylabel('\omega, об/мин');
title('Аналитический метод');
axis([0, 2.1, -55, 55]);
subplot(2, 2, 3);
plot(Time, w1_pv*30/pi);
grid on;
xlabel('t, c');
ylabel('\omega, об/мин');
title('Метод планов');
axis([0, 2.1, -55, 55]);
subplot(2, 2, 4);
plot(Time, w1_mat*30/pi);
grid on;
xlabel('t, c');
ylabel('\omega, об/мин');
title('Матричный мотод');
axis([0, 2.1, -55, 55]);
hold off;</code></pre><p>Тут используется функция, которую я демонстрировал в первом подходе, функция, решающая ОЗК, которую я давал ранее и код, в котором объявляются константы (InputConstant;):</p><pre><code class="matlab">%Задаём параметры механизма
global f F R_l R_r cos120 sin120 cos240 sin240 VM OQ
f = 110;    %Длина стороны треугольника платформы
F = 270;    %Длина стороны треугольника основания
R_l = 170;  %Длина рычагов
R_r = 320;  %Длина штанг
%Расчёт констант
cos120 = cosd(120);
sin120 = sind(120);
cos240 = cosd(240);
sin240 = sind(240);

VM = f*sqrt(3)/6;
OQ = F*sqrt(3)/6;</code></pre><p>Я это всё слепил из того, что было. Можно оформить это "красивше".</p></div></details><p>Добавив к коду выше вот это:</p><pre><code class="matlab">dim = [f F R_l R_r];
figure
for k = 1:Diskr
V = [X_V(k), Y_V(k), Z_V(k)];
[Theta1, Theta2, Theta3] = OZK(X_V(k), Y_V(k), Z_V(k));
Theta = [Theta1, Theta2, Theta3];
drawDelta(dim, V, Theta)%Это я накидывал бонусом  ранее
axis([-250, 250, -250, 250, -390, 100]);
hold on;
plot3(X_V(1:k), Y_V(1:k), Z_V(1:k),'LineWidth', 1.5, 'Color', 'r');
hold off;
drawnow
pause(dTime(k)*20);
end</code></pre><p>Можно получить вот такую симуляцию работы (я замедлил отрисовку в 20 раз, а потом на видео ускорил в 65 раз, а то MATLAB на моём слабеньком ноуте не успевал считать):</p><figure class="full-width "><img src="/img/image-loader.svg" height="482" data-src="https://habrastorage.org/getpro/habr/upload_files/010/300/bbb/010300bbbb4c94915c5831ee1a229990.gif" data-width="551"/><figcaption></figcaption></figure><p>Да, так быстро дельта-робот может и должен двигаться – 2.1 секунды на всю траекторию. Скорость платформы, кстати, 1 м/с.</p><h2>Поиск максимальной скорости привода</h2><p>Пришло время использовать то, что мы получили ранее. Для поиска максимальной скорости привода возьмём размеры робота, найденные в ходе <a href="https://habr.com/ru/post/583190/" rel="noopener noreferrer nofollow">предыдущей</a> работы.</p><p>Первым делом сгенерируем массив точек для анализа внутри желаемой рабочей зоны:</p><figure class="full-width "><img src="/img/image-loader.svg" height="637" data-src="https://habrastorage.org/getpro/habr/upload_files/ffe/048/8b3/ffe0488b35a8b553b20bae13499a6327.png" data-width="1063"/><figcaption></figcaption></figure><p>Не забываем, что дельта-робот имеет симметрию и достаточно рассмотреть лишь 1/6 рабочей зоны.</p><p>Вот моя реализация этого алгоритма:</p><details class="spoiler"><summary>Функция genTP</summary><div class="spoiler__content"><pre><code class="matlab">%Генерирует массив точек для анализа
function [TestPointsX, TestPointsY, TestPointsZ] = genTP()
%Добавляем глобальные переменные входных и выходных данных
global WZ_D WZ_H WZ_Z WZ_d WZ_h %Рабочая зона
global addSeg %Переменная, показывающая необходимость дополнительного
%сегмента в рабочей зоне
global dotDensity %Плотность точек

%Для тестирования
dotDensity = 30;
WZ_D = 320;
WZ_d = 100;
WZ_d = 562;
WZ_H = 150;
WZ_Z = -390;
WZ_h = 50;
addSeg = 0;

%Задаём массив точек, заведомо покрывающий интересующий нас участок рабочей
%зоны
x = linspace(-WZ_D/2, 0, dotDensity);
y = linspace(-WZ_D/2, 0, dotDensity);
z = linspace(WZ_Z-WZ_h, WZ_Z+WZ_H, dotDensity);
[X, Y, Z] = meshgrid(x, y, z);
X = reshape(X, [1, size(X, 1)^3, 1]);
Y = reshape(Y, [1, size(Y, 1)^3, 1]);
Z = reshape(Z, [1, size(Z, 1)^3, 1]);

%Находим индексы точек, попадающих в цилиндрическую область
inCil = X.^2+Y.^2 &lt;= (WZ_D/2)^2;
%И попадающих в сектр 60°
inSec = Y &lt; tand(30)*X;
%Находим инексы точек попадающих
%1 Только в цилиндрическую РЗ
if addSeg == 0
    inDopSeg = Z > WZ_Z;
end
%В цилиндрическую РЗ и усёчённый конус
if addSeg == 1
    z0 = WZ_Z - WZ_h*(WZ_D/2)/((WZ_D-WZ_d)/2);
    a2_c2 = ((WZ_D/2)/(WZ_Z-z0))^2;
    inDopSeg = X.^2 + Y.^2 &lt;= a2_c2*(Z-z0).^2;
end
%В цилиндрическую РЗ и в часть сферы
if addSeg == 2
    inDopSeg = (X.^2 + Y.^2 + (Z-(WZ_Z-WZ_h+WZ_d/2)).^2 &lt;= (WZ_d/2)^2)|(Z > WZ_Z);
end
%Формируем индексы точек, удовлетворяющих всем условиям
inWZ = inCil &amp; inDopSeg &amp; inSec;
TestPointsX = X(inWZ);
TestPointsY = Y(inWZ);
TestPointsZ = Z(inWZ);

%Тестовая отрисовка точек
plot3(X(inWZ), Y(inWZ), Z(inWZ), '.r');
xlabel('x, мм');
ylabel('y, мм');
zlabel('z, мм');
grid on;
end
</code></pre></div></details><p>Теперь в каждой точке нам нужно нужно найти угловые скорости рычагов (скорости приводов) при движении исполнительного звена в этой точке с максимальной требуемой скоростью.</p><p>Но ведь скорость входных звеньев зависит ещё и от <em>направления</em> движения выходного звена. Значит для каждой точки нужно рассмотреть ещё и массив направлений. Например точек для анализа у нас будет 1000. Направлений в каждой точке 100, тогда всего нам придётся запускать цикл поиска входных скоростей 100 000 раз. Многовато, не правда ли? Я так и сделал изначально. MATLAB считал секунд 40, но направлений я брал всего 22 в каждой точке:</p><figure class="full-width "><img src="/img/image-loader.svg" height="525" data-src="https://habrastorage.org/getpro/habr/upload_files/2d8/e0d/ae4/2d8e0dae43754cfc255f92b04e696006.png" data-width="700"/><figcaption></figcaption></figure><p>Помимо того, что это долго, у нас ещё есть риск, что максимальная скорость будет чуть больше из-за того, что мы не проверили самое "наихудшее" направление.</p><p>Правильным подходом здесь является запуск алгоритма в каждой тестовой точке лишь с одним, но "наихудшим" направлением вектора скорости. Оказывается, можно это "наихудшее" направление заранее узнать.</p><p>Вот тут на помощь как раз приходит матричный метод. Скорость i-го привода мы вычисляем путём умножения вектора строки Якобиана на вектор столбец скорости рабочего органа:</p><figure class=""><img src="/img/image-loader.svg" alt="(17)" title="(17)" height="60" data-src="https://habrastorage.org/getpro/habr/upload_files/a72/050/779/a72050779709c38824a7736c40dc889b.png" data-width="366"/><figcaption>(17)</figcaption></figure><p>Данное векторное произведение достигает своего максимума тогда, когда эти вектора являются коллинеарными. Если опустить все доказательства, то можно сказать, что для дельта-робота справедлива следующая формула:</p><figure class=""><img src="/img/image-loader.svg" alt="(18)" title="(18)" height="46" data-src="https://habrastorage.org/getpro/habr/upload_files/7ca/ea0/908/7caea0908d0c51bd140a49f6d06f9103.png" data-width="408"/><figcaption>(18)</figcaption></figure><p>Эта запись математически звучит так: "произведение длины вектора максимальной скорости платформы на евклидовой норму i-ой строки обратной матрицы Якоби". Звучит жутко, но записывается коротко, а считается быстро.</p><p>Посчитав для каждой точки для всех трёх приводов по этой формуле максимальную угловую скорость привода и найдя среди итих значений максимум, мы и получим максимальную скорость привода.</p><p>Вот коротенький код:</p><details class="spoiler"><summary>Итоговый код для определения максимальной скорости привода</summary><div class="spoiler__content"><pre><code class="matlab">%Задаём начальное значение
wmax = 0;

%Задаём входные данные
vmax = 1000;
R_l = 170;
R_r = 320;
OQ = 77.9423;
VM = 23.094;
cos120 = cosd(120);
sin120 = sind(120);
cos240 = cosd(240);
sin240 = sind(240);
[TestPointsX, TestPointsY, TestPointsZ] = genTP();

%Запускаем цикл проверки в кажой точке
for k = 1:size(TestPointsX, 2)
J = [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TestPointsX(k)/(R_l*(1 - ((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)))^(1/2)*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1/2)),                                                                                                                                                                                                                                                                                                   ((2*OQ - 2*VM + 2*TestPointsY(k))/(2*R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1/2)) - ((2*OQ - 2*VM + 2*TestPointsY(k))*((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2))/(4*R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)))^(1/2) + (1/((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1/2) - ((2*OQ - 2*VM + 2*TestPointsY(k))*(OQ - VM + TestPointsY(k)))/(2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3/2)))/(1 - (OQ - VM + TestPointsY(k))^2/((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2))^(1/2),                                                                                                                                                                                                                                 (TestPointsZ(k)/(R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1/2)) - (TestPointsZ(k)*((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2))/(2*R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)))^(1/2) - (TestPointsZ(k)*(OQ - VM + TestPointsY(k)))/(((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3/2)*(1 - (OQ - VM + TestPointsY(k))^2/((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2))^(1/2));
    (3^(1/2)/(2*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) - (3^(1/2)*(OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2)/(2*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2))^(1/2) + ((TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2 + 3^(1/2)*(OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2))/(2*R_l*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) - (3^(1/2)*(OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)*((TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2)^2 + (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))/(4*R_l*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2)^2 + (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)))^(1/2), ((VM - OQ + TestPointsY(k)/2 - (3^(1/2)*TestPointsX(k))/2 + 3^(1/2)*(TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2))/(2*R_l*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) + ((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)*((TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2)^2 + (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))/(4*R_l*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2)^2 + (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)))^(1/2) + ((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/(2*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)) - 1/(2*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)))/(1 - (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2))^(1/2), (TestPointsZ(k)/(R_l*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) - (TestPointsZ(k)*((TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2)^2 + (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))/(2*R_l*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((TestPointsX(k)/2 + (3^(1/2)*TestPointsY(k))/2)^2 + (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)))^(1/2) - (TestPointsZ(k)*(OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2))/((1 - (OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2))^(1/2)*((OQ - VM - TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2));
    ((TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2 + 3^(1/2)*(VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2))/(2*R_l*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) - (3^(1/2)*(VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)*((TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2)^2 + (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))/(4*R_l*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2)^2 + (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)))^(1/2) - (3^(1/2)/(2*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) - (3^(1/2)*(VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2)/(2*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2))^(1/2), ((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2 - 3^(1/2)*(TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2))/(2*R_l*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) - ((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)*((TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2)^2 + (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))/(4*R_l*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2)^2 + (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)))^(1/2) + ((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/(2*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)) - 1/(2*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)))/(1 - (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2))^(1/2), (TestPointsZ(k)/(R_l*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(1/2)) - (TestPointsZ(k)*((TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2)^2 + (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))/(2*R_l*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2)))/(1 - ((TestPointsX(k)/2 - (3^(1/2)*TestPointsY(k))/2)^2 + (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2/(4*R_l^2*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)))^(1/2) + (TestPointsZ(k)*(VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2))/((1 - (VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2/((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2))^(1/2)*((VM - OQ + TestPointsY(k)/2 + (3^(1/2)*TestPointsX(k))/2)^2 + TestPointsZ(k)^2)^(3/2))];
w_max_TP = [norm(J(1, :))*vmax, norm(J(2, :))*vmax, norm(J(3, :))*vmax];
    %Находим максимум скорости рычагов
    wmax = max([abs(w_max_TP), wmax]);
end
n = 30*wmax/pi
</code></pre><p>Тут используем лишь одну пользовательскую функцию genTP(), которую я давал ранее.</p></div></details><p>В следующей статье найдём максимальны крутящий момент и порассуждаем, какие комплектующие для привода стоит выбирать. Затронем вопрос точности привода.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B4%D0%B5%D0%BB%D1%8C%D1%82%D0%B0-%D1%80%D0%BE%D0%B1%D0%BE%D1%82%5D" class="tm-tags-list__link">дельта-робот</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0%20%D0%BE%20%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8F%D1%85%5D" class="tm-tags-list__link">задача о скоростях</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%AF%D0%BA%D0%BE%D0%B1%D0%B8%D0%B0%D0%BD%5D" class="tm-tags-list__link">Якобиан</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%BB%D0%B0%D0%BD%20%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D0%B5%D0%B9%5D" class="tm-tags-list__link">план скоростей</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0%20%D0%AF%D0%BA%D0%BE%D0%B1%D0%B8%5D" class="tm-tags-list__link">матрица Якоби</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D0%B8%20%D0%BF%D1%80%D0%B8%D0%B2%D0%BE%D0%B4%D0%BE%D0%B2%5D" class="tm-tags-list__link">скорости приводов</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%83%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%B2%D1%8F%D0%B7%D0%B8%5D" class="tm-tags-list__link">уравнения связи</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BC%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%B7%D0%BC%D1%8B%5D" class="tm-tags-list__link">параллельные механизмы</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/robo_dev/" class="tm-hubs-list__link">
    Разработка робототехники
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/matlab/" class="tm-hubs-list__link">
    Matlab
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/robot/" class="tm-hubs-list__link">
    Робототехника
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 7: ↑7 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 7: ↑7 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+7</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">747</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    11
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/multiengineer/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 19 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    19
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">61</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/multiengineer/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @multiengineer
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/585260/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 4 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/585260/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/585260/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"585260":{"id":"585260","timePublished":"2021-10-25T06:33:43+00:00","isCorporative":false,"lang":"ru","titleHtml":"Заметки о дельта-роботе. Часть 4. Скорости приводов","leadData":{"textHtml":"\u003Cp\u003EВ результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&nbsp;или устройство, которое вращает входные звенья (рычаги), имеет две главные характеристики – максимальную частоту вращения и максимальный крутящий момент. Если говорить более обстоятельно, то максимальный крутящий момент зависит ещё и от частоты вращения и нам стоит подбирать привод так, чтобы его момент был во всём диапазоне скоростей больше того, который может возникнуть в разрабатываемом роботе. Помимо этого, у привода есть параметры, характеризующие его точность. Основной упор сегодня  будет на нахождение максимальной частоты вращения. Как всегда, дам все алгоритмы, реализованные в MATLAB.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F639\u002F455\u002F31e\u002F63945531ecbdb184f05a5eb394af7c9f.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F639\u002F455\u002F31e\u002F63945531ecbdb184f05a5eb394af7c9f.png","fit":"cover","positionY":49.545454545455,"positionX":1.2820512820513}},"editorVersion":"2.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":19,"votesCount":19},"rating":61,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2647083","alias":"multiengineer","fullname":null,"avatarUrl":null,"speciality":null},"statistics":{"commentsCount":4,"favoritesCount":11,"readingCount":747,"score":7,"votesCount":7},"hubs":[{"relatedData":null,"id":"19735","alias":"robo_dev","type":"collective","title":"Разработка робототехники","titleHtml":"Разработка робототехники","isProfiled":true},{"relatedData":null,"id":"21360","alias":"matlab","type":"collective","title":"Matlab","titleHtml":"Matlab","isProfiled":true},{"relatedData":null,"id":"21902","alias":"robot","type":"collective","title":"Робототехника","titleHtml":"Робототехника","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EВ результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод, или устройство, которое вращает входные звенья (рычаги), имеет две главные характеристики – максимальную частоту вращения и максимальный крутящий момент. Если говорить более обстоятельно, то максимальный крутящий момент зависит ещё и от частоты вращения и нам стоит подбирать привод так, чтобы его момент был во всём диапазоне скоростей больше того, который может возникнуть в разрабатываемом роботе. Помимо этого, у привода есть параметры, характеризующие его точность. Основной упор сегодня  будет на нахождение максимальной частоты вращения. Как всегда, дам все алгоритмы, реализованные в MATLAB.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EСписок обозначений\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003EТеперь я не буду дублировать содержание этого списка из предыдущих статей, а занесу сюда лишь пояснения новых символов. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg class=\"formula inline\" source=\"\\omega_1, \\omega_2, \\omega_3\" alt=\"\\omega_1, \\omega_2, \\omega_3\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F117\u002Fed3\u002Fd8d\u002F117ed3d8dd520d081b2837af45333c2e.svg\"\u002F\u003E – угловые скорости первого, второго и третьего приводов (рычагов) соответственно;\u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg class=\"formula inline\" source=\"v_{VX}, v_{VY}, v_{VZ} \" alt=\"v_{VX}, v_{VY}, v_{VZ} \" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F25d\u002F5b8\u002F6b2\u002F25d5b86b27d2e4e9d9b0a6ef830af6f3.svg\"\u002F\u003E – координаты вектора скорости рабочего органа;\u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg class=\"formula inline\" source=\"J\" alt=\"J\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F542\u002F073\u002F577\u002F542073577e66745d23eb2c9ed8ae5da4.svg\"\u002F\u003E – матрица Якоби; \u003Cimg class=\"formula inline\" source=\"J^{-1}\" alt=\"J^{-1}\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcb7\u002Fcda\u002F6a2\u002Fcb7cda6a2b0eed2c7a53b992b2640d3a.svg\"\u002F\u003E – обратная матрица Якоби;\u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg class=\"formula inline\" source=\"j_i^{-1}\" alt=\"j_i^{-1}\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fbc5\u002F2e9\u002F013\u002Fbc52e9013c258c0ed9cab0fc1a1188e1.svg\"\u002F\u003E – вектор строка обратной матрицы Якоби.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EИначе, задача, в которой мы находим скорость вращения входных звеньев при известных скорости и положении выходного звена, называется \u003Cem\u003Eзадачей о скоростях\u003C\u002Fem\u003E. Иногда ещё полученные зависимости называют \u003Cem\u003Eкинематическими характеристиками\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cp\u003EПоиск этих характеристик может понадобиться не только для правильного выбора приводов, но и для синтеза системы управления.\u003C\u002Fp\u003E\u003Cp\u003EНамеченную задачу мы сегодня решим при помощи аж четырёх подходов.\u003C\u002Fp\u003E\u003Cp\u003EПервым делом повторим ещё раз, что мы хотим. Мы хотим найти максимальную частоту вращения приводов, которая может возникнуть при движении выходного звена в пределах рабочей зоны с максимальной заданной линейной скоростью. При расчётах считаем, что нам известны текущие координаты подвижной платформы и вектор её скорости. Для меня было немного неожиданным, что скорость входного звена зависит не только от скорости выходного, но и от его положения, но так бывает, наверное, почти всегда, когда мы переходим с декартовой кинематики (портальные роботы), на какую-то иную сложную кинематику (дельта-робот).\u003C\u002Fp\u003E\u003Ch2\u003EПодход 1. Дифференцирование функций положения (ФП)\u003C\u002Fh2\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F580970\u002F\" rel=\"noopener noreferrer nofollow\"\u003EРанее\u003C\u002Fa\u003E мы рассмотрели два варианта аналитического решения обратной кинематической задачи (это и есть функция положения). Воспользуемся вторым из них (формула (13)). Для поиска первой производной по времени запишем все подготовительные вычисления (формулы (9)-(12)) в итоговую формулу (13) и с помощью пакета прикладных программ MATLAB и встроенного в него модуля символьных вычислений найдём первую производную по времени. Ведь слева в этой формуле у нас \u003Cem\u003E\u003Cimg class=\"formula inline\" source=\"θ_1\" alt=\"θ_1\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ffdf\u002F683\u002F30c\u002Ffdf68330c23827d04efa905a28b04101.svg\"\u002F\u003E, \u003C\u002Fem\u003Eа если быть точнее то \u003Cimg class=\"formula inline\" source=\"θ_1(t)\" alt=\"θ_1(t)\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F25c\u002Fdc2\u002F297\u002F25cdc229743da28f6735fe56f9625269.svg\"\u002F\u003E. Производная по времени от этой функции \u003Cimg class=\"formula inline\" source=\"dθ_1\u002Fdt=w_1(t)\" alt=\"dθ_1\u002Fdt=w_1(t)\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F949\u002Fd54\u002F9bd\u002F949d549bdf871f579ea600da8578eb8f.svg\"\u002F\u003Eкак раз и будет скоростью входного звена.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EСкрипт для нахождения производной в символьном виде в MATLAB\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003E%Объявляем символьные переменные\nsyms Tetta_1(t) X_V(t) Y_V(t) Z_V(t)\nsyms OQ VM R_l R_r F f X_0 Y_0 Z_0\nsyms omega_1(t) v_VX(t) v_VY(t) v_VZ(t)\n%Записываем функцию порложения, как уравнение\nNL = sqrt(R_r^2-X_V^2);\ny_M = -VM + Y_V;\ny_Q = -OQ;\nconst_1 = y_M - y_Q;\nNQ = sqrt(const_1^2 + Z_V^2);\nEq1 = Tetta_1 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ)) - acos(const_1\u002FNQ);\n%Дифференцируем его\nEq2 = diff(Eq1, t);\n%Подставляем вместо производных координат по времени скорости\nEq2 = subs(Eq2, [diff(Tetta_1(t), t), diff(X_V(t), t), diff(Y_V(t), t), diff(Z_V(t), t)], [omega_1 v_VX v_VY v_VZ ]);\n%\"Собираем\" уравнение вокруг v_VX, v_VY и v_VZ\ncol2 = collect(Eq2, [v_VX v_VY v_VZ])\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЯ рекомендую для запуска это кода использовать \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"33\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F312\u002F5a8\u002F6f0\u002F3125a86f0856ab24d3862cacfe51ecfb.png\" data-width=\"121\"\u002F\u003E. Тогда после запуска вы сразу увидите это:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"542\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F4c6\u002F8b2\u002F5e9\u002F4c68b25e9c1c4a3b537212840f559022.png\" data-width=\"910\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВ последних версиях MATLAB появилась возможность даже копировать это в Word, что экономит кучу времени при наборе формул.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EКак итог, получим формулу:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(1)\" title=\"(1)\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff09\u002F9ca\u002F080\u002Ff099ca08040c2df47dcad4749b9f0837.png\" data-width=\"318\"\u002F\u003E\u003Cfigcaption\u003E(1)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003Eгде \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7f6\u002Faeb\u002Fa1c\u002F7f6aeba1c4257bc99a8e7b0d769ae037.png\" data-width=\"126\"\u002F\u003E– угловая скорость первого рычага;\u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"21\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F827\u002F487\u002F8e9\u002F8274878e93a51a9785797ffdb54fe0ee.png\" data-width=\"352\"\u002F\u003E– составляющие скорости точки \u003Cem\u003EV\u003C\u002Fem\u003E, направленные вдоль осей \u003Cem\u003EX\u003C\u002Fem\u003E, \u003Cem\u003EY\u003C\u002Fem\u003E, \u003Cem\u003EZ\u003C\u002Fem\u003E соответственно;\u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"17\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fba0\u002Fe0e\u002Fbdb\u002Fba0e0ebdb5869714330ebd7c96265c07.png\" data-width=\"66\"\u002F\u003E– функции, зависящие от \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"20\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd89\u002Ff35\u002F735\u002Fd89f357359dcec601bf4e47e7dabeffb.png\" data-width=\"157\"\u002F\u003E.\u003C\u002Fp\u003E\u003Cp\u003EФункции \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"17\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2fe\u002Fc02\u002F7ab\u002F2fec027ab212c360c23c57d0b52a50c3.png\" data-width=\"66\"\u002F\u003E определяют следующие формулы:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(2)\" title=\"(2)\" height=\"233\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe58\u002F24d\u002F71d\u002Fe5824d71d1bea791e0e9718837902e47.png\" data-width=\"356\"\u002F\u003E\u003Cfigcaption\u003E(2)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003Eгде \u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"302\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6f1\u002F92d\u002F0a8\u002F6f192d0a83573df1aa2234f0eb7c7d46.png\" data-width=\"321\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EКод функции, для нахождения угловых скоростей дифференцированием ФП\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003E%Находит решение задачи о скоростях методом дифференцирования функций пооложения\nfunction [w_1, w_2, w_3] = OZK_v(X_V, Y_V, Z_V, v_VX, v_VY, v_VZ)\n%Расчёт координат точки V в системах координат, повёрнутых на 120° и 240°\n%по часовой стрелке относительно основной\nglobal R_l R_r cos120 sin120 cos240 sin240 VM OQ\nX_V_120 = X_V*cos120 - Y_V*sin120;\nY_V_120 = X_V*sin120 + Y_V*cos120;\n    X_V_240 = X_V*cos240 - Y_V*sin240;\n    Y_V_240 = X_V*sin240 + Y_V*cos240;\n%Расчёт векторов скоростей точки V в системах координат, повёрнутых на 120° и 240°\n%по часовой стрелке относительно основной\nv_VX_120 = v_VX*cos120 - v_VY*sin120;\nv_VY_120 = v_VX*sin120 + v_VY*cos120;\n    v_VX_240 = v_VX*cos240 - v_VY*sin240;\n    v_VY_240 = X_V*sin240 + v_VY*cos240;\n        Z_V_120 = Z_V;\n        Z_V_240 = Z_V;\n            v_VZ_120 = v_VZ;\n            v_VZ_240 = v_VZ;\n%Расчёт углов поворота рычагов в соответствующих системах координат\nw_1 = (v_VY\u002F(Z_V^2 + (OQ - VM + Y_V)^2)^(1\u002F2) - ((2*v_VY*(OQ - VM + Y_V) + 2*v_VZ*Z_V)*(OQ - VM + Y_V))\u002F(2*(Z_V^2 + (OQ - VM + Y_V)^2)^(3\u002F2)))\u002F(1 - (OQ - VM + Y_V)^2\u002F(Z_V^2 + (OQ - VM + Y_V)^2))^(1\u002F2) + ((2*v_VY*(OQ - VM + Y_V) + 2*v_VX*X_V + 2*v_VZ*Z_V)\u002F(2*R_l*(Z_V^2 + (OQ - VM + Y_V)^2)^(1\u002F2)) - ((2*v_VY*(OQ - VM + Y_V) + 2*v_VZ*Z_V)*(X_V^2 + Z_V^2 + (OQ - VM + Y_V)^2 + R_l^2 - R_r^2))\u002F(4*R_l*(Z_V^2 + (OQ - VM + Y_V)^2)^(3\u002F2)))\u002F(1 - (X_V^2 + Z_V^2 + (OQ - VM + Y_V)^2 + R_l^2 - R_r^2)^2\u002F(4*R_l^2*(Z_V^2 + (OQ - VM + Y_V)^2)))^(1\u002F2);\nw_2 = (v_VY_120\u002F(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(1\u002F2) - ((2*v_VY_120*(OQ - VM + Y_V_120) + 2*v_VZ_120*Z_V_120)*(OQ - VM + Y_V_120))\u002F(2*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(3\u002F2)))\u002F(1 - (OQ - VM + Y_V_120)^2\u002F(Z_V_120^2 + (OQ - VM + Y_V_120)^2))^(1\u002F2) + ((2*v_VY_120*(OQ - VM + Y_V_120) + 2*v_VX_120*X_V_120 + 2*v_VZ_120*Z_V_120)\u002F(2*R_l*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(1\u002F2)) - ((2*v_VY_120*(OQ - VM + Y_V_120) + 2*v_VZ_120*Z_V_120)*(X_V_120^2 + Z_V_120^2 + (OQ - VM + Y_V_120)^2 + R_l^2 - R_r^2))\u002F(4*R_l*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)^(3\u002F2)))\u002F(1 - (X_V_120^2 + Z_V_120^2 + (OQ - VM + Y_V_120)^2 + R_l^2 - R_r^2)^2\u002F(4*R_l^2*(Z_V_120^2 + (OQ - VM + Y_V_120)^2)))^(1\u002F2);\nw_3 = (v_VY_240\u002F(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(1\u002F2) - ((2*v_VY_240*(OQ - VM + Y_V_240) + 2*v_VZ_240*Z_V_240)*(OQ - VM + Y_V_240))\u002F(2*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(3\u002F2)))\u002F(1 - (OQ - VM + Y_V_240)^2\u002F(Z_V_240^2 + (OQ - VM + Y_V_240)^2))^(1\u002F2) + ((2*v_VY_240*(OQ - VM + Y_V_240) + 2*v_VX_240*X_V_240 + 2*v_VZ_240*Z_V_240)\u002F(2*R_l*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(1\u002F2)) - ((2*v_VY_240*(OQ - VM + Y_V_240) + 2*v_VZ_240*Z_V_240)*(X_V_240^2 + Z_V_240^2 + (OQ - VM + Y_V_240)^2 + R_l^2 - R_r^2))\u002F(4*R_l*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)^(3\u002F2)))\u002F(1 - (X_V_240^2 + Z_V_240^2 + (OQ - VM + Y_V_240)^2 + R_l^2 - R_r^2)^2\u002F(4*R_l^2*(Z_V_240^2 + (OQ - VM + Y_V_240)^2)))^(1\u002F2);\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EГромоздко, не правда ли? На самом деле ещё нет. Вот если мы ещё раз продифференцируем, чтобы найти угловое ускорение, вот тогда будет по-настоящему громоздко. Но всё же, можно ли формулы покороче получить?\u003C\u002Fp\u003E\u003Ch3\u003EПодход 2. Метод планов скоростей\u003C\u002Fh3\u003E\u003Cp\u003EВ умных книжках \u003Cabbr title=\"Теория механизмов и машин Тимофеев Г. А. 3-ие издание (книжка есть в моей библиотеке, ссылку давал в первой статье)\"\u003E🕮\u003C\u002Fabbr\u003E по теории механизмов и машин всегда рассказывают о методе планов скоростей. По идее, это графический метод решения нужной нам задачи, но считать то мы будем всё равно в MATLAB-е. Поэтому я бы не сказал, что он менее точный.\u003C\u002Fp\u003E\u003Cp\u003EРассмотрим его. Вообще, с этим методом лучше знакомится на примере плоской задачи.   Но я расскажу сразу на примере пространственного механизма – дельта-робота, подразумевая, что вы с ним заранее ознакомились. Начнём.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"775\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F172\u002Fa3e\u002F156\u002F172a3e15671941abdde098d3a1ef7807.png\" data-width=\"1462\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПугаться этой картинки не стоит. Сейчас я поясню всё, что на ней изображено.\u003C\u002Fp\u003E\u003Cp\u003EПервым шагом введём новую систему координат \u003Cem\u003EX'Y'Z'\u003C\u002Fem\u003E с началом координат \u003Cimg class=\"formula inline\" source=\"p_V\" alt=\"p_V\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F804\u002Fd17\u002F04d\u002F804d1704d56a0a64ab096a962a0473e5.svg\"\u002F\u003E. \u003Cimg class=\"formula inline\" source=\"p_V\" alt=\"p_V\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc4c\u002F619\u002Fd51\u002Fc4c619d513df5e428d5ffd7aa97cecd6.svg\"\u002F\u003E– это полюс скоростей, если говорить \"книжно\". Систему координат можно располагать как угодно (например, как и основную), но мне показалась удобным именно так.\u003C\u002Fp\u003E\u003Cp\u003EВ этой системе координат необходимо построить вектор скорости подвижной платформы. Нам он известен по условию. Вектор найдем как сумму векторов его компонент по осям \u003Cem\u003EX\u003C\u002Fem\u003E, \u003Cem\u003EY\u003C\u002Fem\u003E, и \u003Cem\u003EZ\u003C\u002Fem\u003E. Не забудем перевести эти компоненты в новую систему координат. Этот вектор будет совпадать с векторами скоростей точек \u003Cem\u003EV\u003C\u002Fem\u003E и \u003Cem\u003EM\u003C\u002Fem\u003E, так как это точки одного звена (платформы). Таким образом мы получим вектор \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"22\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F840\u002Fa98\u002F9b1\u002F840a989b12a2e0cc3480b1b4f72e81d6.png\" data-width=\"25\"\u002F\u003E.\u003C\u002Fp\u003E\u003Cp\u003EСкорость точки \u003Cem\u003EL\u003C\u002Fem\u003E, будет направлена по касательной к окружности с центром в точке \u003Cem\u003EQ\u003C\u002Fem\u003E. То есть скорость точки \u003Cem\u003EL\u003C\u002Fem\u003E будет направлена перпендикулярно звену \u003Cem\u003EQL\u003C\u002Fem\u003E и, как и это звено, всегда будет лежать в плоскости \u003Cimg class=\"formula inline\" source=\"X'p_VY'\" alt=\"X'p_VY'\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Feba\u002F2d2\u002F94e\u002Feba2d294e40058ffa5725dae580c4358.svg\"\u002F\u003E. Направление этого вектора мы зададим прямой \u003Cimg class=\"formula inline\" source=\"a\" alt=\"a\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F78c\u002F20f\u002Faab\u002F78c20faab8b6a1388a30644e03e6097f.svg\"\u002F\u003E, а саму прямую легко можем построить, так как знаем координаты точек \u003Cem\u003EL\u003C\u002Fem\u003E и \u003Cem\u003EQ\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\u003Cp\u003EДанный подход предполагает, что мы сначала решаем обратную задачу кинематики и, благодаря полученному решению, можем найти координаты точек \u003Cem\u003EQ\u003C\u002Fem\u003E, \u003Cem\u003EL\u003C\u002Fem\u003E и \u003Cem\u003EM\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\u003Cp\u003EВектор \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"22\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb23\u002F61f\u002F7ae\u002Fb2361f7aed7360b89d52e779e50526a5.png\" data-width=\"25\"\u002F\u003Eначинается из полюса скоростей, то есть как бы из неподвижной точки. Вектор \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe58\u002F938\u002F49a\u002Fe5893849a04b5c2feb04190096735764.png\" data-width=\"20\"\u002F\u003Eтоже будет начинаться как бы из неподвижной точки, то есть полюса скоростей.  Вектор \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F57d\u002Fcb6\u002F5af\u002F57dcb65afd234783bbb32410bc697510.png\" data-width=\"29\"\u002F\u003E – это вектор скорости точки \u003Cem\u003EL\u003C\u002Fem\u003E относительно точки \u003Cem\u003EM\u003C\u002Fem\u003E. И его начало уже неподвижным считать нельзя. Он должен начинаться из конца вектора \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"22\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F181\u002F2f6\u002F552\u002F1812f65526b7fcf01ff059447135b0fb.png\" data-width=\"25\"\u002F\u003E.  \u003C\u002Fp\u003E\u003Cp\u003EМы знаем, что точка \u003Cem\u003EL\u003C\u002Fem\u003E относительно точки \u003Cem\u003EM \u003C\u002Fem\u003Eбудет двигаться в направлении перпендикулярном звену \u003Cem\u003ELM\u003C\u002Fem\u003E (по касательной к сфере с центром в точке \u003Cem\u003EM \u003C\u002Fem\u003Eи радиусом LM). Тогда мы можем построить плоскость \u003Cimg class=\"formula inline\" source=\"γ\" alt=\"γ\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fccd\u002Fcfc\u002Fa48\u002Fccdcfca4877a29fd983d34ea86fbf1cb.svg\"\u002F\u003E, которая будет перпендикулярна звену \u003Cem\u003ELM \u003C\u002Fem\u003E(или прямой \u003Cimg class=\"formula inline\" source=\"b\" alt=\"b\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F25f\u002Fd54\u002F956\u002F25fd54956d08e2de06cf1a25df71e295.svg\"\u002F\u003E) и проходить через точку \u003Cem\u003EM'\u003C\u002Fem\u003E на плане скоростей. Пересечение этой плоскости с прямой \u003Cimg class=\"formula inline\" source=\"a\" alt=\"a\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ffde\u002F40f\u002F820\u002Ffde40f8201f59f2d37bc0f2f8663f931.svg\"\u002F\u003Eопределит координаты точки \u003Cem\u003EL'\u003C\u002Fem\u003E на плане скоростей, что позволит найти вектор \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F86c\u002Fd03\u002Fa43\u002F86cd03a432546c6d3c9b3f293af46182.png\" data-width=\"20\"\u002F\u003E. Зная координаты \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"25\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8d4\u002F4f1\u002Fcc9\u002F8d44f1cc956b38982fe32e8cecb732e1.png\" data-width=\"95\"\u002F\u003E вектора \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fbaf\u002F71c\u002Faff\u002Fbaf71caff9f7d2d1767e675458dc9d56.png\" data-width=\"20\"\u002F\u003E мы можем найти его длину по формуле:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(3)\" title=\"(3)\" height=\"28\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F55f\u002F538\u002F4f6\u002F55f5384f63d30cc95fb66f7aa829cd3f.png\" data-width=\"180\"\u002F\u003E\u003Cfigcaption\u003E(3)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EА зная длину этого вектора, то есть линейную скорость, легко найдём угловую скорость звена \u003Cem\u003EQL\u003C\u002Fem\u003E по формуле:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(4)\" title=\"(4)\" height=\"47\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff05\u002F0b6\u002Fa59\u002Ff050b6a59ca007309a692e1ddb365f51.png\" data-width=\"66\"\u002F\u003E\u003Cfigcaption\u003E(4)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EТаким образом, чтобы найти угловую скорость первого рычага, нужно найти координаты \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"25\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcf2\u002F018\u002F7bd\u002Fcf20187bdaccc2f8c478a4fbecf9b026.png\" data-width=\"95\"\u002F\u003E, как пресечение плоскости \u003Cimg class=\"formula inline\" source=\"γ\" alt=\"γ\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0c1\u002Fa38\u002Fe47\u002F0c1a38e47e22a2aa349d33e290dfce26.svg\"\u002F\u003E и прямой \u003Cimg class=\"formula inline\" source=\"a\" alt=\"a\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F41c\u002Fd5e\u002Fe19\u002F41cd5ee19f9e5b946df608b37401c285.svg\"\u002F\u003E.\u003C\u002Fp\u003E\u003Cp\u003EУравнение плоскости, перпендикулярной прямой (прямой \u003Cimg class=\"formula inline\" source=\"b\" alt=\"b\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7b4\u002Fad2\u002Fafb\u002F7b4ad2afbb83bc3550e84b0eef4656b4.svg\"\u002F\u003E в нашем случае) имеет вид:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(5)\" title=\"(5)\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff71\u002F516\u002F561\u002Ff71516561d286513a9a3e00734ef2a2e.png\" data-width=\"256\"\u002F\u003E\u003Cfigcaption\u003E(5)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003Eгде \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F464\u002Fa68\u002F745\u002F464a6874597bb5af5e8d75a021d4757c.png\" data-width=\"67\"\u002F\u003E – координаты точки, через которую проходит плоскость;\u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F187\u002F6e6\u002F9de\u002F1876e69de443d7f95ee37d2d3de384df.png\" data-width=\"46\"\u002F\u003E – координаты направляющего вектора.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcc2\u002F97c\u002F2fe\u002Fcc297c2fed641c2d28835534aeae8ffc.png\" data-width=\"67\"\u002F\u003E на плане скоростей – это и есть координаты вектора \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"22\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Feee\u002F37e\u002Fcc1\u002Feee37ecc14ec3b5b437a23e54d43ca3b.png\" data-width=\"25\"\u002F\u003E. Координаты направляющего вектора найдём путём вычитания координат точки \u003Cem\u003EL\u003C\u002Fem\u003E из координат точки \u003Cem\u003EM\u003C\u002Fem\u003E. Тогда уравнение плоскости \u003Cimg class=\"formula inline\" source=\"\\gamma\" alt=\"\\gamma\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe91\u002F59e\u002F73c\u002Fe9159e73cd6c48e8708b80eb9d692010.svg\"\u002F\u003E в введённой нами системе координат примет вид:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(6)\" title=\"(6)\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F120\u002Fe8e\u002F3f3\u002F120e8e3f3f1b049fb73364ef95f45a98.png\" data-width=\"457\"\u002F\u003E\u003Cfigcaption\u003E(6)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДалее запишем уравнение прямой \u003Cimg class=\"formula inline\" source=\"a\" alt=\"a\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F43c\u002F9b3\u002F7b6\u002F43c9b37b6fcb18228b5dd4cdc032b570.svg\"\u002F\u003E:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(7)\" title=\"(7)\" height=\"49\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Feaa\u002F9e8\u002F13d\u002Feaa9e813dd1d93dd999c2f0b1c26f21d.png\" data-width=\"100\"\u002F\u003E\u003Cfigcaption\u003E(7)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПомимо этого, мы знаем, что точка пересечения плоскости и прямой \u003Cimg class=\"formula inline\" source=\"a\" alt=\"a\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F4e8\u002F86f\u002Ff26\u002F4e886ff26b17f73e8f68936b713fe4d3.svg\"\u002F\u003Eлежит в плоскости \u003Cimg class=\"formula inline\" source=\"X'p_VY'\" alt=\"X'p_VY'\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff1b\u002Fe98\u002F1d5\u002Ff1be981d546af1152206731e3024c0a3.svg\"\u002F\u003E:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(8)\" title=\"(8)\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd1f\u002F16e\u002Fded\u002Fd1f16eded9a11be087bb4412c6bccbdd.png\" data-width=\"43\"\u002F\u003E\u003Cfigcaption\u003E(8)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EТогда решение системы из этих трёх уравнений (6, 7, 8) и будет искомой точкой, а \u003Cimg class=\"formula inline\" source=\"x, y\" alt=\"x, y\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb9c\u002F519\u002F5c1\u002Fb9c5195c10d2b934761c7c038612f762.svg\"\u002F\u003E и \u003Cimg class=\"formula inline\" source=\"z\" alt=\"z\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe81\u002Fc43\u002Fd75\u002Fe81c43d75f5b64cdcb4fae926ee89c96.svg\"\u002F\u003E будут координатами \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F66f\u002Fe80\u002F43e\u002F66fe8043ed0af18f2f71473c5b054c31.png\" data-width=\"61\"\u002F\u003E и \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Feed\u002Fd4c\u002F9b5\u002Feedd4c9b5a699f5b9914e20396cf40d9.png\" data-width=\"26\"\u002F\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЯ слишком стар, чтобы подставить второе и третье уравнение в первое и выразить \u003Cimg class=\"formula inline\" source=\"x\" alt=\"x\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3ba\u002Fa92\u002F036\u002F3baa9203634113af41b0cf205ed2dcfb.svg\"\u002F\u003E самостоятельно. Поэтому даже здесь я заставил работать MATLAB:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003Esyms X_Q1 Y_Q1 Z_Q1 X_L1 Y_L1 Z_L1 X_M1 Y_M1 Z_M1\nsyms x y z\nsyms v_VX v_VY v_VZ\ny = (Y_Q1-Y_L1)\u002F(Z_Q1-Z_L1)*x;\nz = 0;\nEq3 = (-Y_L1+Y_M1)*(x+v_VY)+(Z_L1-Z_M1)*((Y_Q1-Y_L1)\u002F(Z_Q1-Z_L1)*x-v_VZ)...\n    +(-X_L1+X_M1)*(0+v_VX) == 0\nsolve(Eq3, x)  \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EА он мне выдал:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"94\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F777\u002F604\u002Ffd9\u002F777604fd997588fdcbfc84eb4d1be94a.png\" data-width=\"415\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСтоит отметить ещё необходимость проверки направления получившегося вектора, так как последнее влияет на знак угловой скорости \u003Cimg class=\"formula inline\" source=\"\\omega_1\" alt=\"\\omega_1\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F383\u002F433\u002F185\u002F383433185e315366aeb94b94821bba0d.svg\"\u002F\u003E. Благодаря тому, что мы заранее ограничиваем угол поворота рычага от 90° до 270°, условие проверки упрощается до проверки знака \u003Cimg class=\"formula inline\" source=\"y\" alt=\"y\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5b7\u002Ff4b\u002F024\u002F5b7f4b024eb83478e8f18cd186b3b9d5.svg\"\u002F\u003E. Если \u003Cimg class=\"formula inline\" source=\"y\u003E0\" alt=\"y\u003E0\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8f1\u002F2e0\u002F60a\u002F8f12e060a50ee99510915c8468b73f0f.svg\"\u002F\u003E, то знак у \u003Cimg class=\"formula inline\" source=\"\\omega_1\" alt=\"\\omega_1\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0ef\u002F4ae\u002F92c\u002F0ef4ae92cddb16b4b745b2059dcfa4a4.svg\"\u002F\u003E-, иначе +.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EКод функции, для нахождения угловых скоростей методом планов\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003E%Находит решение задачи о скоростях методом планов\nfunction [w_1, w_2, w_3] = OZK_v_pv(X_V, Y_V, Z_V, v_VX, v_VY, v_VZ)\nglobal R_l VM OQ cos120 sin120 cos240 sin240 %Размеры и константы\n%Расчёт углов поворота рычагов в соответствующих системах координат\n[vectTheta] = OZK(X_V, Y_V, Z_V);\nTheta1 = vectTheta(1); Theta2 = vectTheta(2); Theta3 = vectTheta(3);\n            %Вычисляем координаты точек в системах координат XOY,\n            %X120Y120Z120 и X240Y240Z240\n            Y_Q1 = -OQ;\n            Z_Q1 = 0;\n            X_L1 = 0;\n            Y_L1 = -(OQ + R_l*sind(Theta1-90));\n            Z_L1 =  R_l*cosd(Theta1-90);\n            X_M1 = X_V;\n            Y_M1 = Y_V - VM;\n            Z_M1 = Z_V;\n                X_V_120 = X_V*cos120 - Y_V*sin120;\n                Y_V_120 = X_V*sin120 + Y_V*cos120;\n                Z_V_120 = Z_V;\n                Y_Q2_120 = -OQ;\n                Z_Q2_120 = 0;\n                X_L2_120 = 0;\n                Y_L2_120 = -(OQ + R_l*sind(Theta2-90));\n                Z_L2_120 =  R_l*cosd(Theta2-90);\n                X_M2_120 = X_V_120;\n                Y_M2_120 = Y_V_120 - VM;\n                Z_M2_120 = Z_V_120;\n                    X_V_240 = X_V*cos240 - Y_V*sin240;\n                    Y_V_240 = X_V*sin240 + Y_V*cos240;\n                    Z_V_240 = Z_V;\n                    Y_Q3_240 = -OQ;\n                    Z_Q3_240 = 0;\n                    X_L3_240 = 0;\n                    Y_L3_240 = -(OQ + R_l*sind(Theta3-90));\n                    Z_L3_240 =  R_l*cosd(Theta3-90);\n                    X_M3_240 = X_V_240;\n                    Y_M3_240 = Y_V_240 - VM;\n                    Z_M3_240 = Z_V_240;\n                        v_VX_120 = v_VX*cos120 - v_VY*sin120;\n                        v_VY_120 = v_VX*sin120 + v_VY*cos120;\n                        v_VZ_120 = v_VZ;\n                            v_VX_240 = v_VX*cos240 - v_VY*sin240;\n                            v_VY_240 = v_VX*sin240 + v_VY*cos240;\n                            v_VZ_240 = v_VZ;\n\n\n\nx = (v_VX*(X_L1 - X_M1) + v_VY*(Y_L1 - Y_M1) + v_VZ*(Z_L1 - Z_M1))\u002F(Y_M1 - Y_L1 + ((Y_L1 - Y_Q1)*(Z_L1 - Z_M1))\u002F(Z_L1 - Z_Q1));\ny = (Y_Q1-Y_L1)\u002F(Z_Q1-Z_L1)*x;\nv_L1 = sqrt(x^2+y^2);\nif y\u003E0\n    znak = -1;\nelse\n    znak = 1;\nend\nw_1 = znak*v_L1\u002FR_l;\n    x = (v_VX_120*(X_L2_120 - X_M2_120) + v_VY_120*(Y_L2_120 - Y_M2_120) + v_VZ_120*(Z_L2_120 - Z_M2_120))\u002F(Y_M2_120 - Y_L2_120 + ((Y_L2_120 - Y_Q2_120)*(Z_L2_120 - Z_M2_120))\u002F(Z_L2_120 - Z_Q2_120));\n    y = (Y_Q2_120-Y_L2_120)\u002F(Z_Q2_120-Z_L2_120)*x;\n    v_L2_120 = sqrt(x^2+y^2);\n    if y\u003E0\n        znak = -1;\n    else\n        znak = 1;\n    end\n    w_2 = znak*v_L2_120\u002FR_l;\n        x = (v_VX_240*(X_L3_240 - X_M3_240) + v_VY_240*(Y_L3_240 - Y_M3_240) + v_VZ_240*(Z_L3_240 - Z_M3_240))\u002F(Y_M3_240 - Y_L3_240 + ((Y_L3_240 - Y_Q3_240)*(Z_L3_240 - Z_M3_240))\u002F(Z_L3_240 - Z_Q3_240));\n        y = (Y_Q3_240-Y_L3_240)\u002F(Z_Q3_240-Z_L3_240)*x;\n        v_L3_240 = sqrt(x^2+y^2);\n        if y\u003E0\n            znak = -1;\n        else\n            znak = 1;\n        end\n        w_3 = znak*v_L3_240\u002FR_l;\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ch2\u003EПодход 3. Матричный метод\u003C\u002Fh2\u003E\u003Cp\u003EА вот и настало время для зловещего матричного метода. В статьях, посвящённых дельта-роботу часто можно встретить матричное исчисление. Попробуем и мы применить его, а также скажем, чем этот метод хорош.\u003C\u002Fp\u003E\u003Cp\u003EПо ходу повествования я буду опираться на вот эти \u003Cabbr title=\"ОЦЕНКА БЛИЗОСТИ К ОСОБЫМ ПОЛОЖЕНИЯМ МЕХАНИЗМОВ ПАРАЛЛЕЛЬНОЙ СТРУКТУРЫ ПУТЕМ ДИФФЕРЕНЦИРОВАНИЯ УРАВНЕНИЙ СВЯЗИ П.А. Ларюшкин\"\u003E🕮\u003C\u002Fabbr\u003E, \u003Cabbr title=\"РАЗРАБОТКА И ИССЛЕДОВАНИЕ ПРОСТРАНСТВЕННЫХ МЕХАНИЗМОВ ПАРАЛЛЕЛЬНОЙ СТРУКТУРЫ С ШАРНИРНЫМИ ПАРАЛЛЕЛОГРАММАМИ С РАЗЛИЧНЫМ ЧИСЛОМ СТЕПЕНЕЙ СВОБОДЫ Носова Н. Ю.\"\u003E🕮\u003C\u002Fabbr\u003E, \u003Cabbr title=\"РАЗРАБОТКА НАУЧНЫХ ОСНОВ СОЗДАНИЯ МАНИПУЛЯЦИОННЫХ МЕХАНИЗМОВ ПАРАЛЛЕЛЬНОЙ СТРУКТУРЫ ДЛЯ РОБОТОТЕХНИЧЕСКИХ СИСТЕМ ПРЕДПРИЯТИЙ ТЕКСТИЛЬНОЙ И ЛЕГКОЙ ПРОМЫШЛЕННОСТИ Хейло С. В.\"\u003E🕮\u003C\u002Fabbr\u003E источники. С автором первого источника я лично знаком и походу написания этого раздела активно закидывал его вопросами, чтобы совсем уж дичь тут вам не писать.\u003C\u002Fp\u003E\u003Cp\u003EПервое, что следует сделать – следует записать уравнения связи. Уравнение связи (первое) для дельта-робота это не что иное, как функция положения (формула (13) \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F580970\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eэтой\u003C\u002Fa\u003E работы), у которой после знака = мы оставим 0, а потом вместо 0 запишем \u003Cimg class=\"formula inline\" source=\"F_1\" alt=\"F_1\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F9c7\u002Fdf4\u002Fb8a\u002F9c7df4b8ade97abc8f1d1ffb668ea385.svg\"\u002F\u003E:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(9)\" title=\"(9)\" height=\"52\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F75d\u002Fc7c\u002F2ce\u002F75dc7c2cec0bc10fc1e38e415bd0ef7c.png\" data-width=\"470\"\u002F\u003E\u003Cfigcaption\u003E(9)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EИли, что тоже самое:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(10)\" title=\"(10)\" height=\"50\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6cc\u002F9e5\u002Fd95\u002F6cc9e5d959a33f415fd423c5121df60a.png\" data-width=\"379\"\u002F\u003E\u003Cfigcaption\u003E(10)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЗаметим, что последнее уравнение записано не в явном виде, то есть \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"21\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F441\u002F063\u002Fb5e\u002F441063b5e30e6c8ba76b2db2b5a69410.png\" data-width=\"19\"\u002F\u003E не выражено, через координаты рабочего органа (если мы снова уберём \u003Cimg class=\"formula inline\" source=\"F_1\" alt=\"F_1\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F86b\u002Fb8f\u002F215\u002F86bb8f215472353bd255e2b97eab9101.svg\"\u002F\u003E). Это первое преимущество метода – можно написать более простую неявную функцию.\u003C\u002Fp\u003E\u003Cp\u003EДалее, используя эти уравнения связи можно составить матрицы:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(11)\" title=\"(11)\" height=\"145\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2b4\u002Ffc8\u002F2a3\u002F2b4fc82a32d9e35f52580256cb1926f7.png\" data-width=\"421\"\u002F\u003E\u003Cfigcaption\u003E(11)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЭлементы матриц представляют собой не что иное, как частные производные функций положения по входным или выходным координатам. \u003C\u002Fp\u003E\u003Cp\u003EДалее мы можем записать следующее матричное уравнение:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(12)\" title=\"(12)\" height=\"60\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0cd\u002Fdfa\u002F291\u002F0cddfa29179f461116b7cfe0bbdeb050.png\" data-width=\"181\"\u002F\u003E\u003Cfigcaption\u003E(12)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EРешая его относительно вектора скоростей приводов, получим:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(13)\" title=\"(13)\" height=\"60\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F217\u002Fbc4\u002F458\u002F217bc44585bf135b4454167cbcd8787f.png\" data-width=\"301\"\u002F\u003E\u003Cfigcaption\u003E(13)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cimg class=\"formula inline\" source=\"J\" alt=\"J\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F82f\u002Fd20\u002F380\u002F82fd20380c237a72b37872b04d4fe392.svg\"\u002F\u003E – это, так называемая, матрица Якоби (или Якобиан), то есть матрица, связывающая входные \u003Cimg class=\"formula inline\" source=\"\\omega_1, \\omega_2, \\omega_3\" alt=\"\\omega_1, \\omega_2, \\omega_3\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F65d\u002Fed0\u002F316\u002F65ded031693ee418111811f565844a8c.svg\"\u002F\u003E и выходные \u003Cimg class=\"formula inline\" source=\"v_{VX}, v_{VY}, v_{VZ}\" alt=\"v_{VX}, v_{VY}, v_{VZ}\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F403\u002F9b5\u002F072\u002F4039b50728315b5dca8dd48b90e8b8c7.svg\"\u002F\u003E скорости.\u003C\u002Fp\u003E\u003Cp\u003EТаким образом, знаю эту матрицу, можно легко найти скорости рычагов, зная скорость и положение выходного звена.\u003C\u002Fp\u003E\u003Cp\u003EВторое преимущество такого подхода заключается в том, что мы можем быстренько переписать это матричное уравнение вот так:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(14)\" title=\"(14)\" height=\"60\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F351\u002F743\u002F51c\u002F35174351c301b18b2e1d9b63774b2b89.png\" data-width=\"139\"\u002F\u003E\u003Cfigcaption\u003E(14)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EТо есть, зная Якобиан, можно решить и прямую задачу о скоростях.\u003C\u002Fp\u003E\u003Cp\u003EЗдесь сразу стоит отметить, что если мы составляем уравнение связи из явных функций, то можно сразу решать матричное уравнение и находить скорости входных звеньев. Если же мы составляем их из неявной функции, то сначала потребуется решить задачу о положениях, так как в матрице \u003Cimg class=\"formula inline\" source=\"B\" alt=\"B\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe75\u002Fb8c\u002F137\u002Fe75b8c137ff6baff167898ad05293c26.svg\"\u002F\u003E у нас будут присутствовать входные координаты, которые мы без решения ОЗК не знаем:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(15)\" title=\"(15)\" height=\"65\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F861\u002Fa08\u002F2d7\u002F861a082d71814fd1fae1959bb4febf02.png\" data-width=\"265\"\u002F\u003E\u003Cfigcaption\u003E(15)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЕсли уж быть совсем честным, то в конечном счёте, при вычислении угловых скоростей матричным способом мы придём к уравнениям вида (1), о которых говорили в первом подходе. Та что все рассмотренные способы очень близки.\u003C\u002Fp\u003E\u003Cp\u003EНу и последним преимуществом матричного метода я бы назвал удобство последующего анализа. То есть математически формализуя таким образом решение, мы легко можем узнать, например, скорость входного звена при наихудшем направлении скорости выходного звена. Об этом будет сказано ниже. Помимо этого, можно достаточно легко найти, так называемые, особые положения и много чего ещё.\u003C\u002Fp\u003E\u003Cp\u003EЧуть не забыл про алгоритмы.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EСкрипт для нахождения обратной матрицы Якоби\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003E%Задаём символьные переменные\nsyms Tetta_1 Tetta_2 Tetta_3 X_V Y_V Z_V\nsyms OQ VM R_l R_r F f X_0 Y_0 Z_0\nsyms omega_1(t) v_VX(t) v_VY(t) v_VZ(t)\nsyms epsilon_1 a_VX a_VY a_VZ\nsyms v_VX v_VY v_VZ\n%Записываем решение обратной кинематической задачи в аналитическом виде\nNL = sqrt(R_r^2-X_V^2);\ny_M = -VM + Y_V;\ny_Q = -OQ;\nconst_1 = y_M - y_Q;\nNQ = sqrt(const_1^2 + Z_V^2);\nEq1 = Tetta_1 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ))...\n    - acos(const_1\u002FNQ);\n%Формируем уравнение связи\nF_1 = 2*pi - acos((R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ))...\n    - acos(const_1\u002FNQ) - Tetta_1;\n% F_1 = - (R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ)...\n%     - const_1\u002FNQ+cos(2*pi - Tetta_1);\n    %Проделываем те же операции для 2-го плеча\n    X_V_120 = X_V*cos(2*pi\u002F3) - Y_V*sin(2*pi\u002F3);\n    Y_V_120 = X_V*sin(2*pi\u002F3) + Y_V*cos(2*pi\u002F3);\n    Z_V_120 = Z_V;\n    NL = sqrt(R_r^2-X_V_120^2);\n    y_M = -VM + Y_V_120;\n    y_Q = -OQ;\n    const_1 = y_M - y_Q;\n    NQ = sqrt(const_1^2 + Z_V_120^2);\n    Eq2 = Tetta_2 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ))...\n        - acos(const_1\u002FNQ);\n    F_2 = 2*pi - acos((R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ))...\n        - acos(const_1\u002FNQ) - Tetta_2;\n%     F_2 = - (R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ)...\n%         - const_1\u002FNQ + cos(2*pi - Tetta_2);\n        %Для 3-го плеча\n        X_V_240 = X_V*cos(4*pi\u002F3) - Y_V*sin(4*pi\u002F3);\n        Y_V_240 = X_V*sin(4*pi\u002F3) + Y_V*cos(4*pi\u002F3);\n        Z_V_240 = Z_V;\n        NL = sqrt(R_r^2-X_V_240^2);\n        y_M = -VM + Y_V_240;\n        y_Q = -OQ;\n        const_1 = y_M - y_Q;\n        NQ = sqrt(const_1^2 + Z_V_240^2);\n        Eq3 = Tetta_3 == 2*pi - acos((R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ))...\n            - acos(const_1\u002FNQ);\n        F_3 = 2*pi - acos((R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ))...\n            - acos(const_1\u002FNQ) - Tetta_3;\n%                 F_3 = - (R_l^2 + NQ^2 - NL^2)\u002F(2*R_l*NQ)...\n%             - const_1\u002FNQ + cos(2*pi - Tetta_3);\n\n%Составляем матрицы А и В\nA = [diff(F_1, X_V), diff(F_1, Y_V), diff(F_1, Z_V);\n     diff(F_2, X_V), diff(F_2, Y_V), diff(F_2, Z_V);\n     diff(F_3, X_V), diff(F_3, Y_V), diff(F_3, Z_V)];\nB = [diff(F_1, Tetta_1), 0, 0;\n     0, diff(F_2, Tetta_2), 0;\n     0, 0, diff(F_3, Tetta_3)];\nJ = -A*inv(B)\n\n%Подставляем конкретные значения (для проверки)\nJ_ch = double(subs(J, [X_V, Y_V, Z_V, OQ, VM, R_l, R_r, F, f],...\n  [70.7107, 0, -325, 77.9423, 31.7543, 170, 320, 270, 110]));\n\n%Вычисляем скорости в тестовой точке\nv = [-0.4381; 139.3182; 787.7755];\nw = J_ch*v\n%Ответ [-3.1503; -3.3611; -4.4766]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНа эту матрицу в символьном виде смотреть, конечно, страшно:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6b0\u002F027\u002F27e\u002F6b002727ebacd87a3d5be2857a006c6b.PNG\" width=\"1230\" height=\"329\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСтрелочки указывают на полосы прокрутки. Можно представить сколько дополнительных констант MATLAB там нагенерировал.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ch2\u003EПроверка. Движение по заданной траектории с максимальной скоростью. Подход 4. Графическое дифференцирование\u003C\u002Fh2\u003E\u003Cp\u003EПосле формирования алгоритма для нахождения скоростей входных звеньев следует убедиться в правильности работы полученных скриптов. Я решил проверить сразу всё.\u003C\u002Fp\u003E\u003Cp\u003EДля проверки мы синтезируем траекторию (массив точек), по которым будет (виртуально) перемещаться подвижная платформа с максимальной скоростью. Я выбрал вот такую траекторию:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Синус, &quot;намотанный&quot; на цилиндр\" title=\"Синус, &quot;намотанный&quot; на цилиндр\" height=\"607\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd75\u002Fcd3\u002F8dd\u002Fd75cd38ddb9963f2390c47b2fb43608a.png\" data-width=\"1185\"\u002F\u003E\u003Cfigcaption\u003EСинус, \"намотанный\" на цилиндр\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДалее для каждой точки траектории нужно найти вектор скорости. Направлен он будет к следующей точке.\u003C\u002Fp\u003E\u003Cp\u003EВ результате работы алгоритма хотелось бы получить четыре графика, на которых будут показаны зависимости скорости первого рычага от времени, рассчитываемые всеми четырьмя методами. \u003C\u002Fp\u003E\u003Cp\u003EТут появляется время. Вектор времени можно найти, зная, сколько должно занимать перемещение от одной точки до другой с максимальной скоростью. Между точками у нас расстояние постоянно меняется, поэтому тут придётся его считать для всей траектории.\u003C\u002Fp\u003E\u003Cp\u003EНу а потом, итоговый вектор времени можно получить используя функцию \u003Cem\u003Ecumsum\u003C\u002Fem\u003E, которая создаёт новый вектор, суммируя для каждого значения все предшествующие значения исходного вектора.\u003C\u002Fp\u003E\u003Cp\u003EВ общем, не буду томить. Всё совпало \u003Cs\u003Eс 101-го раза\u003C\u002Fs\u003E:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"777\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F37d\u002F792\u002Fc45\u002F37d792c45d18f954e12cdfe3eefc429c.png\" data-width=\"1316\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПоследний 4-ый подход (на графике он первый) я использовал исключительно для проверки первых трёх.\u003C\u002Fp\u003E\u003Cp\u003EЕго суть заключается в следующем – мы уже умеем решать обратную задачу кинематики. Вот и решим её для каждой точки. То есть найдём зависимость \u003Cimg inline=\"true\" class=\"image image-inline\" src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"23\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb3e\u002Fd4d\u002F0c1\u002Fb3ed4d0c11dc17d917bd5cc297fb0467.png\" data-width=\"41\"\u002F\u003E.\u003C\u002Fp\u003E\u003Cp\u003EА теперь просто можно найти производную численно, так как у нас есть вектора (здесь под векторами я подразумеваю массивы) \u003Cimg class=\"formula inline\" source=\"dt\" alt=\"dt\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd68\u002F488\u002F889\u002Fd684888890c1af01836a509b6b2c0ede.svg\"\u002F\u003E и \u003Cimg class=\"formula inline\" source=\"dθ_1\" alt=\"dθ_1\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2ca\u002Fdfd\u002Fd8f\u002F2cadfdd8f7de8cbedd729ee41a3ee9af.svg\"\u002F\u003E:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(16)\" title=\"(16)\" height=\"44\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fec2\u002F115\u002F55b\u002Fec211555b92acf08ac92682a20b335a0.png\" data-width=\"97\"\u002F\u003E\u003Cfigcaption\u003E(16)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EИ так для каждой точки.\u003C\u002Fp\u003E\u003Cp\u003EТак как мы проверили ОЗК и, наверняка, правильно вычислили вектор значений \u003Cimg class=\"formula inline\" source=\"dt\" alt=\"dt\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F9c0\u002Fc9a\u002Fd20\u002F9c0c9ad20a1a70ddc325cb369cf11eae.svg\"\u002F\u003E, то и полученный график тоже должен быть правильным.\u003C\u002Fp\u003E\u003Cp\u003EВот рабочий скрипт:\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EСкрипт, который находит скорость первого рычага всеми методами\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003Eclear all\n%Входные данные\nBOX = [200, 100]; %Ширина и высота рабочей зоны (квадратный параллелепипед)\nZ0BOX = -375; %Координата дна рабочей зоны\nv_max = 800; %Максимальная требуемая линейная скорость [мм\u002Fс]\n%Подгружаем константы и итоговые конструктивные размеры\nInputConstant;\n\n%Параметры дискретизации пространственных траекторий\nDiskr = 1000; %Число точек, в которых вычизляем значение пространственной кривой\n\n%Подготовительные вычисления\nR_BOX = BOX(1)*sqrt(2)\u002F2; % Радиус описанного цилиндра рабочей области\n\n%Формируем траекторию для исследования скоростных характеристик\nfi1 = linspace(0, 2*pi, Diskr);\nfi2 = linspace(0, 8*2*pi, Diskr);\nX_V = R_BOX*0.5*cos(fi1);\nY_V = R_BOX*0.5*sin(fi1);\nZ_V = Z0BOX + BOX(2)\u002F2 + BOX(2)\u002F2*sin(fi2);\nhold on;\nplot3(X_V, Y_V, Z_V, 'LineWidth', 1.5);\nhold off;\naxis equal;\nxlabel('x, мм');\nylabel('y, мм');\nzlabel('z, мм');\ntitle('Рассматриваемая траектория движения');\ngrid on;\nview([-25, 20]);\n\n\n%Вычисляем вектор скорости в каждой точке каждой траектории\ndX = X_V([2:Diskr, 1])-X_V(1:Diskr);\ndY = Y_V([2:Diskr, 1])-Y_V(1:Diskr);\ndZ = Z_V([2:Diskr, 1])-Z_V(1:Diskr);\ndL = sqrt(dX.^2 + dY.^2 + dZ.^2);\nv_VX = dX*v_max.\u002FdL;\nv_VY = dY*v_max.\u002FdL;\nv_VZ = dZ*v_max.\u002FdL;\n\n%v_vect=sqrt(v_VX.^2 + v_VY.^2 + v_VZ.^2)\n%quiver3(X_V, Y_V, Z_V, v_VX*0.07, v_VY*0.07, v_VZ*0.07, 'AutoScale', 'off');\n\n%Задаём вектор скорости рычага 1\nw1 = [];\n%Вычисляем скорость рычагов в каждой точке траектории\nfor k=1:Diskr\n    [w_1, w_2, w_3] = OZK_v(X_V(k), Y_V(k), Z_V(k), v_VX(k), v_VY(k), v_VZ(k));\n    w1 = [w1, w_1];\nend\n\n%Вычисляем вектор времени\ndTime = dL\u002Fv_max;\nTime = cumsum(dTime);\n\n%Вычисляем скорости методом планов\nfor k=1:Diskr\n    [Tetta1, Tetta2, Tetta3] = OZK(X_V(k), Y_V(k), Z_V(k));\n    Tetta1_vect(k)=Tetta1;\n    Y_L1 = -(OQ + R_l*sind(Tetta1-90));\n    Z_L1 =  R_l*cosd(Tetta1-90);\n    Y_M1 = Y_V(k) - VM;\n    Z_M1 = Z_V(k);\n    Y_Q1 = -OQ;\n    Z_Q1 = 0;\n    X_L1 = 0;\n    X_M1 = X_V(k);\n    x = (v_VX(k)*(X_L1 - X_M1) + v_VY(k)*(Y_L1 - Y_M1) + v_VZ(k)*(Z_L1 - Z_M1))\u002F(Y_M1 - Y_L1 + ((Y_L1 - Y_Q1)*(Z_L1 - Z_M1))\u002F(Z_L1 - Z_Q1));\n    y = (Y_Q1-Y_L1)\u002F(Z_Q1-Z_L1)*x;\n    v_L1 = sqrt(x^2+y^2);\n    if y\u003E0\n        znak = -1;\n    else\n        znak = 1;\n    end\n    w1_pv(k) = znak*v_L1\u002FR_l;\nend\n\n%Вычисляем скорости матричным методом\nfor k=1:Diskr\n    J = [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          X_V(k)\u002F(R_l*(1 - ((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)))^(1\u002F2)*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1\u002F2)),                                                                                                                                                                                                                                                                                                   ((2*OQ - 2*VM + 2*Y_V(k))\u002F(2*R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1\u002F2)) - ((2*OQ - 2*VM + 2*Y_V(k))*((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2))\u002F(4*R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)))^(1\u002F2) + (1\u002F((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1\u002F2) - ((2*OQ - 2*VM + 2*Y_V(k))*(OQ - VM + Y_V(k)))\u002F(2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - (OQ - VM + Y_V(k))^2\u002F((OQ - VM + Y_V(k))^2 + Z_V(k)^2))^(1\u002F2),                                                                                                                                                                                                                                 (Z_V(k)\u002F(R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(1\u002F2)) - (Z_V(k)*((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2))\u002F(2*R_l*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((OQ - VM + Y_V(k))^2 + R_l^2 - R_r^2 + X_V(k)^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((OQ - VM + Y_V(k))^2 + Z_V(k)^2)))^(1\u002F2) - (Z_V(k)*(OQ - VM + Y_V(k)))\u002F(((OQ - VM + Y_V(k))^2 + Z_V(k)^2)^(3\u002F2)*(1 - (OQ - VM + Y_V(k))^2\u002F((OQ - VM + Y_V(k))^2 + Z_V(k)^2))^(1\u002F2));\n    (3^(1\u002F2)\u002F(2*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2)\u002F(2*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2))^(1\u002F2) + ((X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2 + 3^(1\u002F2)*(OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2))\u002F(2*R_l*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)*((X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))\u002F(4*R_l*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)))^(1\u002F2), ((VM - OQ + Y_V(k)\u002F2 - (3^(1\u002F2)*X_V(k))\u002F2 + 3^(1\u002F2)*(X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2))\u002F(2*R_l*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) + ((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)*((X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))\u002F(4*R_l*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)))^(1\u002F2) + ((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F(2*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)) - 1\u002F(2*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)))\u002F(1 - (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2))^(1\u002F2), (Z_V(k)\u002F(R_l*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) - (Z_V(k)*((X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))\u002F(2*R_l*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((X_V(k)\u002F2 + (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)))^(1\u002F2) - (Z_V(k)*(OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2))\u002F((1 - (OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2))^(1\u002F2)*((OQ - VM - Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2));\n    ((X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2 + 3^(1\u002F2)*(VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2))\u002F(2*R_l*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)*((X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))\u002F(4*R_l*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)))^(1\u002F2) - (3^(1\u002F2)\u002F(2*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2)\u002F(2*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2))^(1\u002F2), ((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2 - 3^(1\u002F2)*(X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2))\u002F(2*R_l*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) - ((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)*((X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))\u002F(4*R_l*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)))^(1\u002F2) + ((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F(2*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)) - 1\u002F(2*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)))\u002F(1 - (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2))^(1\u002F2), (Z_V(k)\u002F(R_l*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(1\u002F2)) - (Z_V(k)*((X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2))\u002F(2*R_l*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2)))\u002F(1 - ((X_V(k)\u002F2 - (3^(1\u002F2)*Y_V(k))\u002F2)^2 + (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + R_l^2 - R_r^2 + Z_V(k)^2)^2\u002F(4*R_l^2*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)))^(1\u002F2) + (Z_V(k)*(VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2))\u002F((1 - (VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2\u002F((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2))^(1\u002F2)*((VM - OQ + Y_V(k)\u002F2 + (3^(1\u002F2)*X_V(k))\u002F2)^2 + Z_V(k)^2)^(3\u002F2))];\nv_V = [v_VX(k); v_VY(k); v_VZ(k)];\nw = J*v_V;\nw1_mat(k) = w(1);\nend\n\n%Находим производную Tetta1_vect графически\n%Перевод в радианы\nTetta1_vect = Tetta1_vect*pi\u002F180;\nw1_der = diff([Tetta1_vect, Tetta1_vect(1)]).\u002FdTime;\n%Отображаем скорость первого рычага на графиках\nfigure\nhold on;\nsubplot(2, 2, 1);\nplot(Time, w1_der*30\u002Fpi);\ngrid on;\nxlabel('t, c');\nylabel('\\omega, об\u002Fмин');\ntitle('Грифическое дифференцирование');\naxis([0, 2.1, -55, 55]);\nsubplot(2, 2, 2);\nplot(Time, w1*30\u002Fpi);\ngrid on;\nxlabel('t, c');\nylabel('\\omega, об\u002Fмин');\ntitle('Аналитический метод');\naxis([0, 2.1, -55, 55]);\nsubplot(2, 2, 3);\nplot(Time, w1_pv*30\u002Fpi);\ngrid on;\nxlabel('t, c');\nylabel('\\omega, об\u002Fмин');\ntitle('Метод планов');\naxis([0, 2.1, -55, 55]);\nsubplot(2, 2, 4);\nplot(Time, w1_mat*30\u002Fpi);\ngrid on;\nxlabel('t, c');\nylabel('\\omega, об\u002Fмин');\ntitle('Матричный мотод');\naxis([0, 2.1, -55, 55]);\nhold off;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут используется функция, которую я демонстрировал в первом подходе, функция, решающая ОЗК, которую я давал ранее и код, в котором объявляются константы (InputConstant;):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003E%Задаём параметры механизма\nglobal f F R_l R_r cos120 sin120 cos240 sin240 VM OQ\nf = 110;    %Длина стороны треугольника платформы\nF = 270;    %Длина стороны треугольника основания\nR_l = 170;  %Длина рычагов\nR_r = 320;  %Длина штанг\n%Расчёт констант\ncos120 = cosd(120);\nsin120 = sind(120);\ncos240 = cosd(240);\nsin240 = sind(240);\n\nVM = f*sqrt(3)\u002F6;\nOQ = F*sqrt(3)\u002F6;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЯ это всё слепил из того, что было. Можно оформить это \"красивше\".\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EДобавив к коду выше вот это:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003Edim = [f F R_l R_r];\nfigure\nfor k = 1:Diskr\nV = [X_V(k), Y_V(k), Z_V(k)];\n[Theta1, Theta2, Theta3] = OZK(X_V(k), Y_V(k), Z_V(k));\nTheta = [Theta1, Theta2, Theta3];\ndrawDelta(dim, V, Theta)%Это я накидывал бонусом  ранее\naxis([-250, 250, -250, 250, -390, 100]);\nhold on;\nplot3(X_V(1:k), Y_V(1:k), Z_V(1:k),'LineWidth', 1.5, 'Color', 'r');\nhold off;\ndrawnow\npause(dTime(k)*20);\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМожно получить вот такую симуляцию работы (я замедлил отрисовку в 20 раз, а потом на видео ускорил в 65 раз, а то MATLAB на моём слабеньком ноуте не успевал считать):\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"482\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F010\u002F300\u002Fbbb\u002F010300bbbb4c94915c5831ee1a229990.gif\" data-width=\"551\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДа, так быстро дельта-робот может и должен двигаться – 2.1 секунды на всю траекторию. Скорость платформы, кстати, 1 м\u002Fс.\u003C\u002Fp\u003E\u003Ch2\u003EПоиск максимальной скорости привода\u003C\u002Fh2\u003E\u003Cp\u003EПришло время использовать то, что мы получили ранее. Для поиска максимальной скорости привода возьмём размеры робота, найденные в ходе \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F583190\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eпредыдущей\u003C\u002Fa\u003E работы.\u003C\u002Fp\u003E\u003Cp\u003EПервым делом сгенерируем массив точек для анализа внутри желаемой рабочей зоны:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"637\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fffe\u002F048\u002F8b3\u002Fffe0488b35a8b553b20bae13499a6327.png\" data-width=\"1063\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EНе забываем, что дельта-робот имеет симметрию и достаточно рассмотреть лишь 1\u002F6 рабочей зоны.\u003C\u002Fp\u003E\u003Cp\u003EВот моя реализация этого алгоритма:\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EФункция genTP\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003E%Генерирует массив точек для анализа\nfunction [TestPointsX, TestPointsY, TestPointsZ] = genTP()\n%Добавляем глобальные переменные входных и выходных данных\nglobal WZ_D WZ_H WZ_Z WZ_d WZ_h %Рабочая зона\nglobal addSeg %Переменная, показывающая необходимость дополнительного\n%сегмента в рабочей зоне\nglobal dotDensity %Плотность точек\n\n%Для тестирования\ndotDensity = 30;\nWZ_D = 320;\nWZ_d = 100;\nWZ_d = 562;\nWZ_H = 150;\nWZ_Z = -390;\nWZ_h = 50;\naddSeg = 0;\n\n%Задаём массив точек, заведомо покрывающий интересующий нас участок рабочей\n%зоны\nx = linspace(-WZ_D\u002F2, 0, dotDensity);\ny = linspace(-WZ_D\u002F2, 0, dotDensity);\nz = linspace(WZ_Z-WZ_h, WZ_Z+WZ_H, dotDensity);\n[X, Y, Z] = meshgrid(x, y, z);\nX = reshape(X, [1, size(X, 1)^3, 1]);\nY = reshape(Y, [1, size(Y, 1)^3, 1]);\nZ = reshape(Z, [1, size(Z, 1)^3, 1]);\n\n%Находим индексы точек, попадающих в цилиндрическую область\ninCil = X.^2+Y.^2 &lt;= (WZ_D\u002F2)^2;\n%И попадающих в сектр 60°\ninSec = Y &lt; tand(30)*X;\n%Находим инексы точек попадающих\n%1 Только в цилиндрическую РЗ\nif addSeg == 0\n    inDopSeg = Z \u003E WZ_Z;\nend\n%В цилиндрическую РЗ и усёчённый конус\nif addSeg == 1\n    z0 = WZ_Z - WZ_h*(WZ_D\u002F2)\u002F((WZ_D-WZ_d)\u002F2);\n    a2_c2 = ((WZ_D\u002F2)\u002F(WZ_Z-z0))^2;\n    inDopSeg = X.^2 + Y.^2 &lt;= a2_c2*(Z-z0).^2;\nend\n%В цилиндрическую РЗ и в часть сферы\nif addSeg == 2\n    inDopSeg = (X.^2 + Y.^2 + (Z-(WZ_Z-WZ_h+WZ_d\u002F2)).^2 &lt;= (WZ_d\u002F2)^2)|(Z \u003E WZ_Z);\nend\n%Формируем индексы точек, удовлетворяющих всем условиям\ninWZ = inCil &amp; inDopSeg &amp; inSec;\nTestPointsX = X(inWZ);\nTestPointsY = Y(inWZ);\nTestPointsZ = Z(inWZ);\n\n%Тестовая отрисовка точек\nplot3(X(inWZ), Y(inWZ), Z(inWZ), '.r');\nxlabel('x, мм');\nylabel('y, мм');\nzlabel('z, мм');\ngrid on;\nend\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EТеперь в каждой точке нам нужно нужно найти угловые скорости рычагов (скорости приводов) при движении исполнительного звена в этой точке с максимальной требуемой скоростью.\u003C\u002Fp\u003E\u003Cp\u003EНо ведь скорость входных звеньев зависит ещё и от \u003Cem\u003Eнаправления\u003C\u002Fem\u003E движения выходного звена. Значит для каждой точки нужно рассмотреть ещё и массив направлений. Например точек для анализа у нас будет 1000. Направлений в каждой точке 100, тогда всего нам придётся запускать цикл поиска входных скоростей 100 000 раз. Многовато, не правда ли? Я так и сделал изначально. MATLAB считал секунд 40, но направлений я брал всего 22 в каждой точке:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"525\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2d8\u002Fe0d\u002Fae4\u002F2d8e0dae43754cfc255f92b04e696006.png\" data-width=\"700\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПомимо того, что это долго, у нас ещё есть риск, что максимальная скорость будет чуть больше из-за того, что мы не проверили самое \"наихудшее\" направление.\u003C\u002Fp\u003E\u003Cp\u003EПравильным подходом здесь является запуск алгоритма в каждой тестовой точке лишь с одним, но \"наихудшим\" направлением вектора скорости. Оказывается, можно это \"наихудшее\" направление заранее узнать.\u003C\u002Fp\u003E\u003Cp\u003EВот тут на помощь как раз приходит матричный метод. Скорость i-го привода мы вычисляем путём умножения вектора строки Якобиана на вектор столбец скорости рабочего органа:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(17)\" title=\"(17)\" height=\"60\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fa72\u002F050\u002F779\u002Fa72050779709c38824a7736c40dc889b.png\" data-width=\"366\"\u002F\u003E\u003Cfigcaption\u003E(17)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДанное векторное произведение достигает своего максимума тогда, когда эти вектора являются коллинеарными. Если опустить все доказательства, то можно сказать, что для дельта-робота справедлива следующая формула:\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"(18)\" title=\"(18)\" height=\"46\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7ca\u002Fea0\u002F908\u002F7caea0908d0c51bd140a49f6d06f9103.png\" data-width=\"408\"\u002F\u003E\u003Cfigcaption\u003E(18)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЭта запись математически звучит так: \"произведение длины вектора максимальной скорости платформы на евклидовой норму i-ой строки обратной матрицы Якоби\". Звучит жутко, но записывается коротко, а считается быстро.\u003C\u002Fp\u003E\u003Cp\u003EПосчитав для каждой точки для всех трёх приводов по этой формуле максимальную угловую скорость привода и найдя среди итих значений максимум, мы и получим максимальную скорость привода.\u003C\u002Fp\u003E\u003Cp\u003EВот коротенький код:\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EИтоговый код для определения максимальной скорости привода\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"matlab\"\u003E%Задаём начальное значение\nwmax = 0;\n\n%Задаём входные данные\nvmax = 1000;\nR_l = 170;\nR_r = 320;\nOQ = 77.9423;\nVM = 23.094;\ncos120 = cosd(120);\nsin120 = sind(120);\ncos240 = cosd(240);\nsin240 = sind(240);\n[TestPointsX, TestPointsY, TestPointsZ] = genTP();\n\n%Запускаем цикл проверки в кажой точке\nfor k = 1:size(TestPointsX, 2)\nJ = [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TestPointsX(k)\u002F(R_l*(1 - ((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)))^(1\u002F2)*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1\u002F2)),                                                                                                                                                                                                                                                                                                   ((2*OQ - 2*VM + 2*TestPointsY(k))\u002F(2*R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1\u002F2)) - ((2*OQ - 2*VM + 2*TestPointsY(k))*((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2))\u002F(4*R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)))^(1\u002F2) + (1\u002F((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1\u002F2) - ((2*OQ - 2*VM + 2*TestPointsY(k))*(OQ - VM + TestPointsY(k)))\u002F(2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - (OQ - VM + TestPointsY(k))^2\u002F((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2))^(1\u002F2),                                                                                                                                                                                                                                 (TestPointsZ(k)\u002F(R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(1\u002F2)) - (TestPointsZ(k)*((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2))\u002F(2*R_l*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((OQ - VM + TestPointsY(k))^2 + R_l^2 - R_r^2 + TestPointsX(k)^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)))^(1\u002F2) - (TestPointsZ(k)*(OQ - VM + TestPointsY(k)))\u002F(((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2)^(3\u002F2)*(1 - (OQ - VM + TestPointsY(k))^2\u002F((OQ - VM + TestPointsY(k))^2 + TestPointsZ(k)^2))^(1\u002F2));\n    (3^(1\u002F2)\u002F(2*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2)\u002F(2*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2))^(1\u002F2) + ((TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2 + 3^(1\u002F2)*(OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2))\u002F(2*R_l*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)*((TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))\u002F(4*R_l*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)))^(1\u002F2), ((VM - OQ + TestPointsY(k)\u002F2 - (3^(1\u002F2)*TestPointsX(k))\u002F2 + 3^(1\u002F2)*(TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2))\u002F(2*R_l*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) + ((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)*((TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))\u002F(4*R_l*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)))^(1\u002F2) + ((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F(2*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)) - 1\u002F(2*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)))\u002F(1 - (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2))^(1\u002F2), (TestPointsZ(k)\u002F(R_l*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) - (TestPointsZ(k)*((TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))\u002F(2*R_l*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((TestPointsX(k)\u002F2 + (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)))^(1\u002F2) - (TestPointsZ(k)*(OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2))\u002F((1 - (OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2))^(1\u002F2)*((OQ - VM - TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2));\n    ((TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2 + 3^(1\u002F2)*(VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2))\u002F(2*R_l*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)*((TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))\u002F(4*R_l*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)))^(1\u002F2) - (3^(1\u002F2)\u002F(2*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) - (3^(1\u002F2)*(VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2)\u002F(2*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2))^(1\u002F2), ((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2 - 3^(1\u002F2)*(TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2))\u002F(2*R_l*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) - ((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)*((TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))\u002F(4*R_l*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)))^(1\u002F2) + ((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F(2*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)) - 1\u002F(2*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)))\u002F(1 - (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2))^(1\u002F2), (TestPointsZ(k)\u002F(R_l*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(1\u002F2)) - (TestPointsZ(k)*((TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2))\u002F(2*R_l*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2)))\u002F(1 - ((TestPointsX(k)\u002F2 - (3^(1\u002F2)*TestPointsY(k))\u002F2)^2 + (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + R_l^2 - R_r^2 + TestPointsZ(k)^2)^2\u002F(4*R_l^2*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)))^(1\u002F2) + (TestPointsZ(k)*(VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2))\u002F((1 - (VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2\u002F((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2))^(1\u002F2)*((VM - OQ + TestPointsY(k)\u002F2 + (3^(1\u002F2)*TestPointsX(k))\u002F2)^2 + TestPointsZ(k)^2)^(3\u002F2))];\nw_max_TP = [norm(J(1, :))*vmax, norm(J(2, :))*vmax, norm(J(3, :))*vmax];\n    %Находим максимум скорости рычагов\n    wmax = max([abs(w_max_TP), wmax]);\nend\nn = 30*wmax\u002Fpi\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут используем лишь одну пользовательскую функцию genTP(), которую я давал ранее.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EВ следующей статье найдём максимальны крутящий момент и порассуждаем, какие комплектующие для привода стоит выбирать. Затронем вопрос точности привода.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"дельта-робот"},{"titleHtml":"задача о скоростях"},{"titleHtml":"Якобиан"},{"titleHtml":"план скоростей"},{"titleHtml":"матрица Якоби"},{"titleHtml":"скорости приводов"},{"titleHtml":"уравнения связи"},{"titleHtml":"параллельные механизмы"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F639\u002F455\u002F31e\u002F63945531ecbdb184f05a5eb394af7c9f.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F639\u002F455\u002F31e\u002F63945531ecbdb184f05a5eb394af7c9f.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F585260\\\u002F\"},\"headline\":\"Заметки о дельта-роботе. Часть 4. Скорости приводов\",\"datePublished\":\"2021-10-25T09:33:43+03:00\",\"dateModified\":\"2021-10-25T12:37:25+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"multiengineer\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&nbsp;или устройство, кото...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F585260\\\u002F#post-content-body\",\"about\":[\"h_robo_dev\",\"h_matlab\",\"h_robot\",\"f_develop\",\"f_popsci\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F585260\\\u002F4c2db03fb1ca9fead965ef0965dd4e47\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F117\\\u002Fed3\\\u002Fd8d\\\u002F117ed3d8dd520d081b2837af45333c2e.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F25d\\\u002F5b8\\\u002F6b2\\\u002F25d5b86b27d2e4e9d9b0a6ef830af6f3.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F542\\\u002F073\\\u002F577\\\u002F542073577e66745d23eb2c9ed8ae5da4.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fcb7\\\u002Fcda\\\u002F6a2\\\u002Fcb7cda6a2b0eed2c7a53b992b2640d3a.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fbc5\\\u002F2e9\\\u002F013\\\u002Fbc52e9013c258c0ed9cab0fc1a1188e1.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ffdf\\\u002F683\\\u002F30c\\\u002Ffdf68330c23827d04efa905a28b04101.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F25c\\\u002Fdc2\\\u002F297\\\u002F25cdc229743da28f6735fe56f9625269.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F949\\\u002Fd54\\\u002F9bd\\\u002F949d549bdf871f579ea600da8578eb8f.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F312\\\u002F5a8\\\u002F6f0\\\u002F3125a86f0856ab24d3862cacfe51ecfb.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F4c6\\\u002F8b2\\\u002F5e9\\\u002F4c68b25e9c1c4a3b537212840f559022.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ff09\\\u002F9ca\\\u002F080\\\u002Ff099ca08040c2df47dcad4749b9f0837.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F7f6\\\u002Faeb\\\u002Fa1c\\\u002F7f6aeba1c4257bc99a8e7b0d769ae037.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F827\\\u002F487\\\u002F8e9\\\u002F8274878e93a51a9785797ffdb54fe0ee.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fba0\\\u002Fe0e\\\u002Fbdb\\\u002Fba0e0ebdb5869714330ebd7c96265c07.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd89\\\u002Ff35\\\u002F735\\\u002Fd89f357359dcec601bf4e47e7dabeffb.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2fe\\\u002Fc02\\\u002F7ab\\\u002F2fec027ab212c360c23c57d0b52a50c3.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fe58\\\u002F24d\\\u002F71d\\\u002Fe5824d71d1bea791e0e9718837902e47.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F6f1\\\u002F92d\\\u002F0a8\\\u002F6f192d0a83573df1aa2234f0eb7c7d46.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F172\\\u002Fa3e\\\u002F156\\\u002F172a3e15671941abdde098d3a1ef7807.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F804\\\u002Fd17\\\u002F04d\\\u002F804d1704d56a0a64ab096a962a0473e5.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fc4c\\\u002F619\\\u002Fd51\\\u002Fc4c619d513df5e428d5ffd7aa97cecd6.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F840\\\u002Fa98\\\u002F9b1\\\u002F840a989b12a2e0cc3480b1b4f72e81d6.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Feba\\\u002F2d2\\\u002F94e\\\u002Feba2d294e40058ffa5725dae580c4358.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F78c\\\u002F20f\\\u002Faab\\\u002F78c20faab8b6a1388a30644e03e6097f.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb23\\\u002F61f\\\u002F7ae\\\u002Fb2361f7aed7360b89d52e779e50526a5.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fe58\\\u002F938\\\u002F49a\\\u002Fe5893849a04b5c2feb04190096735764.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F57d\\\u002Fcb6\\\u002F5af\\\u002F57dcb65afd234783bbb32410bc697510.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F181\\\u002F2f6\\\u002F552\\\u002F1812f65526b7fcf01ff059447135b0fb.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fccd\\\u002Fcfc\\\u002Fa48\\\u002Fccdcfca4877a29fd983d34ea86fbf1cb.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F25f\\\u002Fd54\\\u002F956\\\u002F25fd54956d08e2de06cf1a25df71e295.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ffde\\\u002F40f\\\u002F820\\\u002Ffde40f8201f59f2d37bc0f2f8663f931.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F86c\\\u002Fd03\\\u002Fa43\\\u002F86cd03a432546c6d3c9b3f293af46182.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F8d4\\\u002F4f1\\\u002Fcc9\\\u002F8d44f1cc956b38982fe32e8cecb732e1.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fbaf\\\u002F71c\\\u002Faff\\\u002Fbaf71caff9f7d2d1767e675458dc9d56.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F55f\\\u002F538\\\u002F4f6\\\u002F55f5384f63d30cc95fb66f7aa829cd3f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ff05\\\u002F0b6\\\u002Fa59\\\u002Ff050b6a59ca007309a692e1ddb365f51.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fcf2\\\u002F018\\\u002F7bd\\\u002Fcf20187bdaccc2f8c478a4fbecf9b026.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F0c1\\\u002Fa38\\\u002Fe47\\\u002F0c1a38e47e22a2aa349d33e290dfce26.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F41c\\\u002Fd5e\\\u002Fe19\\\u002F41cd5ee19f9e5b946df608b37401c285.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F7b4\\\u002Fad2\\\u002Fafb\\\u002F7b4ad2afbb83bc3550e84b0eef4656b4.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ff71\\\u002F516\\\u002F561\\\u002Ff71516561d286513a9a3e00734ef2a2e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F464\\\u002Fa68\\\u002F745\\\u002F464a6874597bb5af5e8d75a021d4757c.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F187\\\u002F6e6\\\u002F9de\\\u002F1876e69de443d7f95ee37d2d3de384df.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fcc2\\\u002F97c\\\u002F2fe\\\u002Fcc297c2fed641c2d28835534aeae8ffc.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Feee\\\u002F37e\\\u002Fcc1\\\u002Feee37ecc14ec3b5b437a23e54d43ca3b.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fe91\\\u002F59e\\\u002F73c\\\u002Fe9159e73cd6c48e8708b80eb9d692010.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F120\\\u002Fe8e\\\u002F3f3\\\u002F120e8e3f3f1b049fb73364ef95f45a98.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F43c\\\u002F9b3\\\u002F7b6\\\u002F43c9b37b6fcb18228b5dd4cdc032b570.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Feaa\\\u002F9e8\\\u002F13d\\\u002Feaa9e813dd1d93dd999c2f0b1c26f21d.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F4e8\\\u002F86f\\\u002Ff26\\\u002F4e886ff26b17f73e8f68936b713fe4d3.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ff1b\\\u002Fe98\\\u002F1d5\\\u002Ff1be981d546af1152206731e3024c0a3.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd1f\\\u002F16e\\\u002Fded\\\u002Fd1f16eded9a11be087bb4412c6bccbdd.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb9c\\\u002F519\\\u002F5c1\\\u002Fb9c5195c10d2b934761c7c038612f762.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fe81\\\u002Fc43\\\u002Fd75\\\u002Fe81c43d75f5b64cdcb4fae926ee89c96.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F66f\\\u002Fe80\\\u002F43e\\\u002F66fe8043ed0af18f2f71473c5b054c31.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Feed\\\u002Fd4c\\\u002F9b5\\\u002Feedd4c9b5a699f5b9914e20396cf40d9.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F3ba\\\u002Fa92\\\u002F036\\\u002F3baa9203634113af41b0cf205ed2dcfb.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F777\\\u002F604\\\u002Ffd9\\\u002F777604fd997588fdcbfc84eb4d1be94a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F383\\\u002F433\\\u002F185\\\u002F383433185e315366aeb94b94821bba0d.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F5b7\\\u002Ff4b\\\u002F024\\\u002F5b7f4b024eb83478e8f18cd186b3b9d5.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F8f1\\\u002F2e0\\\u002F60a\\\u002F8f12e060a50ee99510915c8468b73f0f.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F0ef\\\u002F4ae\\\u002F92c\\\u002F0ef4ae92cddb16b4b745b2059dcfa4a4.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F9c7\\\u002Fdf4\\\u002Fb8a\\\u002F9c7df4b8ade97abc8f1d1ffb668ea385.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F75d\\\u002Fc7c\\\u002F2ce\\\u002F75dc7c2cec0bc10fc1e38e415bd0ef7c.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F6cc\\\u002F9e5\\\u002Fd95\\\u002F6cc9e5d959a33f415fd423c5121df60a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F441\\\u002F063\\\u002Fb5e\\\u002F441063b5e30e6c8ba76b2db2b5a69410.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F86b\\\u002Fb8f\\\u002F215\\\u002F86bb8f215472353bd255e2b97eab9101.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2b4\\\u002Ffc8\\\u002F2a3\\\u002F2b4fc82a32d9e35f52580256cb1926f7.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F0cd\\\u002Fdfa\\\u002F291\\\u002F0cddfa29179f461116b7cfe0bbdeb050.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F217\\\u002Fbc4\\\u002F458\\\u002F217bc44585bf135b4454167cbcd8787f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F82f\\\u002Fd20\\\u002F380\\\u002F82fd20380c237a72b37872b04d4fe392.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F65d\\\u002Fed0\\\u002F316\\\u002F65ded031693ee418111811f565844a8c.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F403\\\u002F9b5\\\u002F072\\\u002F4039b50728315b5dca8dd48b90e8b8c7.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F351\\\u002F743\\\u002F51c\\\u002F35174351c301b18b2e1d9b63774b2b89.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fe75\\\u002Fb8c\\\u002F137\\\u002Fe75b8c137ff6baff167898ad05293c26.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F861\\\u002Fa08\\\u002F2d7\\\u002F861a082d71814fd1fae1959bb4febf02.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F6b0\\\u002F027\\\u002F27e\\\u002F6b002727ebacd87a3d5be2857a006c6b.PNG\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd75\\\u002Fcd3\\\u002F8dd\\\u002Fd75cd38ddb9963f2390c47b2fb43608a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F37d\\\u002F792\\\u002Fc45\\\u002F37d792c45d18f954e12cdfe3eefc429c.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb3e\\\u002Fd4d\\\u002F0c1\\\u002Fb3ed4d0c11dc17d917bd5cc297fb0467.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd68\\\u002F488\\\u002F889\\\u002Fd684888890c1af01836a509b6b2c0ede.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2ca\\\u002Fdfd\\\u002Fd8f\\\u002F2cadfdd8f7de8cbedd729ee41a3ee9af.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fec2\\\u002F115\\\u002F55b\\\u002Fec211555b92acf08ac92682a20b335a0.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F9c0\\\u002Fc9a\\\u002Fd20\\\u002F9c0c9ad20a1a70ddc325cb369cf11eae.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F010\\\u002F300\\\u002Fbbb\\\u002F010300bbbb4c94915c5831ee1a229990.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fffe\\\u002F048\\\u002F8b3\\\u002Fffe0488b35a8b553b20bae13499a6327.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2d8\\\u002Fe0d\\\u002Fae4\\\u002F2d8e0dae43754cfc255f92b04e696006.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fa72\\\u002F050\\\u002F779\\\u002Fa72050779709c38824a7736c40dc889b.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F7ca\\\u002Fea0\\\u002F908\\\u002F7caea0908d0c51bd140a49f6d06f9103.png\"]}","metaDescription":"В результате предыдущих расчётов мы выбрали размеры дельта-робота, построили его рабочую зону. Теперь настало время выбрать приводы. Привод,&nbsp;или устройство, которое вращает входные звенья...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"robo_dev,matlab,robot"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
