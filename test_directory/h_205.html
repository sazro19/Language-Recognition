<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Введение в параллелизм / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/intel\/blog\/583286\/"},"headline":"Введение в параллелизм","datePublished":"2021-10-21T13:43:40+03:00","dateModified":"2021-10-22T10:24:04+03:00","author":{"@type":"Person","name":"Александра Епанчинцева"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Сейчас почти&nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом.","url":"https:\/\/habr.com\/ru\/company\/intel\/blog\/583286\/#post-content-body","about":["c_intel","h_hi","h_programming","h_cpp","h_parallel_programming","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/583286\/8266b0cbc0ea8325cd2470da8038428e\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2b3\/21d\/8aa\/2b321d8aa8fcdcc53340dfcabf8430bb.jpg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/c7b\/aa0\/0c3\/c7baa00c36f811958c66d4c32cc99cea.jpg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/961\/821\/288\/9618212887484677054c6fd7bfc99d12.jpg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/ad8\/78e\/c82\/ad878ec8244cb5166a9c61494f07dfd5.jpg"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Введение в параллелизм" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Введение в параллелизм" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Введение в параллелизм" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Сейчас почти&amp;nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста:..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Сейчас почти&amp;nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста:..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Сейчас почти&amp;nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста:..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Сейчас почти&amp;nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста:..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Сейчас почти&amp;nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста:..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/54a/816/3ac/54a8163acde4a2eee79e450ea97a926d.jpg" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/54a/816/3ac/54a8163acde4a2eee79e450ea97a926d.jpg" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/54a/816/3ac/54a8163acde4a2eee79e450ea97a926d.jpg" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/54a/816/3ac/54a8163acde4a2eee79e450ea97a926d.jpg" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/54a/816/3ac/54a8163acde4a2eee79e450ea97a926d.jpg" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="583286" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-21T10:43:40.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/583286/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/intel/blog/583286/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/54a/816/3ac/54a8163acde4a2eee79e450ea97a926d.jpg" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/583286/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="intel" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><div class="tm-company-card__branding tm-company-article__branding tm-company-card__branding_loading"><div class="tm-company-card__branding-placeholder"><!----></div> <a href="https://habr.com/ru/company/intel/blog/"><img src="//habrastorage.org/getpro/habr/branding/4a2/56d/ac9/4a256dac9381ab0669f738555c9cbb37.jpg" width="100%" class="tm-company-card__branding-image"></a></div></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/intel/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/d32/960/3df/d329603dfbd0de62304376bdcd0de785.png" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">135.95</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/intel/profile/" class="tm-company-card__name">
        Intel
      </a> <div class="tm-company-card__description"></div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/voomily/" title="voomily" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/316/640/023/31664002319a3bf2a0b62c23bdfd2bdf.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/voomily/" class="tm-user-info__username">
      voomily
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-21T10:43:40.000Z" title="2021-10-21, 13:43">21  октября   в 13:43</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Введение в параллелизм</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/intel/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании Intel</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/hi/" class="tm-article-snippet__hubs-item-link"><span>Высокая производительность</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/cpp/" class="tm-article-snippet__hubs-item-link"><span>C++</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/parallel_programming/" class="tm-article-snippet__hubs-item-link"><span>Параллельное программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>Сейчас почти невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста: это относительно эффективная технология для масштабирования потенциальной производительности процессора. Эта технология стала широкодоступной около двадцати лет назад, и теперь каждый современный разработчик способен создать приложение с параллельным выполнением для использования такой системы. На наш взгляд, сложность параллельного программирования часто недооценивается. </p><p>В этой статье мы попробуем разработать простейшее  приложение, использующее для распараллеливания средства  C++ и сравнить его с версией, использующей <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onetbb.html">Intel oneTBB</a>.</p><p>Операционные системы и язык C++ предоставляют интерфейсы для создания потоков, которые потенциально могут выполнять один и тот же или различные наборы инструкций одновременно. </p><p>Основными источниками проблем многопоточного выполнения являются <em>data races (гонки данных) </em>и <em>race conditions (состояние гонки).</em> Простыми словами, C++ определяет data race как одновременные и несинхронизированные доступы к одной и той же ячейке памяти, при этом один из доступов модифицирует данные. В то время как race conditions является более общим термином, описывающим ситуацию, когда результат выполнения программы зависит от последовательности или времени выполнения потоков. </p><p>Основная проблема race conditions заключается в том, что они могут быть незаметны во время разработки программного обеспечения и могут исчезнуть во время отладки. Такое поведение часто приводит к ситуации, когда приложение считается законченным и корректным, но у конечного пользователя периодически возникают проблемы, часто неясного характера. Для решения проблемы data race, C++ предоставляет набор интерфейсов, таких как атомарные операции и примитивы для создания критических секций (мьютексы).  </p><p>Атомарные операции — это мощный инструмент, который позволяет избежать data races и создавать эффективные алгоритмы синхронизации. Однако<u>,</u> это создает замысловатую модель памяти C++, которая представляет собой еще один уровень сложности. </p><p>Использование мьютекса зачастую намного проще, чем использование атомарных операций. Он позволяет создать критическую секцию, которая может быть выполнена не более чем одним потоком в любой данный момент времени. Кроме того, продвинутые мьютексы, такие как <code>shared_lock</code>, в некоторых случаях могут повысить эффективность, позволяя группе потоков исполнять критическую секцию, если мьютекс не захвачен в эксклюзивное использование. </p><p>Давайте попытаемся распараллелить простую задачу вычисления суммы элементов массива. Решение этой проблемы в однопоточной программе может выглядеть следующим образом: </p><p><code>int summarize(const std::vector&lt;int>&amp; vec) { </code></p><p><code>    int sum = 0; </code></p><p><code>    for (int i = 0; i &lt; vec.size(); ++i) { </code></p><p><code>        sum += vec[i]; </code></p><p><code>    } </code></p><p><code>    return sum; </code></p><p><code>}</code> </p><p>Выполнение алгоритма в однопоточной программе: </p><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/2b3/21d/8aa/2b321d8aa8fcdcc53340dfcabf8430bb.jpg" width="934" height="271" data-src="https://habrastorage.org/getpro/habr/upload_files/2b3/21d/8aa/2b321d8aa8fcdcc53340dfcabf8430bb.jpg" data-blurred="true"/><figcaption></figcaption></figure><p>Для того чтобы исполнить алгоритм параллельно, нам нужно разделить его на независимые части, которые могут обрабатываться независимо друг от друга. Самый простой подход состоит в том, чтобы разделить обрабатываемые элементы на несколько частей и обработать каждую часть в своем собственном потоке. </p><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/c7b/aa0/0c3/c7baa00c36f811958c66d4c32cc99cea.jpg" width="930" height="247" data-src="https://habrastorage.org/getpro/habr/upload_files/c7b/aa0/0c3/c7baa00c36f811958c66d4c32cc99cea.jpg" data-blurred="true"/><figcaption></figcaption></figure><p>Однако в этом коде есть сложность, которая не позволяет нам просто разделить массив на две равные части и обрабатывать его параллельно. Все элементы суммируются в одну переменную, доступ к которой приведёт к data race, потому что один из потоков может записывать эту переменную одновременно с другим потоком, считывающим или записывающим в данную переменную. </p><p>Составной оператор (оператор +=), по сути, состоит из трех операций: чтение из памяти, операция сложения и сохранение результата в памяти. Эти операции могут выполняться параллельно разными потоками, что может привести к неожиданным результатам. На следующем рисунке показан возможный порядок операций на временной шкале двух потоков. Основная сложность заключается в том, что оба потока могут не получить результат операций другого потока и перезаписать данные. C++ трактует такие ситуации как data race, и поведение программы, в таких случаях, не определено. Например, в результате мы можем получить четыре, ожидая шесть (как показано на рисунке). В худшем случае данные могут быть в непредсказуемом состоянии. </p><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/961/821/288/9618212887484677054c6fd7bfc99d12.jpg" width="874" height="448" data-src="https://habrastorage.org/getpro/habr/upload_files/961/821/288/9618212887484677054c6fd7bfc99d12.jpg" data-blurred="true"/><figcaption></figcaption></figure><p>Существует много способов борьбы с data race, давайте рассмотрим самый простой из них - мьютекс. </p><p>Мьютекс имеет два основных интерфейса: блокировка (lock) и разблокировка (unclock). Блокировка переводит мьютекс в эксклюзивное владение, а разблокировка освобождает его, делая доступным для других потоков. Поток, который не может заблокировать мьютекс, будет остановлен, ожидая, пока другой поток освободит данный мьютекс. </p><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/ad8/78e/c82/ad878ec8244cb5166a9c61494f07dfd5.jpg" width="964" height="379" data-src="https://habrastorage.org/getpro/habr/upload_files/ad8/78e/c82/ad878ec8244cb5166a9c61494f07dfd5.jpg" data-blurred="true"/><figcaption></figcaption></figure><p>Код, защищенный мьютексом, также называется критической секцией. Важное наблюдение состоит в том, что второй поток, который не смог заблокировать мьютекс, не будет делать ничего полезного, во время того, пока первый поток находится в критической секции. Таким образом, размер критической секции может значительно повлиять на общую производительность системы. </p><p>Давайте попробуем сделать наш последовательный пример параллельным. Для создания потоков используем библиотеку <code>&lt;thread></code> из стандартной библиотеки C++. </p><p><code>int summarize(const std::vector&lt;int>&amp; vec) {</code></p><p><code>    int num_threads = 2;</code></p><p><code>    std::vector&lt;std::thread> threads(num_threads);</code></p><p><code>    int sum = 0;</code></p><p><code>    std::mutex m;</code></p><p><code>    auto thread_func = [&amp;sum, &amp;vec, &amp;m] (int thread_id) {</code></p><p><code>            // Делим итерационное пространство на 2 части</code></p><p><code>            int start_index = vec.size() / 2 * thread_id;</code></p><p><code>            int end_index = vec.size() / 2 * (thread_id + 1);</code></p><p><code>            for (int i = start_index; i &lt; end_index; ++i) {</code></p><p><code>            // Используем lock_guard, имплементирующий RAII идиому:</code></p><p><code>            // - мьютекс блокируется в конструкторе</code></p><p><code>            // (т.е. вызван mutex.lock())</code></p><p><code>            // - мьютекс освобождается в деструкторе (т.е. вызван mutex.unlock())</code></p><p><code>            std::lock_guard&lt;std::mutex> lock(m);</code></p><p><code>            sum += vec[i];</code></p><p><code>        }</code></p><p><code>    };</code></p><p><code>    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) {</code></p><p><code>        // Запускаем поток со стартовой функцией `thread_func`</code></p><p><code>        // и аргументом функции ` thread_id`</code></p><p><code>        threads[thread_id] = std::thread(thread_func, thread_id);</code></p><p><code>    }</code></p><p><code>    std::cout &lt;&lt; sum &lt;&lt; std::endl;</code></p><p><code>    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) {</code></p><p><code>            //  Нам нужно дождаться всех потоков</code></p><p><code>        // до разрушения std::vector&lt;std::thread></code></p><p><code>        threads[thread_id].join();</code></p><p><code>    }</code></p><p><code>    return sum;</code></p><p><code>}</code> </p><p> </p><p>Запустив нашу программу, мы, вероятно, увидим неверный результат. Причина в том, что с помощью мьютекса мы защитили себя от data race при вычислении суммы, но основной поток может считывать переменную sum, в то время как другие потоки изменяют ее. Даже если мы защитим чтение с помощью мьютекса, это приведет к другой неочевидной сложности, называемой race condition: чтение, защищённое с помощью мьютекса, не гарантирует логическую корректность алгоритма. В нашем случае мы не дожидаемся полного завершения вычислений. Чтобы решить эту проблему, мы должны дождаться завершения потоков, прежде чем считывать результат. Однако, в данном случае мьютекс не требуется для чтения общей суммы , потому что синхронизация вычислений выполняется во время ожидания потоков (с помощью функции join). </p><p><code>int summarize(const std::vector&lt;int>&amp; vec) {</code></p><p><code>    int num_threads = 2;</code></p><p><code>    std::vector&lt;std::thread> threads(num_threads);</code></p><p><code>    int sum = 0;</code></p><p><code>    std::mutex m;</code></p><p><code>    auto thread_func = [&amp;sum, &amp;vec, &amp;m] (int thread_id) {</code></p><p><code>        // Делим итерационное пространство на 2 части</code></p><p><code>        int start_index = vec.size() / 2 * thread_id;</code></p><p><code>        int end_index = vec.size() / 2 * (thread_id + 1);</code></p><p><code>        for (int i = start_index; i &lt; end_index; ++i) {</code></p><p><code>            // Используем lock_guard, имплементирующий RAII идиому:</code></p><p><code>            // - мьютекс блокируется в конструкторе</code></p><p><code>            // (т.е. вызван mutex.lock())</code></p><p><code>            // - мьютекс освобождается в деструкторе</code></p><p><code>            // (т.е. вызван mutex.unlock())</code></p><p><code>            std::lock_guard&lt;std::mutex> lock(m);</code></p><p><code>            sum += vec[i];</code></p><p><code>        }</code></p><p><code>    };</code></p><p><code>    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) {</code></p><p><code>        // Запускаем поток со стартовой функцией `thread_func`</code></p><p><code>        // и аргументом функции ` thread_id`</code></p><p><code>        threads[thread_id] = std::thread(thread_func, thread_id);</code></p><p><code>    }</code></p><p><code>    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) { </code></p><p><code>        //  Нам нужно дождатьсявсех потоков до </code></p><p><code>        // разрушения std::vector&lt;std::thread></code></p><p><code>        threads[thread_id].join();</code></p><p><code>    }</code></p><p><code>    std::cout &lt;&lt; sum &lt;&lt; std::endl;</code></p><p><code>    return sum;</code></p><p><code>}</code> </p><p> </p><p>Этот подход к распараллеливанию, очевидно, будет работать медленнее, чем последовательная версия, потому что для каждого <code>sum += vec[i]</code> мы берем мьютекс <code>std:: lock_guard&lt;std::mutex> lock (m)</code>. Таким образом, мы полностью упорядочиваем вычисления, т. е. разрешаем работать только одному потоку в любой момент времени. Чтобы избежать этого, мы можем сначала выполнить локальное суммирование в каждом потоке, а в конце вычислений добавить результат к глобальной сумме. </p><p><code>int sum = 0;</code></p><p><code>std::mutex m;</code></p><p><code>auto thread_func = [&amp;sum, &amp;vec, &amp;m] (int thread_id) {</code></p><p><code>    // Делим origin rangeитерационное пространство на 2 части</code></p><p><code>    int start_index = vec.size() / 2 * thread_id;</code></p><p><code>    int end_index = vec.size() / 2 * (thread_id + 1);</code></p><p><code>    int local_sum = 0;</code></p><p><code>    for (int i = start_index; i &lt; end_index; ++i) {</code></p><p><code>        local_sum += vec[i]; </code></p><p><code>    }</code></p><p><code>    // Используем lock_guard, имплементирующий RAII идиому:</code></p><p><code>    // - мьютекс блокируется в конструкторе</code></p><p><code>    // (т.е. вызван mutex.lock())</code></p><p><code>    // - мьютекс освобождается в деструкторе</code></p><p><code>    // (т.е. вызван mutex.unlock())</code></p><p><code>    std::lock_guard&lt;std::mutex> lock(m);</code></p><p><code>    sum += local_sum; </code></p><p><code>};</code> </p><p> </p><p>Этот простой пример демонстрирует, что параллельное программирование приводит к ряду проблем, которые невозможно наблюдать в последовательной программе. Более того, эти проблемы не всегда легко обнаружить, и они не всегда очевидны. Библиотеки, такие как oneTBB, упрощают параллельное программирование во многих аспектах. Для наглядности наш пример можно переписать с помощью <code>parallel_reduce</code>, который не требует каких-либо специальных синхронизаций и механизмов, чтобы избежать race conditions: </p><p> </p><p><code>int summarize(const std::vector&lt;int>&amp; vec) {</code></p><p><code>    int sum = tbb::parallel_reduce(tbb::blocked_range&lt;std::size_t>{0, vec.size()}, 0, </code></p><p><code>        [&amp;vec] (const auto&amp; r, int init) {</code></p><p><code>            for (auto i = r.begin(); i != r.end(); ++i) {</code></p><p><code>                init += vec[i];</code></p><p><code>            }</code></p><p><code>            return init;</code></p><p><code>        }, std::plus&lt;int>{});</code></p><p><code>    return sum;</code></p><p><code>}</code> </p><p> </p><p>Хотя этот пример относительно небольшой, он показывает набор значительных упрощений, которые предоставляет oneTBB. Например, oneTBB автоматически создаст набор потоков, которые будут повторно использоваться между несколькими вызовами параллельных алгоритмов. Кроме того, <code>parallel_reduce</code> реализует все необходимые синхронизации, а пользователю достаточно описать требуемую операцию свертки, например<u>,</u> <code>std::plus&lt;int></code>. </p><p>oneTBB использует подход, основанный на work stealing алгоритме распределения задач, предоставляя обобщенные параллельные алгоритмы, применимые для широкого спектра приложений. Основное преимущество подхода oneTBB заключается в том, что он позволяет легко создавать параллелизм в различных независимых компонентах приложения. </p><p>В нашей серии статей мы продемонстрируем, как oneTBB можно использовать для динамической балансировки нагрузки и распараллеливания графов. Помимо параллелизма задач на процессоре, мы покажем, как oneTBB можно использовать в качестве уровня абстракции для балансировки вычислений между несколькими разнородными устройствами, такими как GPU. </p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%2B%2B%5D" class="tm-tags-list__link">с++</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">программирование</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B7%D0%BC%5D" class="tm-tags-list__link">параллелизм</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Btbb%5D" class="tm-tags-list__link">tbb</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Boneapi%5D" class="tm-tags-list__link">oneapi</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/intel/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании Intel
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/hi/" class="tm-hubs-list__link">
    Высокая производительность
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/cpp/" class="tm-hubs-list__link">
    C++
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/parallel_programming/" class="tm-hubs-list__link">
    Параллельное программирование
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 10: ↑6 и ↓4</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 10: ↑6 и ↓4" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+2</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">4.7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    42
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/intel/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/d32/960/3df/d329603dfbd0de62304376bdcd0de785.png" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/intel/profile/" class="tm-company-snippet__title">Intel</a> <div class="tm-company-snippet__description">Компания</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <div class="tm-article-author__company-contacts"><a href="http://www.intel.ru/" rel="noopener" target="_blank" class="tm-article-author__contact">
      Сайт
    </a><a href="https://twitter.com/intelrussia" rel="noopener" target="_blank" class="tm-article-author__contact">
      Twitter
    </a><a href="https://vk.com/intelsoftware" rel="noopener" target="_blank" class="tm-article-author__contact">
      ВКонтакте
    </a></div> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/voomily/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/316/640/023/31664002319a3bf2a0b62c23bdfd2bdf.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 5 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    1
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">2</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Александра Епанчинцева</span> <a href="/ru/users/voomily/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @voomily
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Технический писатель</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/intel/blog/583286/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 10 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="1968-07-17T21:00:00.000Z" title="1968-07-18, 00:00">18  июля  1968</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    США
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://www.intel.ru/" target="_blank" class="tm-company-basic-info__link">
      www.intel.ru
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    5 001–10 000 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2008-08-09T07:43:02.000Z" title="2008-08-09, 11:43">9  августа  2008</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Представитель</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="/ru/users/vikky13/" class="tm-company-basic-info__link">
      Victoria Zhislina
    </a></dd></dl></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/intel/blog/583286/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/intel/blog/583286/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"583286":{"id":"583286","timePublished":"2021-10-21T10:43:40+00:00","isCorporative":true,"lang":"ru","titleHtml":"Введение в параллелизм","leadData":{"textHtml":"\u003Cp\u003EДанная статья посвящена параллелизму&nbsp;в&nbsp;C++,&nbsp;сопутствующим сложностям&nbsp;и как их можно обойти, используя&nbsp;библиотеку&nbsp;\u003Ca href=\"https:\u002F\u002Fwww.intel.com\u002Fcontent\u002Fwww\u002Fus\u002Fen\u002Fdeveloper\u002Ftools\u002Foneapi\u002Fonetbb.html\"\u003EoneAPI&nbsp;Threading&nbsp;Building&nbsp;Blocks\u003C\u002Fa\u003E&nbsp;(oneTBB) для упрощения параллельного программирования.&nbsp;\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F54a\u002F816\u002F3ac\u002F54a8163acde4a2eee79e450ea97a926d.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F54a\u002F816\u002F3ac\u002F54a8163acde4a2eee79e450ea97a926d.jpg","fit":"cover","positionY":0,"positionX":29.487179487179}},"editorVersion":"2.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":1,"votesCount":5},"rating":2,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2801025","alias":"voomily","fullname":"Александра Епанчинцева","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F316\u002F640\u002F023\u002F31664002319a3bf2a0b62c23bdfd2bdf.jpg","speciality":"Технический писатель"},"statistics":{"commentsCount":10,"favoritesCount":42,"readingCount":4659,"score":2,"votesCount":10},"hubs":[{"relatedData":null,"id":"5334","alias":"intel","type":"corporative","title":"Блог компании Intel","titleHtml":"Блог компании Intel","isProfiled":false},{"relatedData":null,"id":"4","alias":"hi","type":"collective","title":"Высокая производительность","titleHtml":"Высокая производительность","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"559","alias":"cpp","type":"collective","title":"C++","titleHtml":"C++","isProfiled":true},{"relatedData":null,"id":"17822","alias":"parallel_programming","type":"collective","title":"Параллельное программирование","titleHtml":"Параллельное программирование","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EСейчас почти невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста: это относительно эффективная технология для масштабирования потенциальной производительности процессора. Эта технология стала широкодоступной около двадцати лет назад, и теперь каждый современный разработчик способен создать приложение с параллельным выполнением для использования такой системы. На наш взгляд, сложность параллельного программирования часто недооценивается. \u003C\u002Fp\u003E\u003Cp\u003EВ этой статье мы попробуем разработать простейшее  приложение, использующее для распараллеливания средства  C++ и сравнить его с версией, использующей \u003Ca href=\"https:\u002F\u002Fwww.intel.com\u002Fcontent\u002Fwww\u002Fus\u002Fen\u002Fdeveloper\u002Ftools\u002Foneapi\u002Fonetbb.html\"\u003EIntel oneTBB\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EОперационные системы и язык C++ предоставляют интерфейсы для создания потоков, которые потенциально могут выполнять один и тот же или различные наборы инструкций одновременно. \u003C\u002Fp\u003E\u003Cp\u003EОсновными источниками проблем многопоточного выполнения являются \u003Cem\u003Edata races (гонки данных) \u003C\u002Fem\u003Eи \u003Cem\u003Erace conditions (состояние гонки).\u003C\u002Fem\u003E Простыми словами, C++ определяет data race как одновременные и несинхронизированные доступы к одной и той же ячейке памяти, при этом один из доступов модифицирует данные. В то время как race conditions является более общим термином, описывающим ситуацию, когда результат выполнения программы зависит от последовательности или времени выполнения потоков. \u003C\u002Fp\u003E\u003Cp\u003EОсновная проблема race conditions заключается в том, что они могут быть незаметны во время разработки программного обеспечения и могут исчезнуть во время отладки. Такое поведение часто приводит к ситуации, когда приложение считается законченным и корректным, но у конечного пользователя периодически возникают проблемы, часто неясного характера. Для решения проблемы data race, C++ предоставляет набор интерфейсов, таких как атомарные операции и примитивы для создания критических секций (мьютексы).  \u003C\u002Fp\u003E\u003Cp\u003EАтомарные операции — это мощный инструмент, который позволяет избежать data races и создавать эффективные алгоритмы синхронизации. Однако\u003Cu\u003E,\u003C\u002Fu\u003E это создает замысловатую модель памяти C++, которая представляет собой еще один уровень сложности. \u003C\u002Fp\u003E\u003Cp\u003EИспользование мьютекса зачастую намного проще, чем использование атомарных операций. Он позволяет создать критическую секцию, которая может быть выполнена не более чем одним потоком в любой данный момент времени. Кроме того, продвинутые мьютексы, такие как \u003Ccode\u003Eshared_lock\u003C\u002Fcode\u003E, в некоторых случаях могут повысить эффективность, позволяя группе потоков исполнять критическую секцию, если мьютекс не захвачен в эксклюзивное использование. \u003C\u002Fp\u003E\u003Cp\u003EДавайте попытаемся распараллелить простую задачу вычисления суммы элементов массива. Решение этой проблемы в однопоточной программе может выглядеть следующим образом: \u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Eint summarize(const std::vector&lt;int\u003E&amp; vec) { \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int sum = 0; \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    for (int i = 0; i &lt; vec.size(); ++i) { \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        sum += vec[i]; \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    } \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    return sum; \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E}\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\u003Cp\u003EВыполнение алгоритма в однопоточной программе: \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2b3\u002F21d\u002F8aa\u002F2b321d8aa8fcdcc53340dfcabf8430bb.jpg\" width=\"934\" height=\"271\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2b3\u002F21d\u002F8aa\u002F2b321d8aa8fcdcc53340dfcabf8430bb.jpg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДля того чтобы исполнить алгоритм параллельно, нам нужно разделить его на независимые части, которые могут обрабатываться независимо друг от друга. Самый простой подход состоит в том, чтобы разделить обрабатываемые элементы на несколько частей и обработать каждую часть в своем собственном потоке. \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc7b\u002Faa0\u002F0c3\u002Fc7baa00c36f811958c66d4c32cc99cea.jpg\" width=\"930\" height=\"247\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc7b\u002Faa0\u002F0c3\u002Fc7baa00c36f811958c66d4c32cc99cea.jpg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EОднако в этом коде есть сложность, которая не позволяет нам просто разделить массив на две равные части и обрабатывать его параллельно. Все элементы суммируются в одну переменную, доступ к которой приведёт к data race, потому что один из потоков может записывать эту переменную одновременно с другим потоком, считывающим или записывающим в данную переменную. \u003C\u002Fp\u003E\u003Cp\u003EСоставной оператор (оператор +=), по сути, состоит из трех операций: чтение из памяти, операция сложения и сохранение результата в памяти. Эти операции могут выполняться параллельно разными потоками, что может привести к неожиданным результатам. На следующем рисунке показан возможный порядок операций на временной шкале двух потоков. Основная сложность заключается в том, что оба потока могут не получить результат операций другого потока и перезаписать данные. C++ трактует такие ситуации как data race, и поведение программы, в таких случаях, не определено. Например, в результате мы можем получить четыре, ожидая шесть (как показано на рисунке). В худшем случае данные могут быть в непредсказуемом состоянии. \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F961\u002F821\u002F288\u002F9618212887484677054c6fd7bfc99d12.jpg\" width=\"874\" height=\"448\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F961\u002F821\u002F288\u002F9618212887484677054c6fd7bfc99d12.jpg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСуществует много способов борьбы с data race, давайте рассмотрим самый простой из них - мьютекс. \u003C\u002Fp\u003E\u003Cp\u003EМьютекс имеет два основных интерфейса: блокировка (lock) и разблокировка (unclock). Блокировка переводит мьютекс в эксклюзивное владение, а разблокировка освобождает его, делая доступным для других потоков. Поток, который не может заблокировать мьютекс, будет остановлен, ожидая, пока другой поток освободит данный мьютекс. \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fad8\u002F78e\u002Fc82\u002Fad878ec8244cb5166a9c61494f07dfd5.jpg\" width=\"964\" height=\"379\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fad8\u002F78e\u002Fc82\u002Fad878ec8244cb5166a9c61494f07dfd5.jpg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EКод, защищенный мьютексом, также называется критической секцией. Важное наблюдение состоит в том, что второй поток, который не смог заблокировать мьютекс, не будет делать ничего полезного, во время того, пока первый поток находится в критической секции. Таким образом, размер критической секции может значительно повлиять на общую производительность системы. \u003C\u002Fp\u003E\u003Cp\u003EДавайте попробуем сделать наш последовательный пример параллельным. Для создания потоков используем библиотеку \u003Ccode\u003E&lt;thread\u003E\u003C\u002Fcode\u003E из стандартной библиотеки C++. \u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Eint summarize(const std::vector&lt;int\u003E&amp; vec) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int num_threads = 2;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    std::vector&lt;std::thread\u003E threads(num_threads);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int sum = 0;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    std::mutex m;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    auto thread_func = [&amp;sum, &amp;vec, &amp;m] (int thread_id) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F Делим итерационное пространство на 2 части\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            int start_index = vec.size() \u002F 2 * thread_id;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            int end_index = vec.size() \u002F 2 * (thread_id + 1);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            for (int i = start_index; i &lt; end_index; ++i) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F Используем lock_guard, имплементирующий RAII идиому:\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F - мьютекс блокируется в конструкторе\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F (т.е. вызван mutex.lock())\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F - мьютекс освобождается в деструкторе (т.е. вызван mutex.unlock())\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            std::lock_guard&lt;std::mutex\u003E lock(m);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            sum += vec[i];\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    };\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F Запускаем поток со стартовой функцией `thread_func`\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F и аргументом функции ` thread_id`\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        threads[thread_id] = std::thread(thread_func, thread_id);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    std::cout &lt;&lt; sum &lt;&lt; std::endl;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F  Нам нужно дождаться всех потоков\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F до разрушения std::vector&lt;std::thread\u003E\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        threads[thread_id].join();\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    return sum;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E}\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\u003Cp\u003E \u003C\u002Fp\u003E\u003Cp\u003EЗапустив нашу программу, мы, вероятно, увидим неверный результат. Причина в том, что с помощью мьютекса мы защитили себя от data race при вычислении суммы, но основной поток может считывать переменную sum, в то время как другие потоки изменяют ее. Даже если мы защитим чтение с помощью мьютекса, это приведет к другой неочевидной сложности, называемой race condition: чтение, защищённое с помощью мьютекса, не гарантирует логическую корректность алгоритма. В нашем случае мы не дожидаемся полного завершения вычислений. Чтобы решить эту проблему, мы должны дождаться завершения потоков, прежде чем считывать результат. Однако, в данном случае мьютекс не требуется для чтения общей суммы , потому что синхронизация вычислений выполняется во время ожидания потоков (с помощью функции join). \u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Eint summarize(const std::vector&lt;int\u003E&amp; vec) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int num_threads = 2;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    std::vector&lt;std::thread\u003E threads(num_threads);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int sum = 0;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    std::mutex m;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    auto thread_func = [&amp;sum, &amp;vec, &amp;m] (int thread_id) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F Делим итерационное пространство на 2 части\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        int start_index = vec.size() \u002F 2 * thread_id;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        int end_index = vec.size() \u002F 2 * (thread_id + 1);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        for (int i = start_index; i &lt; end_index; ++i) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F Используем lock_guard, имплементирующий RAII идиому:\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F - мьютекс блокируется в конструкторе\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F (т.е. вызван mutex.lock())\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F - мьютекс освобождается в деструкторе\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            \u002F\u002F (т.е. вызван mutex.unlock())\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            std::lock_guard&lt;std::mutex\u003E lock(m);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            sum += vec[i];\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    };\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F Запускаем поток со стартовой функцией `thread_func`\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F и аргументом функции ` thread_id`\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        threads[thread_id] = std::thread(thread_func, thread_id);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    for (int thread_id = 0; thread_id &lt; num_threads; ++ thread_id) { \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F  Нам нужно дождатьсявсех потоков до \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        \u002F\u002F разрушения std::vector&lt;std::thread\u003E\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        threads[thread_id].join();\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    std::cout &lt;&lt; sum &lt;&lt; std::endl;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    return sum;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E}\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\u003Cp\u003E \u003C\u002Fp\u003E\u003Cp\u003EЭтот подход к распараллеливанию, очевидно, будет работать медленнее, чем последовательная версия, потому что для каждого \u003Ccode\u003Esum += vec[i]\u003C\u002Fcode\u003E мы берем мьютекс \u003Ccode\u003Estd:: lock_guard&lt;std::mutex\u003E lock (m)\u003C\u002Fcode\u003E. Таким образом, мы полностью упорядочиваем вычисления, т. е. разрешаем работать только одному потоку в любой момент времени. Чтобы избежать этого, мы можем сначала выполнить локальное суммирование в каждом потоке, а в конце вычислений добавить результат к глобальной сумме. \u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Eint sum = 0;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Estd::mutex m;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Eauto thread_func = [&amp;sum, &amp;vec, &amp;m] (int thread_id) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    \u002F\u002F Делим origin rangeитерационное пространство на 2 части\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int start_index = vec.size() \u002F 2 * thread_id;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int end_index = vec.size() \u002F 2 * (thread_id + 1);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int local_sum = 0;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    for (int i = start_index; i &lt; end_index; ++i) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        local_sum += vec[i]; \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    \u002F\u002F Используем lock_guard, имплементирующий RAII идиому:\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    \u002F\u002F - мьютекс блокируется в конструкторе\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    \u002F\u002F (т.е. вызван mutex.lock())\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    \u002F\u002F - мьютекс освобождается в деструкторе\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    \u002F\u002F (т.е. вызван mutex.unlock())\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    std::lock_guard&lt;std::mutex\u003E lock(m);\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    sum += local_sum; \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E};\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\u003Cp\u003E \u003C\u002Fp\u003E\u003Cp\u003EЭтот простой пример демонстрирует, что параллельное программирование приводит к ряду проблем, которые невозможно наблюдать в последовательной программе. Более того, эти проблемы не всегда легко обнаружить, и они не всегда очевидны. Библиотеки, такие как oneTBB, упрощают параллельное программирование во многих аспектах. Для наглядности наш пример можно переписать с помощью \u003Ccode\u003Eparallel_reduce\u003C\u002Fcode\u003E, который не требует каких-либо специальных синхронизаций и механизмов, чтобы избежать race conditions: \u003C\u002Fp\u003E\u003Cp\u003E \u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Eint summarize(const std::vector&lt;int\u003E&amp; vec) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    int sum = tbb::parallel_reduce(tbb::blocked_range&lt;std::size_t\u003E{0, vec.size()}, 0, \u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        [&amp;vec] (const auto&amp; r, int init) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            for (auto i = r.begin(); i != r.end(); ++i) {\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E                init += vec[i];\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            }\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E            return init;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E        }, std::plus&lt;int\u003E{});\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E    return sum;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003E}\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\u003Cp\u003E \u003C\u002Fp\u003E\u003Cp\u003EХотя этот пример относительно небольшой, он показывает набор значительных упрощений, которые предоставляет oneTBB. Например, oneTBB автоматически создаст набор потоков, которые будут повторно использоваться между несколькими вызовами параллельных алгоритмов. Кроме того, \u003Ccode\u003Eparallel_reduce\u003C\u002Fcode\u003E реализует все необходимые синхронизации, а пользователю достаточно описать требуемую операцию свертки, например\u003Cu\u003E,\u003C\u002Fu\u003E \u003Ccode\u003Estd::plus&lt;int\u003E\u003C\u002Fcode\u003E. \u003C\u002Fp\u003E\u003Cp\u003EoneTBB использует подход, основанный на work stealing алгоритме распределения задач, предоставляя обобщенные параллельные алгоритмы, применимые для широкого спектра приложений. Основное преимущество подхода oneTBB заключается в том, что он позволяет легко создавать параллелизм в различных независимых компонентах приложения. \u003C\u002Fp\u003E\u003Cp\u003EВ нашей серии статей мы продемонстрируем, как oneTBB можно использовать для динамической балансировки нагрузки и распараллеливания графов. Помимо параллелизма задач на процессоре, мы покажем, как oneTBB можно использовать в качестве уровня абстракции для балансировки вычислений между несколькими разнородными устройствами, такими как GPU. \u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"с++"},{"titleHtml":"программирование"},{"titleHtml":"параллелизм"},{"titleHtml":"tbb"},{"titleHtml":"oneapi"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F54a\u002F816\u002F3ac\u002F54a8163acde4a2eee79e450ea97a926d.jpg","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F54a\u002F816\u002F3ac\u002F54a8163acde4a2eee79e450ea97a926d.jpg","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fintel\\\u002Fblog\\\u002F583286\\\u002F\"},\"headline\":\"Введение в параллелизм\",\"datePublished\":\"2021-10-21T13:43:40+03:00\",\"dateModified\":\"2021-10-22T10:24:04+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Александра Епанчинцева\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Сейчас почти&nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом.\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fintel\\\u002Fblog\\\u002F583286\\\u002F#post-content-body\",\"about\":[\"c_intel\",\"h_hi\",\"h_programming\",\"h_cpp\",\"h_parallel_programming\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F583286\\\u002F8266b0cbc0ea8325cd2470da8038428e\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2b3\\\u002F21d\\\u002F8aa\\\u002F2b321d8aa8fcdcc53340dfcabf8430bb.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fc7b\\\u002Faa0\\\u002F0c3\\\u002Fc7baa00c36f811958c66d4c32cc99cea.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F961\\\u002F821\\\u002F288\\\u002F9618212887484677054c6fd7bfc99d12.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fad8\\\u002F78e\\\u002Fc82\\\u002Fad878ec8244cb5166a9c61494f07dfd5.jpg\"]}","metaDescription":"Сейчас почти&nbsp;невозможно найти современную компьютерную систему без многоядерного процессора. Даже недорогие мобильные телефоны предлагают пару ядер под капотом. Идея многоядерных систем проста:...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"intel":{"alias":"intel","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002Fd32\u002F960\u002F3df\u002Fd329603dfbd0de62304376bdcd0de785.png","titleHtml":"Intel","descriptionHtml":null,"relatedData":null,"statistics":{"postsCount":1289,"newsCount":0,"vacanciesCount":0,"employeesCount":146,"careerRating":null,"subscribersCount":54902,"rating":135.95,"invest":null},"foundationDate":{"year":"1968","month":"07","day":"18"},"location":{"city":{"id":"462377","title":"Santa Clara"},"region":{"id":"209","title":"California"},"country":{"id":"198","title":"США"}},"siteUrl":"http:\u002F\u002Fwww.intel.ru\u002F","staffNumber":"5 001–10 000 человек","registrationDate":"2008-08-09T07:43:02+00:00","representativeUser":{"alias":"vikky13","fullname":"Victoria Zhislina"},"contacts":[{"title":"Сайт","url":"http:\u002F\u002Fwww.intel.ru\u002F"},{"title":"Twitter","url":"https:\u002F\u002Ftwitter.com\u002Fintelrussia"},{"title":"ВКонтакте","url":"https:\u002F\u002Fvk.com\u002Fintelsoftware"}],"settings":{"analyticsSettings":[{"type":"ga","trackingId":"UA-106496329-1"}],"branding":{"imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fbranding\u002F4a2\u002F56d\u002Fac9\u002F4a256dac9381ab0669f738555c9cbb37.jpg","linkUrl":"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fintel\u002Fblog\u002F","pixelUrl":""},"status":"active"},"metadata":{"titleHtml":"Intel, Santa Clara -  с 18 июля 1968 г.","title":"Intel, Santa Clara -  с 18 июля 1968 г.","keywords":["Компьютерное железо","Программирование","Процессоры","Машинное обучение","Искусственный интеллект"],"descriptionHtml":"1 289 статей от авторов компании Intel","description":"1 289 статей от авторов компании Intel"},"aDeskSettings":null,"careerAlias":"intel","maxCustomTrackerLinks":3}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
