<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Корутины в C++20 — что это и как с ними работать / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/wunderfund\/blog\/582000\/"},"headline":"Корутины в C++20 — что это и как с ними работать","datePublished":"2021-10-25T17:06:30+03:00","dateModified":"2021-10-25T17:06:30+03:00","author":{"@type":"Person","name":"mr-pickles"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промис...","url":"https:\/\/habr.com\/ru\/company\/wunderfund\/blog\/582000\/#post-content-body","about":["c_wunderfund","h_programming","h_cpp","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/582000\/365c01d958c07b10a1936e5f80e06514\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/dfe\/3c5\/106\/dfe3c51063238c007eb2dbd960f079b3.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/749\/946\/eea\/749946eea0c07443b04425d455f90314.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/070\/510\/599\/070510599b4b897e30b915538151e38d.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Корутины в C++20 — что это и как с ними работать" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Корутины в C++20 — что это и как с ними работать" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Корутины в C++20 — что это и как с ними работать" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/2d4/6ee/e85/2d46eee8594e8fca63e142a5973441fc.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/2d4/6ee/e85/2d46eee8594e8fca63e142a5973441fc.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/2d4/6ee/e85/2d46eee8594e8fca63e142a5973441fc.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/2d4/6ee/e85/2d46eee8594e8fca63e142a5973441fc.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/2d4/6ee/e85/2d46eee8594e8fca63e142a5973441fc.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="582000" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-25T14:06:30.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/582000/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/wunderfund/blog/582000/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/2d4/6ee/e85/2d46eee8594e8fca63e142a5973441fc.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/582000/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="wunderfund" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/wunderfund/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/b1a/8c4/544/b1a8c4544d951f4ea9bad437589d958e.png" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">60.88</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/wunderfund/profile/" class="tm-company-card__name">
        Wunder Fund
      </a> <div class="tm-company-card__description">Мы занимаемся высокочастотной торговлей на бирже</div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/mr-pickles/" title="mr-pickles" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/a90/a35/fb7/a90a35fb73f6e7f05770af0978f90b11.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/mr-pickles/" class="tm-user-info__username">
      mr-pickles
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-25T14:06:30.000Z" title="2021-10-25, 17:06">сегодня в 17:06</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Корутины в C++20 — что это и как с ними работать</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/wunderfund/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании Wunder Fund</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/cpp/" class="tm-article-snippet__hubs-item-link"><span>C++</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://blog.feabhas.com/2021/09/c20-coroutines/" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Martin Bond
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><figure class="full-width "><img src="/img/image-loader.svg" height="440" data-src="https://habrastorage.org/getpro/habr/upload_files/dfe/3c5/106/dfe3c51063238c007eb2dbd960f079b3.png" data-width="780"/><figcaption></figcaption></figure><p><em>Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному мнению, можно было бы реализовать и поизящнее. Приходите к нам работать, если имеете сильные мнения о корутинах хе-хе.</em></p><p>Возникает такое ощущение, что тема реализации корутин в C++20 окутана серьёзной неопределённостью. Полагаю, это так из-за того, что в проекте технической спецификации C++20 сказано, что работа над механизмами корутин всё ещё ведётся, в результате в данный момент нельзя ожидать полной поддержки этих механизмов компиляторами и стандартной библиотекой. Множество проблем, вероятно, возникает из-за отсутствия официальной документации по работе с корутинами. Нам дали синтаксическую поддержку корутин в C++ (<code>co_yield</code> и <code>co_return</code>), но не всё то, что я счёл бы признаками их полной библиотечной поддержки. В стандартной библиотеке имеются хуки и базовый функционал поддержки корутин, но нам приходится самостоятельно встраивать всё это в наши собственные классы. Я ожидаю, что полная поддержка корутин-генераторов появится в C++23.</p><p>Спецификация C++20, очевидно, направлена на поддержку параллельных (или асинхронных) корутин с использованием <code>co_await</code>, что усложняет реализацию более простых синхронных корутин-генераторов. Среди требований к реализации наших корутин имеются сведения об использовании <code>Future</code> и <code>Promise</code>, что похоже на то, как при реализации асинхронных потоков используется <a href="https://en.cppreference.com/w/cpp/thread/async">std::async</a>.</p><p>Если вы — Python- или C#-разработчик и ожидаете увидеть в C++ простую механику работы с корутинами, то вас ждёт разочарование, так как фреймворк общего назначения C++20 недоработан. Учитывая это, можно отметить, что в интернете имеется множество публикаций, в состав кода, обсуждаемого в которых, входит шаблонный класс, поддерживающий корутины-генераторы. В этом материале вы найдёте шаблон корутины, применимый на практике, а также примеры кода. Всё это предваряется общими сведениями о корутинах.</p><h3>Что такое корутины?</h3><p>Я впервые столкнулся с корутинами, увидев инструкцию <code>yield</code> в <a href="https://en.wikipedia.org/wiki/CLU_(programming_language)">CLU</a>. Корутины, наподобие генераторов в Python (и конструкции <code>yield return</code> в C#), определяются с использованием функционального синтаксиса, а доступ к ним организуется с применением синтаксических конструкций цикла <code>for</code>. Корутины описывались как взаимодействующие программы (но не как конкурентные программы), выполняющиеся в одном потоке. Существуют и другие разновидности корутин. Для того чтобы разобраться в том, чем отличаются друг от друга функции, генераторы и потоки, можно начать с <a href="https://en.wikipedia.org/wiki/Coroutine">этой</a> статьи из Википедии.</p><p>В этом материале я уделяю основное внимание корутинам, выполняемым в контексте вызывающей стороны, применение которых позволяет двум различным блокам кода периодически передавать друг другу управление ходом выполнения программы.</p><p>Новая инструкция <code>co_yield</code> в C++20 позволяет одной программе предоставить фрагмент данных, и в то же время вернуть управление ходом выполнения программы вызывающей программе для обработки этих данных. В общем-то, это — всего лишь витиеватый способ сказать о том, что корутины в C++20 дают нам однопоточную реализацию паттерна продюсер/консьюмер (<a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">producer/consumer</a>).</p><p>Мы можем показать классический пример взаимодействия продюсера и консьюмера, связанный с применением корутин, подготовив следующую <a href="https://en.wikipedia.org/wiki/Sequence_diagram">UML-диаграмму последовательности</a>.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Корутина-генератор" title="Корутина-генератор" height="379" data-src="https://habrastorage.org/getpro/habr/upload_files/749/946/eea/749946eea0c07443b04425d455f90314.png" data-width="1143"/><figcaption>Корутина-генератор</figcaption></figure><p>Блоки, олицетворяющие время, когда управление ходом выполнения программы находятся у той или иной сущности, показывают передачу управления от одной программе другой.</p><p>Когда управление ходом выполнения программы передаётся от одной программе другой — текущее состояние программы должно быть сохранено, а затем, когда выполнение программы возобновляется, должно быть восстановлено. В случае с консьюмером это происходит в рамках обычного механизма вызова функции, когда текущий кадр стека сохраняет состояние программы. В случае с продюсером (это — корутина) нужна дополнительная поддержка со стороны компилятора и системы выполнения кода. А именно, при возвращении консьюмеру некоего значения нужно сохранять кадр стека продюсера.</p><p>В спецификации C++20 сказано, что состояние корутины сохраняется в куче, то есть — корутины не подходят для встраиваемых систем, которые не используют динамическую память. Но в спецификации абсолютно чётко заявлено, что в конкретной реализации языка использование кучи может быть убрано при соблюдении следующих условий:</p><ul><li><p>Если время жизни корутины строго ограничено временем жизни вызывающей стороны.</p></li><li><p>Если размер состояния корутины может быть определён во время компиляции кода.</p></li></ul><p>На практике, в случае с простыми корутинами-генераторами, которым посвящён этот материал, подобные корутины соответствуют этим критериям, состояние таких корутин может быть сохранено в кадре стека вызывающей стороны. Исследование использования кучи в двух примерах, рассмотренных в этой статье, показывает, что и GCC-11, и Clang-12 (последние версии компиляторов на момент написания материала) используют для сохранения состояния корутин кучу. Учитывая то, что поддержка корутин в компиляторах появилась сравнительно недавно, и то, что она сейчас находится в процессе развития, вполне возможно, что в более поздних их версиях соответствующий код будет оптимизирован, или, возможно, появится поддержка опций компиляторов для включения или отключения сохранения состояния корутин в динамической памяти.</p><p>Для организации поддержки сохранения и восстановления состояния корутин мы должны предоставить системе вспомогательный класс, который интегрируется с механизмами поддержки корутин в стандартной библиотеке, описанными в заголовочном файле, подключаемом к коду с помощью конструкции <code>#include &lt;coroutine></code>. Именно в этой сфере сейчас и находится всё то, что вызывает сложности в реализации корутин.</p><h4>Поддержка корутин в C++20</h4><p>Для того чтобы приступить к разговору о корутинах — мы можем создать одну из них, выдающую фразу «Hello world!» в виде трёх отдельных объектов. Её код показан ниже (тут нам нужно подключить заголовочный файл <code>&lt;coroutine></code>).</p><pre><code class="cpp">#include &lt;coroutine>

X coroutine()
{
    co_yield "Hello ";
    co_yield "world";
    co_return "!";
}
</code></pre><p>Первое, на что тут можно обратить внимание, заключается в том, что это — не определение функции! Мы только что использовали синтаксис функции для определения блока кода, которому могут быть переданы аргументы при создании его экземпляра. У функции имелась бы инструкция <code>return</code> (или как в случае с void-функциями, подразумевалось бы, что значение явным образом не возвращается). А тут код выдаёт три отдельных значения. Обратите внимание на то, что воспользоваться инструкцией <code>return</code> в корутине нельзя.</p><p>Второй интересный момент заключается в том, что мы возвращаем какой-то неизвестный (на данный момент) объект типа <code>X</code>. Это — объект, который реализует корутину. Компилятор реорганизует наш блок кода для реализации механизмов корутин, предусматривающих сохранение и восстановление состояния, но сейчас ему нужна небольшая помощь от нас, которая выражается в написании вспомогательного класса <code>X</code>.</p><p>В блоке кода, представляющего корутину, мы используем <code>co_yield</code> для выдачи значения и сохранения состояния корутины, а <code>co_return</code> — для выдачи значения и выхода из корутины без сохранения её состояния.</p><p>Это предельно простой пример использования корутины, где обратиться к ней нужно в точности три раза — как показано в следующем примере:</p><pre><code class="cpp">auto x = coroutine();
std::cout &lt;&lt; x.next();
std::cout &lt;&lt; x.next();
std::cout &lt;&lt; x.next();
std::cout &lt;&lt; std::endl;</code></pre><p>После того как мы потребили все значения, выданные корутиной, её работа завершается, она освобождает всю память, использованную для хранения её состояния.</p><p>В нашем примере у объекта корутины есть метод <code>next</code>, вызов которого приводит к выполнению следующих действий:</p><ol><li><p>Приостановка выполнения текущего кода консьюмера.</p></li><li><p>Восстановление состояния корутины (продюсера).</p></li><li><p>Возобновление выполнения кода корутины с предыдущей инструкции, выдающей значение (или с начала блока кода).</p></li><li><p>Сохранение значения, полученного из следующей инструкции, выдающей значение.</p></li><li><p>Сохранение состояния корутины.</p></li><li><p>Восстановление состояния консьюмера.</p></li><li><p>Возобновление выполнения кода консьюмера путём передачи ему значения, сохранённого после выполнения соответствующей инструкции, выдающей значение.</p></li></ol><p>Сейчас в стандартной библиотеке нет шаблона для нашего класса <code>X</code>. В результате нам нужно разобраться с тем, что сейчас имеется в стандартной библиотеке в плане поддержки корутин. Пример шаблонного класса показан ниже, там, где мы будем говорить о практическом применении корутин, а пока мы взглянем на базовый пример, код которого написан исключительно в учебных целях.</p><p>Для того чтобы написать собственный вспомогательный класс <code>X</code> для корутин, нам нужно обеспечить поддержку операций жизненного цикла корутины, предоставив реализации особых методов. Стандарт C++20 определяет требования к этим методам, используя концепции, ознакомиться с которыми можно <a href="https://blog.feabhas.com/2018/12/a-brief-introduction-to-concepts-part-1/">здесь</a> и <a href="https://blog.feabhas.com/2018/12/a-brief-introduction-to-concepts-part-2/">здесь</a>. Для того чтобы тут мы не отвлекались от темы корутин, мы применим традиционный для C++ поход к описанию методов, наличие которых ожидается системой, в виде частей нашего класса.</p><p>Для использования корутин в C++20 нам нужно подготовить два взаимосвязанных вспомогательных класса:</p><ul><li><p>Класс для сохранения состояния корутины и для сохранения выданных данных. Обычно его называют <code>promise</code>.</p></li><li><p>Класс для управления объектом корутины (<code>promise</code>). Это класс <code>X</code>, который, по традиции, называют <code>future</code>.</p></li></ul><p>В объекте типа <code>Promise</code> нужно реализовать несколько методов жизненного цикла корутины. Пока мы сосредоточимся на поддержке выражений, выдающих значения, и не будем обращать внимания на методы, необходимые для управления состоянием корутины.</p><p>Так как наша корутина использует инструкцию <code>co_yield</code> со значением <code>const char*</code>, нам нужен метод со следующей сигнатурой:</p><pre><code class="cpp">std::suspend_always yield_value(const char* value);</code></pre><p>Аргумент — это выдаваемый корутиной объект, возвращаемый тип сообщает системе выполнения кода о том, нужно ли сохранять состояние потока, что, в случае с однопоточной корутиной, мы всегда планируем делать, возвращая объект <code>std::suspend_always</code>. В данной ситуации есть возможность возврата объекта <code>std::suspend_never</code>, что допустимо при работе с асинхронными корутинами, но это ведёт к множеству сложностей, связанных с управлением приостановленными потоками и с возобновлением их работы. Мы не собираемся с этим связываться, работая над нашей простой синхронной корутиной.</p><p>Метод <code>yield_value</code> обязан сохранить свой аргумент, в результате он может быть возвращён вызывающей программе (консьюмеру). Вот как выглядит типичная реализация этого метода:</p><pre><code class="cpp">std::suspend_always yield_value(const char* value) {
    this->value = value;
    return {};
}</code></pre><p>Если вы ещё не сталкивались с современной синтаксической конструкцией C++ <code>return {}</code>, то знайте, что её смысл заключается всего лишь в том, чтобы создать объект возвращаемого типа этого метода, конструируемый по умолчанию. Ещё тут можно было использовать <code>return</code> <code>std::suspend_always{}</code>.</p><p>Для поддержки инструкции <code>co_return</code>, которая выдаёт значение, но не сохраняет состояние, нам нужен второй метод жизненного цикла корутины:</p><pre><code class="cpp">void return_value(const char* value) {
    this->value = std::move(value);
}</code></pre><p>Вызов <code>co_return</code> завершает выполнение корутины, соответствующая функция жизненного цикла корутины имеет возвращаемый тип <code>void</code>, так как состояние корутины будет уничтожено.</p><p>Если не вдаваться в детали реализации класса <code>X</code>, можно показать, как компилятор может расширить код сущности-консьюмера, превратив его в набор встроенных последовательных операций, а после этого взглянуть на методы жизненного цикла. В следующем примере метод <code>promise</code> даёт доступ к объекту <code>Promise</code>, который сохраняет состояние корутины и выдаваемое ей значение. Метод <code>next</code> может получить сохранённое значение из объекта <code>Promise</code>:</p><pre><code class="cpp">auto x = coroutine();
x.promise().yield_value("Hello "); // сохраняется значение и состояние
std::cout &lt;&lt; x.next();
x.promise().yield_value("world");  // сохраняется значение и состояние
std::cout &lt;&lt; x.next();
x.promise().return_value("!");    // сохраняется значение, но не состояние
std::cout &lt;&lt; x.next();
std::cout &lt;&lt; std::endl;</code></pre><p>Можно видеть, что компилятор преобразовал наш код, превратив два блока кода в один, представленный последовательным набором вызовов чередующихся методов.</p><p>Перед тем как мы разберём полноценный пример, в котором имеется весь необходимый шаблонный код для классов <code>Promise</code> и <code>Future</code>, нам нужно взглянуть на альтернативный способ написания кода корутин-генераторов:</p><pre><code class="cpp">X coroutine()
{
    co_yield "Hello ";
    co_yield "world";
    co_yield "!";
//  подразумеваемый вызов co_return;
}</code></pre><p>При применении такого подхода мы используем <code>co_yield</code> для всех значений, не выделяя особым образом (с помощью <code>co_return</code>) последнюю операцию выдачи значения; мы просто позволяем блоку кода завершить работу. Компилятор сам добавит в нужное место инструкцию <code>co_return</code> для завершения работы корутины.</p><p>Для обработки инструкции <code>co_return</code> (без значения) нам нужна реализация особого метода жизненного цикла корутины <code>void return_void</code>:</p><pre><code class="cpp">void return_void() {
    this->value = nullptr;
}</code></pre><p>Класс <code>Promise</code> не может предоставить и метод <code>return_value</code>, и метод <code>return_void</code>, которые считаются взаимоисключающими.</p><p>В этом простейшем примере код консьюмера не меняется, так как он выполняет чтение в точности трёх значений. В более реалистичном примере, где чтение значений из корутин выполняется в цикле, нам нужно каким-то образом отметить конец потока данных. Тут используются указатели, в результате для завершения цикла может быть использован <code>nullptr</code>; в противном случае наиболее общим подходом можно назвать объект <code>std::optional</code>.</p><p>Наш новый консьюмер с возможностью остановки работы выглядит так:</p><pre><code class="cpp">auto x = coroutine();
while (const char* item = x.next()) {
    std::cout &lt;&lt; item;
}
std::cout &lt;&lt; std::endl;</code></pre><p>Мы могли бы описать цикл так:</p><pre><code class="cpp">while (auto item = x.next()) {</code></pre><p>Но тут мы решили сохранить явное объявление типа, в результате из этого кода ясно то, как именно используется генератор.</p><p>Полная версия этого кода находится в файле <code>char_demo.cpp</code> в GitHub-репозитории <a href="https://github.com/feabhas/coroutines-blog">coroutines-blog</a>.</p><h3>Работа с корутинами</h3><p>Корутины — это удобный механизм для реализации множества алгоритмов в виде отдельных блоков кода, а не в такой форме, когда соответствующий код собирают в одном месте, где реализации разных алгоритмов оказываются смешанными друг с другом.</p><p>В качестве примера рассмотрим встроенное устройство, которое наблюдает за некими значениями, например, за показателями температуры, и выводит эти значения на последовательный порт (<a href="https://en.wikipedia.org/wiki/RS-232">RS232</a>), снабжая их отметкой времени. Это может быть время с момента загрузки устройства, или точное время, синхронизированное по сети.</p><p>Отметка времени и значение сохраняются в виде числа с плавающей запятой (каждое занимает 4 байта) и в двоичном виде сохраняются в виде потока байтов. Сделано это ради снижения сложности кода и размера обрабатываемых данных. Поток данных выглядит примерно так, как показано ниже (тут используется обратный (<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>) порядок байтов).</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Двоичный формат, используемый для хранения отметки времени и элемента данных
" title="Двоичный формат, используемый для хранения отметки времени и элемента данных
" height="253" data-src="https://habrastorage.org/getpro/habr/upload_files/070/510/599/070510599b4b897e30b915538151e38d.png" data-width="664"/><figcaption>Двоичный формат, используемый для хранения отметки времени и элемента данных
</figcaption></figure><p>В нашем приложении, которое занимается сбором данных, нужно считывать этот поток и помещать данные в структуру, содержащую два значения с плавающей запятой, после чего — выводить эти значения на соответствующем устройстве, вроде некоего дисплея. А если показатель температуры превышает заданное пороговое значение — сообщение нужно снабдить предупреждением.</p><p>Общий алгоритм работы системы будет выглядеть так:</p><ol><li><p>Чтение 4 байтов, необходимых для создания отметки времени.</p></li><li><p>Чтение 4 байтов, необходимых для создания элемента данных.</p></li><li><p>Создание структуры данных, содержащих оба значения, представленных числами с плавающей запятой.</p></li><li><p>Вывод значений из структуры данных.</p></li><li><p>Вывод предупреждения в том случае, если показатель температуры превысит заданное пороговое значение.</p></li></ol><p>Теперь подумаем о том, что произойдёт в том случае, если поток данных прервётся в ходе передачи значений, представленных числами с плавающей запятой. В нашем коде имеется средство для обработки ошибки, связанной с окончанием потока, применяемое для каждой отдельной операции чтения данных (речь идёт о восьми самостоятельных операциях по чтению одного байта). Даже при разумном использовании функций этот код будет представлять собой сложный набор условий и инструкций, направленных на реконструкцию данных. Такой код непросто, хотя и интересно, писать и поддерживать.</p><p>При использовании корутин подобный код можно разбить на два блока:</p><ol><li><p>Парсинг данных.</p></li><li><p>Вывод данных и, возможно, предупреждающего сообщения.</p></li></ol><p>Мы на практике пойдём ещё дальше и разобьём первый блок на две части:</p><ol><li><p>Разбор необработанного потока байтов и преобразование их в числа с плавающей запятой.</p></li><li><p>Сохранение отметки времени и показателя температуры в структуре.</p></li></ol><h3>Шаблон Future для корутины</h3><p>Первым шагом нашей работы будет создание шаблона для классов, о которых мы уже говорили, представляющих класс <code>Future</code> корутины и класс <code>Promise</code> для данных.</p><h4>Класс Promise, хранящий данные</h4><p>Вот — класс <code>Promise</code>, представляющий собой структуру, вложенную в класс <code>Future</code>:</p><pre><code class="cpp">template &lt;typename T>
class Future
{
    class Promise
    {
    public:
        using value_type = std::optional&lt;T>;
 
        Promise() = default;
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void unhandled_exception() { 
            std::rethrow_exception(std::move(std::current_exception())); 
        }
        std::suspend_always yield_value(T value) {
            this->value = std::move(value);
            return {};
        }
        void return_void() {
            this->value = std::nullopt;
        }
        inline Future get_return_object()
        value_type get_value() {
            return value;
        }
    private:
        value_type value{};
    };
    …
};</code></pre><p>Структура <code>Promise</code> (которую мы объявили приватной для включающего её в себя класса <code>Future</code>) сохраняет отдельное значение данных в приватном объекте <code>std::optional</code> с методом доступа <code>get_value</code>. Используя объект <code>std::optiona</code>l мы можем воспользоваться <code>std::nullop</code> для проверки на завершение работы корутины после вызова метода <code>return_void</code>. Мы придерживаемся стиля метапрограммирования шаблонов C++, определяя признак типа <code>value_type</code>, что позволяет нам опрашивать класс для определения типа данных, лежащего в его основе.</p><p>Мы создаём конструктор, используемый по умолчанию и два метода жизненного цикла, необходимых для Promise-объекта корутины (<code>initial_suspend</code> и <code>final_suspend</code>), которые всегда приостанавливают работу корутины, чтобы мы могли бы работать в однопоточном режиме. Эти методы жизненного цикла необходимы, но это — лишь их стандартные реализации, которые не нуждаются в дальнейшем рассмотрении.</p><p>Ещё нам надо указать то, как фреймворк должен обрабатывать неперехваченные исключения. Вместо того чтобы отвлекаться на их обработку и создавать механизмы восстановления работы после возникновения ошибки, мы просто передаём исключение вызывающей стороне, которая должна принять решение о том, что с ними делать дальше.</p><p>Методы <code>yield_value</code> и <code>return_void</code>, о которых мы уже говорили, определены для того, чтобы копировать или перемещать выданное корутиной значение в хранилище <code>std::optional</code>, или для того, чтобы использовать <code>std::nullopt</code> для указания на завершение работы корутины. Обратите внимание на использование <code>std::move</code>. Это сделано для того, чтобы обеспечить поддержку семантики перемещения данных для аргументов функции, передаваемых по значению: это необходимо, например, если надо выдать <code>std::unique_ptr</code>.</p><p>Ещё один метод, который нужно подготовить, это — <code>get_return_object</code>. Он должен возвращать объект <code>Future</code> для данного объекта <code>Promise</code>. Так как мы пока не завершили определение класса <code>Future</code>, нам нужно реализовать этот метод после того, как будут готовы классы <code>Future</code> и <code>Promise</code>.</p><h4>Класс Future — менеджер контекста корутины</h4><p>Сам класс <code>Future</code> предоставляет нам конструктор/деструктор для управления составным объектом <code>Promise</code>, а так же — механизм для получения значений, выданных корутиной (метод <code>next</code>, о котором мы уже говорили):</p><pre><code class="cpp">template &lt;typename T>
class Future
{
    struct Promise { … };
public:
    using value_type = T;
    using promise_type = Promise;
    explicit Future(std::coroutine_handle&lt;Promise> handle)
    : handle (handle)
    {}
    ~Future() {
        if (handle) { handle.destroy(); }
    }
    // Promise::value_type next() { … }
private:
    std::coroutine_handle&lt;Promise> handle;
};</code></pre><p>В стандартной библиотеке имеется поддержка управления объектами <code>Promise</code> через шаблонный класс <code>std::coroutine_handle</code>, передаваемый в виде аргумента конструктору класса <code>Future</code>. Нам нужно сохранить этот объект <code>coroutine_handle</code> и обеспечить вызов его метода <code>destroy</code> при уничтожении объекта <code>Future</code>.</p><p>Стандартная библиотека предъявляет ещё одно требование для класса <code>Future</code>, в соответствии с которым мы должны определить вложенный тип <code>promise_type</code>, что позволит шаблонам стандартной библиотеки выяснять тип данных, лежащий в основе класса.</p><pre><code>using promise_type = Promise;
</code></pre><p>В нашей реализации метода <code>next</code> необходимо обеспечить проверку того, что объект <code>Promise</code> всё ещё актуален, или вернуть пустой объект <code>std::optional</code>:</p><pre><code class="cpp">Promise::value_type next() {
    if (handle) {
        handle.resume();
        return handle.promise().get_value();
    }
    else {
        return {};
    }
}</code></pre><p>Вот что мы делаем для возврата значения, выданного корутиной:</p><ul><li><p>Мы просто проверяем, существует ли всё ещё корутина (её объект <code>handle</code> не был уничтожен).</p></li><li><p>Мы вызываем метод <code>resume</code> объекта <code>coroutine_handle</code> для выполнения кода до следующей инструкции <code>co_yield</code>.</p></li><li><p>Мы возвращаем значение, сохранённое методом <code>yield_value</code> объекта <code>Promise</code>: благодаря поддержке стандартной библиотеки будут обработаны операции восстановления и сохранения состояния корутины.</p></li><li><p>Если корутин была уничтожена — мы возвращаем пустое значение (<code>std::nullopt</code>).</p></li></ul><p>Теперь, когда определён класс <code>Future</code>, мы можем дополнить объект <code>Promise</code> необходимым методом <code>get_return_object</code>:</p><pre><code class="cpp">template &lt;typename T>
inline Future&lt;T> Future&lt;T>::Promise::get_return_object()
{
    return Future{ std::coroutine_handle&lt;Promise>::from_promise(*this) };
}</code></pre><p>Тут мы используем метод <a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle/from_promise">std::from_promise</a> для создания объекта <code>coroutine_handle</code>, который передаётся конструктору <code>Future</code>.</p><p>Как видите, перед нами — всего лишь стандартный код, <a href="https://en.wikipedia.org/wiki/Boilerplate_text">заготовка</a> для создания классов <code>Future</code> и <code>Promise</code>.</p><p>Теперь, когда завершены подготовительные операции, этот шаблон может быть использован в применении к большинству типов данных и классов. Я сказал бы, что он применим ко всем классам, но всегда найдутся особые случаи, в которых воспользоваться им не получится.</p><h3>Корутина, занимающаяся сбором данных</h3><p>Теперь можно сосредоточиться на нашей реальной задаче, которая заключается в организации сбора данных. Первый шаг работы заключается в написании корутины, занимающейся чтением данных из объекта <code>istream</code> и выдачей значений, представляющих собой числа с плавающей запятой:</p><pre><code class="cpp">Future&lt;float> read_stream(std::istream&amp; in)
{
    int count{};
    uint8_t byte;
    while (in >> byte) {
        data = data &lt;&lt; 8 | byte;
        if (++count == 4) {
            co_yield reinterpret_cast&lt;float>(&amp;data);
            data = 0;
            count = 0;
        }
    }
}</code></pre><p>Тут мы просто читаем блоки данных размером 4 байта и помещаем их в 32-битные слова, после чего используем приведение типов, интерпретируя соответствующую область памяти в виде числа с плавающей запятой для инструкции <code>co_yield</code>. Если поток данных завершается в ходе чтения 4-байтового слова, мы игнорируем частично прочитанное значение и завершаем работу корутины.</p><p>Мы можем подтвердить работоспособность этой корутины, просто выводя каждое float-значение, которое прочитано из стандартного потока ввода:</p><pre><code class="cpp">auto raw_data = read_stream(std::cin);
while (auto next = raw_data.next()) {
    std::cout &lt;&lt; *next &lt;&lt; std::endl;
}</code></pre><p>А, так как надо сохранить пары значений в структуре данных, можно воспользоваться второй корутиной, которая инкапсулирует соответствующий алгоритм:</p><pre><code class="cpp">struct DataPoint
{
    float timestamp;
    float data;
};
Future&lt;DataPoint> read_data(std::istream&amp; in)
{
    std::optional&lt;float> first{};
    auto raw_data = read_stream(in);
    while (auto next = raw_data.next()) {
        if (first) {
            co_yield DataPoint{*first, *next};
            first = std::nullopt;
        }
        else {
            first = next;
        }
    }
}</code></pre><p>И, опять же, если входной поток неожиданно завершается при чтении данных, относящихся к отметке времени или к элементу данных — мы отбрасываем неполные данные.</p><p>Последний шаг этого примера заключается в обработке значений, представляющих отметку времени и данные:</p><pre><code class="cpp">static constexpr float threshold{25.0};
int main()
{
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);
    std::cout &lt;&lt; "Time (ms)   Data" &lt;&lt; std::endl;
    auto values = read_data(std::cin);
    while (auto n = values.next()) {
        std::cout &lt;&lt; std::setw(8) &lt;&lt; n->timestamp
                  &lt;&lt; std::setw(8) &lt;&lt; n->data
                  &lt;&lt; (n->data > threshold ? " Threshold exceeded" : "")
                  &lt;&lt; std::endl;
    }
    return 0;
}</code></pre><p>Этот код выражает то, как мы решили обрабатывать данные, а все тонкости преобразования байтов в значения с плавающей запятой и их записи в структуру данных, скрыты в соответствующей корутине.</p><p>Хочется надеяться, что теперь вы способны прочувствовать плюсы использования корутин для разделения различных аспектов реализации сложных алгоритмов на более простые блоки кода. Сейчас, пользуясь C++20, нужно выполнять массу действий, которые кажутся сложными или ненужными для достижения нашей цели и заключаются в создании классов <code>Future</code> и <code>Promise</code>. Но я тем не менее надеюсь, что в C++23 уже будет встроено нечто подобное этому шаблону, что позволит программистам уделять внимание написанию собственного кода, не отвлекаясь на создание вспомогательных механизмов.</p><p>Протестировать этот код можно, воспользовавшись простым Python-скриптом, например, таким, который показан ниже. Он, в частности, выдаёт четыре жёстко заданных в коде элемента данных:</p><pre><code class="cpp">import struct
import sys
start = 0.0
for ms, value in enumerate([20.1, 20.9, 20.8, 21.1]):
    sys.stdout.buffer.write(struct.pack('>ff', start + ms*0.1, value))</code></pre><p>Если скомпилированный исполняемый файл называется <code>datapoint_demo</code>, то мы можем воспользоваться следующим конвейером в командной строке Linux и убедиться в работоспособности корутин:</p><pre><code class="bash"># Linux
python3 test_temp.py | ./datapoint_demo</code></pre><p>В результате будет выведено следующее:</p><pre><code class="bash">Time (ms)   Data
    0.00   20.10
    0.10   20.90
    0.20   20.80
    0.30   21.10 Threshold exceeded</code></pre><p>Полный вариант кода этого примера, представленный файлами <code>future.h</code> и <code>datapoint_demo.cpp</code>, можно найти <a href="https://github.com/feabhas/coroutines-blog">здесь</a>. Для того чтобы скомпилировать эти примеры с использованием GCC (версии 10 или выше), нужно воспользоваться <code>-std=c++20</code> и <code>-fcoroutines</code> в командной строке <code>g++</code>.</p><p>В следующем материале я планирую добавить в шаблонный класс <code>Future</code> поддержку итераторов, что позволит использовать корутину в цикле <code>for</code> или в виде входного итератора для неких библиотечных механизмов.</p><h3>Итоги</h3><p>Корутины — это мощная техника программирования, позволяющая разделять различные аспекты реализаций сложных алгоритмов, описывая их в виде самостоятельных и достаточно простых блоков кода.</p><p>C++20, как Python и C#, использует функциональный синтаксис для определения кода корутин. Многие программисты поначалу находят это странным, так как это — всего лишь синтаксическая конструкция для описания инструкций, входящих в состав корутины.</p><p>Как мы видели, то, что сейчас нет простого стандартного шаблона для создания корутин-генераторов, усложняет жизнь тем, кто только собирается попробовать корутины. Сейчас применение корутин несколько напоминает сборку пазла, картинки-загадки, в условиях, когда тот, кто пазл собирает, не видел картинки, которая у него должна получиться. Поначалу такая задача выглядит пугающе сложной, но решить её вполне реально. Надеюсь, что шаблон <code>Future</code>, который мы тут рассмотрели, это и есть та картинка, глядя на которую вы сможете собирать собственные пазлы.</p><details class="spoiler"><summary>О, а приходите к нам работать? 😏</summary><div class="spoiler__content"><p>Мы в <a href="http://wunderfund.io/"><strong>wunderfund.io</strong></a> занимаемся <a href="https://en.wikipedia.org/wiki/High-frequency_trading">высокочастотной алготорговлей</a> с 2014 года. Высокочастотная торговля — это непрерывное соревнование лучших программистов и математиков всего мира. Присоединившись к нам, вы станете частью этой увлекательной схватки.</p><p>Мы предлагаем интересные и сложные задачи по анализу данных и low latency разработке для увлеченных исследователей и программистов. Гибкий график и никакой бюрократии, решения быстро принимаются и воплощаются в жизнь.</p><p>Сейчас мы ищем плюсовиков, питонистов, дата-инженеров и мл-рисерчеров.<br/><a href="http://wunderfund.io/#join_us">Присоединяйтесь к нашей команде.</a></p></div></details></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%A1%2B%2B%5D" class="tm-tags-list__link">С++</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%5D" class="tm-tags-list__link">разработка</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">асинхронное программирование</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C%5D" class="tm-tags-list__link">асинхронность</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B%5D" class="tm-tags-list__link">корутины</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bc%2B%2B20%5D" class="tm-tags-list__link">c++20</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bwunderfund%5D" class="tm-tags-list__link">wunderfund</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bwunder%20fund%5D" class="tm-tags-list__link">wunder fund</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/wunderfund/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании Wunder Fund
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/cpp/" class="tm-hubs-list__link">
    C++
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 4: ↑4 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 4: ↑4 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+4</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">595</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    7
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/wunderfund/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/b1a/8c4/544/b1a8c4544d951f4ea9bad437589d958e.png" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/wunderfund/profile/" class="tm-company-snippet__title">Wunder Fund</a> <div class="tm-company-snippet__description">Мы занимаемся высокочастотной торговлей на бирже</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <div class="tm-article-author__company-contacts"><a href="http://wunderfund.io" rel="noopener" target="_blank" class="tm-article-author__contact">
      Сайт
    </a></div> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/mr-pickles/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/a90/a35/fb7/a90a35fb73f6e7f05770af0978f90b11.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 19 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    17
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">38.8</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/mr-pickles/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @mr-pickles
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/wunderfund/blog/582000/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментировать 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2013-12-31T20:00:00.000Z" title="2014-01-01, 00:00">1  января  2014</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://wunderfund.io" target="_blank" class="tm-company-basic-info__link">
      wunderfund.io
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    11–30 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2015-11-22T01:25:19.000Z" title="2015-11-22, 04:25">22  ноября  2015</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Представитель</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="/ru/users/xopxe/" class="tm-company-basic-info__link">
      xopxe
    </a></dd></dl></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/wunderfund/blog/582000/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/wunderfund/blog/582000/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"582000":{"id":"582000","timePublished":"2021-10-25T14:06:30+00:00","isCorporative":true,"lang":"ru","titleHtml":"Корутины в C++20 — что это и как с ними работать","leadData":{"textHtml":"\u003Cp\u003E\u003Cem\u003EПрим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному мнению, можно было бы реализовать и поизящнее. Приходите к нам работать, если имеете сильные мнения о корутинах хе-хе.\u003Cbr\u003E\u003C\u002Fem\u003E\u003Cbr\u003EВозникает такое ощущение, что тема реализации корутин в C++20 окутана серьёзной неопределённостью. Полагаю, это так из-за того, что в проекте технической спецификации C++20 сказано, что работа над механизмами корутин всё ещё ведётся, в результате в данный момент нельзя ожидать полной поддержки этих механизмов компиляторами и стандартной библиотекой.Множество проблем, вероятно, возникает из-за отсутствия официальной документации по работе с корутинами. Нам дали синтаксическую поддержку корутин в C++ (\u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E&nbsp;и&nbsp;\u003Ccode\u003Eco_return\u003C\u002Fcode\u003E), но не всё то, что я счёл бы признаками их полной библиотечной поддержки. В стандартной библиотеке имеются хуки и базовый функционал поддержки корутин, но нам приходится самостоятельно встраивать всё это в наши собственные классы. Я ожидаю, что полная поддержка корутин-генераторов появится в C++23.\u003C\u002Fp\u003E\u003Cp\u003EЕсли вы — Python- или C#-разработчик и ожидаете увидеть в C++ простую механику работы с корутинами, то вас ждёт разочарование, так как фреймворк общего назначения C++20 недоработан. Учитывая это, можно отметить, что в интернете имеется множество публикаций, в состав кода, обсуждаемого в которых, входит шаблонный класс, поддерживающий корутины-генераторы. В этом материале вы найдёте шаблон корутины, применимый на практике, а также примеры кода. Всё это предваряется общими сведениями о корутинах.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2d4\u002F6ee\u002Fe85\u002F2d46eee8594e8fca63e142a5973441fc.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2d4\u002F6ee\u002Fe85\u002F2d46eee8594e8fca63e142a5973441fc.png","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Martin Bond","originalUrl":"https:\u002F\u002Fblog.feabhas.com\u002F2021\u002F09\u002Fc20-coroutines\u002F"}}],"author":{"scoreStats":{"score":17,"votesCount":19},"rating":38.8,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1521341","alias":"mr-pickles","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fa90\u002Fa35\u002Ffb7\u002Fa90a35fb73f6e7f05770af0978f90b11.png","speciality":null},"statistics":{"commentsCount":0,"favoritesCount":7,"readingCount":595,"score":4,"votesCount":4},"hubs":[{"relatedData":null,"id":"19715","alias":"wunderfund","type":"corporative","title":"Блог компании Wunder Fund","titleHtml":"Блог компании Wunder Fund","isProfiled":false},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"559","alias":"cpp","type":"collective","title":"C++","titleHtml":"C++","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"440\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fdfe\u002F3c5\u002F106\u002Fdfe3c51063238c007eb2dbd960f079b3.png\" data-width=\"780\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cem\u003EПрим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному мнению, можно было бы реализовать и поизящнее. Приходите к нам работать, если имеете сильные мнения о корутинах хе-хе.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EВозникает такое ощущение, что тема реализации корутин в C++20 окутана серьёзной неопределённостью. Полагаю, это так из-за того, что в проекте технической спецификации C++20 сказано, что работа над механизмами корутин всё ещё ведётся, в результате в данный момент нельзя ожидать полной поддержки этих механизмов компиляторами и стандартной библиотекой. Множество проблем, вероятно, возникает из-за отсутствия официальной документации по работе с корутинами. Нам дали синтаксическую поддержку корутин в C++ (\u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E и \u003Ccode\u003Eco_return\u003C\u002Fcode\u003E), но не всё то, что я счёл бы признаками их полной библиотечной поддержки. В стандартной библиотеке имеются хуки и базовый функционал поддержки корутин, но нам приходится самостоятельно встраивать всё это в наши собственные классы. Я ожидаю, что полная поддержка корутин-генераторов появится в C++23.\u003C\u002Fp\u003E\u003Cp\u003EСпецификация C++20, очевидно, направлена на поддержку параллельных (или асинхронных) корутин с использованием \u003Ccode\u003Eco_await\u003C\u002Fcode\u003E, что усложняет реализацию более простых синхронных корутин-генераторов. Среди требований к реализации наших корутин имеются сведения об использовании \u003Ccode\u003EFuture\u003C\u002Fcode\u003E и \u003Ccode\u003EPromise\u003C\u002Fcode\u003E, что похоже на то, как при реализации асинхронных потоков используется \u003Ca href=\"https:\u002F\u002Fen.cppreference.com\u002Fw\u002Fcpp\u002Fthread\u002Fasync\"\u003Estd::async\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЕсли вы — Python- или C#-разработчик и ожидаете увидеть в C++ простую механику работы с корутинами, то вас ждёт разочарование, так как фреймворк общего назначения C++20 недоработан. Учитывая это, можно отметить, что в интернете имеется множество публикаций, в состав кода, обсуждаемого в которых, входит шаблонный класс, поддерживающий корутины-генераторы. В этом материале вы найдёте шаблон корутины, применимый на практике, а также примеры кода. Всё это предваряется общими сведениями о корутинах.\u003C\u002Fp\u003E\u003Ch3\u003EЧто такое корутины?\u003C\u002Fh3\u003E\u003Cp\u003EЯ впервые столкнулся с корутинами, увидев инструкцию \u003Ccode\u003Eyield\u003C\u002Fcode\u003E в \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCLU_(programming_language)\"\u003ECLU\u003C\u002Fa\u003E. Корутины, наподобие генераторов в Python (и конструкции \u003Ccode\u003Eyield return\u003C\u002Fcode\u003E в C#), определяются с использованием функционального синтаксиса, а доступ к ним организуется с применением синтаксических конструкций цикла \u003Ccode\u003Efor\u003C\u002Fcode\u003E. Корутины описывались как взаимодействующие программы (но не как конкурентные программы), выполняющиеся в одном потоке. Существуют и другие разновидности корутин. Для того чтобы разобраться в том, чем отличаются друг от друга функции, генераторы и потоки, можно начать с \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCoroutine\"\u003Eэтой\u003C\u002Fa\u003E статьи из Википедии.\u003C\u002Fp\u003E\u003Cp\u003EВ этом материале я уделяю основное внимание корутинам, выполняемым в контексте вызывающей стороны, применение которых позволяет двум различным блокам кода периодически передавать друг другу управление ходом выполнения программы.\u003C\u002Fp\u003E\u003Cp\u003EНовая инструкция \u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E в C++20 позволяет одной программе предоставить фрагмент данных, и в то же время вернуть управление ходом выполнения программы вызывающей программе для обработки этих данных. В общем-то, это — всего лишь витиеватый способ сказать о том, что корутины в C++20 дают нам однопоточную реализацию паттерна продюсер\u002Fконсьюмер (\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FProducer%E2%80%93consumer_problem\"\u003Eproducer\u002Fconsumer\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Cp\u003EМы можем показать классический пример взаимодействия продюсера и консьюмера, связанный с применением корутин, подготовив следующую \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FSequence_diagram\"\u003EUML-диаграмму последовательности\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Корутина-генератор\" title=\"Корутина-генератор\" height=\"379\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F749\u002F946\u002Feea\u002F749946eea0c07443b04425d455f90314.png\" data-width=\"1143\"\u002F\u003E\u003Cfigcaption\u003EКорутина-генератор\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EБлоки, олицетворяющие время, когда управление ходом выполнения программы находятся у той или иной сущности, показывают передачу управления от одной программе другой.\u003C\u002Fp\u003E\u003Cp\u003EКогда управление ходом выполнения программы передаётся от одной программе другой — текущее состояние программы должно быть сохранено, а затем, когда выполнение программы возобновляется, должно быть восстановлено. В случае с консьюмером это происходит в рамках обычного механизма вызова функции, когда текущий кадр стека сохраняет состояние программы. В случае с продюсером (это — корутина) нужна дополнительная поддержка со стороны компилятора и системы выполнения кода. А именно, при возвращении консьюмеру некоего значения нужно сохранять кадр стека продюсера.\u003C\u002Fp\u003E\u003Cp\u003EВ спецификации C++20 сказано, что состояние корутины сохраняется в куче, то есть — корутины не подходят для встраиваемых систем, которые не используют динамическую память. Но в спецификации абсолютно чётко заявлено, что в конкретной реализации языка использование кучи может быть убрано при соблюдении следующих условий:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EЕсли время жизни корутины строго ограничено временем жизни вызывающей стороны.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли размер состояния корутины может быть определён во время компиляции кода.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EНа практике, в случае с простыми корутинами-генераторами, которым посвящён этот материал, подобные корутины соответствуют этим критериям, состояние таких корутин может быть сохранено в кадре стека вызывающей стороны. Исследование использования кучи в двух примерах, рассмотренных в этой статье, показывает, что и GCC-11, и Clang-12 (последние версии компиляторов на момент написания материала) используют для сохранения состояния корутин кучу. Учитывая то, что поддержка корутин в компиляторах появилась сравнительно недавно, и то, что она сейчас находится в процессе развития, вполне возможно, что в более поздних их версиях соответствующий код будет оптимизирован, или, возможно, появится поддержка опций компиляторов для включения или отключения сохранения состояния корутин в динамической памяти.\u003C\u002Fp\u003E\u003Cp\u003EДля организации поддержки сохранения и восстановления состояния корутин мы должны предоставить системе вспомогательный класс, который интегрируется с механизмами поддержки корутин в стандартной библиотеке, описанными в заголовочном файле, подключаемом к коду с помощью конструкции \u003Ccode\u003E#include &lt;coroutine\u003E\u003C\u002Fcode\u003E. Именно в этой сфере сейчас и находится всё то, что вызывает сложности в реализации корутин.\u003C\u002Fp\u003E\u003Ch4\u003EПоддержка корутин в C++20\u003C\u002Fh4\u003E\u003Cp\u003EДля того чтобы приступить к разговору о корутинах — мы можем создать одну из них, выдающую фразу «Hello world!» в виде трёх отдельных объектов. Её код показан ниже (тут нам нужно подключить заголовочный файл \u003Ccode\u003E&lt;coroutine\u003E\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E#include &lt;coroutine\u003E\n\nX coroutine()\n{\n    co_yield \"Hello \";\n    co_yield \"world\";\n    co_return \"!\";\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПервое, на что тут можно обратить внимание, заключается в том, что это — не определение функции! Мы только что использовали синтаксис функции для определения блока кода, которому могут быть переданы аргументы при создании его экземпляра. У функции имелась бы инструкция \u003Ccode\u003Ereturn\u003C\u002Fcode\u003E (или как в случае с void-функциями, подразумевалось бы, что значение явным образом не возвращается). А тут код выдаёт три отдельных значения. Обратите внимание на то, что воспользоваться инструкцией \u003Ccode\u003Ereturn\u003C\u002Fcode\u003E в корутине нельзя.\u003C\u002Fp\u003E\u003Cp\u003EВторой интересный момент заключается в том, что мы возвращаем какой-то неизвестный (на данный момент) объект типа \u003Ccode\u003EX\u003C\u002Fcode\u003E. Это — объект, который реализует корутину. Компилятор реорганизует наш блок кода для реализации механизмов корутин, предусматривающих сохранение и восстановление состояния, но сейчас ему нужна небольшая помощь от нас, которая выражается в написании вспомогательного класса \u003Ccode\u003EX\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВ блоке кода, представляющего корутину, мы используем \u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E для выдачи значения и сохранения состояния корутины, а \u003Ccode\u003Eco_return\u003C\u002Fcode\u003E — для выдачи значения и выхода из корутины без сохранения её состояния.\u003C\u002Fp\u003E\u003Cp\u003EЭто предельно простой пример использования корутины, где обратиться к ней нужно в точности три раза — как показано в следующем примере:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eauto x = coroutine();\nstd::cout &lt;&lt; x.next();\nstd::cout &lt;&lt; x.next();\nstd::cout &lt;&lt; x.next();\nstd::cout &lt;&lt; std::endl;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПосле того как мы потребили все значения, выданные корутиной, её работа завершается, она освобождает всю память, использованную для хранения её состояния.\u003C\u002Fp\u003E\u003Cp\u003EВ нашем примере у объекта корутины есть метод \u003Ccode\u003Enext\u003C\u002Fcode\u003E, вызов которого приводит к выполнению следующих действий:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EПриостановка выполнения текущего кода консьюмера.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВосстановление состояния корутины (продюсера).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВозобновление выполнения кода корутины с предыдущей инструкции, выдающей значение (или с начала блока кода).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСохранение значения, полученного из следующей инструкции, выдающей значение.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСохранение состояния корутины.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВосстановление состояния консьюмера.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВозобновление выполнения кода консьюмера путём передачи ему значения, сохранённого после выполнения соответствующей инструкции, выдающей значение.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EСейчас в стандартной библиотеке нет шаблона для нашего класса \u003Ccode\u003EX\u003C\u002Fcode\u003E. В результате нам нужно разобраться с тем, что сейчас имеется в стандартной библиотеке в плане поддержки корутин. Пример шаблонного класса показан ниже, там, где мы будем говорить о практическом применении корутин, а пока мы взглянем на базовый пример, код которого написан исключительно в учебных целях.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы написать собственный вспомогательный класс \u003Ccode\u003EX\u003C\u002Fcode\u003E для корутин, нам нужно обеспечить поддержку операций жизненного цикла корутины, предоставив реализации особых методов. Стандарт C++20 определяет требования к этим методам, используя концепции, ознакомиться с которыми можно \u003Ca href=\"https:\u002F\u002Fblog.feabhas.com\u002F2018\u002F12\u002Fa-brief-introduction-to-concepts-part-1\u002F\"\u003Eздесь\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fblog.feabhas.com\u002F2018\u002F12\u002Fa-brief-introduction-to-concepts-part-2\u002F\"\u003Eздесь\u003C\u002Fa\u003E. Для того чтобы тут мы не отвлекались от темы корутин, мы применим традиционный для C++ поход к описанию методов, наличие которых ожидается системой, в виде частей нашего класса.\u003C\u002Fp\u003E\u003Cp\u003EДля использования корутин в C++20 нам нужно подготовить два взаимосвязанных вспомогательных класса:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EКласс для сохранения состояния корутины и для сохранения выданных данных. Обычно его называют \u003Ccode\u003Epromise\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКласс для управления объектом корутины (\u003Ccode\u003Epromise\u003C\u002Fcode\u003E). Это класс \u003Ccode\u003EX\u003C\u002Fcode\u003E, который, по традиции, называют \u003Ccode\u003Efuture\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВ объекте типа \u003Ccode\u003EPromise\u003C\u002Fcode\u003E нужно реализовать несколько методов жизненного цикла корутины. Пока мы сосредоточимся на поддержке выражений, выдающих значения, и не будем обращать внимания на методы, необходимые для управления состоянием корутины.\u003C\u002Fp\u003E\u003Cp\u003EТак как наша корутина использует инструкцию \u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E со значением \u003Ccode\u003Econst char*\u003C\u002Fcode\u003E, нам нужен метод со следующей сигнатурой:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estd::suspend_always yield_value(const char* value);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EАргумент — это выдаваемый корутиной объект, возвращаемый тип сообщает системе выполнения кода о том, нужно ли сохранять состояние потока, что, в случае с однопоточной корутиной, мы всегда планируем делать, возвращая объект \u003Ccode\u003Estd::suspend_always\u003C\u002Fcode\u003E. В данной ситуации есть возможность возврата объекта \u003Ccode\u003Estd::suspend_never\u003C\u002Fcode\u003E, что допустимо при работе с асинхронными корутинами, но это ведёт к множеству сложностей, связанных с управлением приостановленными потоками и с возобновлением их работы. Мы не собираемся с этим связываться, работая над нашей простой синхронной корутиной.\u003C\u002Fp\u003E\u003Cp\u003EМетод \u003Ccode\u003Eyield_value\u003C\u002Fcode\u003E обязан сохранить свой аргумент, в результате он может быть возвращён вызывающей программе (консьюмеру). Вот как выглядит типичная реализация этого метода:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estd::suspend_always yield_value(const char* value) {\n    this-\u003Evalue = value;\n    return {};\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕсли вы ещё не сталкивались с современной синтаксической конструкцией C++ \u003Ccode\u003Ereturn {}\u003C\u002Fcode\u003E, то знайте, что её смысл заключается всего лишь в том, чтобы создать объект возвращаемого типа этого метода, конструируемый по умолчанию. Ещё тут можно было использовать \u003Ccode\u003Ereturn\u003C\u002Fcode\u003E \u003Ccode\u003Estd::suspend_always{}\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EДля поддержки инструкции \u003Ccode\u003Eco_return\u003C\u002Fcode\u003E, которая выдаёт значение, но не сохраняет состояние, нам нужен второй метод жизненного цикла корутины:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid return_value(const char* value) {\n    this-\u003Evalue = std::move(value);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВызов \u003Ccode\u003Eco_return\u003C\u002Fcode\u003E завершает выполнение корутины, соответствующая функция жизненного цикла корутины имеет возвращаемый тип \u003Ccode\u003Evoid\u003C\u002Fcode\u003E, так как состояние корутины будет уничтожено.\u003C\u002Fp\u003E\u003Cp\u003EЕсли не вдаваться в детали реализации класса \u003Ccode\u003EX\u003C\u002Fcode\u003E, можно показать, как компилятор может расширить код сущности-консьюмера, превратив его в набор встроенных последовательных операций, а после этого взглянуть на методы жизненного цикла. В следующем примере метод \u003Ccode\u003Epromise\u003C\u002Fcode\u003E даёт доступ к объекту \u003Ccode\u003EPromise\u003C\u002Fcode\u003E, который сохраняет состояние корутины и выдаваемое ей значение. Метод \u003Ccode\u003Enext\u003C\u002Fcode\u003E может получить сохранённое значение из объекта \u003Ccode\u003EPromise\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eauto x = coroutine();\nx.promise().yield_value(\"Hello \"); \u002F\u002F сохраняется значение и состояние\nstd::cout &lt;&lt; x.next();\nx.promise().yield_value(\"world\");  \u002F\u002F сохраняется значение и состояние\nstd::cout &lt;&lt; x.next();\nx.promise().return_value(\"!\");    \u002F\u002F сохраняется значение, но не состояние\nstd::cout &lt;&lt; x.next();\nstd::cout &lt;&lt; std::endl;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМожно видеть, что компилятор преобразовал наш код, превратив два блока кода в один, представленный последовательным набором вызовов чередующихся методов.\u003C\u002Fp\u003E\u003Cp\u003EПеред тем как мы разберём полноценный пример, в котором имеется весь необходимый шаблонный код для классов \u003Ccode\u003EPromise\u003C\u002Fcode\u003E и \u003Ccode\u003EFuture\u003C\u002Fcode\u003E, нам нужно взглянуть на альтернативный способ написания кода корутин-генераторов:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EX coroutine()\n{\n    co_yield \"Hello \";\n    co_yield \"world\";\n    co_yield \"!\";\n\u002F\u002F  подразумеваемый вызов co_return;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПри применении такого подхода мы используем \u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E для всех значений, не выделяя особым образом (с помощью \u003Ccode\u003Eco_return\u003C\u002Fcode\u003E) последнюю операцию выдачи значения; мы просто позволяем блоку кода завершить работу. Компилятор сам добавит в нужное место инструкцию \u003Ccode\u003Eco_return\u003C\u002Fcode\u003E для завершения работы корутины.\u003C\u002Fp\u003E\u003Cp\u003EДля обработки инструкции \u003Ccode\u003Eco_return\u003C\u002Fcode\u003E (без значения) нам нужна реализация особого метода жизненного цикла корутины \u003Ccode\u003Evoid return_void\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid return_void() {\n    this-\u003Evalue = nullptr;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКласс \u003Ccode\u003EPromise\u003C\u002Fcode\u003E не может предоставить и метод \u003Ccode\u003Ereturn_value\u003C\u002Fcode\u003E, и метод \u003Ccode\u003Ereturn_void\u003C\u002Fcode\u003E, которые считаются взаимоисключающими.\u003C\u002Fp\u003E\u003Cp\u003EВ этом простейшем примере код консьюмера не меняется, так как он выполняет чтение в точности трёх значений. В более реалистичном примере, где чтение значений из корутин выполняется в цикле, нам нужно каким-то образом отметить конец потока данных. Тут используются указатели, в результате для завершения цикла может быть использован \u003Ccode\u003Enullptr\u003C\u002Fcode\u003E; в противном случае наиболее общим подходом можно назвать объект \u003Ccode\u003Estd::optional\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EНаш новый консьюмер с возможностью остановки работы выглядит так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eauto x = coroutine();\nwhile (const char* item = x.next()) {\n    std::cout &lt;&lt; item;\n}\nstd::cout &lt;&lt; std::endl;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EМы могли бы описать цикл так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Ewhile (auto item = x.next()) {\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНо тут мы решили сохранить явное объявление типа, в результате из этого кода ясно то, как именно используется генератор.\u003C\u002Fp\u003E\u003Cp\u003EПолная версия этого кода находится в файле \u003Ccode\u003Echar_demo.cpp\u003C\u002Fcode\u003E в GitHub-репозитории \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffeabhas\u002Fcoroutines-blog\"\u003Ecoroutines-blog\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Ch3\u003EРабота с корутинами\u003C\u002Fh3\u003E\u003Cp\u003EКорутины — это удобный механизм для реализации множества алгоритмов в виде отдельных блоков кода, а не в такой форме, когда соответствующий код собирают в одном месте, где реализации разных алгоритмов оказываются смешанными друг с другом.\u003C\u002Fp\u003E\u003Cp\u003EВ качестве примера рассмотрим встроенное устройство, которое наблюдает за некими значениями, например, за показателями температуры, и выводит эти значения на последовательный порт (\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRS-232\"\u003ERS232\u003C\u002Fa\u003E), снабжая их отметкой времени. Это может быть время с момента загрузки устройства, или точное время, синхронизированное по сети.\u003C\u002Fp\u003E\u003Cp\u003EОтметка времени и значение сохраняются в виде числа с плавающей запятой (каждое занимает 4 байта) и в двоичном виде сохраняются в виде потока байтов. Сделано это ради снижения сложности кода и размера обрабатываемых данных. Поток данных выглядит примерно так, как показано ниже (тут используется обратный (\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FEndianness\"\u003Elittle endian\u003C\u002Fa\u003E) порядок байтов).\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Двоичный формат, используемый для хранения отметки времени и элемента данных\n\" title=\"Двоичный формат, используемый для хранения отметки времени и элемента данных\n\" height=\"253\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F070\u002F510\u002F599\u002F070510599b4b897e30b915538151e38d.png\" data-width=\"664\"\u002F\u003E\u003Cfigcaption\u003EДвоичный формат, используемый для хранения отметки времени и элемента данных\n\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВ нашем приложении, которое занимается сбором данных, нужно считывать этот поток и помещать данные в структуру, содержащую два значения с плавающей запятой, после чего — выводить эти значения на соответствующем устройстве, вроде некоего дисплея. А если показатель температуры превышает заданное пороговое значение — сообщение нужно снабдить предупреждением.\u003C\u002Fp\u003E\u003Cp\u003EОбщий алгоритм работы системы будет выглядеть так:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EЧтение 4 байтов, необходимых для создания отметки времени.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЧтение 4 байтов, необходимых для создания элемента данных.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСоздание структуры данных, содержащих оба значения, представленных числами с плавающей запятой.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВывод значений из структуры данных.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВывод предупреждения в том случае, если показатель температуры превысит заданное пороговое значение.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EТеперь подумаем о том, что произойдёт в том случае, если поток данных прервётся в ходе передачи значений, представленных числами с плавающей запятой. В нашем коде имеется средство для обработки ошибки, связанной с окончанием потока, применяемое для каждой отдельной операции чтения данных (речь идёт о восьми самостоятельных операциях по чтению одного байта). Даже при разумном использовании функций этот код будет представлять собой сложный набор условий и инструкций, направленных на реконструкцию данных. Такой код непросто, хотя и интересно, писать и поддерживать.\u003C\u002Fp\u003E\u003Cp\u003EПри использовании корутин подобный код можно разбить на два блока:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EПарсинг данных.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВывод данных и, возможно, предупреждающего сообщения.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EМы на практике пойдём ещё дальше и разобьём первый блок на две части:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EРазбор необработанного потока байтов и преобразование их в числа с плавающей запятой.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСохранение отметки времени и показателя температуры в структуре.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Ch3\u003EШаблон Future для корутины\u003C\u002Fh3\u003E\u003Cp\u003EПервым шагом нашей работы будет создание шаблона для классов, о которых мы уже говорили, представляющих класс \u003Ccode\u003EFuture\u003C\u002Fcode\u003E корутины и класс \u003Ccode\u003EPromise\u003C\u002Fcode\u003E для данных.\u003C\u002Fp\u003E\u003Ch4\u003EКласс Promise, хранящий данные\u003C\u002Fh4\u003E\u003Cp\u003EВот — класс \u003Ccode\u003EPromise\u003C\u002Fcode\u003E, представляющий собой структуру, вложенную в класс \u003Ccode\u003EFuture\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Etemplate &lt;typename T\u003E\nclass Future\n{\n    class Promise\n    {\n    public:\n        using value_type = std::optional&lt;T\u003E;\n \n        Promise() = default;\n        std::suspend_always initial_suspend() { return {}; }\n        std::suspend_always final_suspend() noexcept { return {}; }\n        void unhandled_exception() { \n            std::rethrow_exception(std::move(std::current_exception())); \n        }\n        std::suspend_always yield_value(T value) {\n            this-\u003Evalue = std::move(value);\n            return {};\n        }\n        void return_void() {\n            this-\u003Evalue = std::nullopt;\n        }\n        inline Future get_return_object()\n        value_type get_value() {\n            return value;\n        }\n    private:\n        value_type value{};\n    };\n    …\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EСтруктура \u003Ccode\u003EPromise\u003C\u002Fcode\u003E (которую мы объявили приватной для включающего её в себя класса \u003Ccode\u003EFuture\u003C\u002Fcode\u003E) сохраняет отдельное значение данных в приватном объекте \u003Ccode\u003Estd::optional\u003C\u002Fcode\u003E с методом доступа \u003Ccode\u003Eget_value\u003C\u002Fcode\u003E. Используя объект \u003Ccode\u003Estd::optiona\u003C\u002Fcode\u003El мы можем воспользоваться \u003Ccode\u003Estd::nullop\u003C\u002Fcode\u003E для проверки на завершение работы корутины после вызова метода \u003Ccode\u003Ereturn_void\u003C\u002Fcode\u003E. Мы придерживаемся стиля метапрограммирования шаблонов C++, определяя признак типа \u003Ccode\u003Evalue_type\u003C\u002Fcode\u003E, что позволяет нам опрашивать класс для определения типа данных, лежащего в его основе.\u003C\u002Fp\u003E\u003Cp\u003EМы создаём конструктор, используемый по умолчанию и два метода жизненного цикла, необходимых для Promise-объекта корутины (\u003Ccode\u003Einitial_suspend\u003C\u002Fcode\u003E и \u003Ccode\u003Efinal_suspend\u003C\u002Fcode\u003E), которые всегда приостанавливают работу корутины, чтобы мы могли бы работать в однопоточном режиме. Эти методы жизненного цикла необходимы, но это — лишь их стандартные реализации, которые не нуждаются в дальнейшем рассмотрении.\u003C\u002Fp\u003E\u003Cp\u003EЕщё нам надо указать то, как фреймворк должен обрабатывать неперехваченные исключения. Вместо того чтобы отвлекаться на их обработку и создавать механизмы восстановления работы после возникновения ошибки, мы просто передаём исключение вызывающей стороне, которая должна принять решение о том, что с ними делать дальше.\u003C\u002Fp\u003E\u003Cp\u003EМетоды \u003Ccode\u003Eyield_value\u003C\u002Fcode\u003E и \u003Ccode\u003Ereturn_void\u003C\u002Fcode\u003E, о которых мы уже говорили, определены для того, чтобы копировать или перемещать выданное корутиной значение в хранилище \u003Ccode\u003Estd::optional\u003C\u002Fcode\u003E, или для того, чтобы использовать \u003Ccode\u003Estd::nullopt\u003C\u002Fcode\u003E для указания на завершение работы корутины. Обратите внимание на использование \u003Ccode\u003Estd::move\u003C\u002Fcode\u003E. Это сделано для того, чтобы обеспечить поддержку семантики перемещения данных для аргументов функции, передаваемых по значению: это необходимо, например, если надо выдать \u003Ccode\u003Estd::unique_ptr\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЕщё один метод, который нужно подготовить, это — \u003Ccode\u003Eget_return_object\u003C\u002Fcode\u003E. Он должен возвращать объект \u003Ccode\u003EFuture\u003C\u002Fcode\u003E для данного объекта \u003Ccode\u003EPromise\u003C\u002Fcode\u003E. Так как мы пока не завершили определение класса \u003Ccode\u003EFuture\u003C\u002Fcode\u003E, нам нужно реализовать этот метод после того, как будут готовы классы \u003Ccode\u003EFuture\u003C\u002Fcode\u003E и \u003Ccode\u003EPromise\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Ch4\u003EКласс Future — менеджер контекста корутины\u003C\u002Fh4\u003E\u003Cp\u003EСам класс \u003Ccode\u003EFuture\u003C\u002Fcode\u003E предоставляет нам конструктор\u002Fдеструктор для управления составным объектом \u003Ccode\u003EPromise\u003C\u002Fcode\u003E, а так же — механизм для получения значений, выданных корутиной (метод \u003Ccode\u003Enext\u003C\u002Fcode\u003E, о котором мы уже говорили):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Etemplate &lt;typename T\u003E\nclass Future\n{\n    struct Promise { … };\npublic:\n    using value_type = T;\n    using promise_type = Promise;\n    explicit Future(std::coroutine_handle&lt;Promise\u003E handle)\n    : handle (handle)\n    {}\n    ~Future() {\n        if (handle) { handle.destroy(); }\n    }\n    \u002F\u002F Promise::value_type next() { … }\nprivate:\n    std::coroutine_handle&lt;Promise\u003E handle;\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ стандартной библиотеке имеется поддержка управления объектами \u003Ccode\u003EPromise\u003C\u002Fcode\u003E через шаблонный класс \u003Ccode\u003Estd::coroutine_handle\u003C\u002Fcode\u003E, передаваемый в виде аргумента конструктору класса \u003Ccode\u003EFuture\u003C\u002Fcode\u003E. Нам нужно сохранить этот объект \u003Ccode\u003Ecoroutine_handle\u003C\u002Fcode\u003E и обеспечить вызов его метода \u003Ccode\u003Edestroy\u003C\u002Fcode\u003E при уничтожении объекта \u003Ccode\u003EFuture\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EСтандартная библиотека предъявляет ещё одно требование для класса \u003Ccode\u003EFuture\u003C\u002Fcode\u003E, в соответствии с которым мы должны определить вложенный тип \u003Ccode\u003Epromise_type\u003C\u002Fcode\u003E, что позволит шаблонам стандартной библиотеки выяснять тип данных, лежащий в основе класса.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Eusing promise_type = Promise;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ нашей реализации метода \u003Ccode\u003Enext\u003C\u002Fcode\u003E необходимо обеспечить проверку того, что объект \u003Ccode\u003EPromise\u003C\u002Fcode\u003E всё ещё актуален, или вернуть пустой объект \u003Ccode\u003Estd::optional\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EPromise::value_type next() {\n    if (handle) {\n        handle.resume();\n        return handle.promise().get_value();\n    }\n    else {\n        return {};\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВот что мы делаем для возврата значения, выданного корутиной:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EМы просто проверяем, существует ли всё ещё корутина (её объект \u003Ccode\u003Ehandle\u003C\u002Fcode\u003E не был уничтожен).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EМы вызываем метод \u003Ccode\u003Eresume\u003C\u002Fcode\u003E объекта \u003Ccode\u003Ecoroutine_handle\u003C\u002Fcode\u003E для выполнения кода до следующей инструкции \u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EМы возвращаем значение, сохранённое методом \u003Ccode\u003Eyield_value\u003C\u002Fcode\u003E объекта \u003Ccode\u003EPromise\u003C\u002Fcode\u003E: благодаря поддержке стандартной библиотеки будут обработаны операции восстановления и сохранения состояния корутины.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли корутин была уничтожена — мы возвращаем пустое значение (\u003Ccode\u003Estd::nullopt\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EТеперь, когда определён класс \u003Ccode\u003EFuture\u003C\u002Fcode\u003E, мы можем дополнить объект \u003Ccode\u003EPromise\u003C\u002Fcode\u003E необходимым методом \u003Ccode\u003Eget_return_object\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Etemplate &lt;typename T\u003E\ninline Future&lt;T\u003E Future&lt;T\u003E::Promise::get_return_object()\n{\n    return Future{ std::coroutine_handle&lt;Promise\u003E::from_promise(*this) };\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут мы используем метод \u003Ca href=\"https:\u002F\u002Fen.cppreference.com\u002Fw\u002Fcpp\u002Fcoroutine\u002Fcoroutine_handle\u002Ffrom_promise\"\u003Estd::from_promise\u003C\u002Fa\u003E для создания объекта \u003Ccode\u003Ecoroutine_handle\u003C\u002Fcode\u003E, который передаётся конструктору \u003Ccode\u003EFuture\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EКак видите, перед нами — всего лишь стандартный код, \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FBoilerplate_text\"\u003Eзаготовка\u003C\u002Fa\u003E для создания классов \u003Ccode\u003EFuture\u003C\u002Fcode\u003E и \u003Ccode\u003EPromise\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EТеперь, когда завершены подготовительные операции, этот шаблон может быть использован в применении к большинству типов данных и классов. Я сказал бы, что он применим ко всем классам, но всегда найдутся особые случаи, в которых воспользоваться им не получится.\u003C\u002Fp\u003E\u003Ch3\u003EКорутина, занимающаяся сбором данных\u003C\u002Fh3\u003E\u003Cp\u003EТеперь можно сосредоточиться на нашей реальной задаче, которая заключается в организации сбора данных. Первый шаг работы заключается в написании корутины, занимающейся чтением данных из объекта \u003Ccode\u003Eistream\u003C\u002Fcode\u003E и выдачей значений, представляющих собой числа с плавающей запятой:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EFuture&lt;float\u003E read_stream(std::istream&amp; in)\n{\n    int count{};\n    uint8_t byte;\n    while (in \u003E\u003E byte) {\n        data = data &lt;&lt; 8 | byte;\n        if (++count == 4) {\n            co_yield reinterpret_cast&lt;float\u003E(&amp;data);\n            data = 0;\n            count = 0;\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут мы просто читаем блоки данных размером 4 байта и помещаем их в 32-битные слова, после чего используем приведение типов, интерпретируя соответствующую область памяти в виде числа с плавающей запятой для инструкции \u003Ccode\u003Eco_yield\u003C\u002Fcode\u003E. Если поток данных завершается в ходе чтения 4-байтового слова, мы игнорируем частично прочитанное значение и завершаем работу корутины.\u003C\u002Fp\u003E\u003Cp\u003EМы можем подтвердить работоспособность этой корутины, просто выводя каждое float-значение, которое прочитано из стандартного потока ввода:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eauto raw_data = read_stream(std::cin);\nwhile (auto next = raw_data.next()) {\n    std::cout &lt;&lt; *next &lt;&lt; std::endl;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EА, так как надо сохранить пары значений в структуре данных, можно воспользоваться второй корутиной, которая инкапсулирует соответствующий алгоритм:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estruct DataPoint\n{\n    float timestamp;\n    float data;\n};\nFuture&lt;DataPoint\u003E read_data(std::istream&amp; in)\n{\n    std::optional&lt;float\u003E first{};\n    auto raw_data = read_stream(in);\n    while (auto next = raw_data.next()) {\n        if (first) {\n            co_yield DataPoint{*first, *next};\n            first = std::nullopt;\n        }\n        else {\n            first = next;\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ, опять же, если входной поток неожиданно завершается при чтении данных, относящихся к отметке времени или к элементу данных — мы отбрасываем неполные данные.\u003C\u002Fp\u003E\u003Cp\u003EПоследний шаг этого примера заключается в обработке значений, представляющих отметку времени и данные:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic constexpr float threshold{25.0};\nint main()\n{\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);\n    std::cout &lt;&lt; \"Time (ms)   Data\" &lt;&lt; std::endl;\n    auto values = read_data(std::cin);\n    while (auto n = values.next()) {\n        std::cout &lt;&lt; std::setw(8) &lt;&lt; n-\u003Etimestamp\n                  &lt;&lt; std::setw(8) &lt;&lt; n-\u003Edata\n                  &lt;&lt; (n-\u003Edata \u003E threshold ? \" Threshold exceeded\" : \"\")\n                  &lt;&lt; std::endl;\n    }\n    return 0;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭтот код выражает то, как мы решили обрабатывать данные, а все тонкости преобразования байтов в значения с плавающей запятой и их записи в структуру данных, скрыты в соответствующей корутине.\u003C\u002Fp\u003E\u003Cp\u003EХочется надеяться, что теперь вы способны прочувствовать плюсы использования корутин для разделения различных аспектов реализации сложных алгоритмов на более простые блоки кода. Сейчас, пользуясь C++20, нужно выполнять массу действий, которые кажутся сложными или ненужными для достижения нашей цели и заключаются в создании классов \u003Ccode\u003EFuture\u003C\u002Fcode\u003E и \u003Ccode\u003EPromise\u003C\u002Fcode\u003E. Но я тем не менее надеюсь, что в C++23 уже будет встроено нечто подобное этому шаблону, что позволит программистам уделять внимание написанию собственного кода, не отвлекаясь на создание вспомогательных механизмов.\u003C\u002Fp\u003E\u003Cp\u003EПротестировать этот код можно, воспользовавшись простым Python-скриптом, например, таким, который показан ниже. Он, в частности, выдаёт четыре жёстко заданных в коде элемента данных:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eimport struct\nimport sys\nstart = 0.0\nfor ms, value in enumerate([20.1, 20.9, 20.8, 21.1]):\n    sys.stdout.buffer.write(struct.pack('\u003Eff', start + ms*0.1, value))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕсли скомпилированный исполняемый файл называется \u003Ccode\u003Edatapoint_demo\u003C\u002Fcode\u003E, то мы можем воспользоваться следующим конвейером в командной строке Linux и убедиться в работоспособности корутин:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Linux\npython3 test_temp.py | .\u002Fdatapoint_demo\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ результате будет выведено следующее:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003ETime (ms)   Data\n    0.00   20.10\n    0.10   20.90\n    0.20   20.80\n    0.30   21.10 Threshold exceeded\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПолный вариант кода этого примера, представленный файлами \u003Ccode\u003Efuture.h\u003C\u002Fcode\u003E и \u003Ccode\u003Edatapoint_demo.cpp\u003C\u002Fcode\u003E, можно найти \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffeabhas\u002Fcoroutines-blog\"\u003Eздесь\u003C\u002Fa\u003E. Для того чтобы скомпилировать эти примеры с использованием GCC (версии 10 или выше), нужно воспользоваться \u003Ccode\u003E-std=c++20\u003C\u002Fcode\u003E и \u003Ccode\u003E-fcoroutines\u003C\u002Fcode\u003E в командной строке \u003Ccode\u003Eg++\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВ следующем материале я планирую добавить в шаблонный класс \u003Ccode\u003EFuture\u003C\u002Fcode\u003E поддержку итераторов, что позволит использовать корутину в цикле \u003Ccode\u003Efor\u003C\u002Fcode\u003E или в виде входного итератора для неких библиотечных механизмов.\u003C\u002Fp\u003E\u003Ch3\u003EИтоги\u003C\u002Fh3\u003E\u003Cp\u003EКорутины — это мощная техника программирования, позволяющая разделять различные аспекты реализаций сложных алгоритмов, описывая их в виде самостоятельных и достаточно простых блоков кода.\u003C\u002Fp\u003E\u003Cp\u003EC++20, как Python и C#, использует функциональный синтаксис для определения кода корутин. Многие программисты поначалу находят это странным, так как это — всего лишь синтаксическая конструкция для описания инструкций, входящих в состав корутины.\u003C\u002Fp\u003E\u003Cp\u003EКак мы видели, то, что сейчас нет простого стандартного шаблона для создания корутин-генераторов, усложняет жизнь тем, кто только собирается попробовать корутины. Сейчас применение корутин несколько напоминает сборку пазла, картинки-загадки, в условиях, когда тот, кто пазл собирает, не видел картинки, которая у него должна получиться. Поначалу такая задача выглядит пугающе сложной, но решить её вполне реально. Надеюсь, что шаблон \u003Ccode\u003EFuture\u003C\u002Fcode\u003E, который мы тут рассмотрели, это и есть та картинка, глядя на которую вы сможете собирать собственные пазлы.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EО, а приходите к нам работать? 😏\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003EМы в \u003Ca href=\"http:\u002F\u002Fwunderfund.io\u002F\"\u003E\u003Cstrong\u003Ewunderfund.io\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E занимаемся \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FHigh-frequency_trading\"\u003Eвысокочастотной алготорговлей\u003C\u002Fa\u003E с 2014 года. Высокочастотная торговля — это непрерывное соревнование лучших программистов и математиков всего мира. Присоединившись к нам, вы станете частью этой увлекательной схватки.\u003C\u002Fp\u003E\u003Cp\u003EМы предлагаем интересные и сложные задачи по анализу данных и low latency разработке для увлеченных исследователей и программистов. Гибкий график и никакой бюрократии, решения быстро принимаются и воплощаются в жизнь.\u003C\u002Fp\u003E\u003Cp\u003EСейчас мы ищем плюсовиков, питонистов, дата-инженеров и мл-рисерчеров.\u003Cbr\u002F\u003E\u003Ca href=\"http:\u002F\u002Fwunderfund.io\u002F#join_us\"\u003EПрисоединяйтесь к нашей команде.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"С++"},{"titleHtml":"разработка"},{"titleHtml":"асинхронное программирование"},{"titleHtml":"асинхронность"},{"titleHtml":"корутины"},{"titleHtml":"c++20"},{"titleHtml":"wunderfund"},{"titleHtml":"wunder fund"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2d4\u002F6ee\u002Fe85\u002F2d46eee8594e8fca63e142a5973441fc.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2d4\u002F6ee\u002Fe85\u002F2d46eee8594e8fca63e142a5973441fc.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fwunderfund\\\u002Fblog\\\u002F582000\\\u002F\"},\"headline\":\"Корутины в C++20 — что это и как с ними работать\",\"datePublished\":\"2021-10-25T17:06:30+03:00\",\"dateModified\":\"2021-10-25T17:06:30+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"mr-pickles\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промис...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fwunderfund\\\u002Fblog\\\u002F582000\\\u002F#post-content-body\",\"about\":[\"c_wunderfund\",\"h_programming\",\"h_cpp\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F582000\\\u002F365c01d958c07b10a1936e5f80e06514\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fdfe\\\u002F3c5\\\u002F106\\\u002Fdfe3c51063238c007eb2dbd960f079b3.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F749\\\u002F946\\\u002Feea\\\u002F749946eea0c07443b04425d455f90314.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F070\\\u002F510\\\u002F599\\\u002F070510599b4b897e30b915538151e38d.png\"]}","metaDescription":"Прим. Wunder Fund: В статьи описаны базовые подходы к работе с корутинами в 20м стандарте С++, на паре практических примеров разбораны шаблоны классов для промисов и фьючеров. По нашему скромному...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"wunderfund":{"alias":"wunderfund","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002Fb1a\u002F8c4\u002F544\u002Fb1a8c4544d951f4ea9bad437589d958e.png","titleHtml":"Wunder Fund","descriptionHtml":"Мы занимаемся высокочастотной торговлей на бирже","relatedData":null,"statistics":{"postsCount":29,"newsCount":0,"vacanciesCount":1,"employeesCount":3,"careerRating":null,"subscribersCount":436,"rating":60.88,"invest":null},"foundationDate":{"year":"2014","month":"01","day":"01"},"location":{"city":{"id":"447159","title":"Москва"},"region":{"id":"1885","title":"Москва и Московская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"http:\u002F\u002Fwunderfund.io","staffNumber":"11–30 человек","registrationDate":"2015-11-22T01:25:19+00:00","representativeUser":{"alias":"xopxe","fullname":null},"contacts":[{"title":"Сайт","url":"http:\u002F\u002Fwunderfund.io"}],"settings":{"analyticsSettings":[{"type":"ym","trackingId":"85710558"}],"branding":null,"status":"active"},"metadata":{"titleHtml":"Wunder Fund, Москва - Мы занимаемся высокочастотной торговлей на бирже с 1 января 2014 г.","title":"Wunder Fund, Москва - Мы занимаемся высокочастотной торговлей на бирже с 1 января 2014 г.","keywords":["Программирование","Алгоритмы","Математика","Natural Language Processing","Python"],"descriptionHtml":"29 статей от авторов компании Wunder Fund","description":"29 статей от авторов компании Wunder Fund"},"aDeskSettings":null,"careerAlias":"wunderfund","maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
