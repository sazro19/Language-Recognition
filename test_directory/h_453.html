<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Логистика. Часть 3. Еще одна модель динамического ценообразования / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/580782\/"},"headline":"Логистика. Часть 3. Еще одна модель динамического ценообразования","datePublished":"2021-10-16T00:29:30+03:00","dateModified":"2021-10-19T18:50:31+03:00","author":{"@type":"Person","name":"Andrey"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мыс...","url":"https:\/\/habr.com\/ru\/post\/580782\/#post-content-body","about":["h_algorithms","h_maths","h_ecommerce_development","h_ecommerce","h_transport","f_develop","f_management","f_popsci"],"image":["https:\/\/habr.com\/share\/publication\/580782\/afbd034971b54c23e44548e6e375c297\/","https:\/\/habrastorage.org\/webt\/13\/lo\/wx\/13lowxkxgxz91jd26oqjz9zw6nm.jpeg","https:\/\/habrastorage.org\/webt\/r2\/oi\/nu\/r2oinulcws61uxqdhmplxbq-i1u.png","https:\/\/habrastorage.org\/webt\/q5\/fm\/py\/q5fmpy1cwt6dbhp-je3czfznqgc.png","https:\/\/habrastorage.org\/webt\/la\/xg\/pp\/laxgppn5h_xol4i8v0tpzdxaoco.png","https:\/\/habrastorage.org\/webt\/z0\/bi\/pt\/z0biptmarht6jxhsqiedcpbecpm.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/b87\/c43\/419\/b87c4341953d9930499c99cfd4f7de89.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/af3\/360\/e5a\/af3360e5a8f861c3f0dc6097396caba5.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/712\/5c7\/7f7\/7125c77f701219f0ea40d62e1e6dfb20.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/d51\/0ff\/0b5\/d510ff0b5084ee6b6886523588fd9316.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/d76\/a4f\/87a\/d76a4f87a47846d29dd9758f30070dbf.svg","https:\/\/habrastorage.org\/webt\/av\/-3\/8g\/av-38gdtwkdubh30dypemgnpk9o.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/e45\/275\/2e5\/e452752e5729a1c7416345ef63bc4df0.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/096\/ed7\/65c\/096ed765c8bbbc1f1e34d3b19d3550ed.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/c56\/240\/e10\/c56240e100662324ed83f17092ee9fa2.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/ff9\/de2\/94e\/ff9de294e6aca9810aed4f3eebd4d2bc.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/4cc\/fd4\/32e\/4ccfd432ea4f2a64f3a5c8c7378517af.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/637\/bc1\/6ce\/637bc16ce01bbbb767d2cab3850d0420.svg","https:\/\/habrastorage.org\/webt\/hz\/bb\/fg\/hzbbfg2imha5i1ki9v6qsw5qupe.png","https:\/\/habrastorage.org\/webt\/va\/ob\/db\/vaobdbc-jpo1hpoepy47hepudim.png","https:\/\/habrastorage.org\/webt\/sn\/ka\/cg\/snkacgruttycsyvyztzkhazsttk.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/53a\/ea9\/f07\/53aea9f07ccaf30ffac7cd8719e70972.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/2fb\/b7c\/851\/2fbb7c8514633d9dbc23336d18634f04.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/1d6\/e3d\/c60\/1d6e3dc60633569bb3f51249e1a4ee2c.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/d31\/1eb\/78a\/d311eb78a0617bccfcb9c311add8ba87.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/d63\/aa6\/9de\/d63aa69decbb67ddf001a6b13fc54bb6.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/082\/329\/06a\/08232906a2219e19d5b55fcc298988b3.svg","https:\/\/habrastorage.org\/webt\/ns\/6d\/mu\/ns6dmuvrtkyeeysc2wnmqo0ghto.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/5bf\/c52\/aae\/5bfc52aaead575e156515b8c206fd63d.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/a7d\/f0b\/0cf\/a7df0b0cf52583a7326d63832fe3d4ed.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/117\/5ef\/b8b\/1175efb8bee3e7b48fb17482fa0cd6e7.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/9aa\/e08\/704\/9aae087046a60218262bab4a00522adc.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/167\/c15\/e50\/167c15e502e5a7e133b1a9f9ef7d0bce.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/25e\/17a\/b19\/25e17ab19263202dfb3c1aebfacf19f9.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/36a\/7a3\/4c0\/36a7a34c01ac63d36be1138a96b2a855.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/9d8\/a3d\/960\/9d8a3d960748cc0475baf28df77f4503.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/552\/1bc\/f0b\/5521bcf0bc906cefe74582db8c0359d9.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/86a\/538\/279\/86a538279987ae5a5cd4a304e7a473ea.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/9bb\/f5a\/4d7\/9bbf5a4d79b8208d4c01b4422de33c18.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/9f4\/af5\/8b0\/9f4af58b0f7eb150df3148c5fd587c9d.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/446\/d35\/399\/446d3539913a80cb65e58f051e004642.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/0a3\/09e\/ea1\/0a309eea16d2da7f3efd734d08d6b5a8.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/d94\/eac\/f64\/d94eacf64bc69d68ec23f2bf35f55b9e.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/9ed\/24a\/da4\/9ed24ada4750b2f910c10dbdff774b00.svg","https:\/\/habrastorage.org\/webt\/l1\/hz\/kp\/l1hzkpvy1r9ddfcywei_cxw5dlk.png","https:\/\/habrastorage.org\/webt\/_o\/-o\/ce\/_o-oce3hlkolwlehw-bdwtxou9o.png","https:\/\/habrastorage.org\/webt\/j2\/cm\/op\/j2cmopnsjyap-cxwufo_sejqxqs.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/118\/471\/ce7\/118471ce780db31b150774846ac1c463.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/5c5\/e36\/db9\/5c5e36db9aa19979c7f6bb87da974a77.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/e71\/aeb\/1ba\/e71aeb1ba620216cb4189e94b76aaf29.svg","https:\/\/habrastorage.org\/webt\/tk\/9r\/wm\/tk9rwmkknervwbatofyvn2x-6wo.gif","https:\/\/habrastorage.org\/webt\/ji\/vf\/p9\/jivfp9mv5oi23n56cz_ff2ydxcq.png","https:\/\/habrastorage.org\/webt\/-o\/y0\/va\/-oy0vaopheddusn3mzxu9nsp5x0.png","https:\/\/habrastorage.org\/webt\/vd\/hl\/pq\/vdhlpq20urlmd9bt0ykbbdlsoic.png","https:\/\/habrastorage.org\/webt\/vx\/ua\/bp\/vxuabplvuuel6nouvrxx6elouci.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/234\/756\/ba0\/234756ba02fcf44c798e4e66aedb3efd.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/dde\/35b\/631\/dde35b63133e1e49275c05ed00f4cd5d.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/201\/452\/4b7\/2014524b753fe3952e1d23685a5abd69.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/1a9\/77c\/ac2\/1a977cac2cf20bea49d0fdc767870c52.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/5cc\/533\/72d\/5cc53372dffdbc45385ac0fb1a95f4a9.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/37f\/c60\/2df\/37fc602df17cd0b1a13d2d5521d9405b.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/880\/bcf\/3aa\/880bcf3aaf2ccb7df6dbf0f6cd81fd41.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/24e\/802\/b5b\/24e802b5b6c51b1b789c4144730f8359.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/507\/4e4\/3d6\/5074e43d6122f1c4589abf6a3efc4bcd.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/99a\/8d4\/297\/99a8d42976dd82af5dc1a7e9906e76d6.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/a7a\/232\/066\/a7a232066f94f3bc1a8a7e7dc8ffec12.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/a32\/8ad\/81c\/a328ad81c5f1577dbf6c922fab9924b7.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/73d\/beb\/90f\/73dbeb90f104f08a18224ed0eedc014d.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/1f2\/b36\/77d\/1f2b3677d71680975e0f552a92393e24.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/a72\/5a3\/b2f\/a725a3b2f2f265b66e8fe0e7575bf371.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/8b9\/f2d\/153\/8b9f2d153dd0c14313df669f7bcf9467.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/80c\/c83\/502\/80cc835025159653c3b8c1fbffea0a79.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/bfd\/65a\/74d\/bfd65a74de356945ba7db1a6899f9f76.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/e38\/146\/7f4\/e381467f43d7ce7688e31b457ec4938d.svg","https:\/\/habrastorage.org\/webt\/ej\/kw\/zw\/ejkwzwz__2hkdgscldvgmca570g.png","https:\/\/habrastorage.org\/webt\/oa\/ps\/rz\/oapsrzmc5deznobaxlyfptyr7uy.png","https:\/\/habrastorage.org\/webt\/qj\/gy\/sv\/qjgysv2hmsy0ttpzyjulxsaphdq.png","https:\/\/habrastorage.org\/webt\/eu\/cf\/bm\/eucfbmsw-ppiyybjjf6ecrrznhc.png","https:\/\/habrastorage.org\/webt\/b7\/xr\/hg\/b7xrhgkjkaclaqyzzpukfvxbzua.png","https:\/\/habrastorage.org\/webt\/a4\/hu\/ze\/a4huzebrcwlsppbb-k5-maqhoii.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/bb9\/9dd\/06b\/bb99dd06bc822424df5c44ffcb2be720.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/619\/893\/974\/619893974ce5e5136d1c0815bfabaed2.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/3fd\/874\/494\/3fd8744949d2433267bc8216f7d09e5b.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/fb4\/0fb\/d4d\/fb40fbd4d1af9c4c34dbc7b22033730a.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/dd5\/7a3\/6e6\/dd57a36e67b69440b7d3a97b1e5f6e56.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/c31\/8e0\/606\/c318e0606625f9e246bbd1a1f13281b7.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/ca0\/537\/90c\/ca053790c820407b818c358aebba69da.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/621\/b81\/968\/621b81968021ea2576ab3165db3e8ed8.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/971\/be2\/2ea\/971be22ea4c5021440806a7348f3cabb.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/880\/67f\/133\/88067f133f4e67e895bff596a553b89b.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/f3d\/153\/ec5\/f3d153ec5bafeb6f2790b31036abb2bc.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/99a\/b8b\/347\/99ab8b3476d97cf9b0b84343d98fa1cd.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/c39\/a08\/da1\/c39a08da1f07d8df6b33970c5b131305.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/fc9\/ede\/a40\/fc9edea400279d3bbb719fedcb9b8736.svg","https:\/\/habrastorage.org\/webt\/qn\/vy\/q-\/qnvyq-vvgl4d5kmms1zeqtebd48.png","https:\/\/habrastorage.org\/webt\/cg\/1c\/4j\/cg1c4jiqgyzpmkgrk7qvzefwhws.png","https:\/\/habrastorage.org\/webt\/iw\/pw\/bp\/iwpwbpmaozkc95psos_9ppfaetw.png","https:\/\/habrastorage.org\/webt\/p6\/zc\/wk\/p6zcwksgwok7i8tc7bit_siypd8.png","https:\/\/habrastorage.org\/webt\/wh\/6r\/8q\/wh6r8qkmyy0cqgbh0anzd2atut0.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/e0a\/b52\/493\/e0ab52493f9173988771ba36df62208e.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/915\/acb\/b16\/915acbb16ed63f15541d3e0bda30d453.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/07d\/b3c\/ce4\/07db3cce40928fd36ad7738c522b7e18.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/4af\/348\/266\/4af348266f7268a3ac9b46a8a0bf32ac.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/1a4\/407\/c0d\/1a4407c0d32591184aa5ee93ebf16e25.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/a20\/2f5\/358\/a202f53584475a2972a9739e8150cdb1.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/f2d\/db7\/2d8\/f2ddb72d8056981528ead2fc4ad89cac.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/6e9\/8f3\/e0f\/6e98f3e0fc5cfe53e3ffcaa3d03cd937.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/d62\/a07\/7e1\/d62a077e11dcf3ba6dcc9d3a8e97e3fb.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/571\/e4f\/258\/571e4f25876015cdf65251503d9cf1b3.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/c69\/f49\/578\/c69f495783af4e66ee11b84d4a1bccc5.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/aaa\/09b\/131\/aaa09b131c8a57595e96094a4c67cf3c.svg","https:\/\/habrastorage.org\/webt\/5c\/hp\/dg\/5chpdggj_8mrhhtxqmkyfijqot8.png","https:\/\/habrastorage.org\/webt\/jx\/11\/y7\/jx11y7ridvqqx5agiyff4v2iwca.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/8a7\/140\/859\/8a71408594b9fc1df8cd8789a27751e5.svg","https:\/\/habrastorage.org\/webt\/lg\/6h\/ab\/lg6habiw51lk9t8dcmduh2ytnay.png","https:\/\/habrastorage.org\/webt\/qd\/xl\/bh\/qdxlbhze5vrughbh1ifskokz97s.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/c36\/6c6\/afe\/c366c6afe45292863afba99b2ae9a9fa.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/5cf\/97e\/a95\/5cf97ea9554c90b66fb8e74187252845.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/925\/79b\/045\/92579b045e333f06fbb8f4f7647323ce.svg","https:\/\/habrastorage.org\/webt\/k7\/nj\/mk\/k7njmksq1ufzxlvxu03i51d0qik.png","https:\/\/habrastorage.org\/webt\/io\/os\/mo\/ioosmopa5kcdcm0b0q1vvvt1ri4.png","https:\/\/habrastorage.org\/webt\/a_\/ne\/xl\/a_nexlfbemxcmwdtghpfq4kdcyu.png","https:\/\/habrastorage.org\/webt\/cz\/kk\/ig\/czkkigb31oszjoboakba3ury90u.png","https:\/\/habrastorage.org\/webt\/ke\/w4\/cw\/kew4cwbfxzwwcmc87csag1f-1nq.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/459\/2e6\/c32\/4592e6c32cb5645e058d730f7f6ee87b.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/5ec\/549\/a0a\/5ec549a0ae995aeaee0eabc57515744d.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/b7a\/74f\/7a9\/b7a74f7a9c1990ee3d87da166fc397a7.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/e8b\/167\/49e\/e8b16749e99dda97509dbc07ee5e03b3.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/b4f\/7dd\/211\/b4f7dd2118d5d0ef16f999d9fdeed89e.svg","https:\/\/habrastorage.org\/webt\/lc\/_z\/4z\/lc_z4zuljru-vmul0y5osmisq3a.png","https:\/\/habrastorage.org\/webt\/4g\/xv\/na\/4gxvna3ct1wtuuwezmlryuuuvcy.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/d42\/43a\/637\/d4243a637259458b5bdb16df941a48c1.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/0ea\/551\/526\/0ea551526006921e2da3a705b2a8d04f.svg","https:\/\/habrastorage.org\/webt\/ye\/l6\/sb\/yel6sbzgnt9fo81ixldd3q_bemq.png","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/8b2\/c9b\/86b\/8b2c9b86b6d2346947ae10f78df31c73.svg","https:\/\/habrastorage.org\/webt\/82\/ce\/eu\/82ceeuuvmlnofgm8xpkuv5fjkg0.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Логистика. Часть 3. Еще одна модель динамического ценообразования" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Логистика. Часть 3. Еще одна модель динамического ценообразования" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Логистика. Часть 3. Еще одна модель динамического ценообразования" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="580782" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-15T21:29:30.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/580782/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/580782/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/AndreyKotlov/" title="AndreyKotlov" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/4aa/37a/985/4aa37a9857149222324ccb5f9e4e68c4.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/AndreyKotlov/" class="tm-user-info__username">
      AndreyKotlov
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-15T21:29:30.000Z" title="2021-10-16, 00:29">16  октября   в 00:29</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Логистика. Часть 3. Еще одна модель динамического ценообразования</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/algorithms/" class="tm-article-snippet__hubs-item-link"><span>Алгоритмы</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/maths/" class="tm-article-snippet__hubs-item-link"><span>Математика</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/ecommerce_development/" class="tm-article-snippet__hubs-item-link"><span>Разработка под e-commerce</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/ecommerce/" class="tm-article-snippet__hubs-item-link"><span>Управление e-commerce</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/transport/" class="tm-article-snippet__hubs-item-link"><span>Транспорт</span> <!----></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml">Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более оптимальное решение. Примерно так и получилось с <a href="https://habr.com/ru/post/506240/">задачей динамического ценообразования для авиабилетов</a>, которую мы описывали более года назад в прошлой статье. Решение основывалось на алгоритме семплирования Томпсона. Компьютерное моделирование продаж показывало превосходные результаты, а тот факт, что такие гиганты как Walmart и Amazon уже давным давно и более чем успешно используют различные модификации этого алгоритма, только укрепляло уверенность в том, что мы на верном пути и иных способов оптимального решения задачи просто нет. Но в подавляющем большинстве случаев то, что отлично и везде работает, в авиаотрасли должно работать лучше. Не потому что так хочется, а потому что в этом действительно есть сильная потребность. Должно быть меньше экспериментов с ценой, она не должна меняться очень часто, а сам процесс поиска оптимальной цены должен быть еще быстрее. Но самое главное, алгоритм семплирования Томпсона не позволяет получить более-менее адекватную вероятностную модель спроса, без которой невозможно в полной мере использовать стохастическое программирование и заняться задачами глобальной оптимизации.<br/>
<br/>
<img src="https://habrastorage.org/r/w780q1/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-src="https://habrastorage.org/webt/13/lo/wx/13lowxkxgxz91jd26oqjz9zw6nm.jpeg" data-blurred="true"/><br/>
<a name="habracut"></a> <br/>
<br/>
<b>Распределение спроса вместо кривой спроса</b><br/>
<br/>
Переосмысление подхода к решению задачи началось, когда один из членов команды обратил внимание на предпринимателей розничной торговли, которые открывают социальные магазины. Это своеобразная форма благотворительности, которая заключается в том, что в магазине нет продавца, вместо которого есть что-то вроде ящика для пожертвований. В таком магазине можно взять любой товар с полки и самостоятельно решить сколько денег за него отдать. Все это конечно любопытно и наталкивает на множество размышлений, но примечательно то, что в подобных магазинах обычная кривая спроса превращается в некоторое распределение.<br/>
<br/>
Что бы продемонстрировать это, а также все дальнейшие примеры мы будем использовать язык Python, поэтому сразу сделаем все необходимые импорты:<br/>
<pre><code class="python">import numpy as np
np.random.seed(42)
import pandas as pd
from scipy import stats
from scipy.stats import norm, binom, bernoulli, poisson, beta
import matplotlib.pyplot as plt
from pylab import rcParams
rcParams['figure.figsize'] = 10, 6
%config InlineBackend.figure_format = 'svg'
import seaborn as sns
sns.set()
</code></pre><br/>
У нас нет данных о том сколько денег каждый посетитель подобного магазина платил за какой-то отдельно взятый товар, но это не помешает нам немного поразмышлять в этом направлении. Например, в знаменитом наборе данных tips отражена схожая ситуация, в которой посетителям ресторана нужно было самостоятельно принять решение о размере чаевых. Вряд ли в меню ресторана было большими красными буквами указано требование о том, что размер чаевых должен составлять 20% от стоимости заказа, но если взглянуть на график, то мы увидим, что значительная часть посетителей старается следовать этому негласному правилу:<br/>
<pre><code class="python">tips = sns.load_dataset('tips')
sns.relplot(x='total_bill', y='tip', data=tips);
</code></pre><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/r2/oi/nu/r2oinulcws61uxqdhmplxbq-i1u.png"/><br/>
В какой-то мере это негласное правило можно считать социальной нормой. В любом случае, схожий механизм работает и в социальных магазинах: какая-то часть посетителей руководствуется чувством справедливости и старается платить столько, сколько указано на ценнике товара. В наборе данных tips можно оценить влияние других факторов на размер чаевых: день недели, время суток, пол человека, оплачивающего счет, или количество людей в группе, выполнившей заказ. Очевидно, что каждый посетитель социального магазина, так же может руководствоваться множеством самых разных факторов: уровень дохода и наличие работы, количество человек в семье, торопится он на данный момент или нет, есть кто-нибудь рядом или нет и т.д. По центральной предельной теореме распределение спроса на товар в таких магазинах можно считать предельно нормальным.<br/>
<br/>
Если взять какой-нибудь конкретный товар в магазине без продавца, на ценнике которого указана стоимость в 12 рублей, то распределение спроса на него вполне могло бы выглядеть так:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">prices = np.r_[0: 35]
mu, sigma = 12, 5
demand = norm.rvs(mu, sigma, 1200)
sns.histplot(x=demand[demand > 0], discrete=True)
plt.title('Распределение спроса на некоторый товар в магазине без продавца', fontsize=15)
plt.xlabel('Цена', fontsize=15)
plt.ylabel('Количество покупок', fontsize=15, labelpad=10);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/q5/fm/py/q5fmpy1cwt6dbhp-je3czfznqgc.png"/><br/>
На самом деле мы можем лишь гадать как в действительности мог бы выглядеть этот график, так как у нас нет реальных данных. Но эти размышления наталкивают на мысль о том, что у спроса действительно должно быть какое-то распределение и, скорее всего, оно должно быть нормальным. В тоже самое время, если это действительно так, то это неизбежно должно приводить к тому, что какая-то часть распределения может оказаться в области отрицательных цен. Например, если бы мы опросили всех потенциальных покупателей некоторого города «A» о том, сколько они готовы заплатить за авиабилеты в город «B», ничего им не сообщая о его истинной стоимости, то вполне могли бы получить следующий результат:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python"> prices = np.r_[-10: 35]
mu, sigma = 12, 5
demand = norm.rvs(mu, sigma, 10000)
sns.histplot(demand, discrete=True)
plt.title('Распределение спроса в городе "A" на авиабилеты в город "B"', fontsize=15)
plt.xlabel('Цена (тыс. рублей)', fontsize=15)
plt.ylabel('Количество ответов', fontsize=15, labelpad=10); 
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/la/xg/pp/laxgppn5h_xol4i8v0tpzdxaoco.png"/><br/>
С одной стороны, принятие во внимание отрицательных цен выглядит нелогичным и даже комичным. С другой стороны, вряд ли какая-то значительная часть читателей согласится слетать на выходные в Афганистан, даже если авиакомпания предложит за перелет приличную сумму денег. Так и во многих сферах коммерческой деятельности возможны ситуации, когда компании выгодно продавать свой товар или услуги по отрицательным ценам, чем не продавать вовсе. К примеру товар, который имеет ограниченный срок годности, после которого он должен быть утилизирован (бытовая химия, косметика, продукты питания) – компании проще отдать бесплатно или немного доплатить покупателям, чем оплачивать стоимость транспортировки и утилизации в дальнейшем. Попытка сэкономить и не утилизировать товар может привести к увеличению общих затрат компании, т.к. бесконечно хранить у себя на складах такие товары не получится. Это увеличивает стоимость логистик (складской), да и ресурсы складов не бесконечны. О примере продажи товаров с отрицательной ценой каждый слышал: цена нефти Brent опустилась ниже 0 в 2020 году. Но вернемся к распределению спроса: вовсе не обязательно, что какая-то часть спроса должна находиться в области отрицательных цен, но это действительно возможно, хотя бы потому что всегда могут найтись люди, которым определенный товар будет не нужен даже за значительную доплату.<br/>
<br/>
Если спрос распределен нормально, то мы можем легко получить кривую спроса, для чего нужно просто начать продавать товар. Да, при более точном рассмотрении, обладая большим набором данных, мы можем прийти к тому, что спрос имеет другое распределение, но в первом приближении большинство методологий рекомендует начинать с нормального распределения, а дальше уже уточнять более сложными распределениями.<br/>
<br/>
Представим совсем нереалистичную ситуацию, в которой некоторая авиакомпания решила найти оптимальную стоимость авиабилетов из «A» в «B». Не реалистичность будет заключаться в том, что спрос на авиабилеты будет стационарным, а в авиакомпании решили пойти на беспрецедентный эксперимент — изменять стоимость билетов от 0 до 25 тысяч рублей, увеличивая значение цены на 1 тысячу рублей после каждых 2000 тысяч посетителей. После такого эксперимента, можно было бы наблюдать следующую картину:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python"> np.random.seed(42)
prices = np.r_[0: 25]
mu, sigma = 12, 5
demand = [np.sum(norm.rvs(mu, sigma, 2000) > price) for price in prices]
plt.bar(prices, demand, alpha=0.6)
plt.plot(prices, demand, 'ro-', lw=3, label='Кривая спроса')
plt.title('Распределение спроса на авиабилеты из "A" в "B"', fontsize=15)
plt.xlabel('Цена одного билета (тыс. рублей)', fontsize=15)
plt.ylabel('Количество покупок', fontsize=15, labelpad=10)
plt.legend(); 
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/z0/bi/pt/z0biptmarht6jxhsqiedcpbecpm.png"/><br/>
Оптимальную цену авиабилета можно было бы найти исходя из максимизации выручки, обозначим <img src="https://habrastorage.org/getpro/habr/formulas/b87/c43/419/b87c4341953d9930499c99cfd4f7de89.svg" alt="$i$" data-tex="inline"/> -ю цену как <img src="https://habrastorage.org/getpro/habr/formulas/af3/360/e5a/af3360e5a8f861c3f0dc6097396caba5.svg" alt="$\textrm{price}_{i}$" data-tex="inline"/> а спрос при данной цене (количество купленных авиабилетов) как <img src="https://habrastorage.org/getpro/habr/formulas/712/5c7/7f7/7125c77f701219f0ea40d62e1e6dfb20.svg" alt="$d_{i}$" data-tex="inline"/>, тогда для максимизации выручки нам нужно найти такую цену <img src="https://habrastorage.org/getpro/habr/formulas/d51/0ff/0b5/d510ff0b5084ee6b6886523588fd9316.svg" alt="$\textrm{price}^{*}$" data-tex="inline"/> при которой произведение <img src="https://habrastorage.org/getpro/habr/formulas/af3/360/e5a/af3360e5a8f861c3f0dc6097396caba5.svg" alt="$\textrm{price}_{i}$" data-tex="inline"/> на <img src="https://habrastorage.org/getpro/habr/formulas/712/5c7/7f7/7125c77f701219f0ea40d62e1e6dfb20.svg" alt="$d_{i}$" data-tex="inline"/> окажется самым большим, то есть<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/d76/a4f/87a/d76a4f87a47846d29dd9758f30070dbf.svg" alt="$\textrm{price}^{*} = \underset{\textrm{price}}{\textrm{argmax}} \; \textrm{price}_{i} \times d_{i},$" data-tex="inline"/><br/>
<br/>
что можно изобразить на следующем графике:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(prices, demand*prices, 'bo', lw=3)
plt.vlines(prices, 0, demand*prices)
plt.title('Зависимость выручки от цены', fontsize=15)
plt.xlabel('Цена одного авиабилета (тыс. рублей)', fontsize=15)
plt.ylabel('Выручка (тыс. рублей)', fontsize=15, labelpad=10);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/av/-3/8g/av-38gdtwkdubh30dypemgnpk9o.png"/><br/>
Если бы в авиакомпании взглянули на этот график, то вполне могли бы решить, что оптимальная цена авиабилетов составляет 10 тысяч рублей.<br/>
<br/>
Но что если бы в авиакомпании изначально знали, о том что спрос на билеты распределен как <img src="https://habrastorage.org/getpro/habr/formulas/e45/275/2e5/e452752e5729a1c7416345ef63bc4df0.svg" alt="$N(12, 5^{2})$" data-tex="inline"/>? Очевидно, что в этом случае они могли бы вычислить вероятность покупки одного билета при его определенной стоимости. Обозначим количество денег которое покупатель готов заплатить за один билет символом <img src="https://habrastorage.org/getpro/habr/formulas/096/ed7/65c/096ed765c8bbbc1f1e34d3b19d3550ed.svg" alt="$X$" data-tex="inline"/>, тогда вероятность того, что покупатель его купит можно вычислить по следующей формуле:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/c56/240/e10/c56240e100662324ed83f17092ee9fa2.svg" alt="$P(X \geqslant \textrm{price}_{i}) = 1 - P(X &lt; \textrm{price}_{i}) = 1 - \int_{-\infty }^{\textrm{price}_{i}}f(x)d x,$" data-tex="inline"/><br/>
<br/>
где <img src="https://habrastorage.org/getpro/habr/formulas/ff9/de2/94e/ff9de294e6aca9810aed4f3eebd4d2bc.svg" alt="$f(\textrm{x})$" data-tex="inline"/> — функция плотности вероятности нормального распределения, а <img src="https://habrastorage.org/getpro/habr/formulas/4cc/fd4/32e/4ccfd432ea4f2a64f3a5c8c7378517af.svg" alt="$x$" data-tex="inline"/> — пробегает по всем допустимым значениям цен. Затем, чтобы получить значение оптимальной цены, достаточно умножить полученные значения вероятностей на соответствующие им цены, то есть оптимальная цена может быть найдена как<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/637/bc1/6ce/637bc16ce01bbbb767d2cab3850d0420.svg" alt="$\textrm{price}^{*} = \underset{\textrm{price}}{\textrm{argmax}} \; P(X \geqslant \textrm{price}_{i}) \times d_{i}.$" data-tex="inline"/><br/>
<br/>
Давайте изобразим это на графике:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">x = np.r_[0: 25]
y = norm.sf(x, mu, sigma)
plt.plot(x, y, c='r', label=r'$P(X \geqslant p_{i})$')
plt.plot(x, x*y, 'bo', lw=3, label=r'$P(X \geqslant p_{i}) \times d_{i}$')
plt.vlines(x, 0, x*y)
plt.xlabel('Цена одного билета (тыс. рублей)', fontsize=15)
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/hz/bb/fg/hzbbfg2imha5i1ki9v6qsw5qupe.png"/><br/>
Получается, что кривая спроса может быть получена на основе распределения его плотности вероятности. Тогда возникает вполне закономерный вопрос: почему мы практически всегда пытаемся определить именно кривую спроса, но обделяем вниманием его распределение? На этот вопрос непросто ответить, но можно предположить, что пристальное внимание именно к кривой спроса обусловлено тем, что все началось в эпоху офлайн продаж, а дальше все двигалось по инерции. Например, в обычном магазине вполне возможно посчитать количество посетителей, но нет возможности оценить количество посетителей заинтересованных в каком-то конкретном товаре. В этом случае оценка вероятности продажи одной единицы конкретного товара сильно осложняется. В офлайне гораздо проще и логичнее воспринимать количество проданного товара в некоторый промежуток времени, как случайную величину из Пуассоновского распределения. Можно вообще не вести подсчет посетителей и учитывать только количество единиц проданного товара:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">f, ax = plt.subplots()
price = np.array([8, 10, 12, 14, 16])
teoretic_means = 100*norm.sf(price, mu, sigma)
len_periods, n_periods = 20, 5
demand = poisson.rvs(mu=teoretic_means, size=(len_periods, n_periods))
real_means = demand.mean(axis=0)
colors = sns.color_palette('Dark2', n_periods)
for i in range(n_periods):
    ax.vlines(np.r_[len_periods*i: len_periods*(i + 1)], 0,
              demand.T[i], color=colors[i], label=str(price[i]))
    ax.hlines(real_means[i], len_periods*i, len_periods*(i + 1)-1, color='k');
ax.legend(title='Цена (тыс. рублей)')
plt.title('Зависимость количества проданных авиабилетов от цены', fontsize=15)
plt.xlabel('Номер дня', fontsize=15)
plt.ylabel('Количество', fontsize=15, labelpad=10);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/va/ob/db/vaobdbc-jpo1hpoepy47hepudim.png"/><br/>
На вышеприведенном графике показано как могли бы выглядеть такие продажи авиабилетов при разной цене, где черной линией показано среднее значение продаж в каждом периоде. Именно благодаря средним значениям мы можем построить кривую спроса и определить оптимальную стоимость:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">f, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))
ax1.plot(price, real_means)
ax1.set(title='"Кривая" спроса', xlabel='Стоимость', ylabel='Среднее количество')
ax2.plot(price, price*real_means)
ax2.set(title='Средняя выручка', xlabel='Стоимость', ylabel='Объем выручки');
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/sn/ka/cg/snkacgruttycsyvyztzkhazsttk.png"/><br/>
Получается, что информация о продажах в офлайне позволяет оценивать только кривую спроса и ее недостаточно для того чтобы оценить его распределение. Но что если продажи переместятся в онлайн и теперь для того, что бы узнать стоимость некоторого товара, допустим, того же авиабилета и, уж тем более, приобрести его, придется зайти на отдельную страничку интернет-магазина (да, для авиабилета уже так происходит, но может не происходит для других товаров или услуг: к примеру, если мы говорим о b2b логистике)? Появится ли у нас информация, которой будет достаточно для оценки распределения?<br/>
<br/>
Допустим страницу с авиабилетом по направлению «A-B» посетили 20 человек, если спрос распределен как <img src="https://habrastorage.org/getpro/habr/formulas/e45/275/2e5/e452752e5729a1c7416345ef63bc4df0.svg" alt="$N(12, 5^{2})$" data-tex="inline"/>, то мы можем смоделировать значения случайной величины <img src="https://habrastorage.org/getpro/habr/formulas/096/ed7/65c/096ed765c8bbbc1f1e34d3b19d3550ed.svg" alt="$X$" data-tex="inline"/> — максимальную стоимость авиабилета, которую может себе позволить посетитель:<br/>
<pre><code class="python">X = norm.rvs(mu, sigma, 20)
X
</code></pre><br/>
<code>array([18.79350012, 17.82463618, 19.93989386, 2.45863418, 13.00361375,<br/>
 12.45140662, 9.19133558, 13.62229695, 10.39279135, 12.80996134,<br/>
 29.00937781, 13.58565382, 13.79565799, 16.10609668, 12.90322265,<br/>
 6.50983662, 3.76644135, 11.85354469, 10.65444486, 2.18198959])<br/>
</code><br/>
Если бы существовал какой-то волшебный способ получить такую выборку, то, даже несмотря на ее крошечный объем, можно все равно получить более-менее правдоподобные оценки параметров распределения:<br/>
<pre><code class="python">print(f'mu = {X.mean():.3}, sigma = {X.std(ddof=1):.3}')
</code></pre><br/>
<code>mu = 12.5, sigma = 6.29<br/>
</code><br/>
Но волшебства не существует, и все что нам остается это устанавливать и менять цену, наблюдая сколько посетителей совершит или не совершит покупку. Если каждый из 20 смоделированных выше посетителей увидит, что билет стоит 11 тысяч рублей, то единственное, что мы узнаем в итоге, это то, что:<br/>
<pre><code class="python">print(f'{sum(X >= 11)} посетителей из 20 совершили покупку.')
</code></pre><br/>
<code>13 посетителей из 20 совершили покупку.<br/>
</code><br/>
Кажется что цена — это просто цена, тем не менее, можно задать простой вопрос: чем цена на товар в офлайне отличается от той же самой цены в онлайне? Пусть случайная величина <img src="https://habrastorage.org/getpro/habr/formulas/53a/ea9/f07/53aea9f07ccaf30ffac7cd8719e70972.svg" alt="$Y$" data-tex="inline"/> показывает совершил посетитель покупку или нет, т.е. принимает всего два значения: 1 — покупка совершена и 0 — покупка не совершена, тогда оценка вероятности продажи одной единицы товара, в нашем случае — авиабилета, может быть вычислена по следующей формуле:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/2fb/b7c/851/2fbb7c8514633d9dbc23336d18634f04.svg" alt="$\widehat{p} = P(Y = 1 \mid \textrm{price} = 11) = \frac{u}{u + z} = \frac{13}{13+7}=0.65,$" data-tex="inline"/><br/>
<br/>
где <img src="https://habrastorage.org/getpro/habr/formulas/1d6/e3d/c60/1d6e3dc60633569bb3f51249e1a4ee2c.svg" alt="$u$" data-tex="inline"/> — это количество единиц, а <img src="https://habrastorage.org/getpro/habr/formulas/d31/1eb/78a/d311eb78a0617bccfcb9c311add8ba87.svg" alt="$z$" data-tex="inline"/> — количество нулей.<br/>
<br/>
После того как мы получили оценку вероятности продажи одной единицы товара, цена перестала быть просто ценой, ведь теперь 0.45-квантиль величины <img src="https://habrastorage.org/getpro/habr/formulas/096/ed7/65c/096ed765c8bbbc1f1e34d3b19d3550ed.svg" alt="$X$" data-tex="inline"/> равен 11 тысячи рублей, причем <img src="https://habrastorage.org/getpro/habr/formulas/d63/aa6/9de/d63aa69decbb67ddf001a6b13fc54bb6.svg" alt="$1 - \widehat{p} = 0.45$" data-tex="inline"/> — это оцениваемый нами уровень данного квантиля:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/082/329/06a/08232906a2219e19d5b55fcc298988b3.svg" alt="$Q_{1 - \widehat{p}} = Q_{0.45} = 11$" data-tex="inline"/><br/>
<br/>
Значение квантиля показывает нам с какой вероятность значение <img src="https://habrastorage.org/getpro/habr/formulas/096/ed7/65c/096ed765c8bbbc1f1e34d3b19d3550ed.svg" alt="$X$" data-tex="inline"/> не превысит 11 тысяч рублей, по нашим скромным оценкам эта вероятность равна 0.45 (на самом деле, чтобы вписаться в определение квантиля, мы должны считать квантилем не 11, а 10.99 тысяч рублей, но это не критично в данном случае). Чем больше людей посетят страницу по продаже билетов с ценой в 11 тысяч рублей, тем точнее будут оценки квантильного уровня:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">N = 1000
p_est = np.cumsum(norm.rvs(mu, sigma, N) > 11)/np.r_[1 : N + 1]
plt.plot(p_est)
plt.hlines(norm.sf(11, mu, sigma), 0, N, color='k', ls='--')
plt.title('Изменение оценок квантильного уровня')
plt.xlabel('Количество посетителей')
plt.ylabel('Уровень');
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ns/6d/mu/ns6dmuvrtkyeeysc2wnmqo0ghto.png"/><br/>
В пределе значение <img src="https://habrastorage.org/getpro/habr/formulas/5bf/c52/aae/5bfc52aaead575e156515b8c206fd63d.svg" alt="$\widehat{p}$" data-tex="inline"/> должно стремиться к <img src="https://habrastorage.org/getpro/habr/formulas/a7d/f0b/0cf/a7df0b0cf52583a7326d63832fe3d4ed.svg" alt="$p$" data-tex="inline"/> — истинному значению вероятности продажи одной единицы товара, которая на графике обозначена черной пунктирной линией. В определенных ситуациях, даже этой единственной оценки уже достаточно, чтобы понять насколько выбранная нами цена является оптимальной. Например, если вероятность покупки очень большая, то, очевидно, что цена занижена и наоборот, если покупают слишком мало, то цена завышена. Если нам необходимо продавать какое-то определенное количество товара, то зная среднюю посещаемость, можно сразу понять является ли цена оптимальной или нет. Получается, что даже из первой полученной оценки можно попробовать извлечь хоть какую-то полезную информацию. Но давайте вернемся к оценке параметров распределения спроса.<br/>
<br/>
Величина <img src="https://habrastorage.org/getpro/habr/formulas/53a/ea9/f07/53aea9f07ccaf30ffac7cd8719e70972.svg" alt="$Y$" data-tex="inline"/> имеет распределение Бернулли, тогда величина <img src="https://habrastorage.org/getpro/habr/formulas/117/5ef/b8b/1175efb8bee3e7b48fb17482fa0cd6e7.svg" alt="$K$" data-tex="inline"/> — количество проданного товара <img src="https://habrastorage.org/getpro/habr/formulas/9aa/e08/704/9aae087046a60218262bab4a00522adc.svg" alt="$N$" data-tex="inline"/> посетителям подчиняется биномиальному закону распределения:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/167/c15/e50/167c15e502e5a7e133b1a9f9ef7d0bce.svg" alt="$Y \sim \textrm{Bern}(\widehat{p})$" data-tex="inline"/><br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/25e/17a/b19/25e17ab19263202dfb3c1aebfacf19f9.svg" alt="$K \sim \textrm{Bin}(N, \widehat{p})$" data-tex="inline"/><br/>
Если предположить, что <img src="https://habrastorage.org/getpro/habr/formulas/36a/7a3/4c0/36a7a34c01ac63d36be1138a96b2a855.svg" alt="$\widehat{p}_{\textrm{price}_{i}}$" data-tex="inline"/> — оценка вероятности продажи одной единицы товара по цене <img src="https://habrastorage.org/getpro/habr/formulas/af3/360/e5a/af3360e5a8f861c3f0dc6097396caba5.svg" alt="$\textrm{price}_{i}$" data-tex="inline"/> приближенно равна истинному значению этой вероятности <img src="https://habrastorage.org/getpro/habr/formulas/9d8/a3d/960/9d8a3d960748cc0475baf28df77f4503.svg" alt="$p_{\textrm{price}_{i}}$" data-tex="inline"/> то можно записать следующее:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/552/1bc/f0b/5521bcf0bc906cefe74582db8c0359d9.svg" alt="$\widehat{p}_{\textrm{price}_{i}} \approx p_{\textrm{price}_{i}} \Rightarrow \frac{u}{u + z} \approx 1 - \frac{1}{\sigma \sqrt{2 \pi}}\int_{-\infty }^{\textrm{price}_{i}} e ^{-\frac{(x-\mu)^2}{2\sigma^{2}}}d x,$" data-tex="inline"/><br/>
<br/>
а это значит, что на основе <img src="https://habrastorage.org/getpro/habr/formulas/36a/7a3/4c0/36a7a34c01ac63d36be1138a96b2a855.svg" alt="$\widehat{p}_{\textrm{price}_{i}}$" data-tex="inline"/> мы можем получить оценки параметров распределения спроса <img src="https://habrastorage.org/getpro/habr/formulas/86a/538/279/86a538279987ae5a5cd4a304e7a473ea.svg" alt="$\widehat{\mu}$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/9bb/f5a/4d7/9bbf5a4d79b8208d4c01b4422de33c18.svg" alt="$\widehat{\sigma}$" data-tex="inline"/>.<br/>
<br/>
Допустим мы установили стоимость авиабилета в 7 тысяч рублей, представим, что в течение для его купили 50 посетителей из 55, пусть<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/9f4/af5/8b0/9f4af58b0f7eb150df3148c5fd587c9d.svg" alt="$\widehat{\mu} \in [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]$" data-tex="inline"/><br/>
<br/>
и<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/446/d35/399/446d3539913a80cb65e58f051e004642.svg" alt="$\widehat{\sigma} \in [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11],$" data-tex="inline"/><br/>
<br/>
тогда мы можем оценить вероятность продажи 50-и авиабилетов 55-и посетителям для разных значений <img src="https://habrastorage.org/getpro/habr/formulas/0a3/09e/ea1/0a309eea16d2da7f3efd734d08d6b5a8.svg" alt="$\widehat{\mu}_{j}$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/d94/eac/f64/d94eacf64bc69d68ec23f2bf35f55b9e.svg" alt="$\widehat{\sigma}_{k}$" data-tex="inline"/> как<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/9ed/24a/da4/9ed24ada4750b2f910c10dbdff774b00.svg" alt="$p_{\textrm{price}, j, k} = P(K = u \mid \textrm{price} = 7) = C_{u + z}^{u}p^{u}(1-p)^{z} =\\ =C_{u + z}^{u}\left ( 1 - \frac{1}{\sigma_{k} \sqrt{2 \pi}}\int_{-\infty }^{\textrm{price}} e ^{-\frac{(x-\mu_{j})^2}{2\sigma_{k}^{2}}}d x \right )^{u}\left (\frac{1}{\sigma_{k} \sqrt{2 \pi}}\int_{-\infty }^{\textrm{price}} e ^{-\frac{(x-\mu_{j})^2}{2\sigma_{k}^{2}}}d x \right )^{z}$" data-tex="inline"/><br/>
<br/>
Изобразим данные оценки в виде тепловой карты:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">mu_est = np.linspace(2, 22, 21)
sigma_est = np.linspace(1, 11, 21)
MU, SIGMA = np.meshgrid(mu_est, sigma_est)

price, u, z = 7, 50, 55
p = norm.sf(price, loc = MU, scale=SIGMA)
P1 = binom.pmf(u, z, p)

sns.heatmap(P1, xticklabels = mu_est, yticklabels=sigma_est,
            square=True, linewidths=.5)
plt.title('Вероятности продажи 50 авиабилетов 55-и посетителям\n \
по 7 тыс. рублей за штуку')
plt.xlabel('$\widehat{\mu}$', fontsize=20)
plt.ylabel('$\widehat{\sigma}$', rotation=0, fontsize=20, labelpad=15);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/l1/hz/kp/l1hzkpvy1r9ddfcywei_cxw5dlk.png"/><br/>
Если в следующий день установить стоимость в 14 тысяч рублей и представить, что было продано 16 билетов 34-м посетителям, то тепловая карта будет выглядеть так:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">mu_est = np.linspace(2, 22, 21)
sigma_est = np.linspace(1, 11, 21)
MU, SIGMA = np.meshgrid(mu_est, sigma_est)

price, u, z = 14, 16, 34
p = norm.sf(price, loc = MU, scale=SIGMA)
P2 = binom.pmf(u, z, p)

sns.heatmap(P2, xticklabels = mu_est, yticklabels=sigma_est,
            square=True, linewidths=.5)
plt.title('Вероятности продажи 16 авиабилетов 34-м посетителям\n \
по 14 тыс. рублей за штуку')
plt.xlabel('$\widehat{\mu}$', fontsize=20)
plt.ylabel('$\widehat{\sigma}$', rotation=0, fontsize=20, labelpad=15);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/_o/-o/ce/_o-oce3hlkolwlehw-bdwtxou9o.png"/><br/>
Имея всего два квантиля мы можем оценить вероятность совместного наступления двух исходов как простое произведение вероятностей их отдельного наступления:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">sns.heatmap(P1*P2, xticklabels = mu_est, yticklabels=sigma_est, square=True, linewidths=.5)
plt.title('Вероятности совместного наступления исходов\n \
двух процессов продаж')
plt.xlabel('$\widehat{\mu}$', fontsize=20)
plt.ylabel('$\widehat{\sigma}$', rotation=0, fontsize=20, labelpad=15);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/j2/cm/op/j2cmopnsjyap-cxwufo_sejqxqs.png"/><br/>
При наличии некоторого количества квантилей мы можем найти наилучшие оценки <img src="https://habrastorage.org/getpro/habr/formulas/118/471/ce7/118471ce780db31b150774846ac1c463.svg" alt="$\mu_{j}^{*}$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/5c5/e36/db9/5c5e36db9aa19979c7f6bb87da974a77.svg" alt="$\sigma_{k}^{*}$" data-tex="inline"/> для их истинных значений из условия максимального правдоподобия, т.е.<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/e71/aeb/1ba/e71aeb1ba620216cb4189e94b76aaf29.svg" alt="$(\mu_{j}^{*}, \sigma_{k}^{*}) = \underset{(\widehat{\mu}, \widehat{\sigma})}{\textrm{argmax}}\prod_{j, k}\widehat{p}_{\textrm{price}_{i}, j, k}$" data-tex="inline"/><br/>
<br/>
Например, двух вышеприведенных квантилей достаточно чтобы получить первые оценки параметров распределения спроса, а значит — приступить к процессу максимизации выручки:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python"># функция для вычисления оптимальной цены
# на основе оценок параметров распределения спроса
def optim_price(prices, mu_est, sigma_est):
    return prices[np.argmax(norm.sf(prices, mu_est, sigma_est)*prices)]

# функция для вычисления оценок параметров
# спроса и их максимальных значений
def param_est(used_prices, u, n):
    used_prices = used_prices.reshape(used_prices.size, 1, 1)
    u = u.reshape(u.size, 1, 1)
    n = n.reshape(n.size, 1, 1)
    mu_est = np.linspace(2, 22, 21)
    sigma_est = np.linspace(1, 11, 21)
    MU, SIGMA = np.meshgrid(mu_est, sigma_est)
    MU = np.expand_dims(MU, axis=0)
    SIGMA = np.expand_dims(SIGMA, axis=0)
    p = norm.sf(used_prices, loc = MU, scale=SIGMA)
    p_est = np.prod(binom.pmf(u, n, p), axis=0)
    idx = divmod(np.argmax(p_est), 21)
    mu_opt = mu_est[idx[1]]
    sigma_opt = sigma_est[idx[0]]
    return p_est, mu_opt, sigma_opt

# Создаем список возможных цен:
prices = np.linspace(6, 18, 25)
# Выбираем две неравные друг другу цены, которые на наш
# взгляд являются самыми перспективными для исследований,
# или выбираем их случайно, если таких представлений нет:
used_prices = np.array([7, 14])
# моделируем (в реальности - считаем) количество посетителей:
n = np.array([55, 32])
# моделируем (в реальности - считаем) количество покупателей:
u = np.array([50, 16])
# На основе двух полученных квантилей, вычисляем наилучшие
# оценки параметров распределения спроса:
P_map, mu_est, sigma_est = param_est(used_prices, u, n)
# Сохраняем все значения для визуализации:
P_maps = [P_map]
for i in range(30):
    # На основе имеющихся оценок параметров распределения спроса
    # вычисляем оптимальную стоимость товара:
    used_prices = np.append(used_prices, optim_price(prices, mu_est, sigma_est))
    # моделируем (в реальности - считаем) количество посетителей и
    # покупателей:
    n = np.append(n, np.random.randint(20, 70))
    u = np.append(u, np.sum(norm.rvs(12, 5, n[-1]) > used_prices[-1]))
    # Используем все данные для вычисления новых значений 
    # параметров распределения спроса:
    P_map, mu_est, sigma_est = param_est(used_prices, u, n)
    P_maps.append(P_map)
</code></pre><br/>
<pre><code class="python">import matplotlib.animation as animation
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure()
fig.set_figwidth(16)
fig.set_figheight(8)
ax2 = fig.add_subplot(122, projection='3d')
ax1 = fig.add_subplot(121)

mu_est = np.linspace(2, 22, 21)
sigma_est = np.linspace(1, 11, 21)
MU, SIGMA = np.meshgrid(mu_est, sigma_est)

def animate(i):
    fig.suptitle('Процесс сходимости оценок параметров\nраспределения спроса',
                 fontsize = 20, y = 0.95)
    ax1 = sns.heatmap(P_maps[i], cbar=False, xticklabels = mu_est,
                      yticklabels=sigma_est, square=True)
    ax1.set_xlabel('$\widehat{\mu}$', fontsize=20)
    ax1.set_ylabel('$\widehat{\sigma}$', rotation=0, fontsize=20, labelpad=15)
    ax2.clear()
    ax2.plot_surface(MU, SIGMA, P_maps[i], cmap='Wistia', linewidth=1, edgecolor='0.3')
    ax2.set_xlabel('$\widehat{\mu}$', fontsize=15)
    ax2.set_ylabel('$\widehat{\sigma}$', fontsize=15)
    ax2.set_xticks(mu_est[::2])
    ax2.set_zticks([])
    return ax1

anim = animation.FuncAnimation(fig, 
                               animate, 
                               frames=np.arange(0, len(P_maps)),
                               interval = 10,
                               repeat = False)

anim.save('Асимптотическая сходимость.gif',
                 writer='imagemagick', 
                 fps=8)
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/tk/9r/wm/tk9rwmkknervwbatofyvn2x-6wo.gif"/><br/>
Мы можем повторить данный эксперимент 100 раз и взглянуть на динамику усредненных значений:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">qa_proceeds = []
prices_data = []
all_visitors = []
prices = np.linspace(6, 18, 25)
for i in range(100):
    used_prices = np.random.choice(prices, 2, replace=False)
    # генерируем количество посетителей
    n = np.random.randint(20, 70, 2)
    # генерируем количество покупателей
    u = np.array([np.sum(norm.rvs(12, 5, n[i]) > used_prices[i]) for i in range(len(n))])
    mu_est, sigma_est = param_est(used_prices, u, n)[1:]
    for j in range(20):
        used_prices = np.append(used_prices, optim_price(prices, mu_est, sigma_est))
        n = np.append(n, np.random.randint(20, 70))
        u = np.append(u, np.sum(norm.rvs(12, 5, n[-1]) > used_prices[-1]))
        mu_est, sigma_est = param_est(used_prices, u, n)[1:]
    prices_data.append(used_prices)
    qa_proceeds.append(np.sum(used_prices * u))
    all_visitors.append(np.sum(n))
qa_prices_data = pd.concat([pd.Series(i, index=range(len(i))) for i in prices_data])

sns.lineplot(data=qa_prices_data, ci='sd')
plt.hlines(optim_price(prices, 12, 5), 0, len(prices_data[0]) - 1, color='r',
           label='Оптимальная стоимость авиабилета')
plt.yticks(prices[::2])
plt.title('Процесс поиска оптимальной цены на основе квантильного анализа')
plt.xlabel('Количество изменений цены')
plt.ylabel('Стоимость одного авиабилета (тыс. рублей)')
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ji/vf/p9/jivfp9mv5oi23n56cz_ff2ydxcq.png"/><br/>
На графике показано среднее значение цены и ее стандартное отклонение. Взглянем на объем выручки в каждом эксперименте:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(qa_proceeds)
qa_mean_proc = np.mean(qa_proceeds)
plt.hlines(qa_mean_proc, 0, len(qa_proceeds), color='r',
           label=f'Средняя выручка ({int(qa_mean_proc)} тыс. рублей)')
plt.title('Объем выручки в каждом эксперименте')
plt.xlabel('Номер эксперимента')
plt.ylabel('Объем выручки (тыс. рублей)')
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/-o/y0/va/-oy0vaopheddusn3mzxu9nsp5x0.png"/><br/>
Теперь для сравнения попробуем найти оптимальную стоимость с помощью алгоритма сэмплирования Томпсона (TS). Что бы провести более-менее корректное сравнение, выясним сколько в среднем посетителей участвовало в одном эксперименте на основе квантильного анализа:<br/>
<pre><code class="python">np.mean(all_visitors)
</code></pre><br/>
<code>985.01 <br/>
</code><br/>
Округлим это значение до 1000 и точно так же повторим эксперимент 100 раз:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">def thompson_sampling(a,b):
    samples = beta.rvs(a=a+1, b=b+1)
    return np.argmax(samples)

n = len(prices)
ts_prices_data = []
ts_proceeds = []

for i in range(100):
    # Количество нажатий на рычаг, в нашем случае
    # количество использований определенной цены
    count = np.zeros(n)
    # Сумма наград для каждой руки (количество
    # проданного товара по данной цене)
    sum_rewards = np.zeros(n)
    # Средняя награда от рычага (оценка вероятности
    # продажи одной единицы товара)
    Q = np.zeros(n)
    # Инициализируем значения alpha и beta
    a = np.ones(n)
    b = np.ones(n)
    price = []
    proceeds = []
    for j in range(1000):
        # Выбираем руку с применением выборки Томпсона
        arm = thompson_sampling(a, b)
        count[arm] += 1
        price.append(prices[arm])
        # Моделируем посетителя
        reward = bernoulli.rvs(norm.sf(prices[arm], 12, 5))
        # если reward = 1, значит совершена покупка 
        if reward == 1:
            sum_rewards[arm] += 1
            proceeds.append(prices[arm])
        # вычисляем вероятность продажи одной единицы товара
        Q[arm] = sum_rewards[arm] / count[arm]
        # Если выручка по данной цене является максимальной, то:
        if arm == np.argmax(prices*Q):
            a[arm] += 1    # увеличиваем alpha
        else:
            b[arm] += 1    # если нет, то увеличиваем beta
    ts_prices_data.append(price)
    ts_proceeds.append(sum(proceeds))
ts_prices_data = pd.concat([pd.Series(i, index=range(len(i))) for i in ts_prices_data])

sns.lineplot(data=ts_prices_data, ci='sd')
plt.hlines(optim_price(prices, 12, 5), 0, 1000, color='r',
           label='Оптимальная стоимость авиабилета')
plt.yticks(prices[::2])
plt.title('Процесс поиска оптимальной цены на основе\n \
алгоритма семплирования Томпсона')
plt.xlabel('Количество изменений цены')
plt.ylabel('Стоимость одного авиабилета (тыс. рублей)')
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/vd/hl/pq/vdhlpq20urlmd9bt0ykbbdlsoic.png"/><br/>
И так же взглянем на объем выручки в каждом эксперименте:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(ts_proceeds)
ts_mean_proc = np.mean(ts_proceeds)
plt.hlines(ts_mean_proc, 0, len(ts_proceeds), color='r',
           label=f'Средняя выручка ({int(ts_mean_proc)} тыс. рублей)')
plt.title('Объем выручки в каждом эксперименте')
plt.xlabel('Номер эксперимента')
plt.ylabel('Объем выручки (тыс. рублей)')
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/vx/ua/bp/vxuabplvuuel6nouvrxx6elouci.png"/><br/>
<br/>
Преимущества квантильного анализа перед TS алгоритмом очевидны:<br/>
 — более быстрая сходимость;<br/>
 — гораздо меньшее количество изменений цены;<br/>
 — незначительное, но все же, увеличение объема выручки.<br/>
<br/>
Разумеется, результаты сравнения выглядят немного подозрительными и для сомнений в их корректности есть основания. Во-первых, алгоритм TS это эвристика, а это значит, что мы можем оптимизировать его множеством самых разных способов. Например, мы можем использовать наши некоторые представления о кривой спроса и перед запуском установить параметры <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/> в соответствующие этим представлениям значения. Мы можем пойти еще дальше и использовать еще больше предметно-ориентированных знаний и создать что-то вроде алгоритма-советника, который помогал бы принимать более правильные решения по установке и изменению цен. Но все это не приведет к желаемому результату, потому что основная причина такого результата кроется в количестве проверяемых цен:<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/201/452/4b7/2014524b753fe3952e1d23685a5abd69.svg" alt="$\textrm{prices} \in [6,6.5,7,7.5,8,8.5,9,9.5,10,10.5,11,11.5,12,12.5,13,13.5,14,14.5,15,15.5,16,16.5,17,17.5,18].$" data-tex="inline"/><br/>
<br/>
На первый взгляд, в таком количестве цен для продажи большинства товаров нет никакой логики. Гораздо лучше и логичнее поступить так, как это принято — использовать меньшее количество цен, например:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/1a9/77c/ac2/1a977cac2cf20bea49d0fdc767870c52.svg" alt="$\textrm{prices} \in [7.99, 8.99, 9.99, 10.99, 11.99].$" data-tex="inline"/><br/>
<br/>
В этом случае TS алгоритм будет работать просто идеально. Но что если оптимальная цена равна 9.5 тысяч рублей? В случае небольших объемов продаж это не критично, но если объемы продаж велики, то это негативно скажется на прибыли. Основное требование к продаже авиабилетов как раз и заключается в том, что количество проверяемых цен должно быть максимально большим. А что если спрос изменится и оптимальная цена вообще покинет установленный диапазон цен? Это означает, что мы все равно должны как-то учитывать цены за пределами выбранного диапазона, т.е. так или иначе цен становится еще больше. Конечно, вышеприведенные эксперименты предполагали стационарность спроса на авиабилеты, который в действительности является динамическим. Алгоритм TS может быть модифицирован для работы с изменяющимся спросом. Суть модификации заключается в ограничении параметров <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/> какими-то максимальными значениями — чем меньше эти значения, тем быстрее TS реагирует на изменение. В то же самое время, чем меньше ограничивающие значения, тем больше уклон на исследования цен. Кстати процесс исследования цен, это тоже отдельная и очень большая проблема, связанная с тем, что мы не можем менять цену после каждого посетителя. А это значит, что если мы выбрали какую-то, пусть даже самую неоптимальную цену, то все равно придется продержать ее какое-то время иначе это неизбежно приведет к появлению противоречивого опыта у некоторых посетителей.<br/>
<br/>
Все вышеперечисленные трудности можно преодолеть с разной степенью успеха благодаря множеству модификаций TS алгоритма. Но самая главная проблема заключается в том, что данные о продажах, появляющиеся в ходе его работы абсолютно непригодны для решения задачи глобальной оптимизации. Ведь в действительности, даже имея на руках самый идеальный алгоритм ценообразования, от него не будет абсолютно никакого толка если авиакомпания не выполнит оптимальную расстановку авиапарка по маршрутам. В свою очередь, от алгоритмов ценообразования и расстановки авиапарка также не будет никакой пользы, если авиакомпании не будут иметь согласованных стратегий (для общего эффекта на отрасль в короткие сроки; если же стратегии не согласованы, то рынок бы тоже выровнялся со временем при внедрении алгоритмов хотя бы одной авиакомпанией, но, к сожалению, отрасль является в том или ином виде дотационной во многих странах мира, что сильно ограничивает возможности саморегулирования). А ведь помимо авиакомпаний в системе присутствуют и другие игроки, например, поставщики топлива и аэропорты, чьи действия могут свести на нет даже самую оптимальную стратегию авиакомпаний. Это чрезвычайно сложная система, которая, как это ни странно, существует в основном только за счет кошельков конечных потребителей. Поэтому единственный способ начать оптимизацию всей системы — это начать с ценообразования.<br/>
<br/>
Например, суть расстановки авиапарка заключается в том, что мы должны постоянно принимать управляющие решения о назначении самолетов конкретного типа на конкретные маршруты, для чего необходима информация хотя бы о кривой спроса. Если использовать самую идеальную реализацию TS алгоритма, которая с первых попыток находит оптимальную цену, то окажется что для восстановления кривой спроса просто не окажется нужных данных по другим ценам. Сначала это не кажется проблемой, ведь у нас есть идеальный алгоритм ценообразования, но в этой ситуации алгоритм глобальной оптимизации тоже становится эвристическим, т.е. для того что бы понять, что какому-то самолету не стоит летать по данному направлению, придется понести серьезные убытки. Наличие кривых спроса, наоборот, позволяет без всяких экспериментов сразу менять маршруты и расписания с минимальными убытками.<br/>
<br/>
Квантильный анализ требует установки всего двух исследуемых цен, которые могут выбираться как случайно, так и на основе имеющейся аналитики. Все последующие изменения делаются только на основе уточняющихся оценок параметров распределения спроса. Это означает, что квантильный анализ не является эвристическим и, каким бы ни было количество возможных цен, исследоваться будут только те цены, которые считаются оптимальными на данном этапе. И самое главное, появляющиеся после каждого очередного квантиля оценки, могут быть использованы в многоэтапных задачах стохастической оптимизации. Казалось бы — все круто. Но у квантильного анализа есть один существенный минус — непонятно каким должен быть объем выборки, т.е. непонятно сколько нужно посетителей для того, чтобы оценка квантильного уровня была более-менее статистически значимой. Если использовать для оценки вероятности продажи одной единицы товара <img src="https://habrastorage.org/getpro/habr/formulas/36a/7a3/4c0/36a7a34c01ac63d36be1138a96b2a855.svg" alt="$\widehat{p}_{\textrm{price}_{i}}$" data-tex="inline"/> небольшое количество посетителей, то очевидно, что эта оценка будет обладать слишком большой дисперсией, и процесс поиска оптимальной цены слишком затянется. Если использовать слишком большое количество посетителей, то мы будем получать более точные значения <img src="https://habrastorage.org/getpro/habr/formulas/36a/7a3/4c0/36a7a34c01ac63d36be1138a96b2a855.svg" alt="$\widehat{p}_{\textrm{price}_{i}}$" data-tex="inline"/>, но в том случае если <img src="https://habrastorage.org/getpro/habr/formulas/af3/360/e5a/af3360e5a8f861c3f0dc6097396caba5.svg" alt="$\textrm{price}_{i}$" data-tex="inline"/> является далеко не оптимальной, то ее долгое использование может привести к катастрофически большим убыткам. Неопределенность объема выборки — это действительно серьезная проблема, и, пожалуй, единственный способ ее преодоления заключается в использовании последовательного статистического анализа.<br/>
<br/>
<b>Последовательный статистический анализ Вальда</b><br/>
<br/>
Первоначальные оценки параметров спроса могут быть как верными так и нет, это значит, что мы можем с первых попыток найти самую оптимальную цену, ну или по крайней мере близкую к ней. Убедиться в оптимальности цены довольно просто, ведь если оценки параметров спроса верны, то вычисленная вероятность продажи одной единицы товара <img src="https://habrastorage.org/getpro/habr/formulas/5cc/533/72d/5cc53372dffdbc45385ac0fb1a95f4a9.svg" alt="$\widehat{p}_{\textrm{price}_{i}}\,^{'}$" data-tex="inline"/> не будет значительно отличаться от наблюдаемой <img src="https://habrastorage.org/getpro/habr/formulas/36a/7a3/4c0/36a7a34c01ac63d36be1138a96b2a855.svg" alt="$\widehat{p}_{\textrm{price}_{i}}$" data-tex="inline"/>. Допустим у нас есть оценка <img src="https://habrastorage.org/getpro/habr/formulas/36a/7a3/4c0/36a7a34c01ac63d36be1138a96b2a855.svg" alt="$\widehat{p}_{\textrm{price}_{i}}$" data-tex="inline"/>, тогда мы можем выделить область безразличия, ограниченную значениями <img src="https://habrastorage.org/getpro/habr/formulas/37f/c60/2df/37fc602df17cd0b1a13d2d5521d9405b.svg" alt="$p_{0}$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/880/bcf/3aa/880bcf3aaf2ccb7df6dbf0f6cd81fd41.svg" alt="$p_{1}$" data-tex="inline"/>. Если <img src="https://habrastorage.org/getpro/habr/formulas/24e/802/b5b/24e802b5b6c51b1b789c4144730f8359.svg" alt="$p_{0} &lt; \widehat{p}_{\textrm{price}_{i}} &lt; p_{1}$" data-tex="inline"/>, то мы не предпринимаем никаких действий по изменению цены и считаем, что наша оценка верна. В противном случае мы уточняем оценки параметров распределения спроса и на основе их уточненных значений меняем цену.<br/>
<br/>
Выдвинем основную гипотезу <img src="https://habrastorage.org/getpro/habr/formulas/507/4e4/3d6/5074e43d6122f1c4589abf6a3efc4bcd.svg" alt="$H_{0}$" data-tex="inline"/> о том, что вероятность продажи одной единицы товара <img src="https://habrastorage.org/getpro/habr/formulas/36a/7a3/4c0/36a7a34c01ac63d36be1138a96b2a855.svg" alt="$\widehat{p}_{\textrm{price}_{i}}$" data-tex="inline"/> при выбранной цене равна <img src="https://habrastorage.org/getpro/habr/formulas/37f/c60/2df/37fc602df17cd0b1a13d2d5521d9405b.svg" alt="$p_{0}$" data-tex="inline"/> и одну конкурирующую гипотезу <img src="https://habrastorage.org/getpro/habr/formulas/99a/8d4/297/99a8d42976dd82af5dc1a7e9906e76d6.svg" alt="$H_{1}$" data-tex="inline"/>, заключающуюся в том, что на самом деле <img src="https://habrastorage.org/getpro/habr/formulas/a7a/232/066/a7a232066f94f3bc1a8a7e7dc8ffec12.svg" alt="$\widehat{p}_{\textrm{price}_{i}} = p_{1}$" data-tex="inline"/>. При доказательстве гипотез мы можем совершить ошибки первого и второго рода, обозначаемые <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/> соответственно. Тогда, согласно правилам последовательного статистического анализа Вальда, мы можем выделить две критические области:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/a32/8ad/81c/a328ad81c5f1577dbf6c922fab9924b7.svg" alt="$A = \frac{1 - \beta}{\alpha}, \;\;\; B = \frac{\beta}{1 - \alpha}$" data-tex="inline"/><br/>
<br/>
Мы можем принять гипотезу <img src="https://habrastorage.org/getpro/habr/formulas/507/4e4/3d6/5074e43d6122f1c4589abf6a3efc4bcd.svg" alt="$H_{0}$" data-tex="inline"/> о том что <img src="https://habrastorage.org/getpro/habr/formulas/73d/beb/90f/73dbeb90f104f08a18224ed0eedc014d.svg" alt="$p = p_{0}$" data-tex="inline"/>, если<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/1f2/b36/77d/1f2b3677d71680975e0f552a92393e24.svg" alt="$u \ln \frac{p_{1}}{p_{0}} + z \ln \frac{1 - p_{1}}{1 - p_{0}} \leqslant \ln B,$" data-tex="inline"/><br/>
<br/>
или принять гипотезу <img src="https://habrastorage.org/getpro/habr/formulas/99a/8d4/297/99a8d42976dd82af5dc1a7e9906e76d6.svg" alt="$H_{1}$" data-tex="inline"/> о том что <img src="https://habrastorage.org/getpro/habr/formulas/a72/5a3/b2f/a725a3b2f2f265b66e8fe0e7575bf371.svg" alt="$p = p_{1}$" data-tex="inline"/>, если<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/8b9/f2d/153/8b9f2d153dd0c14313df669f7bcf9467.svg" alt="$u \ln \frac{p_{1}}{p_{0}} + z \ln \frac{1 - p_{1}}{1 - p_{0}} \geqslant \ln A.$" data-tex="inline"/><br/>
<br/>
В случае когда<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/formulas/80c/c83/502/80cc835025159653c3b8c1fbffea0a79.svg" alt="$\ln B &lt; u \ln \frac{p_{1}}{p_{0}} + z \ln \frac{1 - p_{1}}{1 - p_{0}} &lt; \ln A$" data-tex="inline"/><br/>
<br/>
мы продолжаем торговлю.<br/>
<br/>
Критерий Вальда включает в себя критерий Неймана-Пирсона как частный случай, то есть может обеспечить те же самые уровни ошибок <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/>, но при этом не требует фиксированного объема выборки. Чтобы продемонстрировать последовательный анализ в действии, предположим что ошибки первого рода обходятся гораздо дороже, чем ошибки второго рода, пусть <img src="https://habrastorage.org/getpro/habr/formulas/bfd/65a/74d/bfd65a74de356945ba7db1a6899f9f76.svg" alt="$\alpha = 0.05$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/e38/146/7f4/e381467f43d7ce7688e31b457ec4938d.svg" alt="$\beta = 0.5$" data-tex="inline"/>. А вероятности <img src="https://habrastorage.org/getpro/habr/formulas/37f/c60/2df/37fc602df17cd0b1a13d2d5521d9405b.svg" alt="$p_{0}$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/880/bcf/3aa/880bcf3aaf2ccb7df6dbf0f6cd81fd41.svg" alt="$p_{1}$" data-tex="inline"/> будут равны 0.45 и 0.55 соответственно, тогда процесс тестирования гипотез может выглядеть так:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">alpha, beta = 0.05, 0.5
A = np.log((1 - beta)/alpha)
B = np.log(beta/(1 - alpha))
p0, p1 = 0.45, 0.55

# Моделируем выборку для последовательного анализа:
samples_p0 = bernoulli.rvs(p0, size = 100, random_state=42)
# Подсчитываем количество последовательных извлечений
# из выборки:
n = np.r_[1:samples_p0.size + 1]
# подсчитываем количество успешных исходов:
u = samples_p0.cumsum()
z = n - u

stat = u * np.log(p1/p0) + z * np.log((1 - p1)/(1 - p0))

sns.lineplot(x = n, y = stat)
plt.hlines(A, 1, 100, color='g', label='$\ln A$')
plt.hlines(B, 1, 100, color='r', label='$\ln B$')

if np.any(stat > A):
        stop_n = (stat &lt; A).argmin()+ 1
else:
    if np.any(stat &lt; B):
        stop_n = (stat > B).argmin()
plt.vlines(stop_n, -1, 2.5, color='0.3', lw=2, alpha=0.5)
plt.vlines(70, -1, 2.5, color='m', lw=6, alpha=0.5)
plt.xlabel('Количество испытаний')
plt.ylabel('Статистика')
plt.title('Процесс последовательного анализа Вальда')
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ej/kw/zw/ejkwzwz__2hkdgscldvgmca570g.png"/><br/>
Фиолетовой линией обозначен объем выборки, рассчитанный по критерию Неймана-Пирсона, а серой линией обозначено количество испытаний в критерии Вальда. На графике видно, что в этом конкретном случае потребовалось гораздо меньше испытаний, чем для критерия Неймана-Пирсона. Тем не менее иногда количество испытаний может превышать количество, требуемое для критерия Неймана-Пирсона:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.hlines(A, 1, 100, color='g', label='$\ln A$')
plt.hlines(B, 1, 100, color='r', label='$\ln B$')
plt.vlines(70, -1, 2.5, color='m', lw=6, alpha=0.5)

for i in range(20):
    samples_p0 = bernoulli.rvs(p0, size = 100)
    n = np.r_[1:samples_p0.size + 1]
    u = samples_p0.cumsum()
    z = n - u
    stat = u * np.log(p1/p0) + z * np.log((1 - p1)/(1 - p0))

    #sns.lineplot(x = n, y = stat, alpha=0.9)
    if np.any(stat > A):
        stop_n = (stat &lt; A).argmin()+ 1
    else:
        if np.any(stat &lt; B):
            stop_n = (stat > B).argmin()
    sns.lineplot(x = n[:stop_n], y = stat[:stop_n], alpha=0.9)
    plt.vlines(stop_n, -1, 2.5, color='0.3', lw=2, alpha=0.7)

plt.xlabel('Количество испытаний')
plt.ylabel('Статистика')
plt.title('Процессы последовательного анализа Вальда в 20-и экспериментах')
plt.legend(loc='lower left');
</code></pre><br/>
</div>
                    </div><br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/oa/ps/rz/oapsrzmc5deznobaxlyfptyr7uy.png"/><br/>
Теперь проверим заданный уровень ошибок для α. Смоделируем 10000 последовательных анализов в предположении, что каждый посетитель может купить одну единицу товара с вероятностью равной 0.45. В этом случае мы должны всегда принимать нулевую гипотезу, но поскольку α=0.05, то критерий Вальда должен ошибаться примерно в 5% случаев:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">N = 10000
a, one_m_a = 0, 0
h_test, exper = [], []
for i in range(N):
    u, n = 0, 0
    stat = (A - B)/2
    while B &lt; stat &lt; A:
        n += 1
        u += bernoulli.rvs(p0)
        z = n - u
        stat = u * np.log(p1/p0) + z * np.log((1 - p1)/(1 - p0))
        if stat > A:
            a +=1
            h_test.append(0)
        if stat &lt; B:
            one_m_a += 1
            h_test.append(1)
    exper.append(n)
    
plt.text(-0.15, a + 100, fr'$\alpha = ${a/N:.4}', fontsize = 20)
plt.text(1-0.25, one_m_a + 100, fr'$1 - \alpha = ${one_m_a/N:.4}', fontsize = 20)
plt.title(r'Количество ошибок первого рода (верная $H_{0}$ отвергнута)')
sns.countplot(x=h_test)
plt.xticks(ticks = [0,1], labels = [r'$H_{0}$ отвергнута', r'$H_{0}$ принята'])
plt.ylim(0, N + 1000);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/qj/gy/sv/qjgysv2hmsy0ttpzyjulxsaphdq.png"/><br/>
Вообще, в силу дискретной природы некоторых распределений и произвольных вещественных значений <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/>, можно увидеть некоторое отклонение фактического количества ошибок от заданного заранее уровня. Но если взглянуть на распределение количества испытаний в экспериментах, то становятся очевидны преимущества данного метода, так как в среднем он требует около 32 экспериментов (против 70 в критерии Неймана-Пирсона):<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">sns.histplot(x=exper, discrete=True)
plt.vlines(np.mean(exper), 0, 900, color='r', label=f'{np.mean(exper):.4}')
plt.title('Распределение количества испытаний в экспериментах')
plt.xlabel('Количество испытаний в одном эксперименте')
plt.ylabel('Количество экспериментов')
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/eu/cf/bm/eucfbmsw-ppiyybjjf6ecrrznhc.png"/><br/>
Выполним ту же проверку для ошибок второго рода (<img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/>):<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">N = 10000
b, one_m_b = 0, 0
h_test, exper = [], []

for i in range(N):
    u, n = 0, 0
    stat = (A - B)/2
    while B &lt; stat &lt; A:
        n += 1
        u += bernoulli.rvs(p1)
        z = n - u
        stat = u * np.log(p1/p0) + z * np.log((1 - p1)/(1 - p0))
        if stat > A:
            b +=1
            h_test.append(0)
        if stat &lt; B:
            one_m_b += 1
            h_test.append(1)
    exper.append(n)
    
plt.text(-0.18, b + 100, fr'$1 - \beta = ${b/N:.4}', fontsize = 20)
plt.text(1-0.15, one_m_b + 100, fr'$\beta = ${one_m_b/N:.4}', fontsize = 20)
sns.countplot(x=h_test)
plt.xticks(ticks = [0,1], labels = [r'$H_{0}$ отвергнута', r'$H_{0}$ принята'])
plt.title('Количество ошибок второго рода (неверная $H_{0}$ принята)')
plt.ylim(0, N + 1000);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/b7/xr/hg/b7xrhgkjkaclaqyzzpukfvxbzua.png"/><br/>
Полученное значение <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/> так же несколько отличается от заданного, что в общем-то согласуется с теорией, но распределение количества посетителей в экспериментах компенсирует такое отклонение:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python"> sns.histplot(x=exper, discrete=True)
plt.vlines(np.mean(exper), 0, 900, color='r', label=f'{np.mean(exper):.4}')
plt.title('Распределение количества испытаний в экспериментах')
plt.xlabel('Количество испытаний в одном эксперименте')
plt.ylabel('Количество экспериментов')
plt.legend(); 
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/a4/hu/ze/a4huzebrcwlsppbb-k5-maqhoii.png"/><br/>
Большим преимуществом критерия Вальда является то, что чем сильнее мы ошибаемся в оценках параметров распределения спроса, тем меньше требуется посетителей для того, чтобы убедиться в этом. Следовательно, мы быстрее вычисляем новые оценки и на их основе определяем новую стоимость товара.<br/>
<br/>
В качестве простой демонстрации того как критерий Вальда может быть использован предположим, что нам необходимо продать какое-то ограниченное количество товара в некоторый фиксированный промежуток времени. Пусть <img src="https://habrastorage.org/getpro/habr/formulas/bb9/9dd/06b/bb99dd06bc822424df5c44ffcb2be720.svg" alt="$N = 3000$" data-tex="inline"/> — это среднее количество посетителей в рассматриваемом промежутке времени, а <img src="https://habrastorage.org/getpro/habr/formulas/619/893/974/619893974ce5e5136d1c0815bfabaed2.svg" alt="$Q = 300$" data-tex="inline"/> — это имеющееся количество единиц товара. Спрос распределен как <img src="https://habrastorage.org/getpro/habr/formulas/3fd/874/494/3fd8744949d2433267bc8216f7d09e5b.svg" alt="$N(21, 3^{2})$" data-tex="inline"/>. Поскольку истинные параметры распределения спроса нам неизвестны, то и значение оптимальной цены для нас так же является неизвестной величиной. Можно подумать, что суть задачи заключается в поиске <img src="https://habrastorage.org/getpro/habr/formulas/fb4/0fb/d4d/fb40fbd4d1af9c4c34dbc7b22033730a.svg" alt="$\textrm{Price}^{*}$" data-tex="inline"/>, но на самом деле первостепенной задачей является определение параметров спроса, а уже потом определение <img src="https://habrastorage.org/getpro/habr/formulas/fb4/0fb/d4d/fb40fbd4d1af9c4c34dbc7b22033730a.svg" alt="$\textrm{Price}^{*}$" data-tex="inline"/> на их основе.<br/>
<br/>
Для моделирования создадим несколько вспомогательных функций. <br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python"> # функция определения оптимальной цены по 
# оценкам mu и sigma:
def optim_price(q, n, mu_est, sigma_est):
    prices = np.linspace(3, 38, 2*(38-3)+1)
    p_est = norm.sf(prices, loc=mu_est, scale=sigma_est)
    prop = np.clip(n * p_est, a_min = 0, a_max=q)
    income = prices * prop
    return prices[income.argmax()] 
</code></pre><br/>
</div>
                    </div><br/>
Работает данная функция очень просто: принимает значения имеющихся оценок параметров спроса, вычисляет вероятности продажи одной единицы товара по каждой из возможных цен, а затем выбирает наилучшую из них. Данная функция может определять цену несколько выше, чем та, благодаря которой можно продать весть товар. Например, если у нас есть 10 единиц товара, и по цене 10 у.е мы можем продать все, а по цене 12 у.е. — только 9 единиц, то функция вернет 12 у.е. потому что <img src="https://habrastorage.org/getpro/habr/formulas/dd5/7a3/6e6/dd57a36e67b69440b7d3a97b1e5f6e56.svg" alt="$9\cdot12 > 10\cdot10$$" data-tex="inline"/>.<br/>
<pre><code class="python"> # функция для моделирования одного посетителя:
def visitor(price, mu, sigma):
    return int(norm.rvs(loc=mu, scale=sigma) > price) 
</code></pre><br/>
Генерируем одно значение из скрытого распределения спроса и если оно окажется больше установленной цены, то выдаем 1 — товар куплен; в противном случае выдаем 0 — товар не куплен.<br/>
<br/>
Далее, нам понадобится реализация критерия Вальда:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">def vald(vis, p_est, alpha=0.05, beta=0.5):
    A = np.log((1 - beta)/alpha)
    B = np.log(beta/(1 - alpha))
    
    p0 = p_est - 0.05
    if p0 &lt;= 0: p0 = 0.01
    p1 = p_est + 0.05
    if p1 >= 1: p1 = 0.99
    
    ln_p = np.log(p1 / p0)
    ln_1_mp = np.log((1 - p1) / (1 - p0))
    
    u = np.sum(vis)
    n = len(vis)
    z = n - u
    
    test = ln_p * u + ln_1_mp * z
    
    if test &lt;= B:
        return -1, p0, p1, test    # принимаем p0
    if test >= A:
        return 1, p0, p1, test     # принимаем p1
    if B &lt; test &lt; A:
        return 0, p0, p1, test     # продолжаем эксперимент
</code></pre><br/>
</div>
                    </div><br/>
<br/>
В данной функции мы используем имеющуюся оценку вероятности продажи одной единицы товара — <img src="https://habrastorage.org/getpro/habr/formulas/a7d/f0b/0cf/a7df0b0cf52583a7326d63832fe3d4ed.svg" alt="$p$" data-tex="inline"/> и после каждого посетителя применяем критерий Вальда, чтобы ответить на три нижеследующих вопроса:<br/>
<br/>
1. <img src="https://habrastorage.org/getpro/habr/formulas/c31/8e0/606/c318e0606625f9e246bbd1a1f13281b7.svg" alt="$p_{0} &lt; p &lt; p_{1}$" data-tex="inline"/>?<br/>
2. <img src="https://habrastorage.org/getpro/habr/formulas/ca0/537/90c/ca053790c820407b818c358aebba69da.svg" alt="$p \leqslant p_{0}$" data-tex="inline"/>?<br/>
3. <img src="https://habrastorage.org/getpro/habr/formulas/621/b81/968/621b81968021ea2576ab3165db3e8ed8.svg" alt="$p \geqslant p_{1}$" data-tex="inline"/>?<br/>
<br/>
Причем отвечать на эти вопросы мы должны с заранее заданным уровнем ошибок <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/>.<br/>
<br/>
Далее каждый раз когда мы выходим за пределы <img src="https://habrastorage.org/getpro/habr/formulas/971/be2/2ea/971be22ea4c5021440806a7348f3cabb.svg" alt="$(p_{0}; p_{1})$" data-tex="inline"/> мы должны предпринимать какие-то решения по поводу изменения цены. Несмотря на то, что оценки вероятности продажи одной единицы товара, получаемые с помощью относительных частот, испытывают очень сильные колебания из-за маленьких объемов выборок, мы все равно можем использовать эту информацию для создания оценок. По сути мы просто используем Байесовскую статистику — вычисляем вероятность получения совокупности наблюдаемых исходов в зависимости от разных предположений о параметрах спроса. Это очень накладно в вычислительном плане, зато работает:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python"># функция определения параметров нормального спроса
def masp(used_prices, u, n):
    used_prices = used_prices.reshape(used_prices.size, 1, 1)    # цены
    u = u.reshape(u.size, 1, 1)    # количество покупок
    n = n.reshape(n.size, 1, 1)    # количество посетителей
    
    mu = np.arange(15, 26)
    sigma = np.arange(1, 12)
    MU, SIGMA = np.meshgrid(mu, sigma)
    MU = np.expand_dims(MU, axis=0)
    SIGMA = np.expand_dims(SIGMA, axis=0)
    p = norm.sf(used_prices, loc = MU, scale=SIGMA)
    z = np.prod(binom.pmf(u, n, p), axis=0)
    i, j = divmod(z.argmax(), 11)
    return mu[j], sigma[i]
</code></pre><br/>
</div>
                    </div><br/>
Прежде чем переходить к моделированию процесса торговли сделаем некоторые уточнения. После установки начальной (самой первой) цены, ее коррекция происходит не на основе оценок параметров спроса, для которых пока просто не существует нужных данных, а в ручном режиме. Изменение происходит на некоторую величину, которая кажется наиболее целесообразной. В эксперименте она меняется на минимально возможное изменение цены (0.5 у.е.).<br/>
<br/>
Еще одно замечание связано с тем, что в алгоритме задается максимально возможное изменение цены. Такая мера кажется целесообразной потому, что колебания относительных частот могут иметь очень сильные отклонения, но из-за таких «флуктуаций» относительной частоты изменение цены может быть просто катастрофически неверным. В эксперименте максимальная дельта цены равна 1.5 у.е.<br/>
<br/>
Что бы провести эксперимент, создадим следующую функцию:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">def sales_model(mu, sigma, mu_0, sigma_0, Q, N, alpha=0.05, beta=0.5):
    '''
    mu, sigma - скрытые, истинные параметры спроса;
    mu_0, sigma_0 - первоначальные оценки параметров спроса;
    Q - исходное количество товара;
    N - среднее количество посетителей в рассматриваемый период времени;
    '''
    
    # Список для хранения оценок мат.ожидания 
    # распределения спроса:
    M_star = [mu_0]

    # Список для хранения оценок СКО распределения
    # спроса:
    S_star = [sigma_0]

    # Список для хранения посетителей при заданной цене:
    Visitors = []

    M = []    # количество посетителей во время тестов
    MS = []   # количество покупок
    S = []   # доход полученный при заданной цене

    # Список для хранения цен. Значение начальной цены
    # вычисляется в соответствии с нашими первоначальными
    # (теоретическими) представлениями о параметрах спроса:
    prices = [optim_price(Q, N, M_star[0], S_star[0])]

    # Список для хранеия оценок вероятностей:
    P_star = [norm.sf(prices[-1], loc=M_star[0], scale=S_star[0])]
    
    # Списки для хранения гипотетических вероятностей и теста Вальда:
    P0, P1, T = [], [], []
    
    ##################################################################

    # Начало продаж выполняемое по нашим теоретическим представлениям:

    est_flag = 0
    vis = []
    while est_flag == 0:
        N -= 1
        v = visitor(prices[-1], mu, sigma)
        if v != 0:
            Q -= 1
        vis.append(v)
        test, P0_i, P1_i, T_i = vald(vis, P_star[-1], alpha=alpha, beta=beta)
        P0.append(P0_i)
        P1.append(P1_i)
        T.append(T_i)
        if test != 0:
            est_flag = 1
            M.append(len(vis))
            MS.append(sum(vis))
            P_star.append(MS[-1] / M[-1])

            # меняем цену в соответствии с значением теста
            if test == -1:
                prices.append(prices[-1] - 0.5)
            if test == 1:
                prices.append(prices[-1] + 0.5)
    
    # вычисляем первое значение полученной прибыли:
    S.append(MS[-1]*prices[-1])
    
    ###############################

    # Основной цикл
    
    vis=[]
    while (N != 0) and (Q != 0):
        N -= 1
        v = visitor(prices[-1], mu, sigma)
        if v != 0:
            Q -= 1
        vis.append(v)
        test, P0_i, P1_i, T_i = vald(vis, P_star[-1], alpha=alpha, beta=beta)
        P0.append(P0_i)
        P1.append(P1_i)
        T.append(T_i)
        if test != 0:
            M.append(len(vis))
            MS.append(sum(vis))
            P_star.append(MS[-1] / M[-1])
            Visitors.append(vis)
            S.append(MS[-1]*prices[-1])
            est_par = masp(np.array(prices), np.array(MS), np.array(M))
            M_star.append(est_par[0])
            S_star.append(est_par[1])
            prices.append(optim_price(Q, N, M_star[-1], S_star[-1]))
            if prices[-1] - prices[-2] > 1.5:
                prices[-1] = prices[-2] + 1
            if prices[-1] - prices[-2] &lt; -1.5:
                prices[-1] = prices[-2] - 1
                
            vis = []
        if Q == 0 and len(vis) != 0:
            Visitors.append(vis)
            M.append(len(vis))
            MS.append(sum(vis))
            S.append(MS[-1]*prices[-1])
    
    return MS, M, S, prices, P_star, M_star, S_star, Visitors, P0, P1, T 
</code></pre><br/>
</div>
                    </div><br/>
Итак, проведем эксперимент исходя из следующих начальных условий: спрос распределен как <img src="https://habrastorage.org/getpro/habr/formulas/880/67f/133/88067f133f4e67e895bff596a553b89b.svg" alt="$N(21; 3^{2})$" data-tex="inline"/>, первоначальные представления о параметрах спроса (исходные оценки спроса): <img src="https://habrastorage.org/getpro/habr/formulas/f3d/153/ec5/f3d153ec5bafeb6f2790b31036abb2bc.svg" alt="$\mu = 18$" data-tex="inline"/>, <img src="https://habrastorage.org/getpro/habr/formulas/99a/b8b/347/99ab8b3476d97cf9b0b84343d98fa1cd.svg" alt="$\sigma = 1$" data-tex="inline"/>, исходное количество товара <img src="https://habrastorage.org/getpro/habr/formulas/619/893/974/619893974ce5e5136d1c0815bfabaed2.svg" alt="$Q = 300$" data-tex="inline"/>, среднее число посетителей за некоторый период времени <img src="https://habrastorage.org/getpro/habr/formulas/bb9/9dd/06b/bb99dd06bc822424df5c44ffcb2be720.svg" alt="$N = 3000$" data-tex="inline"/>, ошибки первого и второго рода: <img src="https://habrastorage.org/getpro/habr/formulas/bfd/65a/74d/bfd65a74de356945ba7db1a6899f9f76.svg" alt="$\alpha = 0.05$" data-tex="inline"/>, <img src="https://habrastorage.org/getpro/habr/formulas/c39/a08/da1/c39a08da1f07d8df6b33970c5b131305.svg" alt="$\beta = 0.1$" data-tex="inline"/>:<br/>
<pre><code class="python"> MS, M, SS, prices, P_star, M_star, S_star, Visitors, P0, P1, T = sales_model(21, 3, 18, 1, 300, 3000, 0.05, 0.1) 
</code></pre><br/>
Сначала взглянем на то, как работает последовательный анализ Вальда и как он взаимосвязан с изменением интервала <img src="https://habrastorage.org/getpro/habr/formulas/fc9/ede/a40/fc9edea400279d3bbb719fedcb9b8736.svg" alt="$[p_{0}; p_{1}]$" data-tex="inline"/>. А что бы можно было хоть что-то разглядеть построим его для первых 200 посетителей:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(P0[:200], color='g', label='$p_{0}$', zorder=11)
plt.plot(P1[:200], color='g', ls='--', label='$p_{1}$', zorder=10)
plt.plot(T[:200], color='0.3', label='test')
alpha = 0.05
beta = 0.1
A = np.log((1 - beta)/alpha)
plt.hlines(A, 0, 200, color='b', label='A')
B = np.log(beta/(1 - alpha))
plt.hlines(B, 0, 200, color='r', label='B')
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/qn/vy/q-/qnvyq-vvgl4d5kmms1zeqtebd48.png"/><br/>
Видно, что границы интервала меняются как только статистика, обозначенная черным цветом, пересекает критические значения (А — снизу, В — сверху).<br/>
<br/>
На графике ниже можно наблюдать быструю сходимость оценок параметров распределения к истинным значениям, даже с учетом того, что наши первоначальные оценки были слишком занижены:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">fig, ax = plt.subplots(nrows=1, ncols=2, figsize = (10, 5))

ax[0].plot(M_star)
ax[0].set_title('Оценка мат.ожидания спроса\n(истинное $\mu = 21$)')
ax[0].set_xlabel('Количество оценок вероятностей')
ax[0].set_ylabel('$\mu$', rotation=0, fontsize=20, labelpad=15)

ax[1].plot(S_star)
ax[1].set_title('Оценка отклонения спроса\n(истинное $\sigma = 3$)')
ax[1].set_xlabel('Количество оценок вероятностей')
ax[1].set_ylabel('$\sigma$', rotation=0, fontsize=20, labelpad=15);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/cg/1c/4j/cg1c4jiqgyzpmkgrk7qvzefwhws.png"/><br/>
Полученные оценки позволяют достичь максимально возможных значений прибыли:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(np.cumsum(SS))
plt.hlines(300*optim_price(300, 3000, 21, 3), 0, len(SS),
           color='g', label='Максимальная\nсредняя прибыль')
plt.legend(loc='center right')
plt.title('Изменение кумулятивной суммы прибыли')
plt.ylabel('Кумулятивная сумма прибыли')
plt.xlabel('Количество оценок');
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/iw/pw/bp/iwpwbpmaozkc95psos_9ppfaetw.png"/><br/>
При этом цена одной единицы товара не испытывает сильных колебаний:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(prices)
plt.hlines(optim_price(300, 3000, 21, 3), 0, len(prices),
           color='g', lw=3, alpha=0.5, zorder=100,
           label='$Price_{opt}$')
plt.title('Изменение цены 1-й единицы товара')
plt.ylabel('Цена 1-й единицы товара')
plt.xlabel('Количество оценок')
plt.legend(loc='center right');
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/p6/zc/wk/p6zcwksgwok7i8tc7bit_siypd8.png"/><br/>
Ну и напоследок, можно видеть, что алгоритм успевает продать весь товар:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(np.cumsum(MS))
plt.title('Кумулятивная сумма единиц проданного товара')
plt.ylabel('Кумулятивная сумма')
plt.xlabel('Количество оценок');
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/wh/6r/8q/wh6r8qkmyy0cqgbh0anzd2atut0.png"/><br/>
Наши первоначальные оценки параметров распределения спроса были довольно далеки от настоящих, но довольно быстро алгоритм все-таки нашел их правильные значения, и далее все продажи выполнялись по оптимальным ценам. Но самое главное в этом примере то, что благодаря критерию Вальда, мы смогли избавиться от фиксированного объема выборки, более того, благодаря параметрам <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/>, мы можем управлять статистической значимостью и мощностью выполняемого анализа. Это полезно еще и тем, что стоимость ошибок первого и второго рода может очень сильно отличаться, например, может быть гораздо выгоднее ошибиться и назначить более высокую стоимость товара, чем низкую. Так же данные параметры могут характеризовать склонность к риску, ведь если у нас есть какая-то аналитика предыдущих продаж, то мы можем сделать хорошие первоначальные оценки параметров распределения спроса, а значит можем рискнуть и с самого начала установить очень низкие значения <img src="https://habrastorage.org/getpro/habr/formulas/234/756/ba0/234756ba02fcf44c798e4e66aedb3efd.svg" alt="$\alpha$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/dde/35b/631/dde35b63133e1e49275c05ed00f4cd5d.svg" alt="$\beta$" data-tex="inline"/>. Так же данные параметры вовсе не обязаны быть статичными: допустим в начале продаж они могут быть довольно большими, а затем постепенно уменьшаться.<br/>
<br/>
В общем, как и в случае алгоритма семплирования Томпсона, представленный алгоритм на основе квантильного и последовательного анализа вовсе не являются универсальным рецептом оптимальных продаж, но принцип его работы на удивление прост и гибок, а это значит, что он может быть легко модифицирован и адаптирован под самые разные задачи. Давайте напоследок именно это и продемонстрируем.<br/>
<br/>
<b>Продажа авиабилетов при динамическом спросе</b><br/>
<br/>
Стационарный спрос характерен для большого количества товаров, но не меньшее количество товаров характеризуется нестационарным спросом. Так же следует упомянуть, что понятие «оптимальная цена» может сильно меняться в зависимости от контекста. Например, для стационарного спроса оптимальность цены может зависеть от того, чего мы хотим добиться: продавать определенное количество товара, максимизировать валовую прибыль или выручку. Все это может учитываться и при нестационарном спросе, но могут появляться дополнительные требования, например, в ходе продаж может возникнуть срочная потребность в наличных деньгах или срочной распродаже товара. В конечном счете все эти требования к оптимальности цены могут быть учтены в алгоритме. Нас же теперь интересует как модифицировать алгоритм так, чтобы он мог учитывать динамику спроса.<br/>
<br/>
Давайте снова рассмотрим какой-нибудь простой случай: пусть теперь спрос распределен как <img src="https://habrastorage.org/getpro/habr/formulas/e0a/b52/493/e0ab52493f9173988771ba36df62208e.svg" alt="$N(\epsilon t + \mu_{0}; \sigma^{2})$" data-tex="inline"/>, где <img src="https://habrastorage.org/getpro/habr/formulas/915/acb/b16/915acbb16ed63f15541d3e0bda30d453.svg" alt="$t$" data-tex="inline"/> — это время. Такая модель спроса уже очень близка к тем ситуациям, когда спрос на некоторый товар меняется со временем (не обязательно линейно), например спрос на шампанское увеличивается к новому году, а спрос на фрукты, лежащие на прилавках, падает с каждым днем, потому что они портятся. Тоже самое можно сказать про билеты на культурные мероприятия и про авиабилеты. Естественно цена на такие товары тоже не может быть стационарной, просто потому, что это не выгодно как для продавцов, так и для покупателей.<br/>
<br/>
Для большей простоты пока предположим, что нам неизвестны только <img src="https://habrastorage.org/getpro/habr/formulas/07d/b3c/ce4/07db3cce40928fd36ad7738c522b7e18.svg" alt="$\epsilon$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/4af/348/266/4af348266f7268a3ac9b46a8a0bf32ac.svg" alt="$\mu_{0}$" data-tex="inline"/>, но для эксперимента предположим, что <img src="https://habrastorage.org/getpro/habr/formulas/1a4/407/c0d/1a4407c0d32591184aa5ee93ebf16e25.svg" alt="$\epsilon = 1$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/a20/2f5/358/a202f53584475a2972a9739e8150cdb1.svg" alt="$\mu_{0} = 20$" data-tex="inline"/>. Очень трудно представить более-менее реалистичную ситуацию, при которой нам известно значение <img src="https://habrastorage.org/getpro/habr/formulas/f2d/db7/2d8/f2ddb72d8056981528ead2fc4ad89cac.svg" alt="$\sigma$" data-tex="inline"/> и неизвестно значение <img src="https://habrastorage.org/getpro/habr/formulas/4af/348/266/4af348266f7268a3ac9b46a8a0bf32ac.svg" alt="$\mu_{0}$" data-tex="inline"/>, но пока предположим, что это так и пусть <img src="https://habrastorage.org/getpro/habr/formulas/6e9/8f3/e0f/6e98f3e0fc5cfe53e3ffcaa3d03cd937.svg" alt="$\sigma=4$" data-tex="inline"/>. Допустим мы торговали некоторым товаром в течении 5 дней, т.е. <img src="https://habrastorage.org/getpro/habr/formulas/915/acb/b16/915acbb16ed63f15541d3e0bda30d453.svg" alt="$t$" data-tex="inline"/> будет следующим массивом:<br/>
<pre><code class="python">t = np.array([0, 1, 2, 3, 4])
</code></pre><br/>
В каждый из дней мы устанавливали следующие цены:<br/>
<pre><code class="python">price = np.array([23, 25, 25, 27, 28])
</code></pre><br/>
Количество посетителей в каждый из дней было таким:<br/>
<pre><code class="python">m  = np.array([40, 31, 35, 48, 50])
</code></pre><br/>
Согласно нашей модели, в каждый из дней были следующие значения мат. ожидания нормального распределения:<br/>
<pre><code class="python">mu = np.array([20, 21, 22, 23, 24]) 
</code></pre><br/>
Тогда количество проданного товара может быть очень просто смоделировано следующим образом:<br/>
<pre><code class="python">ms = np.array([np.sum(norm.rvs(mu[i], 4, m[i]) > price[i]) for i in np.r_[:5]])
ms 
</code></pre><br/>
<pre><code class="javascript">array([9, 4, 8, 9, 5]) 
</code></pre><br/>
Теперь перейдем к неизвестным параметрам <img src="https://habrastorage.org/getpro/habr/formulas/07d/b3c/ce4/07db3cce40928fd36ad7738c522b7e18.svg" alt="$\epsilon$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/4af/348/266/4af348266f7268a3ac9b46a8a0bf32ac.svg" alt="$\mu_{0}$" data-tex="inline"/>: предположим, что мы знаем более-менее реалистичные границы этих параметров, например <img src="https://habrastorage.org/getpro/habr/formulas/d62/a07/7e1/d62a077e11dcf3ba6dcc9d3a8e97e3fb.svg" alt="$\epsilon \in [0.7; 1.3]$" data-tex="inline"/> а <img src="https://habrastorage.org/getpro/habr/formulas/571/e4f/258/571e4f25876015cdf65251503d9cf1b3.svg" alt="$\mu_{0} \in [15; 25]$" data-tex="inline"/>. Тогда мы можем предположить, что <img src="https://habrastorage.org/getpro/habr/formulas/07d/b3c/ce4/07db3cce40928fd36ad7738c522b7e18.svg" alt="$\epsilon$" data-tex="inline"/> может принимать следующие значения:<br/>
<pre><code class="python">e = np.array([0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3])
</code></pre><br/>
А <img src="https://habrastorage.org/getpro/habr/formulas/4af/348/266/4af348266f7268a3ac9b46a8a0bf32ac.svg" alt="$\mu_{0}$" data-tex="inline"/> может быть любым из следующего массива:<br/>
<pre><code class="python">mu0 = np.array([15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])
</code></pre><br/>
Тогда мы можем предположить, что если <img src="https://habrastorage.org/getpro/habr/formulas/c69/f49/578/c69f495783af4e66ee11b84d4a1bccc5.svg" alt="$\epsilon_{0} = 0.5$" data-tex="inline"/> то мат. ожидание может меняться следующим образом:<br/>
<pre><code class="python">mu_e0 = e[0] * t.reshape(-1, 1) + mu0
mu_e0 
</code></pre><br/>
<pre><code class="javascript">array([[15. , 16. , 17. , 18. , 19. , 20. , 21. , 22. , 23. , 24. , 25. ],
       [15.7, 16.7, 17.7, 18.7, 19.7, 20.7, 21.7, 22.7, 23.7, 24.7, 25.7],
       [16.4, 17.4, 18.4, 19.4, 20.4, 21.4, 22.4, 23.4, 24.4, 25.4, 26.4],
       [17.1, 18.1, 19.1, 20.1, 21.1, 22.1, 23.1, 24.1, 25.1, 26.1, 27.1],
       [17.8, 18.8, 19.8, 20.8, 21.8, 22.8, 23.8, 24.8, 25.8, 26.8, 27.8]])
</code></pre><br/>
Каждый столбец в данном массиве показывает как могло бы меняться мат. ожидание с каждым днем, если бы <img src="https://habrastorage.org/getpro/habr/formulas/aaa/09b/131/aaa09b131c8a57595e96094a4c67cf3c.svg" alt="$\epsilon = \epsilon_{0} = 0.5$" data-tex="inline"/>. Теперь мы можем проверить вероятность получить имеющиеся значения количества проданных единиц товара по каждому столбцу:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">ps = norm.sf(price.reshape(5, 1), loc=mu_e0, scale=4)
PS = binom.pmf(ms.reshape(5, 1), m.reshape(5, 1), ps)
sns.heatmap(PS)
xticks_label = [f'{e[0]}t+{i}' for i in mu0]
plt.xticks(np.r_[0.5:11.5], xticks_label, rotation=60)
plt.xlabel('f(t)', fontsize=15)
plt.ylabel('t', fontsize=15, rotation=0, labelpad=10);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/5c/hp/dg/5chpdggj_8mrhhtxqmkyfijqot8.png"/><br/>
На графике можем наблюдать, что только в столбцах близких к истинному значению <img src="https://habrastorage.org/getpro/habr/formulas/4af/348/266/4af348266f7268a3ac9b46a8a0bf32ac.svg" alt="$\mu_{0}$" data-tex="inline"/> наблюдаются максимальные значения. В этом можно убедиться, если изобразить произведение вероятностей (сумму логарифмов) в каждом столбце:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">plt.plot(np.sum(np.log(PS), axis=0), marker='o')
plt.xticks(np.r_[0:11], xticks_label, rotation=60); 
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/jx/11/y7/jx11y7ridvqqx5agiyff4v2iwca.png"/><br/>
Если построить подобные графики для всех <img src="https://habrastorage.org/getpro/habr/formulas/8a7/140/859/8a71408594b9fc1df8cd8789a27751e5.svg" alt="$\epsilon_{i}$" data-tex="inline"/>, то можем наблюдать следующую картину:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">for i in e:
    mu_e0 = i* t.reshape(-1, 1) + mu0
    ps = norm.sf(price.reshape(5, 1), loc=mu_e0, scale=4)
    PS = binom.pmf(ms.reshape(5, 1), m.reshape(5, 1), ps)
    S = np.sum(np.log(PS), axis=0)
    plt.plot(S, label=f'$\epsilon$ = {round(i, 1)}')
xticks_label = [fr'$\epsilon$t+{i}' for i in mu0]
plt.xticks(np.r_[0:11], xticks_label, rotation=60)
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/lg/6h/ab/lg6habiw51lk9t8dcmduh2ytnay.png"/><br/>
На этом графике, конечно же, невозможно разглядеть максимумы, да и один эксперимент вовсе не показатель сходимости, поэтому проведем больше экспериментов и взглянем на усредненные значения максимумов отдельно:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">t = np.r_[0:10]
mu = np.r_[20:30]
res = []
for j in range(5000):
    for i in e:
        mu_e0 = i*t.reshape(-1, 1) + mu0
        price = np.arange(21, 31)
        ps = norm.sf(price.reshape(10, 1), loc=mu_e0, scale=4)
        m  = np.random.randint(25, 70, 10)
        ms = np.array([np.sum(norm.rvs(mu[k], 4, m[k]) > price[k]) for k in np.r_[:10]])
        PS = binom.pmf(ms.reshape(10, 1), m.reshape(10, 1), ps)
        S = np.sum(np.log(PS), axis=0)
        res.append([i, np.argmax(S) + 15, S.max()])
res = pd.DataFrame(res, columns=['eps', 'mu', 'val'])
sns.pointplot(x='mu', y='val', hue='eps', dodge=True, errwidth=0, palette='tab10', data=res);
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/qd/xl/bh/qdxlbhze5vrughbh1ifskokz97s.png"/><br/>
Как видим, наибольшие максимумы соответствуют значениям, которые близки к истинному значению <img src="https://habrastorage.org/getpro/habr/formulas/07d/b3c/ce4/07db3cce40928fd36ad7738c522b7e18.svg" alt="$\epsilon$" data-tex="inline"/>. Разумеется, все это не строгое доказательство, но видно, что метод действительно сходится, поэтому давайте попробуем сделать модель по продаже билетов в условиях динамического спроса. Предположим, что нам нужно продать <img src="https://habrastorage.org/getpro/habr/formulas/c36/6c6/afe/c366c6afe45292863afba99b2ae9a9fa.svg" alt="$Q = 350$" data-tex="inline"/> билетов и продажи начинаются за 100 дней до вылета. Пусть количество посетителей будет распределено как <img src="https://habrastorage.org/getpro/habr/formulas/5cf/97e/a95/5cf97ea9554c90b66fb8e74187252845.svg" alt="$N(0.65t+5,(0.18t+2)^{2})$" data-tex="inline"/>, а спрос будет распределен как <img src="https://habrastorage.org/getpro/habr/formulas/925/79b/045/92579b045e333f06fbb8f4f7647323ce.svg" alt="$N(0.125t+9300,(0.05t+1500)^{2})$" data-tex="inline"/>, при этом будем считать, что пока закон изменения отклонения со временем является известным, т.е. в ходе продаж необходимо определить только закон изменения мат. ожидания. Если смоделировать данный спрос, то он будет выглядеть следующим образом:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python"># функция для моделирования времени обращения посетителей:
def demand_t(T):
    D_mu_0, k_3 = 5, 0.65
    D_sigma_0, k_4 = 2, 0.18    
    num_day = np.r_[0: T]
    D_mu_t = k_3 * num_day + D_mu_0
    D_sigma_t = k_4 * num_day + D_sigma_0
    vis_day = norm.rvs(D_mu_t, D_sigma_t).astype(int)    
    t = np.sort(np.hstack([np.random.randint(i*1440, (i + 1)*1440, j) for i, j in zip(range(T), vis_day)]))    
    return t

# функция для моделирования одного посетителя:
def visitor(price, t):
    money_mu_t = 0.125*t + 9300
    money_sigma_t = 0.05*t + 1500
    return int(norm.rvs(money_mu_t, money_sigma_t) > price)

time_vis = demand_t(100)
money_vis = norm.rvs(0.125*time_vis + 9300, 0.05*time_vis + 1500)
plt.scatter(time_vis, money_vis, s=10)
plt.xlabel('Время от начала продаж (мин.)')
plt.ylabel('Стоимость билета (руб.)')
plt.title('Модель распределения спроса на авиабилеты'); 
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/k7/nj/mk/k7njmksq1ufzxlvxu03i51d0qik.png"/><br/>
По оси ординат отложена максимальная стоимость билета, выше которой посетитель не может совершить покупку. Допустим, что нам необходимо обеспечить равномерную продажу авиабилетов, т.е. на всем периоде продаж должны иметься доступные для покупки авиабилеты. Данное требование означает, что мы должны изменять цену так, чтобы вероятность продажи одного билета была неизменной на протяжении всего периода продаж. Для этого мы можем создать следующую простую функцию:<br/>
<pre><code class="python">def p_prog(q, D_est, mu_est, sigma_est):
    p_star = q / D_est
    price_star = norm.interval(1 - 2*p_star, loc=mu_est, scale=sigma_est)[1]
    return p_star, price_star
</code></pre><br/>
Благодаря этой функции мы будем оценивать прогнозируемую вероятность продажи одного билета на ближайшие сутки, а так же выяснять стоимость билета, на основе имеющихся оценок параметров и прогнозируемого количества посетителей. Теперь осталось определить всего две функции: одну для прогнозирования количества посетителей в ближайшие сутки (на основе простой линейной регрессии):<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">def dem_prog(vis_times):
    if vis_times[-1] >= 5*1440:
        idx = int(vis_times[-1]/1440)
        dem_of_day = [np.sum((vis_times > i*1440) &amp; (vis_times &lt;= (i + 1)*1440)) for i in range(idx)]
        t = np.arange(1, idx+1)*1440
        reg = np.poly1d(np.polyfit(t, dem_of_day, 1))
        D_prog = reg(vis_times[-1] + 1440)
        return D_prog
    else:
        return 10
</code></pre><br/>
</div>
                    </div><br/>
И еще одну для оценки параметров распределения спроса:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">from scipy import optimize
def k_mu_est(T, V, pt):
    buy = np.hstack(V)
    t = np.hstack(T)

    def func(x):
        money_mu_t = x[0]*t + x[1]
        money_sigma_t = 0.05*t + 1500
        p = norm.sf(pt, money_mu_t, money_sigma_t)
        z = np.sum(np.log(bernoulli.pmf(buy, p)))
        return -z
    
    x0=np.array([K[-1], MU[-1]])
    bounds = [(0, 1), (8800, 9800)]
    result = optimize.minimize(func,x0=x0,bounds=bounds, method='Powell',
                               options={'maxiter':100000})
    return result['x']
</code></pre><br/>
<pre><code class="python"># Количество билетов:
Q = 350

# Генерируем время посещения:
vt = demand_t(100)

# Начальная цена и список для хранения цен в 
# момент времени t:
prices, prices_t = [9500], []

# Первоначальные оценки вероятности продажи одного
# билета, и параметров функции мат. ожидания:
P_est, K, MU = [0.35], [0.11], [9100]

# Количество покупок и посетителей при заданной цене:
U, N = [], []

# купил или не купил посетитель билет по заданной цене
# и время обращения:
vis, vis_t = [], []
V, T = [], []

S = []

##################################################################
# Начало продаж выполняемое по нашим теоретическим представлениям:

est_flag = 0
i = 0
while est_flag == 0:
    vis_t.append(vt[i])
    prices_t.append(prices[-1])
    vis.append(visitor(prices[-1], vt[i]))
    if vis[-1] == 1:
        Q -= 1
    test = vald(vis, P_est[-1])[0]
    if test != 0:
        est_flag = 1
        U.append(sum(vis))
        N.append(len(vis))
        V.append(vis)
        T.append(vis_t)
        P_est.append(U[-1]/N[-1])
        S.append(U[-1]*prices[-1])
        # меняем цену в соответствии с значением теста
        if test == -1:
            prices.append(prices[-1] - 150)
        if test == 1:
            prices.append(prices[-1] + 150)
    i += 1

##################################################################
# Основной цикл:
    
vis = []
vis_t = []    
for i in range(i, len(vt)):
    vis_t.append(vt[i])
    prices_t.append(prices[-1])
    vis.append(visitor(prices[-1], vt[i]))
    if vis[-1] == 1:
        Q -= 1
    test = vald(vis, P_est[-1])[0]
    if test != 0:
        U.append(sum(vis))
        N.append(len(vis))
        S.append(U[-1]*prices[-1])
        V.append(vis)
        T.append(vis_t)
        k_est, mu_est = k_mu_est(T, V, prices_t)
        K.append(k_est)
        MU.append(mu_est)
        mu_prog = K[-1]*(vis_t[-1]+1440) + MU[-1]
        sigma_prog = 0.05*(vis_t[-1]+1440) + 1500
        D = dem_prog(vt[:i])
        q = Q/(100-(vis_t[-1])/1440)
        p_est, price = p_prog(q, D, mu_prog, sigma_prog)
        P_est.append(p_est)
        if abs(price - prices[-1]) &lt;= 200:
            prices.append(prices[-1])
        else:
            prices.append(price)
        vis = []
        vis_t = []
    if Q == 0:
        if len(vis) != 0:
            U.append(sum(vis))
            N.append(len(vis))
            V.append(vis)
            T.append(vis_t)
            S.append(U[-1]*prices[-1])
        break
</code></pre><br/>
</div>
                    </div><br/>
Взглянем как менялись выручка, стоимость билета и количество проданных билетов:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">f, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 3))
ax1.plot(np.cumsum(np.array(SS)/1000))
ax1.set_title('Выручка (млн. руб.)')
ax2.plot(prices)
ax2.set_title('Цена (тыс. руб.)')
ax3.plot(np.cumsum(U))
ax3.set_title('Проданных билетов')
ax3.set_yticks(np.r_[0:400:50]); 
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/io/os/mo/ioosmopa5kcdcm0b0q1vvvt1ri4.png"/><br/>
Это неплохой результат, который, кстати, был обеспечен не такими уж точными оценками параметров:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">f, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4))
ax1.plot(MU)
ax1.set_title(r'Изменение оценок $\mu_{0}$')
ax2.plot(K)
ax2.set_title(r'Изменение оценок $k_{1}$');
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/a_/ne/xl/a_nexlfbemxcmwdtghpfq4kdcyu.png"/><br/>
Можно еще раз задаться вопросом: зачем вообще нужен критерий Вальда? Ведь если выполнять квантильный анализ после каждого 25-го посетителя, то можно добиться практически тех же самых результатов:<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/cz/kk/ig/czkkigb31oszjoboakba3ury90u.png"/><br/>
Критерий Вальда нужен лишь для того, что бы задать уровень статистической значимости выводов о том где сейчас находится вероятность продажи одной единицы товара. Например, если мы склонны доверять имеющейся аналитике о параметрах распределения спроса, то можем значительно снизить уровни ошибок первого и второго рода, что будет равносильно увеличению фиксированного количества посетителей после которого выполняется квантильный анализ: <br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ke/w4/cw/kew4cwbfxzwwcmc87csag1f-1nq.png"/><br/>
В данном случае мы можем наблюдать некоторое уменьшение выручки и уменьшение количества изменений цены (из-за которого, во многом, и произошло снижение выручки). Фактически, критерий Вальда даже не участвует в формировании цены, которым занимается квантильный анализ и нужен лишь для того, что бы определить частоту его выполнения. В критерии Неймана-Пирсона эта частота является фиксированной, но в критерии Вальда она зависит от величины ошибки, т.е. чем ошибочнее изменение цены, тем скорее оценка вероятности продажи одной единицы товара покинет зону безразличия, а значит мы скорее отреагируем на эту ошибку и попытаемся ее исправить. В данном примере трудно продемонстрировать достоинство такого поведения, потому что спрос хоть и является динамическим, но имеет стационарные приращения. Тем не менее, такая особенность критерия Вальда может оказаться особенно полезной для динамического спроса с нестационарными приращениями.<br/>
В определенной степени, уровни ошибок первого и второго рода в критерии Вальда можно отнести к классу гиперпараметров, т.е. параметров которые подбираются эмпирически. <br/>
Конечно, это крайне искусственный и очень простой пример, призванный показать, что критерий Вальда и квантильный анализ могут быть применены для динамического спроса. По мере приближения моделей к реальным условиям их сложность сильно возрастает. Например, выше мы договорились, что закон изменения отклонения с течением времени считается известным, но как быть если и он является неизвестным? Ответ на этот вопрос проще продемонстрировать. Предположим, что спрос зависит от времени и распределен как <img src="https://habrastorage.org/getpro/habr/formulas/459/2e6/c32/4592e6c32cb5645e058d730f7f6ee87b.svg" alt="$N(k_{1}t+\mu_{0}, (k_{2}t+\sigma_{0})^{2})$" data-tex="inline"/>. Пусть <img src="https://habrastorage.org/getpro/habr/formulas/5ec/549/a0a/5ec549a0ae995aeaee0eabc57515744d.svg" alt="$k_{1} = 0.5$" data-tex="inline"/>, <img src="https://habrastorage.org/getpro/habr/formulas/b7a/74f/7a9/b7a74f7a9c1990ee3d87da166fc397a7.svg" alt="$k_{2} = 0.1$" data-tex="inline"/>, <img src="https://habrastorage.org/getpro/habr/formulas/e8b/167/49e/e8b16749e99dda97509dbc07ee5e03b3.svg" alt="$\mu_{0} = 10$" data-tex="inline"/> и <img src="https://habrastorage.org/getpro/habr/formulas/b4f/7dd/211/b4f7dd2118d5d0ef16f999d9fdeed89e.svg" alt="$\sigma_{0} = 5$" data-tex="inline"/>, тогда распределение 100000 посетителей будет выглядеть следующим образом:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">t = np.random.randint(0, 100, 100000)
mu = 0.5*t + 10
sigma = 0.1*t + 5
data = norm.rvs(mu, sigma)
sns.histplot(data)
plt.xlabel('Количество денег которое посетитель готов отдать за товар');
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/lc/_z/4z/lc_z4zuljru-vmul0y5osmisq3a.png"/><br/>
Данное распределение является смесью (суммой) бесконечного количества нормальных распределений и может быть задано следующим образом:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">def norm_mix(mu0, sigma0, k1, k2):
    t = np.arange(0, 100)
    mu = k1*t + mu0
    sigma = k2*t + sigma0
    x = np.c_[np.linspace(-20, 120, 300)]
    y = norm.pdf(x, mu, sigma)
    y = y.sum(axis=1)
    y = y/np.trapz(y)
    return x, y
plt.plot(*norm_mix(10, 5, 0.5, 0.1));
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/4g/xv/na/4gxvna3ct1wtuuwezmlryuuuvcy.png"/><br/>
Это распределение является двухпараметрическим, т.е. оно так же как и нормальное распределение имеет параметры смещения и масштаба, но помимо них обладает еще двумя параметрами формы — <img src="https://habrastorage.org/getpro/habr/formulas/d42/43a/637/d4243a637259458b5bdb16df941a48c1.svg" alt="$k_{1}$" data-tex="inline"/>, <img src="https://habrastorage.org/getpro/habr/formulas/0ea/551/526/0ea551526006921e2da3a705b2a8d04f.svg" alt="$k_{2}$" data-tex="inline"/>:<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Python</b>
                        <div class="spoiler_text"><pre><code class="python">mu0 = [10, 10, 25, 25]
sigma0 = [5, 10, 5, 10]
k1 = [0.5, 0.2, 0.5, 0.7]
k2 = [0.1, 0.3, 0.1, 0.05]
for i in range(4):
    plt.plot(*norm_mix(mu0[i], sigma0[i], k1[i], k2[i]),
             label=fr'$k_{1} = {k1[i]}$, $k_{2} = {k2[i]}$, $\mu_{0} = {mu0[i]}$, $\sigma_{0} = {sigma0[i]}$');
plt.legend();
</code></pre><br/>
</div>
                    </div><br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ye/l6/sb/yel6sbzgnt9fo81ixldd3q_bemq.png"/><br/>
Если не рассматривать только фиксированные временные интервалы (например для вышеприведенного графика все распределения построены для <img src="https://habrastorage.org/getpro/habr/formulas/8b2/c9b/86b/8b2c9b86b6d2346947ae10f78df31c73.svg" alt="$t \in [0, 100]$" data-tex="inline"/>), то границы интервалов так же будут влиять на форму распределений. Данное распределение может быть использовано в квантильном анализе, точно так же как выше использовалось нормальное. Причем мат. ожидание и отклонение вовсе не обязаны меняться со временем линейно, изменение может быть ускоренным или иметь другой более сложный вид. В общем случае, если мат. ожидание и отклонение модели спроса задаются как функции от времени, то вся задача сводится к оценке постоянных коэффициентов функций. Иными словами, оценка параметров по-прежнему опирается на Байесовский метод, просто количество измерений условных вероятностей теперь будет равно общему количеству параметров модели спроса.<br/>
<br/>
<b>В заключение</b><br/>
<br/>
Если несколько раз (в данном случае 50) сравнивать работу данного алгоритма с текущим положением дел в ценообразовании авиабилетов, то картина получается следующая: <br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/82/ce/eu/82ceeuuvmlnofgm8xpkuv5fjkg0.png"/><br/>
Линиями показаны мат. ожидания, а доверительные интервалы — это стандартные отклонения.<br/>
<br/>
В данном случае под текущим положением дел понимается единственная и простейшая стратегия которая сейчас используется — ручное управление. С одной стороны может показаться, что такую стратегию практически невозможно смоделировать с учетом всей ее <a href="https://habr.com/ru/post/506240/">сложности</a>. Однако, с определенной «высоты» (и с точки зрения конечного потребителя), вся эта система ведет себя как единственный продавец, который понимает все механизмы только на интуитивном уровне. Поскольку, в качестве цели мы ставили условие максимизации выручки при постоянном наличии билетов в продаже и их полной реализации, то все, что может делать данный продавец — менять цену, пытаясь выровнять скорость продажи билетов с учетом их оставшегося количества. В данном случае «менять цену» означает «угадать цену», т.е. изменение цены является случайной величиной из равномерного распределения, границы которого подобраны так, что бы стратегия удовлетворяла целевым условиям. Вот такая модель текущего положения дел.<br/>
<br/>
Опять же, такое сравнение нельзя назвать абсолютно корректным, но оно дает возможность хотя бы приблизительно оценить прирост выручки обеспеченный ценообразованием на основе квантильного анализа, который можно оценить интервалом от 25% до 35%. Эти цифры вовсе неудивительны, поскольку в режиме ручного управления просто невозможно постоянно угадывать самую оптимальную цену. В случае единичных продаж без ручного управления не обойтись, но когда речь идет о масштабе целой авиакомпании — оно становится серьезным недостатком, который заставляет завышать стоимость билетов и терпеть серьезные убытки.<br/>
<br/>
Вся данная статья базируется на одной простой гипотезе о том, что спрос имеет нормальное распределение. Казалось бы, на том же самом Kaggle полно данных по онлайн торговле и можно легко доказать или опровергнуть эту гипотезу. Но это не было целью данной статьи, так как проблема вовсе не в этом. Здесь мы хотели упрощенно продемонстрировать те подходы, которые используем при решении оптимизационных задач. В своем кругу мы иногда шутим, говоря, что статистическое управление — это то же самое, что управление автомобилем по зеркалу заднего вида, причем довольно маленькому и заляпанному. Ведь смысл оптимального управления заключается не только в том, чтобы найти лучшую стратегию, но еще и в том что бы выполнять ее оптимальную коррекцию на основе поступающих данных о спросе. Как раз коррекция и является самым слабым местом в управлении.<br/>
<br/>
Безусловно, задача динамического ценообразования крайне актуальна для отрасли гражданских авиаперевозок, но как уже говорилось выше, даже если предположить, что у нее есть самое оптимальное решение, то от него все равно не будет никакого толка, если авиакомпания выполнит неоптимальную расстановку авиапарка или выберет для него неоптимальные маршруты. Представленный алгоритм ценообразования, при самых оптимистичных оценках позволяет добиться лишь 10%-го увеличения прибыли в сравнении с алгоритмом сэмплирования Томпсона. Это может показаться хорошим результатом, но на самом деле, если принять во внимание <a href="https://iz.ru/1210338/maksim-talavrinov/prolet-normalnyi-pochemu-aviabilety-po-rossii-podesheveli-na-30" rel="nofollow noopener noreferrer">текущее положение дел</a> глобальных логистических процессов, то эти 10% всего лишь <a href="https://www.youtube.com/watch?v=7iF-xM30rXk" rel="nofollow noopener noreferrer">капля в море</a> той прибыли, которая упускается всеми игроками. Поэтому в следующей статье мы постараемся рассмотреть модели оптимизации использования судов, планирования расписания и формирования ценообразования как единую задачу.</div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%5D" class="tm-tags-list__link">математика</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D0%B2%D0%B8%D0%B0%D1%86%D0%B8%D1%8F%5D" class="tm-tags-list__link">авиация</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%82%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%BE%D1%80%D1%82%5D" class="tm-tags-list__link">транспорт</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%86%D0%B5%D0%BD%D0%BE%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">ценообразование</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B5-commerce%5D" class="tm-tags-list__link">е-commerce</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%5D" class="tm-tags-list__link">алгоритмы</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B1%D0%B8%D0%BB%D0%B5%D1%82%D1%8B%5D" class="tm-tags-list__link">билеты</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Brms%5D" class="tm-tags-list__link">rms</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D1%80%D0%BE%D0%B4%D0%B0%D0%B6%D0%B8%5D" class="tm-tags-list__link">продажи</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D0%B2%D0%B8%D0%B0%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B7%D0%BA%D0%B8%5D" class="tm-tags-list__link">авиаперевозки</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/algorithms/" class="tm-hubs-list__link">
    Алгоритмы
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/maths/" class="tm-hubs-list__link">
    Математика
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/ecommerce_development/" class="tm-hubs-list__link">
    Разработка под e-commerce
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/ecommerce/" class="tm-hubs-list__link">
    Управление e-commerce
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/transport/" class="tm-hubs-list__link">
    Транспорт
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 7: ↑7 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 7: ↑7 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+7</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">2.6K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    47
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/AndreyKotlov/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/4aa/37a/985/4aa37a9857149222324ccb5f9e4e68c4.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 11 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    11
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">7</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Andrey</span> <a href="/ru/users/AndreyKotlov/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @AndreyKotlov
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Создаю системы</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/580782/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментировать 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/580782/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/580782/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"580782":{"id":"580782","timePublished":"2021-10-15T21:29:30+00:00","isCorporative":false,"lang":"ru","titleHtml":"Логистика. Часть 3. Еще одна модель динамического ценообразования","leadData":{"textHtml":"Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более оптимальное решение. Примерно так и получилось с \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F506240\u002F\"\u003Eзадачей динамического ценообразования для авиабилетов\u003C\u002Fa\u003E, которую мы описывали более года назад в прошлой статье. Решение основывалось на алгоритме семплирования Томпсона. Компьютерное моделирование продаж показывало превосходные результаты, а тот факт, что такие гиганты как Walmart и Amazon уже давным давно и более чем успешно используют различные модификации этого алгоритма, только укрепляло уверенность в том, что мы на верном пути и иных способов оптимального решения задачи просто нет. Но в подавляющем большинстве случаев то, что отлично и везде работает, в авиаотрасли должно работать лучше. Не потому что так хочется, а потому что в этом действительно есть сильная потребность. Должно быть меньше экспериментов с ценой, она не должна меняться очень часто, а сам процесс поиска оптимальной цены должен быть еще быстрее. Но самое главное, алгоритм семплирования Томпсона не позволяет получить более-менее адекватную вероятностную модель спроса, без которой невозможно в полной мере использовать стохастическое программирование и заняться задачами глобальной оптимизации.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F13\u002Flo\u002Fwx\u002F13lowxkxgxz91jd26oqjz9zw6nm.jpeg\"\u003E\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":11,"votesCount":11},"rating":7,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"226201","alias":"AndreyKotlov","fullname":"Andrey","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F4aa\u002F37a\u002F985\u002F4aa37a9857149222324ccb5f9e4e68c4.jpg","speciality":"Создаю системы"},"statistics":{"commentsCount":0,"favoritesCount":47,"readingCount":2566,"score":7,"votesCount":7},"hubs":[{"relatedData":null,"id":"8000","alias":"algorithms","type":"collective","title":"Алгоритмы","titleHtml":"Алгоритмы","isProfiled":true},{"relatedData":null,"id":"17812","alias":"maths","type":"collective","title":"Математика","titleHtml":"Математика","isProfiled":true},{"relatedData":null,"id":"18810","alias":"ecommerce_development","type":"collective","title":"Разработка под e-commerce","titleHtml":"Разработка под e-commerce","isProfiled":true},{"relatedData":null,"id":"20716","alias":"ecommerce","type":"collective","title":"Управление e-commerce","titleHtml":"Управление e-commerce","isProfiled":true},{"relatedData":null,"id":"22004","alias":"transport","type":"collective","title":"Транспорт","titleHtml":"Транспорт","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"3","alias":"management","title":"Менеджмент"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003EБывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более оптимальное решение. Примерно так и получилось с \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F506240\u002F\"\u003Eзадачей динамического ценообразования для авиабилетов\u003C\u002Fa\u003E, которую мы описывали более года назад в прошлой статье. Решение основывалось на алгоритме семплирования Томпсона. Компьютерное моделирование продаж показывало превосходные результаты, а тот факт, что такие гиганты как Walmart и Amazon уже давным давно и более чем успешно используют различные модификации этого алгоритма, только укрепляло уверенность в том, что мы на верном пути и иных способов оптимального решения задачи просто нет. Но в подавляющем большинстве случаев то, что отлично и везде работает, в авиаотрасли должно работать лучше. Не потому что так хочется, а потому что в этом действительно есть сильная потребность. Должно быть меньше экспериментов с ценой, она не должна меняться очень часто, а сам процесс поиска оптимальной цены должен быть еще быстрее. Но самое главное, алгоритм семплирования Томпсона не позволяет получить более-менее адекватную вероятностную модель спроса, без которой невозможно в полной мере использовать стохастическое программирование и заняться задачами глобальной оптимизации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002F13\u002Flo\u002Fwx\u002F13lowxkxgxz91jd26oqjz9zw6nm.jpeg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F13\u002Flo\u002Fwx\u002F13lowxkxgxz91jd26oqjz9zw6nm.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EРаспределение спроса вместо кривой спроса\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПереосмысление подхода к решению задачи началось, когда один из членов команды обратил внимание на предпринимателей розничной торговли, которые открывают социальные магазины. Это своеобразная форма благотворительности, которая заключается в том, что в магазине нет продавца, вместо которого есть что-то вроде ящика для пожертвований. В таком магазине можно взять любой товар с полки и самостоятельно решить сколько денег за него отдать. Все это конечно любопытно и наталкивает на множество размышлений, но примечательно то, что в подобных магазинах обычная кривая спроса превращается в некоторое распределение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧто бы продемонстрировать это, а также все дальнейшие примеры мы будем использовать язык Python, поэтому сразу сделаем все необходимые импорты:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport numpy as np\nnp.random.seed(42)\nimport pandas as pd\nfrom scipy import stats\nfrom scipy.stats import norm, binom, bernoulli, poisson, beta\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\nrcParams['figure.figsize'] = 10, 6\n%config InlineBackend.figure_format = 'svg'\nimport seaborn as sns\nsns.set()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nУ нас нет данных о том сколько денег каждый посетитель подобного магазина платил за какой-то отдельно взятый товар, но это не помешает нам немного поразмышлять в этом направлении. Например, в знаменитом наборе данных tips отражена схожая ситуация, в которой посетителям ресторана нужно было самостоятельно принять решение о размере чаевых. Вряд ли в меню ресторана было большими красными буквами указано требование о том, что размер чаевых должен составлять 20% от стоимости заказа, но если взглянуть на график, то мы увидим, что значительная часть посетителей старается следовать этому негласному правилу:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Etips = sns.load_dataset('tips')\nsns.relplot(x='total_bill', y='tip', data=tips);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fr2\u002Foi\u002Fnu\u002Fr2oinulcws61uxqdhmplxbq-i1u.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nВ какой-то мере это негласное правило можно считать социальной нормой. В любом случае, схожий механизм работает и в социальных магазинах: какая-то часть посетителей руководствуется чувством справедливости и старается платить столько, сколько указано на ценнике товара. В наборе данных tips можно оценить влияние других факторов на размер чаевых: день недели, время суток, пол человека, оплачивающего счет, или количество людей в группе, выполнившей заказ. Очевидно, что каждый посетитель социального магазина, так же может руководствоваться множеством самых разных факторов: уровень дохода и наличие работы, количество человек в семье, торопится он на данный момент или нет, есть кто-нибудь рядом или нет и т.д. По центральной предельной теореме распределение спроса на товар в таких магазинах можно считать предельно нормальным.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли взять какой-нибудь конкретный товар в магазине без продавца, на ценнике которого указана стоимость в 12 рублей, то распределение спроса на него вполне могло бы выглядеть так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eprices = np.r_[0: 35]\nmu, sigma = 12, 5\ndemand = norm.rvs(mu, sigma, 1200)\nsns.histplot(x=demand[demand \u003E 0], discrete=True)\nplt.title('Распределение спроса на некоторый товар в магазине без продавца', fontsize=15)\nplt.xlabel('Цена', fontsize=15)\nplt.ylabel('Количество покупок', fontsize=15, labelpad=10);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fq5\u002Ffm\u002Fpy\u002Fq5fmpy1cwt6dbhp-je3czfznqgc.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nНа самом деле мы можем лишь гадать как в действительности мог бы выглядеть этот график, так как у нас нет реальных данных. Но эти размышления наталкивают на мысль о том, что у спроса действительно должно быть какое-то распределение и, скорее всего, оно должно быть нормальным. В тоже самое время, если это действительно так, то это неизбежно должно приводить к тому, что какая-то часть распределения может оказаться в области отрицательных цен. Например, если бы мы опросили всех потенциальных покупателей некоторого города «A» о том, сколько они готовы заплатить за авиабилеты в город «B», ничего им не сообщая о его истинной стоимости, то вполне могли бы получить следующий результат:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E prices = np.r_[-10: 35]\nmu, sigma = 12, 5\ndemand = norm.rvs(mu, sigma, 10000)\nsns.histplot(demand, discrete=True)\nplt.title('Распределение спроса в городе \"A\" на авиабилеты в город \"B\"', fontsize=15)\nplt.xlabel('Цена (тыс. рублей)', fontsize=15)\nplt.ylabel('Количество ответов', fontsize=15, labelpad=10); \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fla\u002Fxg\u002Fpp\u002Flaxgppn5h_xol4i8v0tpzdxaoco.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nС одной стороны, принятие во внимание отрицательных цен выглядит нелогичным и даже комичным. С другой стороны, вряд ли какая-то значительная часть читателей согласится слетать на выходные в Афганистан, даже если авиакомпания предложит за перелет приличную сумму денег. Так и во многих сферах коммерческой деятельности возможны ситуации, когда компании выгодно продавать свой товар или услуги по отрицательным ценам, чем не продавать вовсе. К примеру товар, который имеет ограниченный срок годности, после которого он должен быть утилизирован (бытовая химия, косметика, продукты питания) – компании проще отдать бесплатно или немного доплатить покупателям, чем оплачивать стоимость транспортировки и утилизации в дальнейшем. Попытка сэкономить и не утилизировать товар может привести к увеличению общих затрат компании, т.к. бесконечно хранить у себя на складах такие товары не получится. Это увеличивает стоимость логистик (складской), да и ресурсы складов не бесконечны. О примере продажи товаров с отрицательной ценой каждый слышал: цена нефти Brent опустилась ниже 0 в 2020 году. Но вернемся к распределению спроса: вовсе не обязательно, что какая-то часть спроса должна находиться в области отрицательных цен, но это действительно возможно, хотя бы потому что всегда могут найтись люди, которым определенный товар будет не нужен даже за значительную доплату.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли спрос распределен нормально, то мы можем легко получить кривую спроса, для чего нужно просто начать продавать товар. Да, при более точном рассмотрении, обладая большим набором данных, мы можем прийти к тому, что спрос имеет другое распределение, но в первом приближении большинство методологий рекомендует начинать с нормального распределения, а дальше уже уточнять более сложными распределениями.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПредставим совсем нереалистичную ситуацию, в которой некоторая авиакомпания решила найти оптимальную стоимость авиабилетов из «A» в «B». Не реалистичность будет заключаться в том, что спрос на авиабилеты будет стационарным, а в авиакомпании решили пойти на беспрецедентный эксперимент — изменять стоимость билетов от 0 до 25 тысяч рублей, увеличивая значение цены на 1 тысячу рублей после каждых 2000 тысяч посетителей. После такого эксперимента, можно было бы наблюдать следующую картину:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E np.random.seed(42)\nprices = np.r_[0: 25]\nmu, sigma = 12, 5\ndemand = [np.sum(norm.rvs(mu, sigma, 2000) \u003E price) for price in prices]\nplt.bar(prices, demand, alpha=0.6)\nplt.plot(prices, demand, 'ro-', lw=3, label='Кривая спроса')\nplt.title('Распределение спроса на авиабилеты из \"A\" в \"B\"', fontsize=15)\nplt.xlabel('Цена одного билета (тыс. рублей)', fontsize=15)\nplt.ylabel('Количество покупок', fontsize=15, labelpad=10)\nplt.legend(); \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fz0\u002Fbi\u002Fpt\u002Fz0biptmarht6jxhsqiedcpbecpm.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nОптимальную цену авиабилета можно было бы найти исходя из максимизации выручки, обозначим \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fb87\u002Fc43\u002F419\u002Fb87c4341953d9930499c99cfd4f7de89.svg\" alt=\"$i$\" data-tex=\"inline\"\u002F\u003E -ю цену как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Faf3\u002F360\u002Fe5a\u002Faf3360e5a8f861c3f0dc6097396caba5.svg\" alt=\"$\\textrm{price}_{i}$\" data-tex=\"inline\"\u002F\u003E а спрос при данной цене (количество купленных авиабилетов) как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F712\u002F5c7\u002F7f7\u002F7125c77f701219f0ea40d62e1e6dfb20.svg\" alt=\"$d_{i}$\" data-tex=\"inline\"\u002F\u003E, тогда для максимизации выручки нам нужно найти такую цену \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fd51\u002F0ff\u002F0b5\u002Fd510ff0b5084ee6b6886523588fd9316.svg\" alt=\"$\\textrm{price}^{*}$\" data-tex=\"inline\"\u002F\u003E при которой произведение \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Faf3\u002F360\u002Fe5a\u002Faf3360e5a8f861c3f0dc6097396caba5.svg\" alt=\"$\\textrm{price}_{i}$\" data-tex=\"inline\"\u002F\u003E на \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F712\u002F5c7\u002F7f7\u002F7125c77f701219f0ea40d62e1e6dfb20.svg\" alt=\"$d_{i}$\" data-tex=\"inline\"\u002F\u003E окажется самым большим, то есть\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fd76\u002Fa4f\u002F87a\u002Fd76a4f87a47846d29dd9758f30070dbf.svg\" alt=\"$\\textrm{price}^{*} = \\underset{\\textrm{price}}{\\textrm{argmax}} \\; \\textrm{price}_{i} \\times d_{i},$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nчто можно изобразить на следующем графике:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(prices, demand*prices, 'bo', lw=3)\nplt.vlines(prices, 0, demand*prices)\nplt.title('Зависимость выручки от цены', fontsize=15)\nplt.xlabel('Цена одного авиабилета (тыс. рублей)', fontsize=15)\nplt.ylabel('Выручка (тыс. рублей)', fontsize=15, labelpad=10);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fav\u002F-3\u002F8g\u002Fav-38gdtwkdubh30dypemgnpk9o.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЕсли бы в авиакомпании взглянули на этот график, то вполне могли бы решить, что оптимальная цена авиабилетов составляет 10 тысяч рублей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо что если бы в авиакомпании изначально знали, о том что спрос на билеты распределен как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe45\u002F275\u002F2e5\u002Fe452752e5729a1c7416345ef63bc4df0.svg\" alt=\"$N(12, 5^{2})$\" data-tex=\"inline\"\u002F\u003E? Очевидно, что в этом случае они могли бы вычислить вероятность покупки одного билета при его определенной стоимости. Обозначим количество денег которое покупатель готов заплатить за один билет символом \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F096\u002Fed7\u002F65c\u002F096ed765c8bbbc1f1e34d3b19d3550ed.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E, тогда вероятность того, что покупатель его купит можно вычислить по следующей формуле:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc56\u002F240\u002Fe10\u002Fc56240e100662324ed83f17092ee9fa2.svg\" alt=\"$P(X \\geqslant \\textrm{price}_{i}) = 1 - P(X &lt; \\textrm{price}_{i}) = 1 - \\int_{-\\infty }^{\\textrm{price}_{i}}f(x)d x,$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nгде \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fff9\u002Fde2\u002F94e\u002Fff9de294e6aca9810aed4f3eebd4d2bc.svg\" alt=\"$f(\\textrm{x})$\" data-tex=\"inline\"\u002F\u003E — функция плотности вероятности нормального распределения, а \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F4cc\u002Ffd4\u002F32e\u002F4ccfd432ea4f2a64f3a5c8c7378517af.svg\" alt=\"$x$\" data-tex=\"inline\"\u002F\u003E — пробегает по всем допустимым значениям цен. Затем, чтобы получить значение оптимальной цены, достаточно умножить полученные значения вероятностей на соответствующие им цены, то есть оптимальная цена может быть найдена как\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F637\u002Fbc1\u002F6ce\u002F637bc16ce01bbbb767d2cab3850d0420.svg\" alt=\"$\\textrm{price}^{*} = \\underset{\\textrm{price}}{\\textrm{argmax}} \\; P(X \\geqslant \\textrm{price}_{i}) \\times d_{i}.$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте изобразим это на графике:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ex = np.r_[0: 25]\ny = norm.sf(x, mu, sigma)\nplt.plot(x, y, c='r', label=r'$P(X \\geqslant p_{i})$')\nplt.plot(x, x*y, 'bo', lw=3, label=r'$P(X \\geqslant p_{i}) \\times d_{i}$')\nplt.vlines(x, 0, x*y)\nplt.xlabel('Цена одного билета (тыс. рублей)', fontsize=15)\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fhz\u002Fbb\u002Ffg\u002Fhzbbfg2imha5i1ki9v6qsw5qupe.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nПолучается, что кривая спроса может быть получена на основе распределения его плотности вероятности. Тогда возникает вполне закономерный вопрос: почему мы практически всегда пытаемся определить именно кривую спроса, но обделяем вниманием его распределение? На этот вопрос непросто ответить, но можно предположить, что пристальное внимание именно к кривой спроса обусловлено тем, что все началось в эпоху офлайн продаж, а дальше все двигалось по инерции. Например, в обычном магазине вполне возможно посчитать количество посетителей, но нет возможности оценить количество посетителей заинтересованных в каком-то конкретном товаре. В этом случае оценка вероятности продажи одной единицы конкретного товара сильно осложняется. В офлайне гораздо проще и логичнее воспринимать количество проданного товара в некоторый промежуток времени, как случайную величину из Пуассоновского распределения. Можно вообще не вести подсчет посетителей и учитывать только количество единиц проданного товара:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ef, ax = plt.subplots()\nprice = np.array([8, 10, 12, 14, 16])\nteoretic_means = 100*norm.sf(price, mu, sigma)\nlen_periods, n_periods = 20, 5\ndemand = poisson.rvs(mu=teoretic_means, size=(len_periods, n_periods))\nreal_means = demand.mean(axis=0)\ncolors = sns.color_palette('Dark2', n_periods)\nfor i in range(n_periods):\n    ax.vlines(np.r_[len_periods*i: len_periods*(i + 1)], 0,\n              demand.T[i], color=colors[i], label=str(price[i]))\n    ax.hlines(real_means[i], len_periods*i, len_periods*(i + 1)-1, color='k');\nax.legend(title='Цена (тыс. рублей)')\nplt.title('Зависимость количества проданных авиабилетов от цены', fontsize=15)\nplt.xlabel('Номер дня', fontsize=15)\nplt.ylabel('Количество', fontsize=15, labelpad=10);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fva\u002Fob\u002Fdb\u002Fvaobdbc-jpo1hpoepy47hepudim.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nНа вышеприведенном графике показано как могли бы выглядеть такие продажи авиабилетов при разной цене, где черной линией показано среднее значение продаж в каждом периоде. Именно благодаря средним значениям мы можем построить кривую спроса и определить оптимальную стоимость:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ef, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))\nax1.plot(price, real_means)\nax1.set(title='\"Кривая\" спроса', xlabel='Стоимость', ylabel='Среднее количество')\nax2.plot(price, price*real_means)\nax2.set(title='Средняя выручка', xlabel='Стоимость', ylabel='Объем выручки');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fsn\u002Fka\u002Fcg\u002Fsnkacgruttycsyvyztzkhazsttk.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nПолучается, что информация о продажах в офлайне позволяет оценивать только кривую спроса и ее недостаточно для того чтобы оценить его распределение. Но что если продажи переместятся в онлайн и теперь для того, что бы узнать стоимость некоторого товара, допустим, того же авиабилета и, уж тем более, приобрести его, придется зайти на отдельную страничку интернет-магазина (да, для авиабилета уже так происходит, но может не происходит для других товаров или услуг: к примеру, если мы говорим о b2b логистике)? Появится ли у нас информация, которой будет достаточно для оценки распределения?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДопустим страницу с авиабилетом по направлению «A-B» посетили 20 человек, если спрос распределен как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe45\u002F275\u002F2e5\u002Fe452752e5729a1c7416345ef63bc4df0.svg\" alt=\"$N(12, 5^{2})$\" data-tex=\"inline\"\u002F\u003E, то мы можем смоделировать значения случайной величины \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F096\u002Fed7\u002F65c\u002F096ed765c8bbbc1f1e34d3b19d3550ed.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E — максимальную стоимость авиабилета, которую может себе позволить посетитель:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003EX = norm.rvs(mu, sigma, 20)\nX\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003Earray([18.79350012, 17.82463618, 19.93989386, 2.45863418, 13.00361375,\u003Cbr\u002F\u003E\r\n 12.45140662, 9.19133558, 13.62229695, 10.39279135, 12.80996134,\u003Cbr\u002F\u003E\r\n 29.00937781, 13.58565382, 13.79565799, 16.10609668, 12.90322265,\u003Cbr\u002F\u003E\r\n 6.50983662, 3.76644135, 11.85354469, 10.65444486, 2.18198959])\u003Cbr\u002F\u003E\r\n\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nЕсли бы существовал какой-то волшебный способ получить такую выборку, то, даже несмотря на ее крошечный объем, можно все равно получить более-менее правдоподобные оценки параметров распределения:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eprint(f'mu = {X.mean():.3}, sigma = {X.std(ddof=1):.3}')\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003Emu = 12.5, sigma = 6.29\u003Cbr\u002F\u003E\r\n\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nНо волшебства не существует, и все что нам остается это устанавливать и менять цену, наблюдая сколько посетителей совершит или не совершит покупку. Если каждый из 20 смоделированных выше посетителей увидит, что билет стоит 11 тысяч рублей, то единственное, что мы узнаем в итоге, это то, что:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eprint(f'{sum(X \u003E= 11)} посетителей из 20 совершили покупку.')\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003E13 посетителей из 20 совершили покупку.\u003Cbr\u002F\u003E\r\n\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nКажется что цена — это просто цена, тем не менее, можно задать простой вопрос: чем цена на товар в офлайне отличается от той же самой цены в онлайне? Пусть случайная величина \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F53a\u002Fea9\u002Ff07\u002F53aea9f07ccaf30ffac7cd8719e70972.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E показывает совершил посетитель покупку или нет, т.е. принимает всего два значения: 1 — покупка совершена и 0 — покупка не совершена, тогда оценка вероятности продажи одной единицы товара, в нашем случае — авиабилета, может быть вычислена по следующей формуле:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F2fb\u002Fb7c\u002F851\u002F2fbb7c8514633d9dbc23336d18634f04.svg\" alt=\"$\\widehat{p} = P(Y = 1 \\mid \\textrm{price} = 11) = \\frac{u}{u + z} = \\frac{13}{13+7}=0.65,$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nгде \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F1d6\u002Fe3d\u002Fc60\u002F1d6e3dc60633569bb3f51249e1a4ee2c.svg\" alt=\"$u$\" data-tex=\"inline\"\u002F\u003E — это количество единиц, а \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fd31\u002F1eb\u002F78a\u002Fd311eb78a0617bccfcb9c311add8ba87.svg\" alt=\"$z$\" data-tex=\"inline\"\u002F\u003E — количество нулей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле того как мы получили оценку вероятности продажи одной единицы товара, цена перестала быть просто ценой, ведь теперь 0.45-квантиль величины \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F096\u002Fed7\u002F65c\u002F096ed765c8bbbc1f1e34d3b19d3550ed.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E равен 11 тысячи рублей, причем \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fd63\u002Faa6\u002F9de\u002Fd63aa69decbb67ddf001a6b13fc54bb6.svg\" alt=\"$1 - \\widehat{p} = 0.45$\" data-tex=\"inline\"\u002F\u003E — это оцениваемый нами уровень данного квантиля:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F082\u002F329\u002F06a\u002F08232906a2219e19d5b55fcc298988b3.svg\" alt=\"$Q_{1 - \\widehat{p}} = Q_{0.45} = 11$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗначение квантиля показывает нам с какой вероятность значение \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F096\u002Fed7\u002F65c\u002F096ed765c8bbbc1f1e34d3b19d3550ed.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E не превысит 11 тысяч рублей, по нашим скромным оценкам эта вероятность равна 0.45 (на самом деле, чтобы вписаться в определение квантиля, мы должны считать квантилем не 11, а 10.99 тысяч рублей, но это не критично в данном случае). Чем больше людей посетят страницу по продаже билетов с ценой в 11 тысяч рублей, тем точнее будут оценки квантильного уровня:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003EN = 1000\np_est = np.cumsum(norm.rvs(mu, sigma, N) \u003E 11)\u002Fnp.r_[1 : N + 1]\nplt.plot(p_est)\nplt.hlines(norm.sf(11, mu, sigma), 0, N, color='k', ls='--')\nplt.title('Изменение оценок квантильного уровня')\nplt.xlabel('Количество посетителей')\nplt.ylabel('Уровень');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fns\u002F6d\u002Fmu\u002Fns6dmuvrtkyeeysc2wnmqo0ghto.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nВ пределе значение \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F5bf\u002Fc52\u002Faae\u002F5bfc52aaead575e156515b8c206fd63d.svg\" alt=\"$\\widehat{p}$\" data-tex=\"inline\"\u002F\u003E должно стремиться к \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fa7d\u002Ff0b\u002F0cf\u002Fa7df0b0cf52583a7326d63832fe3d4ed.svg\" alt=\"$p$\" data-tex=\"inline\"\u002F\u003E — истинному значению вероятности продажи одной единицы товара, которая на графике обозначена черной пунктирной линией. В определенных ситуациях, даже этой единственной оценки уже достаточно, чтобы понять насколько выбранная нами цена является оптимальной. Например, если вероятность покупки очень большая, то, очевидно, что цена занижена и наоборот, если покупают слишком мало, то цена завышена. Если нам необходимо продавать какое-то определенное количество товара, то зная среднюю посещаемость, можно сразу понять является ли цена оптимальной или нет. Получается, что даже из первой полученной оценки можно попробовать извлечь хоть какую-то полезную информацию. Но давайте вернемся к оценке параметров распределения спроса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВеличина \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F53a\u002Fea9\u002Ff07\u002F53aea9f07ccaf30ffac7cd8719e70972.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E имеет распределение Бернулли, тогда величина \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F117\u002F5ef\u002Fb8b\u002F1175efb8bee3e7b48fb17482fa0cd6e7.svg\" alt=\"$K$\" data-tex=\"inline\"\u002F\u003E — количество проданного товара \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F9aa\u002Fe08\u002F704\u002F9aae087046a60218262bab4a00522adc.svg\" alt=\"$N$\" data-tex=\"inline\"\u002F\u003E посетителям подчиняется биномиальному закону распределения:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F167\u002Fc15\u002Fe50\u002F167c15e502e5a7e133b1a9f9ef7d0bce.svg\" alt=\"$Y \\sim \\textrm{Bern}(\\widehat{p})$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F25e\u002F17a\u002Fb19\u002F25e17ab19263202dfb3c1aebfacf19f9.svg\" alt=\"$K \\sim \\textrm{Bin}(N, \\widehat{p})$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЕсли предположить, что \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F36a\u002F7a3\u002F4c0\u002F36a7a34c01ac63d36be1138a96b2a855.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E — оценка вероятности продажи одной единицы товара по цене \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Faf3\u002F360\u002Fe5a\u002Faf3360e5a8f861c3f0dc6097396caba5.svg\" alt=\"$\\textrm{price}_{i}$\" data-tex=\"inline\"\u002F\u003E приближенно равна истинному значению этой вероятности \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F9d8\u002Fa3d\u002F960\u002F9d8a3d960748cc0475baf28df77f4503.svg\" alt=\"$p_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E то можно записать следующее:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F552\u002F1bc\u002Ff0b\u002F5521bcf0bc906cefe74582db8c0359d9.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}} \\approx p_{\\textrm{price}_{i}} \\Rightarrow \\frac{u}{u + z} \\approx 1 - \\frac{1}{\\sigma \\sqrt{2 \\pi}}\\int_{-\\infty }^{\\textrm{price}_{i}} e ^{-\\frac{(x-\\mu)^2}{2\\sigma^{2}}}d x,$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nа это значит, что на основе \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F36a\u002F7a3\u002F4c0\u002F36a7a34c01ac63d36be1138a96b2a855.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E мы можем получить оценки параметров распределения спроса \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F86a\u002F538\u002F279\u002F86a538279987ae5a5cd4a304e7a473ea.svg\" alt=\"$\\widehat{\\mu}$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F9bb\u002Ff5a\u002F4d7\u002F9bbf5a4d79b8208d4c01b4422de33c18.svg\" alt=\"$\\widehat{\\sigma}$\" data-tex=\"inline\"\u002F\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДопустим мы установили стоимость авиабилета в 7 тысяч рублей, представим, что в течение для его купили 50 посетителей из 55, пусть\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F9f4\u002Faf5\u002F8b0\u002F9f4af58b0f7eb150df3148c5fd587c9d.svg\" alt=\"$\\widehat{\\mu} \\in [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nи\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F446\u002Fd35\u002F399\u002F446d3539913a80cb65e58f051e004642.svg\" alt=\"$\\widehat{\\sigma} \\in [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11],$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nтогда мы можем оценить вероятность продажи 50-и авиабилетов 55-и посетителям для разных значений \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F0a3\u002F09e\u002Fea1\u002F0a309eea16d2da7f3efd734d08d6b5a8.svg\" alt=\"$\\widehat{\\mu}_{j}$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fd94\u002Feac\u002Ff64\u002Fd94eacf64bc69d68ec23f2bf35f55b9e.svg\" alt=\"$\\widehat{\\sigma}_{k}$\" data-tex=\"inline\"\u002F\u003E как\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F9ed\u002F24a\u002Fda4\u002F9ed24ada4750b2f910c10dbdff774b00.svg\" alt=\"$p_{\\textrm{price}, j, k} = P(K = u \\mid \\textrm{price} = 7) = C_{u + z}^{u}p^{u}(1-p)^{z} =\\\\ =C_{u + z}^{u}\\left ( 1 - \\frac{1}{\\sigma_{k} \\sqrt{2 \\pi}}\\int_{-\\infty }^{\\textrm{price}} e ^{-\\frac{(x-\\mu_{j})^2}{2\\sigma_{k}^{2}}}d x \\right )^{u}\\left (\\frac{1}{\\sigma_{k} \\sqrt{2 \\pi}}\\int_{-\\infty }^{\\textrm{price}} e ^{-\\frac{(x-\\mu_{j})^2}{2\\sigma_{k}^{2}}}d x \\right )^{z}$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИзобразим данные оценки в виде тепловой карты:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Emu_est = np.linspace(2, 22, 21)\nsigma_est = np.linspace(1, 11, 21)\nMU, SIGMA = np.meshgrid(mu_est, sigma_est)\n\nprice, u, z = 7, 50, 55\np = norm.sf(price, loc = MU, scale=SIGMA)\nP1 = binom.pmf(u, z, p)\n\nsns.heatmap(P1, xticklabels = mu_est, yticklabels=sigma_est,\n            square=True, linewidths=.5)\nplt.title('Вероятности продажи 50 авиабилетов 55-и посетителям\\n \\\nпо 7 тыс. рублей за штуку')\nplt.xlabel('$\\widehat{\\mu}$', fontsize=20)\nplt.ylabel('$\\widehat{\\sigma}$', rotation=0, fontsize=20, labelpad=15);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fl1\u002Fhz\u002Fkp\u002Fl1hzkpvy1r9ddfcywei_cxw5dlk.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЕсли в следующий день установить стоимость в 14 тысяч рублей и представить, что было продано 16 билетов 34-м посетителям, то тепловая карта будет выглядеть так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Emu_est = np.linspace(2, 22, 21)\nsigma_est = np.linspace(1, 11, 21)\nMU, SIGMA = np.meshgrid(mu_est, sigma_est)\n\nprice, u, z = 14, 16, 34\np = norm.sf(price, loc = MU, scale=SIGMA)\nP2 = binom.pmf(u, z, p)\n\nsns.heatmap(P2, xticklabels = mu_est, yticklabels=sigma_est,\n            square=True, linewidths=.5)\nplt.title('Вероятности продажи 16 авиабилетов 34-м посетителям\\n \\\nпо 14 тыс. рублей за штуку')\nplt.xlabel('$\\widehat{\\mu}$', fontsize=20)\nplt.ylabel('$\\widehat{\\sigma}$', rotation=0, fontsize=20, labelpad=15);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F_o\u002F-o\u002Fce\u002F_o-oce3hlkolwlehw-bdwtxou9o.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nИмея всего два квантиля мы можем оценить вероятность совместного наступления двух исходов как простое произведение вероятностей их отдельного наступления:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Esns.heatmap(P1*P2, xticklabels = mu_est, yticklabels=sigma_est, square=True, linewidths=.5)\nplt.title('Вероятности совместного наступления исходов\\n \\\nдвух процессов продаж')\nplt.xlabel('$\\widehat{\\mu}$', fontsize=20)\nplt.ylabel('$\\widehat{\\sigma}$', rotation=0, fontsize=20, labelpad=15);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fj2\u002Fcm\u002Fop\u002Fj2cmopnsjyap-cxwufo_sejqxqs.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nПри наличии некоторого количества квантилей мы можем найти наилучшие оценки \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F118\u002F471\u002Fce7\u002F118471ce780db31b150774846ac1c463.svg\" alt=\"$\\mu_{j}^{*}$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F5c5\u002Fe36\u002Fdb9\u002F5c5e36db9aa19979c7f6bb87da974a77.svg\" alt=\"$\\sigma_{k}^{*}$\" data-tex=\"inline\"\u002F\u003E для их истинных значений из условия максимального правдоподобия, т.е.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe71\u002Faeb\u002F1ba\u002Fe71aeb1ba620216cb4189e94b76aaf29.svg\" alt=\"$(\\mu_{j}^{*}, \\sigma_{k}^{*}) = \\underset{(\\widehat{\\mu}, \\widehat{\\sigma})}{\\textrm{argmax}}\\prod_{j, k}\\widehat{p}_{\\textrm{price}_{i}, j, k}$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНапример, двух вышеприведенных квантилей достаточно чтобы получить первые оценки параметров распределения спроса, а значит — приступить к процессу максимизации выручки:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E# функция для вычисления оптимальной цены\n# на основе оценок параметров распределения спроса\ndef optim_price(prices, mu_est, sigma_est):\n    return prices[np.argmax(norm.sf(prices, mu_est, sigma_est)*prices)]\n\n# функция для вычисления оценок параметров\n# спроса и их максимальных значений\ndef param_est(used_prices, u, n):\n    used_prices = used_prices.reshape(used_prices.size, 1, 1)\n    u = u.reshape(u.size, 1, 1)\n    n = n.reshape(n.size, 1, 1)\n    mu_est = np.linspace(2, 22, 21)\n    sigma_est = np.linspace(1, 11, 21)\n    MU, SIGMA = np.meshgrid(mu_est, sigma_est)\n    MU = np.expand_dims(MU, axis=0)\n    SIGMA = np.expand_dims(SIGMA, axis=0)\n    p = norm.sf(used_prices, loc = MU, scale=SIGMA)\n    p_est = np.prod(binom.pmf(u, n, p), axis=0)\n    idx = divmod(np.argmax(p_est), 21)\n    mu_opt = mu_est[idx[1]]\n    sigma_opt = sigma_est[idx[0]]\n    return p_est, mu_opt, sigma_opt\n\n# Создаем список возможных цен:\nprices = np.linspace(6, 18, 25)\n# Выбираем две неравные друг другу цены, которые на наш\n# взгляд являются самыми перспективными для исследований,\n# или выбираем их случайно, если таких представлений нет:\nused_prices = np.array([7, 14])\n# моделируем (в реальности - считаем) количество посетителей:\nn = np.array([55, 32])\n# моделируем (в реальности - считаем) количество покупателей:\nu = np.array([50, 16])\n# На основе двух полученных квантилей, вычисляем наилучшие\n# оценки параметров распределения спроса:\nP_map, mu_est, sigma_est = param_est(used_prices, u, n)\n# Сохраняем все значения для визуализации:\nP_maps = [P_map]\nfor i in range(30):\n    # На основе имеющихся оценок параметров распределения спроса\n    # вычисляем оптимальную стоимость товара:\n    used_prices = np.append(used_prices, optim_price(prices, mu_est, sigma_est))\n    # моделируем (в реальности - считаем) количество посетителей и\n    # покупателей:\n    n = np.append(n, np.random.randint(20, 70))\n    u = np.append(u, np.sum(norm.rvs(12, 5, n[-1]) \u003E used_prices[-1]))\n    # Используем все данные для вычисления новых значений \n    # параметров распределения спроса:\n    P_map, mu_est, sigma_est = param_est(used_prices, u, n)\n    P_maps.append(P_map)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport matplotlib.animation as animation\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure()\nfig.set_figwidth(16)\nfig.set_figheight(8)\nax2 = fig.add_subplot(122, projection='3d')\nax1 = fig.add_subplot(121)\n\nmu_est = np.linspace(2, 22, 21)\nsigma_est = np.linspace(1, 11, 21)\nMU, SIGMA = np.meshgrid(mu_est, sigma_est)\n\ndef animate(i):\n    fig.suptitle('Процесс сходимости оценок параметров\\nраспределения спроса',\n                 fontsize = 20, y = 0.95)\n    ax1 = sns.heatmap(P_maps[i], cbar=False, xticklabels = mu_est,\n                      yticklabels=sigma_est, square=True)\n    ax1.set_xlabel('$\\widehat{\\mu}$', fontsize=20)\n    ax1.set_ylabel('$\\widehat{\\sigma}$', rotation=0, fontsize=20, labelpad=15)\n    ax2.clear()\n    ax2.plot_surface(MU, SIGMA, P_maps[i], cmap='Wistia', linewidth=1, edgecolor='0.3')\n    ax2.set_xlabel('$\\widehat{\\mu}$', fontsize=15)\n    ax2.set_ylabel('$\\widehat{\\sigma}$', fontsize=15)\n    ax2.set_xticks(mu_est[::2])\n    ax2.set_zticks([])\n    return ax1\n\nanim = animation.FuncAnimation(fig, \n                               animate, \n                               frames=np.arange(0, len(P_maps)),\n                               interval = 10,\n                               repeat = False)\n\nanim.save('Асимптотическая сходимость.gif',\n                 writer='imagemagick', \n                 fps=8)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Ftk\u002F9r\u002Fwm\u002Ftk9rwmkknervwbatofyvn2x-6wo.gif\"\u002F\u003E\u003Cbr\u002F\u003E\r\nМы можем повторить данный эксперимент 100 раз и взглянуть на динамику усредненных значений:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eqa_proceeds = []\nprices_data = []\nall_visitors = []\nprices = np.linspace(6, 18, 25)\nfor i in range(100):\n    used_prices = np.random.choice(prices, 2, replace=False)\n    # генерируем количество посетителей\n    n = np.random.randint(20, 70, 2)\n    # генерируем количество покупателей\n    u = np.array([np.sum(norm.rvs(12, 5, n[i]) \u003E used_prices[i]) for i in range(len(n))])\n    mu_est, sigma_est = param_est(used_prices, u, n)[1:]\n    for j in range(20):\n        used_prices = np.append(used_prices, optim_price(prices, mu_est, sigma_est))\n        n = np.append(n, np.random.randint(20, 70))\n        u = np.append(u, np.sum(norm.rvs(12, 5, n[-1]) \u003E used_prices[-1]))\n        mu_est, sigma_est = param_est(used_prices, u, n)[1:]\n    prices_data.append(used_prices)\n    qa_proceeds.append(np.sum(used_prices * u))\n    all_visitors.append(np.sum(n))\nqa_prices_data = pd.concat([pd.Series(i, index=range(len(i))) for i in prices_data])\n\nsns.lineplot(data=qa_prices_data, ci='sd')\nplt.hlines(optim_price(prices, 12, 5), 0, len(prices_data[0]) - 1, color='r',\n           label='Оптимальная стоимость авиабилета')\nplt.yticks(prices[::2])\nplt.title('Процесс поиска оптимальной цены на основе квантильного анализа')\nplt.xlabel('Количество изменений цены')\nplt.ylabel('Стоимость одного авиабилета (тыс. рублей)')\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fji\u002Fvf\u002Fp9\u002Fjivfp9mv5oi23n56cz_ff2ydxcq.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nНа графике показано среднее значение цены и ее стандартное отклонение. Взглянем на объем выручки в каждом эксперименте:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(qa_proceeds)\nqa_mean_proc = np.mean(qa_proceeds)\nplt.hlines(qa_mean_proc, 0, len(qa_proceeds), color='r',\n           label=f'Средняя выручка ({int(qa_mean_proc)} тыс. рублей)')\nplt.title('Объем выручки в каждом эксперименте')\nplt.xlabel('Номер эксперимента')\nplt.ylabel('Объем выручки (тыс. рублей)')\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F-o\u002Fy0\u002Fva\u002F-oy0vaopheddusn3mzxu9nsp5x0.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nТеперь для сравнения попробуем найти оптимальную стоимость с помощью алгоритма сэмплирования Томпсона (TS). Что бы провести более-менее корректное сравнение, выясним сколько в среднем посетителей участвовало в одном эксперименте на основе квантильного анализа:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Enp.mean(all_visitors)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003E985.01 \u003Cbr\u002F\u003E\r\n\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\nОкруглим это значение до 1000 и точно так же повторим эксперимент 100 раз:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Edef thompson_sampling(a,b):\n    samples = beta.rvs(a=a+1, b=b+1)\n    return np.argmax(samples)\n\nn = len(prices)\nts_prices_data = []\nts_proceeds = []\n\nfor i in range(100):\n    # Количество нажатий на рычаг, в нашем случае\n    # количество использований определенной цены\n    count = np.zeros(n)\n    # Сумма наград для каждой руки (количество\n    # проданного товара по данной цене)\n    sum_rewards = np.zeros(n)\n    # Средняя награда от рычага (оценка вероятности\n    # продажи одной единицы товара)\n    Q = np.zeros(n)\n    # Инициализируем значения alpha и beta\n    a = np.ones(n)\n    b = np.ones(n)\n    price = []\n    proceeds = []\n    for j in range(1000):\n        # Выбираем руку с применением выборки Томпсона\n        arm = thompson_sampling(a, b)\n        count[arm] += 1\n        price.append(prices[arm])\n        # Моделируем посетителя\n        reward = bernoulli.rvs(norm.sf(prices[arm], 12, 5))\n        # если reward = 1, значит совершена покупка \n        if reward == 1:\n            sum_rewards[arm] += 1\n            proceeds.append(prices[arm])\n        # вычисляем вероятность продажи одной единицы товара\n        Q[arm] = sum_rewards[arm] \u002F count[arm]\n        # Если выручка по данной цене является максимальной, то:\n        if arm == np.argmax(prices*Q):\n            a[arm] += 1    # увеличиваем alpha\n        else:\n            b[arm] += 1    # если нет, то увеличиваем beta\n    ts_prices_data.append(price)\n    ts_proceeds.append(sum(proceeds))\nts_prices_data = pd.concat([pd.Series(i, index=range(len(i))) for i in ts_prices_data])\n\nsns.lineplot(data=ts_prices_data, ci='sd')\nplt.hlines(optim_price(prices, 12, 5), 0, 1000, color='r',\n           label='Оптимальная стоимость авиабилета')\nplt.yticks(prices[::2])\nplt.title('Процесс поиска оптимальной цены на основе\\n \\\nалгоритма семплирования Томпсона')\nplt.xlabel('Количество изменений цены')\nplt.ylabel('Стоимость одного авиабилета (тыс. рублей)')\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fvd\u002Fhl\u002Fpq\u002Fvdhlpq20urlmd9bt0ykbbdlsoic.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nИ так же взглянем на объем выручки в каждом эксперименте:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(ts_proceeds)\nts_mean_proc = np.mean(ts_proceeds)\nplt.hlines(ts_mean_proc, 0, len(ts_proceeds), color='r',\n           label=f'Средняя выручка ({int(ts_mean_proc)} тыс. рублей)')\nplt.title('Объем выручки в каждом эксперименте')\nplt.xlabel('Номер эксперимента')\nplt.ylabel('Объем выручки (тыс. рублей)')\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fvx\u002Fua\u002Fbp\u002Fvxuabplvuuel6nouvrxx6elouci.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПреимущества квантильного анализа перед TS алгоритмом очевидны:\u003Cbr\u002F\u003E\r\n — более быстрая сходимость;\u003Cbr\u002F\u003E\r\n — гораздо меньшее количество изменений цены;\u003Cbr\u002F\u003E\r\n — незначительное, но все же, увеличение объема выручки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРазумеется, результаты сравнения выглядят немного подозрительными и для сомнений в их корректности есть основания. Во-первых, алгоритм TS это эвристика, а это значит, что мы можем оптимизировать его множеством самых разных способов. Например, мы можем использовать наши некоторые представления о кривой спроса и перед запуском установить параметры \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E в соответствующие этим представлениям значения. Мы можем пойти еще дальше и использовать еще больше предметно-ориентированных знаний и создать что-то вроде алгоритма-советника, который помогал бы принимать более правильные решения по установке и изменению цен. Но все это не приведет к желаемому результату, потому что основная причина такого результата кроется в количестве проверяемых цен:\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F201\u002F452\u002F4b7\u002F2014524b753fe3952e1d23685a5abd69.svg\" alt=\"$\\textrm{prices} \\in [6,6.5,7,7.5,8,8.5,9,9.5,10,10.5,11,11.5,12,12.5,13,13.5,14,14.5,15,15.5,16,16.5,17,17.5,18].$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа первый взгляд, в таком количестве цен для продажи большинства товаров нет никакой логики. Гораздо лучше и логичнее поступить так, как это принято — использовать меньшее количество цен, например:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F1a9\u002F77c\u002Fac2\u002F1a977cac2cf20bea49d0fdc767870c52.svg\" alt=\"$\\textrm{prices} \\in [7.99, 8.99, 9.99, 10.99, 11.99].$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этом случае TS алгоритм будет работать просто идеально. Но что если оптимальная цена равна 9.5 тысяч рублей? В случае небольших объемов продаж это не критично, но если объемы продаж велики, то это негативно скажется на прибыли. Основное требование к продаже авиабилетов как раз и заключается в том, что количество проверяемых цен должно быть максимально большим. А что если спрос изменится и оптимальная цена вообще покинет установленный диапазон цен? Это означает, что мы все равно должны как-то учитывать цены за пределами выбранного диапазона, т.е. так или иначе цен становится еще больше. Конечно, вышеприведенные эксперименты предполагали стационарность спроса на авиабилеты, который в действительности является динамическим. Алгоритм TS может быть модифицирован для работы с изменяющимся спросом. Суть модификации заключается в ограничении параметров \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E какими-то максимальными значениями — чем меньше эти значения, тем быстрее TS реагирует на изменение. В то же самое время, чем меньше ограничивающие значения, тем больше уклон на исследования цен. Кстати процесс исследования цен, это тоже отдельная и очень большая проблема, связанная с тем, что мы не можем менять цену после каждого посетителя. А это значит, что если мы выбрали какую-то, пусть даже самую неоптимальную цену, то все равно придется продержать ее какое-то время иначе это неизбежно приведет к появлению противоречивого опыта у некоторых посетителей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВсе вышеперечисленные трудности можно преодолеть с разной степенью успеха благодаря множеству модификаций TS алгоритма. Но самая главная проблема заключается в том, что данные о продажах, появляющиеся в ходе его работы абсолютно непригодны для решения задачи глобальной оптимизации. Ведь в действительности, даже имея на руках самый идеальный алгоритм ценообразования, от него не будет абсолютно никакого толка если авиакомпания не выполнит оптимальную расстановку авиапарка по маршрутам. В свою очередь, от алгоритмов ценообразования и расстановки авиапарка также не будет никакой пользы, если авиакомпании не будут иметь согласованных стратегий (для общего эффекта на отрасль в короткие сроки; если же стратегии не согласованы, то рынок бы тоже выровнялся со временем при внедрении алгоритмов хотя бы одной авиакомпанией, но, к сожалению, отрасль является в том или ином виде дотационной во многих странах мира, что сильно ограничивает возможности саморегулирования). А ведь помимо авиакомпаний в системе присутствуют и другие игроки, например, поставщики топлива и аэропорты, чьи действия могут свести на нет даже самую оптимальную стратегию авиакомпаний. Это чрезвычайно сложная система, которая, как это ни странно, существует в основном только за счет кошельков конечных потребителей. Поэтому единственный способ начать оптимизацию всей системы — это начать с ценообразования.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНапример, суть расстановки авиапарка заключается в том, что мы должны постоянно принимать управляющие решения о назначении самолетов конкретного типа на конкретные маршруты, для чего необходима информация хотя бы о кривой спроса. Если использовать самую идеальную реализацию TS алгоритма, которая с первых попыток находит оптимальную цену, то окажется что для восстановления кривой спроса просто не окажется нужных данных по другим ценам. Сначала это не кажется проблемой, ведь у нас есть идеальный алгоритм ценообразования, но в этой ситуации алгоритм глобальной оптимизации тоже становится эвристическим, т.е. для того что бы понять, что какому-то самолету не стоит летать по данному направлению, придется понести серьезные убытки. Наличие кривых спроса, наоборот, позволяет без всяких экспериментов сразу менять маршруты и расписания с минимальными убытками.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКвантильный анализ требует установки всего двух исследуемых цен, которые могут выбираться как случайно, так и на основе имеющейся аналитики. Все последующие изменения делаются только на основе уточняющихся оценок параметров распределения спроса. Это означает, что квантильный анализ не является эвристическим и, каким бы ни было количество возможных цен, исследоваться будут только те цены, которые считаются оптимальными на данном этапе. И самое главное, появляющиеся после каждого очередного квантиля оценки, могут быть использованы в многоэтапных задачах стохастической оптимизации. Казалось бы — все круто. Но у квантильного анализа есть один существенный минус — непонятно каким должен быть объем выборки, т.е. непонятно сколько нужно посетителей для того, чтобы оценка квантильного уровня была более-менее статистически значимой. Если использовать для оценки вероятности продажи одной единицы товара \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F36a\u002F7a3\u002F4c0\u002F36a7a34c01ac63d36be1138a96b2a855.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E небольшое количество посетителей, то очевидно, что эта оценка будет обладать слишком большой дисперсией, и процесс поиска оптимальной цены слишком затянется. Если использовать слишком большое количество посетителей, то мы будем получать более точные значения \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F36a\u002F7a3\u002F4c0\u002F36a7a34c01ac63d36be1138a96b2a855.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E, но в том случае если \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Faf3\u002F360\u002Fe5a\u002Faf3360e5a8f861c3f0dc6097396caba5.svg\" alt=\"$\\textrm{price}_{i}$\" data-tex=\"inline\"\u002F\u003E является далеко не оптимальной, то ее долгое использование может привести к катастрофически большим убыткам. Неопределенность объема выборки — это действительно серьезная проблема, и, пожалуй, единственный способ ее преодоления заключается в использовании последовательного статистического анализа.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EПоследовательный статистический анализ Вальда\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервоначальные оценки параметров спроса могут быть как верными так и нет, это значит, что мы можем с первых попыток найти самую оптимальную цену, ну или по крайней мере близкую к ней. Убедиться в оптимальности цены довольно просто, ведь если оценки параметров спроса верны, то вычисленная вероятность продажи одной единицы товара \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F5cc\u002F533\u002F72d\u002F5cc53372dffdbc45385ac0fb1a95f4a9.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}\\,^{'}$\" data-tex=\"inline\"\u002F\u003E не будет значительно отличаться от наблюдаемой \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F36a\u002F7a3\u002F4c0\u002F36a7a34c01ac63d36be1138a96b2a855.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E. Допустим у нас есть оценка \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F36a\u002F7a3\u002F4c0\u002F36a7a34c01ac63d36be1138a96b2a855.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E, тогда мы можем выделить область безразличия, ограниченную значениями \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F37f\u002Fc60\u002F2df\u002F37fc602df17cd0b1a13d2d5521d9405b.svg\" alt=\"$p_{0}$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F880\u002Fbcf\u002F3aa\u002F880bcf3aaf2ccb7df6dbf0f6cd81fd41.svg\" alt=\"$p_{1}$\" data-tex=\"inline\"\u002F\u003E. Если \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F24e\u002F802\u002Fb5b\u002F24e802b5b6c51b1b789c4144730f8359.svg\" alt=\"$p_{0} &lt; \\widehat{p}_{\\textrm{price}_{i}} &lt; p_{1}$\" data-tex=\"inline\"\u002F\u003E, то мы не предпринимаем никаких действий по изменению цены и считаем, что наша оценка верна. В противном случае мы уточняем оценки параметров распределения спроса и на основе их уточненных значений меняем цену.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВыдвинем основную гипотезу \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F507\u002F4e4\u002F3d6\u002F5074e43d6122f1c4589abf6a3efc4bcd.svg\" alt=\"$H_{0}$\" data-tex=\"inline\"\u002F\u003E о том, что вероятность продажи одной единицы товара \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F36a\u002F7a3\u002F4c0\u002F36a7a34c01ac63d36be1138a96b2a855.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}}$\" data-tex=\"inline\"\u002F\u003E при выбранной цене равна \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F37f\u002Fc60\u002F2df\u002F37fc602df17cd0b1a13d2d5521d9405b.svg\" alt=\"$p_{0}$\" data-tex=\"inline\"\u002F\u003E и одну конкурирующую гипотезу \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F99a\u002F8d4\u002F297\u002F99a8d42976dd82af5dc1a7e9906e76d6.svg\" alt=\"$H_{1}$\" data-tex=\"inline\"\u002F\u003E, заключающуюся в том, что на самом деле \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fa7a\u002F232\u002F066\u002Fa7a232066f94f3bc1a8a7e7dc8ffec12.svg\" alt=\"$\\widehat{p}_{\\textrm{price}_{i}} = p_{1}$\" data-tex=\"inline\"\u002F\u003E. При доказательстве гипотез мы можем совершить ошибки первого и второго рода, обозначаемые \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E соответственно. Тогда, согласно правилам последовательного статистического анализа Вальда, мы можем выделить две критические области:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fa32\u002F8ad\u002F81c\u002Fa328ad81c5f1577dbf6c922fab9924b7.svg\" alt=\"$A = \\frac{1 - \\beta}{\\alpha}, \\;\\;\\; B = \\frac{\\beta}{1 - \\alpha}$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы можем принять гипотезу \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F507\u002F4e4\u002F3d6\u002F5074e43d6122f1c4589abf6a3efc4bcd.svg\" alt=\"$H_{0}$\" data-tex=\"inline\"\u002F\u003E о том что \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F73d\u002Fbeb\u002F90f\u002F73dbeb90f104f08a18224ed0eedc014d.svg\" alt=\"$p = p_{0}$\" data-tex=\"inline\"\u002F\u003E, если\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F1f2\u002Fb36\u002F77d\u002F1f2b3677d71680975e0f552a92393e24.svg\" alt=\"$u \\ln \\frac{p_{1}}{p_{0}} + z \\ln \\frac{1 - p_{1}}{1 - p_{0}} \\leqslant \\ln B,$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nили принять гипотезу \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F99a\u002F8d4\u002F297\u002F99a8d42976dd82af5dc1a7e9906e76d6.svg\" alt=\"$H_{1}$\" data-tex=\"inline\"\u002F\u003E о том что \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fa72\u002F5a3\u002Fb2f\u002Fa725a3b2f2f265b66e8fe0e7575bf371.svg\" alt=\"$p = p_{1}$\" data-tex=\"inline\"\u002F\u003E, если\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F8b9\u002Ff2d\u002F153\u002F8b9f2d153dd0c14313df669f7bcf9467.svg\" alt=\"$u \\ln \\frac{p_{1}}{p_{0}} + z \\ln \\frac{1 - p_{1}}{1 - p_{0}} \\geqslant \\ln A.$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ случае когда\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F80c\u002Fc83\u002F502\u002F80cc835025159653c3b8c1fbffea0a79.svg\" alt=\"$\\ln B &lt; u \\ln \\frac{p_{1}}{p_{0}} + z \\ln \\frac{1 - p_{1}}{1 - p_{0}} &lt; \\ln A$\" data-tex=\"inline\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nмы продолжаем торговлю.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКритерий Вальда включает в себя критерий Неймана-Пирсона как частный случай, то есть может обеспечить те же самые уровни ошибок \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E, но при этом не требует фиксированного объема выборки. Чтобы продемонстрировать последовательный анализ в действии, предположим что ошибки первого рода обходятся гораздо дороже, чем ошибки второго рода, пусть \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbfd\u002F65a\u002F74d\u002Fbfd65a74de356945ba7db1a6899f9f76.svg\" alt=\"$\\alpha = 0.05$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe38\u002F146\u002F7f4\u002Fe381467f43d7ce7688e31b457ec4938d.svg\" alt=\"$\\beta = 0.5$\" data-tex=\"inline\"\u002F\u003E. А вероятности \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F37f\u002Fc60\u002F2df\u002F37fc602df17cd0b1a13d2d5521d9405b.svg\" alt=\"$p_{0}$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F880\u002Fbcf\u002F3aa\u002F880bcf3aaf2ccb7df6dbf0f6cd81fd41.svg\" alt=\"$p_{1}$\" data-tex=\"inline\"\u002F\u003E будут равны 0.45 и 0.55 соответственно, тогда процесс тестирования гипотез может выглядеть так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ealpha, beta = 0.05, 0.5\nA = np.log((1 - beta)\u002Falpha)\nB = np.log(beta\u002F(1 - alpha))\np0, p1 = 0.45, 0.55\n\n# Моделируем выборку для последовательного анализа:\nsamples_p0 = bernoulli.rvs(p0, size = 100, random_state=42)\n# Подсчитываем количество последовательных извлечений\n# из выборки:\nn = np.r_[1:samples_p0.size + 1]\n# подсчитываем количество успешных исходов:\nu = samples_p0.cumsum()\nz = n - u\n\nstat = u * np.log(p1\u002Fp0) + z * np.log((1 - p1)\u002F(1 - p0))\n\nsns.lineplot(x = n, y = stat)\nplt.hlines(A, 1, 100, color='g', label='$\\ln A$')\nplt.hlines(B, 1, 100, color='r', label='$\\ln B$')\n\nif np.any(stat \u003E A):\n        stop_n = (stat &lt; A).argmin()+ 1\nelse:\n    if np.any(stat &lt; B):\n        stop_n = (stat \u003E B).argmin()\nplt.vlines(stop_n, -1, 2.5, color='0.3', lw=2, alpha=0.5)\nplt.vlines(70, -1, 2.5, color='m', lw=6, alpha=0.5)\nplt.xlabel('Количество испытаний')\nplt.ylabel('Статистика')\nplt.title('Процесс последовательного анализа Вальда')\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fej\u002Fkw\u002Fzw\u002Fejkwzwz__2hkdgscldvgmca570g.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nФиолетовой линией обозначен объем выборки, рассчитанный по критерию Неймана-Пирсона, а серой линией обозначено количество испытаний в критерии Вальда. На графике видно, что в этом конкретном случае потребовалось гораздо меньше испытаний, чем для критерия Неймана-Пирсона. Тем не менее иногда количество испытаний может превышать количество, требуемое для критерия Неймана-Пирсона:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.hlines(A, 1, 100, color='g', label='$\\ln A$')\nplt.hlines(B, 1, 100, color='r', label='$\\ln B$')\nplt.vlines(70, -1, 2.5, color='m', lw=6, alpha=0.5)\n\nfor i in range(20):\n    samples_p0 = bernoulli.rvs(p0, size = 100)\n    n = np.r_[1:samples_p0.size + 1]\n    u = samples_p0.cumsum()\n    z = n - u\n    stat = u * np.log(p1\u002Fp0) + z * np.log((1 - p1)\u002F(1 - p0))\n\n    #sns.lineplot(x = n, y = stat, alpha=0.9)\n    if np.any(stat \u003E A):\n        stop_n = (stat &lt; A).argmin()+ 1\n    else:\n        if np.any(stat &lt; B):\n            stop_n = (stat \u003E B).argmin()\n    sns.lineplot(x = n[:stop_n], y = stat[:stop_n], alpha=0.9)\n    plt.vlines(stop_n, -1, 2.5, color='0.3', lw=2, alpha=0.7)\n\nplt.xlabel('Количество испытаний')\nplt.ylabel('Статистика')\nplt.title('Процессы последовательного анализа Вальда в 20-и экспериментах')\nplt.legend(loc='lower left');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Foa\u002Fps\u002Frz\u002Foapsrzmc5deznobaxlyfptyr7uy.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nТеперь проверим заданный уровень ошибок для α. Смоделируем 10000 последовательных анализов в предположении, что каждый посетитель может купить одну единицу товара с вероятностью равной 0.45. В этом случае мы должны всегда принимать нулевую гипотезу, но поскольку α=0.05, то критерий Вальда должен ошибаться примерно в 5% случаев:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003EN = 10000\na, one_m_a = 0, 0\nh_test, exper = [], []\nfor i in range(N):\n    u, n = 0, 0\n    stat = (A - B)\u002F2\n    while B &lt; stat &lt; A:\n        n += 1\n        u += bernoulli.rvs(p0)\n        z = n - u\n        stat = u * np.log(p1\u002Fp0) + z * np.log((1 - p1)\u002F(1 - p0))\n        if stat \u003E A:\n            a +=1\n            h_test.append(0)\n        if stat &lt; B:\n            one_m_a += 1\n            h_test.append(1)\n    exper.append(n)\n    \nplt.text(-0.15, a + 100, fr'$\\alpha = ${a\u002FN:.4}', fontsize = 20)\nplt.text(1-0.25, one_m_a + 100, fr'$1 - \\alpha = ${one_m_a\u002FN:.4}', fontsize = 20)\nplt.title(r'Количество ошибок первого рода (верная $H_{0}$ отвергнута)')\nsns.countplot(x=h_test)\nplt.xticks(ticks = [0,1], labels = [r'$H_{0}$ отвергнута', r'$H_{0}$ принята'])\nplt.ylim(0, N + 1000);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fqj\u002Fgy\u002Fsv\u002Fqjgysv2hmsy0ttpzyjulxsaphdq.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nВообще, в силу дискретной природы некоторых распределений и произвольных вещественных значений \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E, можно увидеть некоторое отклонение фактического количества ошибок от заданного заранее уровня. Но если взглянуть на распределение количества испытаний в экспериментах, то становятся очевидны преимущества данного метода, так как в среднем он требует около 32 экспериментов (против 70 в критерии Неймана-Пирсона):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Esns.histplot(x=exper, discrete=True)\nplt.vlines(np.mean(exper), 0, 900, color='r', label=f'{np.mean(exper):.4}')\nplt.title('Распределение количества испытаний в экспериментах')\nplt.xlabel('Количество испытаний в одном эксперименте')\nplt.ylabel('Количество экспериментов')\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Feu\u002Fcf\u002Fbm\u002Feucfbmsw-ppiyybjjf6ecrrznhc.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nВыполним ту же проверку для ошибок второго рода (\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003EN = 10000\nb, one_m_b = 0, 0\nh_test, exper = [], []\n\nfor i in range(N):\n    u, n = 0, 0\n    stat = (A - B)\u002F2\n    while B &lt; stat &lt; A:\n        n += 1\n        u += bernoulli.rvs(p1)\n        z = n - u\n        stat = u * np.log(p1\u002Fp0) + z * np.log((1 - p1)\u002F(1 - p0))\n        if stat \u003E A:\n            b +=1\n            h_test.append(0)\n        if stat &lt; B:\n            one_m_b += 1\n            h_test.append(1)\n    exper.append(n)\n    \nplt.text(-0.18, b + 100, fr'$1 - \\beta = ${b\u002FN:.4}', fontsize = 20)\nplt.text(1-0.15, one_m_b + 100, fr'$\\beta = ${one_m_b\u002FN:.4}', fontsize = 20)\nsns.countplot(x=h_test)\nplt.xticks(ticks = [0,1], labels = [r'$H_{0}$ отвергнута', r'$H_{0}$ принята'])\nplt.title('Количество ошибок второго рода (неверная $H_{0}$ принята)')\nplt.ylim(0, N + 1000);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fb7\u002Fxr\u002Fhg\u002Fb7xrhgkjkaclaqyzzpukfvxbzua.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nПолученное значение \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E так же несколько отличается от заданного, что в общем-то согласуется с теорией, но распределение количества посетителей в экспериментах компенсирует такое отклонение:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E sns.histplot(x=exper, discrete=True)\nplt.vlines(np.mean(exper), 0, 900, color='r', label=f'{np.mean(exper):.4}')\nplt.title('Распределение количества испытаний в экспериментах')\nplt.xlabel('Количество испытаний в одном эксперименте')\nplt.ylabel('Количество экспериментов')\nplt.legend(); \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fa4\u002Fhu\u002Fze\u002Fa4huzebrcwlsppbb-k5-maqhoii.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nБольшим преимуществом критерия Вальда является то, что чем сильнее мы ошибаемся в оценках параметров распределения спроса, тем меньше требуется посетителей для того, чтобы убедиться в этом. Следовательно, мы быстрее вычисляем новые оценки и на их основе определяем новую стоимость товара.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ качестве простой демонстрации того как критерий Вальда может быть использован предположим, что нам необходимо продать какое-то ограниченное количество товара в некоторый фиксированный промежуток времени. Пусть \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbb9\u002F9dd\u002F06b\u002Fbb99dd06bc822424df5c44ffcb2be720.svg\" alt=\"$N = 3000$\" data-tex=\"inline\"\u002F\u003E — это среднее количество посетителей в рассматриваемом промежутке времени, а \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F619\u002F893\u002F974\u002F619893974ce5e5136d1c0815bfabaed2.svg\" alt=\"$Q = 300$\" data-tex=\"inline\"\u002F\u003E — это имеющееся количество единиц товара. Спрос распределен как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F3fd\u002F874\u002F494\u002F3fd8744949d2433267bc8216f7d09e5b.svg\" alt=\"$N(21, 3^{2})$\" data-tex=\"inline\"\u002F\u003E. Поскольку истинные параметры распределения спроса нам неизвестны, то и значение оптимальной цены для нас так же является неизвестной величиной. Можно подумать, что суть задачи заключается в поиске \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Ffb4\u002F0fb\u002Fd4d\u002Ffb40fbd4d1af9c4c34dbc7b22033730a.svg\" alt=\"$\\textrm{Price}^{*}$\" data-tex=\"inline\"\u002F\u003E, но на самом деле первостепенной задачей является определение параметров спроса, а уже потом определение \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Ffb4\u002F0fb\u002Fd4d\u002Ffb40fbd4d1af9c4c34dbc7b22033730a.svg\" alt=\"$\\textrm{Price}^{*}$\" data-tex=\"inline\"\u002F\u003E на их основе.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля моделирования создадим несколько вспомогательных функций. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E # функция определения оптимальной цены по \n# оценкам mu и sigma:\ndef optim_price(q, n, mu_est, sigma_est):\n    prices = np.linspace(3, 38, 2*(38-3)+1)\n    p_est = norm.sf(prices, loc=mu_est, scale=sigma_est)\n    prop = np.clip(n * p_est, a_min = 0, a_max=q)\n    income = prices * prop\n    return prices[income.argmax()] \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nРаботает данная функция очень просто: принимает значения имеющихся оценок параметров спроса, вычисляет вероятности продажи одной единицы товара по каждой из возможных цен, а затем выбирает наилучшую из них. Данная функция может определять цену несколько выше, чем та, благодаря которой можно продать весть товар. Например, если у нас есть 10 единиц товара, и по цене 10 у.е мы можем продать все, а по цене 12 у.е. — только 9 единиц, то функция вернет 12 у.е. потому что \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdd5\u002F7a3\u002F6e6\u002Fdd57a36e67b69440b7d3a97b1e5f6e56.svg\" alt=\"$9\\cdot12 \u003E 10\\cdot10$$\" data-tex=\"inline\"\u002F\u003E.\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E # функция для моделирования одного посетителя:\ndef visitor(price, mu, sigma):\n    return int(norm.rvs(loc=mu, scale=sigma) \u003E price) \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nГенерируем одно значение из скрытого распределения спроса и если оно окажется больше установленной цены, то выдаем 1 — товар куплен; в противном случае выдаем 0 — товар не куплен.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДалее, нам понадобится реализация критерия Вальда:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Edef vald(vis, p_est, alpha=0.05, beta=0.5):\n    A = np.log((1 - beta)\u002Falpha)\n    B = np.log(beta\u002F(1 - alpha))\n    \n    p0 = p_est - 0.05\n    if p0 &lt;= 0: p0 = 0.01\n    p1 = p_est + 0.05\n    if p1 \u003E= 1: p1 = 0.99\n    \n    ln_p = np.log(p1 \u002F p0)\n    ln_1_mp = np.log((1 - p1) \u002F (1 - p0))\n    \n    u = np.sum(vis)\n    n = len(vis)\n    z = n - u\n    \n    test = ln_p * u + ln_1_mp * z\n    \n    if test &lt;= B:\n        return -1, p0, p1, test    # принимаем p0\n    if test \u003E= A:\n        return 1, p0, p1, test     # принимаем p1\n    if B &lt; test &lt; A:\n        return 0, p0, p1, test     # продолжаем эксперимент\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ данной функции мы используем имеющуюся оценку вероятности продажи одной единицы товара — \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fa7d\u002Ff0b\u002F0cf\u002Fa7df0b0cf52583a7326d63832fe3d4ed.svg\" alt=\"$p$\" data-tex=\"inline\"\u002F\u003E и после каждого посетителя применяем критерий Вальда, чтобы ответить на три нижеследующих вопроса:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n1. \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc31\u002F8e0\u002F606\u002Fc318e0606625f9e246bbd1a1f13281b7.svg\" alt=\"$p_{0} &lt; p &lt; p_{1}$\" data-tex=\"inline\"\u002F\u003E?\u003Cbr\u002F\u003E\r\n2. \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fca0\u002F537\u002F90c\u002Fca053790c820407b818c358aebba69da.svg\" alt=\"$p \\leqslant p_{0}$\" data-tex=\"inline\"\u002F\u003E?\u003Cbr\u002F\u003E\r\n3. \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F621\u002Fb81\u002F968\u002F621b81968021ea2576ab3165db3e8ed8.svg\" alt=\"$p \\geqslant p_{1}$\" data-tex=\"inline\"\u002F\u003E?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПричем отвечать на эти вопросы мы должны с заранее заданным уровнем ошибок \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДалее каждый раз когда мы выходим за пределы \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F971\u002Fbe2\u002F2ea\u002F971be22ea4c5021440806a7348f3cabb.svg\" alt=\"$(p_{0}; p_{1})$\" data-tex=\"inline\"\u002F\u003E мы должны предпринимать какие-то решения по поводу изменения цены. Несмотря на то, что оценки вероятности продажи одной единицы товара, получаемые с помощью относительных частот, испытывают очень сильные колебания из-за маленьких объемов выборок, мы все равно можем использовать эту информацию для создания оценок. По сути мы просто используем Байесовскую статистику — вычисляем вероятность получения совокупности наблюдаемых исходов в зависимости от разных предположений о параметрах спроса. Это очень накладно в вычислительном плане, зато работает:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E# функция определения параметров нормального спроса\ndef masp(used_prices, u, n):\n    used_prices = used_prices.reshape(used_prices.size, 1, 1)    # цены\n    u = u.reshape(u.size, 1, 1)    # количество покупок\n    n = n.reshape(n.size, 1, 1)    # количество посетителей\n    \n    mu = np.arange(15, 26)\n    sigma = np.arange(1, 12)\n    MU, SIGMA = np.meshgrid(mu, sigma)\n    MU = np.expand_dims(MU, axis=0)\n    SIGMA = np.expand_dims(SIGMA, axis=0)\n    p = norm.sf(used_prices, loc = MU, scale=SIGMA)\n    z = np.prod(binom.pmf(u, n, p), axis=0)\n    i, j = divmod(z.argmax(), 11)\n    return mu[j], sigma[i]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПрежде чем переходить к моделированию процесса торговли сделаем некоторые уточнения. После установки начальной (самой первой) цены, ее коррекция происходит не на основе оценок параметров спроса, для которых пока просто не существует нужных данных, а в ручном режиме. Изменение происходит на некоторую величину, которая кажется наиболее целесообразной. В эксперименте она меняется на минимально возможное изменение цены (0.5 у.е.).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕще одно замечание связано с тем, что в алгоритме задается максимально возможное изменение цены. Такая мера кажется целесообразной потому, что колебания относительных частот могут иметь очень сильные отклонения, но из-за таких «флуктуаций» относительной частоты изменение цены может быть просто катастрофически неверным. В эксперименте максимальная дельта цены равна 1.5 у.е.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧто бы провести эксперимент, создадим следующую функцию:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Edef sales_model(mu, sigma, mu_0, sigma_0, Q, N, alpha=0.05, beta=0.5):\n    '''\n    mu, sigma - скрытые, истинные параметры спроса;\n    mu_0, sigma_0 - первоначальные оценки параметров спроса;\n    Q - исходное количество товара;\n    N - среднее количество посетителей в рассматриваемый период времени;\n    '''\n    \n    # Список для хранения оценок мат.ожидания \n    # распределения спроса:\n    M_star = [mu_0]\n\n    # Список для хранения оценок СКО распределения\n    # спроса:\n    S_star = [sigma_0]\n\n    # Список для хранения посетителей при заданной цене:\n    Visitors = []\n\n    M = []    # количество посетителей во время тестов\n    MS = []   # количество покупок\n    S = []   # доход полученный при заданной цене\n\n    # Список для хранения цен. Значение начальной цены\n    # вычисляется в соответствии с нашими первоначальными\n    # (теоретическими) представлениями о параметрах спроса:\n    prices = [optim_price(Q, N, M_star[0], S_star[0])]\n\n    # Список для хранеия оценок вероятностей:\n    P_star = [norm.sf(prices[-1], loc=M_star[0], scale=S_star[0])]\n    \n    # Списки для хранения гипотетических вероятностей и теста Вальда:\n    P0, P1, T = [], [], []\n    \n    ##################################################################\n\n    # Начало продаж выполняемое по нашим теоретическим представлениям:\n\n    est_flag = 0\n    vis = []\n    while est_flag == 0:\n        N -= 1\n        v = visitor(prices[-1], mu, sigma)\n        if v != 0:\n            Q -= 1\n        vis.append(v)\n        test, P0_i, P1_i, T_i = vald(vis, P_star[-1], alpha=alpha, beta=beta)\n        P0.append(P0_i)\n        P1.append(P1_i)\n        T.append(T_i)\n        if test != 0:\n            est_flag = 1\n            M.append(len(vis))\n            MS.append(sum(vis))\n            P_star.append(MS[-1] \u002F M[-1])\n\n            # меняем цену в соответствии с значением теста\n            if test == -1:\n                prices.append(prices[-1] - 0.5)\n            if test == 1:\n                prices.append(prices[-1] + 0.5)\n    \n    # вычисляем первое значение полученной прибыли:\n    S.append(MS[-1]*prices[-1])\n    \n    ###############################\n\n    # Основной цикл\n    \n    vis=[]\n    while (N != 0) and (Q != 0):\n        N -= 1\n        v = visitor(prices[-1], mu, sigma)\n        if v != 0:\n            Q -= 1\n        vis.append(v)\n        test, P0_i, P1_i, T_i = vald(vis, P_star[-1], alpha=alpha, beta=beta)\n        P0.append(P0_i)\n        P1.append(P1_i)\n        T.append(T_i)\n        if test != 0:\n            M.append(len(vis))\n            MS.append(sum(vis))\n            P_star.append(MS[-1] \u002F M[-1])\n            Visitors.append(vis)\n            S.append(MS[-1]*prices[-1])\n            est_par = masp(np.array(prices), np.array(MS), np.array(M))\n            M_star.append(est_par[0])\n            S_star.append(est_par[1])\n            prices.append(optim_price(Q, N, M_star[-1], S_star[-1]))\n            if prices[-1] - prices[-2] \u003E 1.5:\n                prices[-1] = prices[-2] + 1\n            if prices[-1] - prices[-2] &lt; -1.5:\n                prices[-1] = prices[-2] - 1\n                \n            vis = []\n        if Q == 0 and len(vis) != 0:\n            Visitors.append(vis)\n            M.append(len(vis))\n            MS.append(sum(vis))\n            S.append(MS[-1]*prices[-1])\n    \n    return MS, M, S, prices, P_star, M_star, S_star, Visitors, P0, P1, T \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nИтак, проведем эксперимент исходя из следующих начальных условий: спрос распределен как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F880\u002F67f\u002F133\u002F88067f133f4e67e895bff596a553b89b.svg\" alt=\"$N(21; 3^{2})$\" data-tex=\"inline\"\u002F\u003E, первоначальные представления о параметрах спроса (исходные оценки спроса): \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Ff3d\u002F153\u002Fec5\u002Ff3d153ec5bafeb6f2790b31036abb2bc.svg\" alt=\"$\\mu = 18$\" data-tex=\"inline\"\u002F\u003E, \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F99a\u002Fb8b\u002F347\u002F99ab8b3476d97cf9b0b84343d98fa1cd.svg\" alt=\"$\\sigma = 1$\" data-tex=\"inline\"\u002F\u003E, исходное количество товара \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F619\u002F893\u002F974\u002F619893974ce5e5136d1c0815bfabaed2.svg\" alt=\"$Q = 300$\" data-tex=\"inline\"\u002F\u003E, среднее число посетителей за некоторый период времени \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbb9\u002F9dd\u002F06b\u002Fbb99dd06bc822424df5c44ffcb2be720.svg\" alt=\"$N = 3000$\" data-tex=\"inline\"\u002F\u003E, ошибки первого и второго рода: \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbfd\u002F65a\u002F74d\u002Fbfd65a74de356945ba7db1a6899f9f76.svg\" alt=\"$\\alpha = 0.05$\" data-tex=\"inline\"\u002F\u003E, \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc39\u002Fa08\u002Fda1\u002Fc39a08da1f07d8df6b33970c5b131305.svg\" alt=\"$\\beta = 0.1$\" data-tex=\"inline\"\u002F\u003E:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E MS, M, SS, prices, P_star, M_star, S_star, Visitors, P0, P1, T = sales_model(21, 3, 18, 1, 300, 3000, 0.05, 0.1) \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСначала взглянем на то, как работает последовательный анализ Вальда и как он взаимосвязан с изменением интервала \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Ffc9\u002Fede\u002Fa40\u002Ffc9edea400279d3bbb719fedcb9b8736.svg\" alt=\"$[p_{0}; p_{1}]$\" data-tex=\"inline\"\u002F\u003E. А что бы можно было хоть что-то разглядеть построим его для первых 200 посетителей:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(P0[:200], color='g', label='$p_{0}$', zorder=11)\nplt.plot(P1[:200], color='g', ls='--', label='$p_{1}$', zorder=10)\nplt.plot(T[:200], color='0.3', label='test')\nalpha = 0.05\nbeta = 0.1\nA = np.log((1 - beta)\u002Falpha)\nplt.hlines(A, 0, 200, color='b', label='A')\nB = np.log(beta\u002F(1 - alpha))\nplt.hlines(B, 0, 200, color='r', label='B')\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fqn\u002Fvy\u002Fq-\u002Fqnvyq-vvgl4d5kmms1zeqtebd48.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nВидно, что границы интервала меняются как только статистика, обозначенная черным цветом, пересекает критические значения (А — снизу, В — сверху).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа графике ниже можно наблюдать быструю сходимость оценок параметров распределения к истинным значениям, даже с учетом того, что наши первоначальные оценки были слишком занижены:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efig, ax = plt.subplots(nrows=1, ncols=2, figsize = (10, 5))\n\nax[0].plot(M_star)\nax[0].set_title('Оценка мат.ожидания спроса\\n(истинное $\\mu = 21$)')\nax[0].set_xlabel('Количество оценок вероятностей')\nax[0].set_ylabel('$\\mu$', rotation=0, fontsize=20, labelpad=15)\n\nax[1].plot(S_star)\nax[1].set_title('Оценка отклонения спроса\\n(истинное $\\sigma = 3$)')\nax[1].set_xlabel('Количество оценок вероятностей')\nax[1].set_ylabel('$\\sigma$', rotation=0, fontsize=20, labelpad=15);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fcg\u002F1c\u002F4j\u002Fcg1c4jiqgyzpmkgrk7qvzefwhws.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nПолученные оценки позволяют достичь максимально возможных значений прибыли:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(np.cumsum(SS))\nplt.hlines(300*optim_price(300, 3000, 21, 3), 0, len(SS),\n           color='g', label='Максимальная\\nсредняя прибыль')\nplt.legend(loc='center right')\nplt.title('Изменение кумулятивной суммы прибыли')\nplt.ylabel('Кумулятивная сумма прибыли')\nplt.xlabel('Количество оценок');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fiw\u002Fpw\u002Fbp\u002Fiwpwbpmaozkc95psos_9ppfaetw.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nПри этом цена одной единицы товара не испытывает сильных колебаний:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(prices)\nplt.hlines(optim_price(300, 3000, 21, 3), 0, len(prices),\n           color='g', lw=3, alpha=0.5, zorder=100,\n           label='$Price_{opt}$')\nplt.title('Изменение цены 1-й единицы товара')\nplt.ylabel('Цена 1-й единицы товара')\nplt.xlabel('Количество оценок')\nplt.legend(loc='center right');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fp6\u002Fzc\u002Fwk\u002Fp6zcwksgwok7i8tc7bit_siypd8.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nНу и напоследок, можно видеть, что алгоритм успевает продать весь товар:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(np.cumsum(MS))\nplt.title('Кумулятивная сумма единиц проданного товара')\nplt.ylabel('Кумулятивная сумма')\nplt.xlabel('Количество оценок');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fwh\u002F6r\u002F8q\u002Fwh6r8qkmyy0cqgbh0anzd2atut0.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nНаши первоначальные оценки параметров распределения спроса были довольно далеки от настоящих, но довольно быстро алгоритм все-таки нашел их правильные значения, и далее все продажи выполнялись по оптимальным ценам. Но самое главное в этом примере то, что благодаря критерию Вальда, мы смогли избавиться от фиксированного объема выборки, более того, благодаря параметрам \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E, мы можем управлять статистической значимостью и мощностью выполняемого анализа. Это полезно еще и тем, что стоимость ошибок первого и второго рода может очень сильно отличаться, например, может быть гораздо выгоднее ошибиться и назначить более высокую стоимость товара, чем низкую. Так же данные параметры могут характеризовать склонность к риску, ведь если у нас есть какая-то аналитика предыдущих продаж, то мы можем сделать хорошие первоначальные оценки параметров распределения спроса, а значит можем рискнуть и с самого начала установить очень низкие значения \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F234\u002F756\u002Fba0\u002F234756ba02fcf44c798e4e66aedb3efd.svg\" alt=\"$\\alpha$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fdde\u002F35b\u002F631\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\" alt=\"$\\beta$\" data-tex=\"inline\"\u002F\u003E. Так же данные параметры вовсе не обязаны быть статичными: допустим в начале продаж они могут быть довольно большими, а затем постепенно уменьшаться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ общем, как и в случае алгоритма семплирования Томпсона, представленный алгоритм на основе квантильного и последовательного анализа вовсе не являются универсальным рецептом оптимальных продаж, но принцип его работы на удивление прост и гибок, а это значит, что он может быть легко модифицирован и адаптирован под самые разные задачи. Давайте напоследок именно это и продемонстрируем.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EПродажа авиабилетов при динамическом спросе\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСтационарный спрос характерен для большого количества товаров, но не меньшее количество товаров характеризуется нестационарным спросом. Так же следует упомянуть, что понятие «оптимальная цена» может сильно меняться в зависимости от контекста. Например, для стационарного спроса оптимальность цены может зависеть от того, чего мы хотим добиться: продавать определенное количество товара, максимизировать валовую прибыль или выручку. Все это может учитываться и при нестационарном спросе, но могут появляться дополнительные требования, например, в ходе продаж может возникнуть срочная потребность в наличных деньгах или срочной распродаже товара. В конечном счете все эти требования к оптимальности цены могут быть учтены в алгоритме. Нас же теперь интересует как модифицировать алгоритм так, чтобы он мог учитывать динамику спроса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте снова рассмотрим какой-нибудь простой случай: пусть теперь спрос распределен как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe0a\u002Fb52\u002F493\u002Fe0ab52493f9173988771ba36df62208e.svg\" alt=\"$N(\\epsilon t + \\mu_{0}; \\sigma^{2})$\" data-tex=\"inline\"\u002F\u003E, где \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F915\u002Facb\u002Fb16\u002F915acbb16ed63f15541d3e0bda30d453.svg\" alt=\"$t$\" data-tex=\"inline\"\u002F\u003E — это время. Такая модель спроса уже очень близка к тем ситуациям, когда спрос на некоторый товар меняется со временем (не обязательно линейно), например спрос на шампанское увеличивается к новому году, а спрос на фрукты, лежащие на прилавках, падает с каждым днем, потому что они портятся. Тоже самое можно сказать про билеты на культурные мероприятия и про авиабилеты. Естественно цена на такие товары тоже не может быть стационарной, просто потому, что это не выгодно как для продавцов, так и для покупателей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля большей простоты пока предположим, что нам неизвестны только \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F07d\u002Fb3c\u002Fce4\u002F07db3cce40928fd36ad7738c522b7e18.svg\" alt=\"$\\epsilon$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F4af\u002F348\u002F266\u002F4af348266f7268a3ac9b46a8a0bf32ac.svg\" alt=\"$\\mu_{0}$\" data-tex=\"inline\"\u002F\u003E, но для эксперимента предположим, что \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F1a4\u002F407\u002Fc0d\u002F1a4407c0d32591184aa5ee93ebf16e25.svg\" alt=\"$\\epsilon = 1$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fa20\u002F2f5\u002F358\u002Fa202f53584475a2972a9739e8150cdb1.svg\" alt=\"$\\mu_{0} = 20$\" data-tex=\"inline\"\u002F\u003E. Очень трудно представить более-менее реалистичную ситуацию, при которой нам известно значение \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Ff2d\u002Fdb7\u002F2d8\u002Ff2ddb72d8056981528ead2fc4ad89cac.svg\" alt=\"$\\sigma$\" data-tex=\"inline\"\u002F\u003E и неизвестно значение \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F4af\u002F348\u002F266\u002F4af348266f7268a3ac9b46a8a0bf32ac.svg\" alt=\"$\\mu_{0}$\" data-tex=\"inline\"\u002F\u003E, но пока предположим, что это так и пусть \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6e9\u002F8f3\u002Fe0f\u002F6e98f3e0fc5cfe53e3ffcaa3d03cd937.svg\" alt=\"$\\sigma=4$\" data-tex=\"inline\"\u002F\u003E. Допустим мы торговали некоторым товаром в течении 5 дней, т.е. \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F915\u002Facb\u002Fb16\u002F915acbb16ed63f15541d3e0bda30d453.svg\" alt=\"$t$\" data-tex=\"inline\"\u002F\u003E будет следующим массивом:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Et = np.array([0, 1, 2, 3, 4])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ каждый из дней мы устанавливали следующие цены:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eprice = np.array([23, 25, 25, 27, 28])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКоличество посетителей в каждый из дней было таким:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Em  = np.array([40, 31, 35, 48, 50])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСогласно нашей модели, в каждый из дней были следующие значения мат. ожидания нормального распределения:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Emu = np.array([20, 21, 22, 23, 24]) \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТогда количество проданного товара может быть очень просто смоделировано следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ems = np.array([np.sum(norm.rvs(mu[i], 4, m[i]) \u003E price[i]) for i in np.r_[:5]])\nms \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Earray([9, 4, 8, 9, 5]) \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь перейдем к неизвестным параметрам \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F07d\u002Fb3c\u002Fce4\u002F07db3cce40928fd36ad7738c522b7e18.svg\" alt=\"$\\epsilon$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F4af\u002F348\u002F266\u002F4af348266f7268a3ac9b46a8a0bf32ac.svg\" alt=\"$\\mu_{0}$\" data-tex=\"inline\"\u002F\u003E: предположим, что мы знаем более-менее реалистичные границы этих параметров, например \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fd62\u002Fa07\u002F7e1\u002Fd62a077e11dcf3ba6dcc9d3a8e97e3fb.svg\" alt=\"$\\epsilon \\in [0.7; 1.3]$\" data-tex=\"inline\"\u002F\u003E а \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F571\u002Fe4f\u002F258\u002F571e4f25876015cdf65251503d9cf1b3.svg\" alt=\"$\\mu_{0} \\in [15; 25]$\" data-tex=\"inline\"\u002F\u003E. Тогда мы можем предположить, что \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F07d\u002Fb3c\u002Fce4\u002F07db3cce40928fd36ad7738c522b7e18.svg\" alt=\"$\\epsilon$\" data-tex=\"inline\"\u002F\u003E может принимать следующие значения:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ee = np.array([0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F4af\u002F348\u002F266\u002F4af348266f7268a3ac9b46a8a0bf32ac.svg\" alt=\"$\\mu_{0}$\" data-tex=\"inline\"\u002F\u003E может быть любым из следующего массива:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Emu0 = np.array([15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТогда мы можем предположить, что если \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc69\u002Ff49\u002F578\u002Fc69f495783af4e66ee11b84d4a1bccc5.svg\" alt=\"$\\epsilon_{0} = 0.5$\" data-tex=\"inline\"\u002F\u003E то мат. ожидание может меняться следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Emu_e0 = e[0] * t.reshape(-1, 1) + mu0\nmu_e0 \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Earray([[15. , 16. , 17. , 18. , 19. , 20. , 21. , 22. , 23. , 24. , 25. ],\n       [15.7, 16.7, 17.7, 18.7, 19.7, 20.7, 21.7, 22.7, 23.7, 24.7, 25.7],\n       [16.4, 17.4, 18.4, 19.4, 20.4, 21.4, 22.4, 23.4, 24.4, 25.4, 26.4],\n       [17.1, 18.1, 19.1, 20.1, 21.1, 22.1, 23.1, 24.1, 25.1, 26.1, 27.1],\n       [17.8, 18.8, 19.8, 20.8, 21.8, 22.8, 23.8, 24.8, 25.8, 26.8, 27.8]])\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКаждый столбец в данном массиве показывает как могло бы меняться мат. ожидание с каждым днем, если бы \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Faaa\u002F09b\u002F131\u002Faaa09b131c8a57595e96094a4c67cf3c.svg\" alt=\"$\\epsilon = \\epsilon_{0} = 0.5$\" data-tex=\"inline\"\u002F\u003E. Теперь мы можем проверить вероятность получить имеющиеся значения количества проданных единиц товара по каждому столбцу:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eps = norm.sf(price.reshape(5, 1), loc=mu_e0, scale=4)\nPS = binom.pmf(ms.reshape(5, 1), m.reshape(5, 1), ps)\nsns.heatmap(PS)\nxticks_label = [f'{e[0]}t+{i}' for i in mu0]\nplt.xticks(np.r_[0.5:11.5], xticks_label, rotation=60)\nplt.xlabel('f(t)', fontsize=15)\nplt.ylabel('t', fontsize=15, rotation=0, labelpad=10);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F5c\u002Fhp\u002Fdg\u002F5chpdggj_8mrhhtxqmkyfijqot8.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nНа графике можем наблюдать, что только в столбцах близких к истинному значению \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F4af\u002F348\u002F266\u002F4af348266f7268a3ac9b46a8a0bf32ac.svg\" alt=\"$\\mu_{0}$\" data-tex=\"inline\"\u002F\u003E наблюдаются максимальные значения. В этом можно убедиться, если изобразить произведение вероятностей (сумму логарифмов) в каждом столбце:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eplt.plot(np.sum(np.log(PS), axis=0), marker='o')\nplt.xticks(np.r_[0:11], xticks_label, rotation=60); \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fjx\u002F11\u002Fy7\u002Fjx11y7ridvqqx5agiyff4v2iwca.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЕсли построить подобные графики для всех \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F8a7\u002F140\u002F859\u002F8a71408594b9fc1df8cd8789a27751e5.svg\" alt=\"$\\epsilon_{i}$\" data-tex=\"inline\"\u002F\u003E, то можем наблюдать следующую картину:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efor i in e:\n    mu_e0 = i* t.reshape(-1, 1) + mu0\n    ps = norm.sf(price.reshape(5, 1), loc=mu_e0, scale=4)\n    PS = binom.pmf(ms.reshape(5, 1), m.reshape(5, 1), ps)\n    S = np.sum(np.log(PS), axis=0)\n    plt.plot(S, label=f'$\\epsilon$ = {round(i, 1)}')\nxticks_label = [fr'$\\epsilon$t+{i}' for i in mu0]\nplt.xticks(np.r_[0:11], xticks_label, rotation=60)\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Flg\u002F6h\u002Fab\u002Flg6habiw51lk9t8dcmduh2ytnay.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nНа этом графике, конечно же, невозможно разглядеть максимумы, да и один эксперимент вовсе не показатель сходимости, поэтому проведем больше экспериментов и взглянем на усредненные значения максимумов отдельно:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Et = np.r_[0:10]\nmu = np.r_[20:30]\nres = []\nfor j in range(5000):\n    for i in e:\n        mu_e0 = i*t.reshape(-1, 1) + mu0\n        price = np.arange(21, 31)\n        ps = norm.sf(price.reshape(10, 1), loc=mu_e0, scale=4)\n        m  = np.random.randint(25, 70, 10)\n        ms = np.array([np.sum(norm.rvs(mu[k], 4, m[k]) \u003E price[k]) for k in np.r_[:10]])\n        PS = binom.pmf(ms.reshape(10, 1), m.reshape(10, 1), ps)\n        S = np.sum(np.log(PS), axis=0)\n        res.append([i, np.argmax(S) + 15, S.max()])\nres = pd.DataFrame(res, columns=['eps', 'mu', 'val'])\nsns.pointplot(x='mu', y='val', hue='eps', dodge=True, errwidth=0, palette='tab10', data=res);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fqd\u002Fxl\u002Fbh\u002Fqdxlbhze5vrughbh1ifskokz97s.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nКак видим, наибольшие максимумы соответствуют значениям, которые близки к истинному значению \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F07d\u002Fb3c\u002Fce4\u002F07db3cce40928fd36ad7738c522b7e18.svg\" alt=\"$\\epsilon$\" data-tex=\"inline\"\u002F\u003E. Разумеется, все это не строгое доказательство, но видно, что метод действительно сходится, поэтому давайте попробуем сделать модель по продаже билетов в условиях динамического спроса. Предположим, что нам нужно продать \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc36\u002F6c6\u002Fafe\u002Fc366c6afe45292863afba99b2ae9a9fa.svg\" alt=\"$Q = 350$\" data-tex=\"inline\"\u002F\u003E билетов и продажи начинаются за 100 дней до вылета. Пусть количество посетителей будет распределено как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F5cf\u002F97e\u002Fa95\u002F5cf97ea9554c90b66fb8e74187252845.svg\" alt=\"$N(0.65t+5,(0.18t+2)^{2})$\" data-tex=\"inline\"\u002F\u003E, а спрос будет распределен как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F925\u002F79b\u002F045\u002F92579b045e333f06fbb8f4f7647323ce.svg\" alt=\"$N(0.125t+9300,(0.05t+1500)^{2})$\" data-tex=\"inline\"\u002F\u003E, при этом будем считать, что пока закон изменения отклонения со временем является известным, т.е. в ходе продаж необходимо определить только закон изменения мат. ожидания. Если смоделировать данный спрос, то он будет выглядеть следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E# функция для моделирования времени обращения посетителей:\ndef demand_t(T):\n    D_mu_0, k_3 = 5, 0.65\n    D_sigma_0, k_4 = 2, 0.18    \n    num_day = np.r_[0: T]\n    D_mu_t = k_3 * num_day + D_mu_0\n    D_sigma_t = k_4 * num_day + D_sigma_0\n    vis_day = norm.rvs(D_mu_t, D_sigma_t).astype(int)    \n    t = np.sort(np.hstack([np.random.randint(i*1440, (i + 1)*1440, j) for i, j in zip(range(T), vis_day)]))    \n    return t\n\n# функция для моделирования одного посетителя:\ndef visitor(price, t):\n    money_mu_t = 0.125*t + 9300\n    money_sigma_t = 0.05*t + 1500\n    return int(norm.rvs(money_mu_t, money_sigma_t) \u003E price)\n\ntime_vis = demand_t(100)\nmoney_vis = norm.rvs(0.125*time_vis + 9300, 0.05*time_vis + 1500)\nplt.scatter(time_vis, money_vis, s=10)\nplt.xlabel('Время от начала продаж (мин.)')\nplt.ylabel('Стоимость билета (руб.)')\nplt.title('Модель распределения спроса на авиабилеты'); \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fk7\u002Fnj\u002Fmk\u002Fk7njmksq1ufzxlvxu03i51d0qik.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nПо оси ординат отложена максимальная стоимость билета, выше которой посетитель не может совершить покупку. Допустим, что нам необходимо обеспечить равномерную продажу авиабилетов, т.е. на всем периоде продаж должны иметься доступные для покупки авиабилеты. Данное требование означает, что мы должны изменять цену так, чтобы вероятность продажи одного билета была неизменной на протяжении всего периода продаж. Для этого мы можем создать следующую простую функцию:\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Edef p_prog(q, D_est, mu_est, sigma_est):\n    p_star = q \u002F D_est\n    price_star = norm.interval(1 - 2*p_star, loc=mu_est, scale=sigma_est)[1]\n    return p_star, price_star\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nБлагодаря этой функции мы будем оценивать прогнозируемую вероятность продажи одного билета на ближайшие сутки, а так же выяснять стоимость билета, на основе имеющихся оценок параметров и прогнозируемого количества посетителей. Теперь осталось определить всего две функции: одну для прогнозирования количества посетителей в ближайшие сутки (на основе простой линейной регрессии):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Edef dem_prog(vis_times):\n    if vis_times[-1] \u003E= 5*1440:\n        idx = int(vis_times[-1]\u002F1440)\n        dem_of_day = [np.sum((vis_times \u003E i*1440) &amp; (vis_times &lt;= (i + 1)*1440)) for i in range(idx)]\n        t = np.arange(1, idx+1)*1440\n        reg = np.poly1d(np.polyfit(t, dem_of_day, 1))\n        D_prog = reg(vis_times[-1] + 1440)\n        return D_prog\n    else:\n        return 10\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nИ еще одну для оценки параметров распределения спроса:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efrom scipy import optimize\ndef k_mu_est(T, V, pt):\n    buy = np.hstack(V)\n    t = np.hstack(T)\n\n    def func(x):\n        money_mu_t = x[0]*t + x[1]\n        money_sigma_t = 0.05*t + 1500\n        p = norm.sf(pt, money_mu_t, money_sigma_t)\n        z = np.sum(np.log(bernoulli.pmf(buy, p)))\n        return -z\n    \n    x0=np.array([K[-1], MU[-1]])\n    bounds = [(0, 1), (8800, 9800)]\n    result = optimize.minimize(func,x0=x0,bounds=bounds, method='Powell',\n                               options={'maxiter':100000})\n    return result['x']\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E# Количество билетов:\nQ = 350\n\n# Генерируем время посещения:\nvt = demand_t(100)\n\n# Начальная цена и список для хранения цен в \n# момент времени t:\nprices, prices_t = [9500], []\n\n# Первоначальные оценки вероятности продажи одного\n# билета, и параметров функции мат. ожидания:\nP_est, K, MU = [0.35], [0.11], [9100]\n\n# Количество покупок и посетителей при заданной цене:\nU, N = [], []\n\n# купил или не купил посетитель билет по заданной цене\n# и время обращения:\nvis, vis_t = [], []\nV, T = [], []\n\nS = []\n\n##################################################################\n# Начало продаж выполняемое по нашим теоретическим представлениям:\n\nest_flag = 0\ni = 0\nwhile est_flag == 0:\n    vis_t.append(vt[i])\n    prices_t.append(prices[-1])\n    vis.append(visitor(prices[-1], vt[i]))\n    if vis[-1] == 1:\n        Q -= 1\n    test = vald(vis, P_est[-1])[0]\n    if test != 0:\n        est_flag = 1\n        U.append(sum(vis))\n        N.append(len(vis))\n        V.append(vis)\n        T.append(vis_t)\n        P_est.append(U[-1]\u002FN[-1])\n        S.append(U[-1]*prices[-1])\n        # меняем цену в соответствии с значением теста\n        if test == -1:\n            prices.append(prices[-1] - 150)\n        if test == 1:\n            prices.append(prices[-1] + 150)\n    i += 1\n\n##################################################################\n# Основной цикл:\n    \nvis = []\nvis_t = []    \nfor i in range(i, len(vt)):\n    vis_t.append(vt[i])\n    prices_t.append(prices[-1])\n    vis.append(visitor(prices[-1], vt[i]))\n    if vis[-1] == 1:\n        Q -= 1\n    test = vald(vis, P_est[-1])[0]\n    if test != 0:\n        U.append(sum(vis))\n        N.append(len(vis))\n        S.append(U[-1]*prices[-1])\n        V.append(vis)\n        T.append(vis_t)\n        k_est, mu_est = k_mu_est(T, V, prices_t)\n        K.append(k_est)\n        MU.append(mu_est)\n        mu_prog = K[-1]*(vis_t[-1]+1440) + MU[-1]\n        sigma_prog = 0.05*(vis_t[-1]+1440) + 1500\n        D = dem_prog(vt[:i])\n        q = Q\u002F(100-(vis_t[-1])\u002F1440)\n        p_est, price = p_prog(q, D, mu_prog, sigma_prog)\n        P_est.append(p_est)\n        if abs(price - prices[-1]) &lt;= 200:\n            prices.append(prices[-1])\n        else:\n            prices.append(price)\n        vis = []\n        vis_t = []\n    if Q == 0:\n        if len(vis) != 0:\n            U.append(sum(vis))\n            N.append(len(vis))\n            V.append(vis)\n            T.append(vis_t)\n            S.append(U[-1]*prices[-1])\n        break\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВзглянем как менялись выручка, стоимость билета и количество проданных билетов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ef, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 3))\nax1.plot(np.cumsum(np.array(SS)\u002F1000))\nax1.set_title('Выручка (млн. руб.)')\nax2.plot(prices)\nax2.set_title('Цена (тыс. руб.)')\nax3.plot(np.cumsum(U))\nax3.set_title('Проданных билетов')\nax3.set_yticks(np.r_[0:400:50]); \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fio\u002Fos\u002Fmo\u002Fioosmopa5kcdcm0b0q1vvvt1ri4.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЭто неплохой результат, который, кстати, был обеспечен не такими уж точными оценками параметров:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ef, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4))\nax1.plot(MU)\nax1.set_title(r'Изменение оценок $\\mu_{0}$')\nax2.plot(K)\nax2.set_title(r'Изменение оценок $k_{1}$');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fa_\u002Fne\u002Fxl\u002Fa_nexlfbemxcmwdtghpfq4kdcyu.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nМожно еще раз задаться вопросом: зачем вообще нужен критерий Вальда? Ведь если выполнять квантильный анализ после каждого 25-го посетителя, то можно добиться практически тех же самых результатов:\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fcz\u002Fkk\u002Fig\u002Fczkkigb31oszjoboakba3ury90u.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nКритерий Вальда нужен лишь для того, что бы задать уровень статистической значимости выводов о том где сейчас находится вероятность продажи одной единицы товара. Например, если мы склонны доверять имеющейся аналитике о параметрах распределения спроса, то можем значительно снизить уровни ошибок первого и второго рода, что будет равносильно увеличению фиксированного количества посетителей после которого выполняется квантильный анализ: \u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fke\u002Fw4\u002Fcw\u002Fkew4cwbfxzwwcmc87csag1f-1nq.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nВ данном случае мы можем наблюдать некоторое уменьшение выручки и уменьшение количества изменений цены (из-за которого, во многом, и произошло снижение выручки). Фактически, критерий Вальда даже не участвует в формировании цены, которым занимается квантильный анализ и нужен лишь для того, что бы определить частоту его выполнения. В критерии Неймана-Пирсона эта частота является фиксированной, но в критерии Вальда она зависит от величины ошибки, т.е. чем ошибочнее изменение цены, тем скорее оценка вероятности продажи одной единицы товара покинет зону безразличия, а значит мы скорее отреагируем на эту ошибку и попытаемся ее исправить. В данном примере трудно продемонстрировать достоинство такого поведения, потому что спрос хоть и является динамическим, но имеет стационарные приращения. Тем не менее, такая особенность критерия Вальда может оказаться особенно полезной для динамического спроса с нестационарными приращениями.\u003Cbr\u002F\u003E\r\nВ определенной степени, уровни ошибок первого и второго рода в критерии Вальда можно отнести к классу гиперпараметров, т.е. параметров которые подбираются эмпирически. \u003Cbr\u002F\u003E\r\nКонечно, это крайне искусственный и очень простой пример, призванный показать, что критерий Вальда и квантильный анализ могут быть применены для динамического спроса. По мере приближения моделей к реальным условиям их сложность сильно возрастает. Например, выше мы договорились, что закон изменения отклонения с течением времени считается известным, но как быть если и он является неизвестным? Ответ на этот вопрос проще продемонстрировать. Предположим, что спрос зависит от времени и распределен как \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F459\u002F2e6\u002Fc32\u002F4592e6c32cb5645e058d730f7f6ee87b.svg\" alt=\"$N(k_{1}t+\\mu_{0}, (k_{2}t+\\sigma_{0})^{2})$\" data-tex=\"inline\"\u002F\u003E. Пусть \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F5ec\u002F549\u002Fa0a\u002F5ec549a0ae995aeaee0eabc57515744d.svg\" alt=\"$k_{1} = 0.5$\" data-tex=\"inline\"\u002F\u003E, \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fb7a\u002F74f\u002F7a9\u002Fb7a74f7a9c1990ee3d87da166fc397a7.svg\" alt=\"$k_{2} = 0.1$\" data-tex=\"inline\"\u002F\u003E, \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fe8b\u002F167\u002F49e\u002Fe8b16749e99dda97509dbc07ee5e03b3.svg\" alt=\"$\\mu_{0} = 10$\" data-tex=\"inline\"\u002F\u003E и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fb4f\u002F7dd\u002F211\u002Fb4f7dd2118d5d0ef16f999d9fdeed89e.svg\" alt=\"$\\sigma_{0} = 5$\" data-tex=\"inline\"\u002F\u003E, тогда распределение 100000 посетителей будет выглядеть следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Et = np.random.randint(0, 100, 100000)\nmu = 0.5*t + 10\nsigma = 0.1*t + 5\ndata = norm.rvs(mu, sigma)\nsns.histplot(data)\nplt.xlabel('Количество денег которое посетитель готов отдать за товар');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Flc\u002F_z\u002F4z\u002Flc_z4zuljru-vmul0y5osmisq3a.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nДанное распределение является смесью (суммой) бесконечного количества нормальных распределений и может быть задано следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Edef norm_mix(mu0, sigma0, k1, k2):\n    t = np.arange(0, 100)\n    mu = k1*t + mu0\n    sigma = k2*t + sigma0\n    x = np.c_[np.linspace(-20, 120, 300)]\n    y = norm.pdf(x, mu, sigma)\n    y = y.sum(axis=1)\n    y = y\u002Fnp.trapz(y)\n    return x, y\nplt.plot(*norm_mix(10, 5, 0.5, 0.1));\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F4g\u002Fxv\u002Fna\u002F4gxvna3ct1wtuuwezmlryuuuvcy.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЭто распределение является двухпараметрическим, т.е. оно так же как и нормальное распределение имеет параметры смещения и масштаба, но помимо них обладает еще двумя параметрами формы — \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fd42\u002F43a\u002F637\u002Fd4243a637259458b5bdb16df941a48c1.svg\" alt=\"$k_{1}$\" data-tex=\"inline\"\u002F\u003E, \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F0ea\u002F551\u002F526\u002F0ea551526006921e2da3a705b2a8d04f.svg\" alt=\"$k_{2}$\" data-tex=\"inline\"\u002F\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EPython\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Emu0 = [10, 10, 25, 25]\nsigma0 = [5, 10, 5, 10]\nk1 = [0.5, 0.2, 0.5, 0.7]\nk2 = [0.1, 0.3, 0.1, 0.05]\nfor i in range(4):\n    plt.plot(*norm_mix(mu0[i], sigma0[i], k1[i], k2[i]),\n             label=fr'$k_{1} = {k1[i]}$, $k_{2} = {k2[i]}$, $\\mu_{0} = {mu0[i]}$, $\\sigma_{0} = {sigma0[i]}$');\nplt.legend();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fye\u002Fl6\u002Fsb\u002Fyel6sbzgnt9fo81ixldd3q_bemq.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЕсли не рассматривать только фиксированные временные интервалы (например для вышеприведенного графика все распределения построены для \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F8b2\u002Fc9b\u002F86b\u002F8b2c9b86b6d2346947ae10f78df31c73.svg\" alt=\"$t \\in [0, 100]$\" data-tex=\"inline\"\u002F\u003E), то границы интервалов так же будут влиять на форму распределений. Данное распределение может быть использовано в квантильном анализе, точно так же как выше использовалось нормальное. Причем мат. ожидание и отклонение вовсе не обязаны меняться со временем линейно, изменение может быть ускоренным или иметь другой более сложный вид. В общем случае, если мат. ожидание и отклонение модели спроса задаются как функции от времени, то вся задача сводится к оценке постоянных коэффициентов функций. Иными словами, оценка параметров по-прежнему опирается на Байесовский метод, просто количество измерений условных вероятностей теперь будет равно общему количеству параметров модели спроса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EВ заключение\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли несколько раз (в данном случае 50) сравнивать работу данного алгоритма с текущим положением дел в ценообразовании авиабилетов, то картина получается следующая: \u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F82\u002Fce\u002Feu\u002F82ceeuuvmlnofgm8xpkuv5fjkg0.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nЛиниями показаны мат. ожидания, а доверительные интервалы — это стандартные отклонения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ данном случае под текущим положением дел понимается единственная и простейшая стратегия которая сейчас используется — ручное управление. С одной стороны может показаться, что такую стратегию практически невозможно смоделировать с учетом всей ее \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F506240\u002F\"\u003Eсложности\u003C\u002Fa\u003E. Однако, с определенной «высоты» (и с точки зрения конечного потребителя), вся эта система ведет себя как единственный продавец, который понимает все механизмы только на интуитивном уровне. Поскольку, в качестве цели мы ставили условие максимизации выручки при постоянном наличии билетов в продаже и их полной реализации, то все, что может делать данный продавец — менять цену, пытаясь выровнять скорость продажи билетов с учетом их оставшегося количества. В данном случае «менять цену» означает «угадать цену», т.е. изменение цены является случайной величиной из равномерного распределения, границы которого подобраны так, что бы стратегия удовлетворяла целевым условиям. Вот такая модель текущего положения дел.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОпять же, такое сравнение нельзя назвать абсолютно корректным, но оно дает возможность хотя бы приблизительно оценить прирост выручки обеспеченный ценообразованием на основе квантильного анализа, который можно оценить интервалом от 25% до 35%. Эти цифры вовсе неудивительны, поскольку в режиме ручного управления просто невозможно постоянно угадывать самую оптимальную цену. В случае единичных продаж без ручного управления не обойтись, но когда речь идет о масштабе целой авиакомпании — оно становится серьезным недостатком, который заставляет завышать стоимость билетов и терпеть серьезные убытки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВся данная статья базируется на одной простой гипотезе о том, что спрос имеет нормальное распределение. Казалось бы, на том же самом Kaggle полно данных по онлайн торговле и можно легко доказать или опровергнуть эту гипотезу. Но это не было целью данной статьи, так как проблема вовсе не в этом. Здесь мы хотели упрощенно продемонстрировать те подходы, которые используем при решении оптимизационных задач. В своем кругу мы иногда шутим, говоря, что статистическое управление — это то же самое, что управление автомобилем по зеркалу заднего вида, причем довольно маленькому и заляпанному. Ведь смысл оптимального управления заключается не только в том, чтобы найти лучшую стратегию, но еще и в том что бы выполнять ее оптимальную коррекцию на основе поступающих данных о спросе. Как раз коррекция и является самым слабым местом в управлении.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБезусловно, задача динамического ценообразования крайне актуальна для отрасли гражданских авиаперевозок, но как уже говорилось выше, даже если предположить, что у нее есть самое оптимальное решение, то от него все равно не будет никакого толка, если авиакомпания выполнит неоптимальную расстановку авиапарка или выберет для него неоптимальные маршруты. Представленный алгоритм ценообразования, при самых оптимистичных оценках позволяет добиться лишь 10%-го увеличения прибыли в сравнении с алгоритмом сэмплирования Томпсона. Это может показаться хорошим результатом, но на самом деле, если принять во внимание \u003Ca href=\"https:\u002F\u002Fiz.ru\u002F1210338\u002Fmaksim-talavrinov\u002Fprolet-normalnyi-pochemu-aviabilety-po-rossii-podesheveli-na-30\" rel=\"nofollow noopener noreferrer\"\u003Eтекущее положение дел\u003C\u002Fa\u003E глобальных логистических процессов, то эти 10% всего лишь \u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=7iF-xM30rXk\" rel=\"nofollow noopener noreferrer\"\u003Eкапля в море\u003C\u002Fa\u003E той прибыли, которая упускается всеми игроками. Поэтому в следующей статье мы постараемся рассмотреть модели оптимизации использования судов, планирования расписания и формирования ценообразования как единую задачу.\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"математика"},{"titleHtml":"авиация"},{"titleHtml":"транспорт"},{"titleHtml":"ценообразование"},{"titleHtml":"е-commerce"},{"titleHtml":"алгоритмы"},{"titleHtml":"билеты"},{"titleHtml":"rms"},{"titleHtml":"продажи"},{"titleHtml":"авиаперевозки"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F13\u002Flo\u002Fwx\u002F13lowxkxgxz91jd26oqjz9zw6nm.jpeg","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F13\u002Flo\u002Fwx\u002F13lowxkxgxz91jd26oqjz9zw6nm.jpeg","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F580782\\\u002F\"},\"headline\":\"Логистика. Часть 3. Еще одна модель динамического ценообразования\",\"datePublished\":\"2021-10-16T00:29:30+03:00\",\"dateModified\":\"2021-10-19T18:50:31+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Andrey\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мыс...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F580782\\\u002F#post-content-body\",\"about\":[\"h_algorithms\",\"h_maths\",\"h_ecommerce_development\",\"h_ecommerce\",\"h_transport\",\"f_develop\",\"f_management\",\"f_popsci\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F580782\\\u002Fafbd034971b54c23e44548e6e375c297\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F13\\\u002Flo\\\u002Fwx\\\u002F13lowxkxgxz91jd26oqjz9zw6nm.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fr2\\\u002Foi\\\u002Fnu\\\u002Fr2oinulcws61uxqdhmplxbq-i1u.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fq5\\\u002Ffm\\\u002Fpy\\\u002Fq5fmpy1cwt6dbhp-je3czfznqgc.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fla\\\u002Fxg\\\u002Fpp\\\u002Flaxgppn5h_xol4i8v0tpzdxaoco.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fz0\\\u002Fbi\\\u002Fpt\\\u002Fz0biptmarht6jxhsqiedcpbecpm.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fb87\\\u002Fc43\\\u002F419\\\u002Fb87c4341953d9930499c99cfd4f7de89.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Faf3\\\u002F360\\\u002Fe5a\\\u002Faf3360e5a8f861c3f0dc6097396caba5.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F712\\\u002F5c7\\\u002F7f7\\\u002F7125c77f701219f0ea40d62e1e6dfb20.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fd51\\\u002F0ff\\\u002F0b5\\\u002Fd510ff0b5084ee6b6886523588fd9316.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fd76\\\u002Fa4f\\\u002F87a\\\u002Fd76a4f87a47846d29dd9758f30070dbf.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fav\\\u002F-3\\\u002F8g\\\u002Fav-38gdtwkdubh30dypemgnpk9o.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fe45\\\u002F275\\\u002F2e5\\\u002Fe452752e5729a1c7416345ef63bc4df0.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F096\\\u002Fed7\\\u002F65c\\\u002F096ed765c8bbbc1f1e34d3b19d3550ed.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fc56\\\u002F240\\\u002Fe10\\\u002Fc56240e100662324ed83f17092ee9fa2.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fff9\\\u002Fde2\\\u002F94e\\\u002Fff9de294e6aca9810aed4f3eebd4d2bc.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F4cc\\\u002Ffd4\\\u002F32e\\\u002F4ccfd432ea4f2a64f3a5c8c7378517af.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F637\\\u002Fbc1\\\u002F6ce\\\u002F637bc16ce01bbbb767d2cab3850d0420.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fhz\\\u002Fbb\\\u002Ffg\\\u002Fhzbbfg2imha5i1ki9v6qsw5qupe.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fva\\\u002Fob\\\u002Fdb\\\u002Fvaobdbc-jpo1hpoepy47hepudim.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fsn\\\u002Fka\\\u002Fcg\\\u002Fsnkacgruttycsyvyztzkhazsttk.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F53a\\\u002Fea9\\\u002Ff07\\\u002F53aea9f07ccaf30ffac7cd8719e70972.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F2fb\\\u002Fb7c\\\u002F851\\\u002F2fbb7c8514633d9dbc23336d18634f04.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F1d6\\\u002Fe3d\\\u002Fc60\\\u002F1d6e3dc60633569bb3f51249e1a4ee2c.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fd31\\\u002F1eb\\\u002F78a\\\u002Fd311eb78a0617bccfcb9c311add8ba87.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fd63\\\u002Faa6\\\u002F9de\\\u002Fd63aa69decbb67ddf001a6b13fc54bb6.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F082\\\u002F329\\\u002F06a\\\u002F08232906a2219e19d5b55fcc298988b3.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fns\\\u002F6d\\\u002Fmu\\\u002Fns6dmuvrtkyeeysc2wnmqo0ghto.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F5bf\\\u002Fc52\\\u002Faae\\\u002F5bfc52aaead575e156515b8c206fd63d.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fa7d\\\u002Ff0b\\\u002F0cf\\\u002Fa7df0b0cf52583a7326d63832fe3d4ed.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F117\\\u002F5ef\\\u002Fb8b\\\u002F1175efb8bee3e7b48fb17482fa0cd6e7.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F9aa\\\u002Fe08\\\u002F704\\\u002F9aae087046a60218262bab4a00522adc.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F167\\\u002Fc15\\\u002Fe50\\\u002F167c15e502e5a7e133b1a9f9ef7d0bce.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F25e\\\u002F17a\\\u002Fb19\\\u002F25e17ab19263202dfb3c1aebfacf19f9.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F36a\\\u002F7a3\\\u002F4c0\\\u002F36a7a34c01ac63d36be1138a96b2a855.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F9d8\\\u002Fa3d\\\u002F960\\\u002F9d8a3d960748cc0475baf28df77f4503.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F552\\\u002F1bc\\\u002Ff0b\\\u002F5521bcf0bc906cefe74582db8c0359d9.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F86a\\\u002F538\\\u002F279\\\u002F86a538279987ae5a5cd4a304e7a473ea.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F9bb\\\u002Ff5a\\\u002F4d7\\\u002F9bbf5a4d79b8208d4c01b4422de33c18.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F9f4\\\u002Faf5\\\u002F8b0\\\u002F9f4af58b0f7eb150df3148c5fd587c9d.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F446\\\u002Fd35\\\u002F399\\\u002F446d3539913a80cb65e58f051e004642.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F0a3\\\u002F09e\\\u002Fea1\\\u002F0a309eea16d2da7f3efd734d08d6b5a8.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fd94\\\u002Feac\\\u002Ff64\\\u002Fd94eacf64bc69d68ec23f2bf35f55b9e.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F9ed\\\u002F24a\\\u002Fda4\\\u002F9ed24ada4750b2f910c10dbdff774b00.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fl1\\\u002Fhz\\\u002Fkp\\\u002Fl1hzkpvy1r9ddfcywei_cxw5dlk.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F_o\\\u002F-o\\\u002Fce\\\u002F_o-oce3hlkolwlehw-bdwtxou9o.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fj2\\\u002Fcm\\\u002Fop\\\u002Fj2cmopnsjyap-cxwufo_sejqxqs.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F118\\\u002F471\\\u002Fce7\\\u002F118471ce780db31b150774846ac1c463.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F5c5\\\u002Fe36\\\u002Fdb9\\\u002F5c5e36db9aa19979c7f6bb87da974a77.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fe71\\\u002Faeb\\\u002F1ba\\\u002Fe71aeb1ba620216cb4189e94b76aaf29.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Ftk\\\u002F9r\\\u002Fwm\\\u002Ftk9rwmkknervwbatofyvn2x-6wo.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fji\\\u002Fvf\\\u002Fp9\\\u002Fjivfp9mv5oi23n56cz_ff2ydxcq.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F-o\\\u002Fy0\\\u002Fva\\\u002F-oy0vaopheddusn3mzxu9nsp5x0.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fvd\\\u002Fhl\\\u002Fpq\\\u002Fvdhlpq20urlmd9bt0ykbbdlsoic.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fvx\\\u002Fua\\\u002Fbp\\\u002Fvxuabplvuuel6nouvrxx6elouci.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F234\\\u002F756\\\u002Fba0\\\u002F234756ba02fcf44c798e4e66aedb3efd.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fdde\\\u002F35b\\\u002F631\\\u002Fdde35b63133e1e49275c05ed00f4cd5d.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F201\\\u002F452\\\u002F4b7\\\u002F2014524b753fe3952e1d23685a5abd69.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F1a9\\\u002F77c\\\u002Fac2\\\u002F1a977cac2cf20bea49d0fdc767870c52.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F5cc\\\u002F533\\\u002F72d\\\u002F5cc53372dffdbc45385ac0fb1a95f4a9.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F37f\\\u002Fc60\\\u002F2df\\\u002F37fc602df17cd0b1a13d2d5521d9405b.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F880\\\u002Fbcf\\\u002F3aa\\\u002F880bcf3aaf2ccb7df6dbf0f6cd81fd41.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F24e\\\u002F802\\\u002Fb5b\\\u002F24e802b5b6c51b1b789c4144730f8359.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F507\\\u002F4e4\\\u002F3d6\\\u002F5074e43d6122f1c4589abf6a3efc4bcd.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F99a\\\u002F8d4\\\u002F297\\\u002F99a8d42976dd82af5dc1a7e9906e76d6.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fa7a\\\u002F232\\\u002F066\\\u002Fa7a232066f94f3bc1a8a7e7dc8ffec12.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fa32\\\u002F8ad\\\u002F81c\\\u002Fa328ad81c5f1577dbf6c922fab9924b7.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F73d\\\u002Fbeb\\\u002F90f\\\u002F73dbeb90f104f08a18224ed0eedc014d.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F1f2\\\u002Fb36\\\u002F77d\\\u002F1f2b3677d71680975e0f552a92393e24.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fa72\\\u002F5a3\\\u002Fb2f\\\u002Fa725a3b2f2f265b66e8fe0e7575bf371.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F8b9\\\u002Ff2d\\\u002F153\\\u002F8b9f2d153dd0c14313df669f7bcf9467.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F80c\\\u002Fc83\\\u002F502\\\u002F80cc835025159653c3b8c1fbffea0a79.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fbfd\\\u002F65a\\\u002F74d\\\u002Fbfd65a74de356945ba7db1a6899f9f76.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fe38\\\u002F146\\\u002F7f4\\\u002Fe381467f43d7ce7688e31b457ec4938d.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fej\\\u002Fkw\\\u002Fzw\\\u002Fejkwzwz__2hkdgscldvgmca570g.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Foa\\\u002Fps\\\u002Frz\\\u002Foapsrzmc5deznobaxlyfptyr7uy.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fqj\\\u002Fgy\\\u002Fsv\\\u002Fqjgysv2hmsy0ttpzyjulxsaphdq.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Feu\\\u002Fcf\\\u002Fbm\\\u002Feucfbmsw-ppiyybjjf6ecrrznhc.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fb7\\\u002Fxr\\\u002Fhg\\\u002Fb7xrhgkjkaclaqyzzpukfvxbzua.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa4\\\u002Fhu\\\u002Fze\\\u002Fa4huzebrcwlsppbb-k5-maqhoii.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fbb9\\\u002F9dd\\\u002F06b\\\u002Fbb99dd06bc822424df5c44ffcb2be720.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F619\\\u002F893\\\u002F974\\\u002F619893974ce5e5136d1c0815bfabaed2.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F3fd\\\u002F874\\\u002F494\\\u002F3fd8744949d2433267bc8216f7d09e5b.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Ffb4\\\u002F0fb\\\u002Fd4d\\\u002Ffb40fbd4d1af9c4c34dbc7b22033730a.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fdd5\\\u002F7a3\\\u002F6e6\\\u002Fdd57a36e67b69440b7d3a97b1e5f6e56.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fc31\\\u002F8e0\\\u002F606\\\u002Fc318e0606625f9e246bbd1a1f13281b7.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fca0\\\u002F537\\\u002F90c\\\u002Fca053790c820407b818c358aebba69da.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F621\\\u002Fb81\\\u002F968\\\u002F621b81968021ea2576ab3165db3e8ed8.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F971\\\u002Fbe2\\\u002F2ea\\\u002F971be22ea4c5021440806a7348f3cabb.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F880\\\u002F67f\\\u002F133\\\u002F88067f133f4e67e895bff596a553b89b.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Ff3d\\\u002F153\\\u002Fec5\\\u002Ff3d153ec5bafeb6f2790b31036abb2bc.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F99a\\\u002Fb8b\\\u002F347\\\u002F99ab8b3476d97cf9b0b84343d98fa1cd.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fc39\\\u002Fa08\\\u002Fda1\\\u002Fc39a08da1f07d8df6b33970c5b131305.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Ffc9\\\u002Fede\\\u002Fa40\\\u002Ffc9edea400279d3bbb719fedcb9b8736.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fqn\\\u002Fvy\\\u002Fq-\\\u002Fqnvyq-vvgl4d5kmms1zeqtebd48.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fcg\\\u002F1c\\\u002F4j\\\u002Fcg1c4jiqgyzpmkgrk7qvzefwhws.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fiw\\\u002Fpw\\\u002Fbp\\\u002Fiwpwbpmaozkc95psos_9ppfaetw.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fp6\\\u002Fzc\\\u002Fwk\\\u002Fp6zcwksgwok7i8tc7bit_siypd8.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fwh\\\u002F6r\\\u002F8q\\\u002Fwh6r8qkmyy0cqgbh0anzd2atut0.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fe0a\\\u002Fb52\\\u002F493\\\u002Fe0ab52493f9173988771ba36df62208e.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F915\\\u002Facb\\\u002Fb16\\\u002F915acbb16ed63f15541d3e0bda30d453.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F07d\\\u002Fb3c\\\u002Fce4\\\u002F07db3cce40928fd36ad7738c522b7e18.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F4af\\\u002F348\\\u002F266\\\u002F4af348266f7268a3ac9b46a8a0bf32ac.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F1a4\\\u002F407\\\u002Fc0d\\\u002F1a4407c0d32591184aa5ee93ebf16e25.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fa20\\\u002F2f5\\\u002F358\\\u002Fa202f53584475a2972a9739e8150cdb1.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Ff2d\\\u002Fdb7\\\u002F2d8\\\u002Ff2ddb72d8056981528ead2fc4ad89cac.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F6e9\\\u002F8f3\\\u002Fe0f\\\u002F6e98f3e0fc5cfe53e3ffcaa3d03cd937.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fd62\\\u002Fa07\\\u002F7e1\\\u002Fd62a077e11dcf3ba6dcc9d3a8e97e3fb.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F571\\\u002Fe4f\\\u002F258\\\u002F571e4f25876015cdf65251503d9cf1b3.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fc69\\\u002Ff49\\\u002F578\\\u002Fc69f495783af4e66ee11b84d4a1bccc5.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Faaa\\\u002F09b\\\u002F131\\\u002Faaa09b131c8a57595e96094a4c67cf3c.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F5c\\\u002Fhp\\\u002Fdg\\\u002F5chpdggj_8mrhhtxqmkyfijqot8.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fjx\\\u002F11\\\u002Fy7\\\u002Fjx11y7ridvqqx5agiyff4v2iwca.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F8a7\\\u002F140\\\u002F859\\\u002F8a71408594b9fc1df8cd8789a27751e5.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Flg\\\u002F6h\\\u002Fab\\\u002Flg6habiw51lk9t8dcmduh2ytnay.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fqd\\\u002Fxl\\\u002Fbh\\\u002Fqdxlbhze5vrughbh1ifskokz97s.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fc36\\\u002F6c6\\\u002Fafe\\\u002Fc366c6afe45292863afba99b2ae9a9fa.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F5cf\\\u002F97e\\\u002Fa95\\\u002F5cf97ea9554c90b66fb8e74187252845.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F925\\\u002F79b\\\u002F045\\\u002F92579b045e333f06fbb8f4f7647323ce.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fk7\\\u002Fnj\\\u002Fmk\\\u002Fk7njmksq1ufzxlvxu03i51d0qik.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fio\\\u002Fos\\\u002Fmo\\\u002Fioosmopa5kcdcm0b0q1vvvt1ri4.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Fne\\\u002Fxl\\\u002Fa_nexlfbemxcmwdtghpfq4kdcyu.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fcz\\\u002Fkk\\\u002Fig\\\u002Fczkkigb31oszjoboakba3ury90u.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fke\\\u002Fw4\\\u002Fcw\\\u002Fkew4cwbfxzwwcmc87csag1f-1nq.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F459\\\u002F2e6\\\u002Fc32\\\u002F4592e6c32cb5645e058d730f7f6ee87b.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F5ec\\\u002F549\\\u002Fa0a\\\u002F5ec549a0ae995aeaee0eabc57515744d.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fb7a\\\u002F74f\\\u002F7a9\\\u002Fb7a74f7a9c1990ee3d87da166fc397a7.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fe8b\\\u002F167\\\u002F49e\\\u002Fe8b16749e99dda97509dbc07ee5e03b3.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fb4f\\\u002F7dd\\\u002F211\\\u002Fb4f7dd2118d5d0ef16f999d9fdeed89e.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Flc\\\u002F_z\\\u002F4z\\\u002Flc_z4zuljru-vmul0y5osmisq3a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F4g\\\u002Fxv\\\u002Fna\\\u002F4gxvna3ct1wtuuwezmlryuuuvcy.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fd42\\\u002F43a\\\u002F637\\\u002Fd4243a637259458b5bdb16df941a48c1.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F0ea\\\u002F551\\\u002F526\\\u002F0ea551526006921e2da3a705b2a8d04f.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fye\\\u002Fl6\\\u002Fsb\\\u002Fyel6sbzgnt9fo81ixldd3q_bemq.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F8b2\\\u002Fc9b\\\u002F86b\\\u002F8b2c9b86b6d2346947ae10f78df31c73.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F82\\\u002Fce\\\u002Feu\\\u002F82ceeuuvmlnofgm8xpkuv5fjkg0.png\"]}","metaDescription":"Бывает так, что попадается какая-то задача, находится ее решение, причем довольно неплохое, но потом эта задача все равно не отпускает. Появляется навязчивая мысль о том, что у нее должно быть более...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"algorithms,maths,ecommerce_development,ecommerce,transport"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
