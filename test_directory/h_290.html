<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Обработка жестов в iOS / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/584100\/"},"headline":"Обработка жестов в iOS","datePublished":"2021-10-19T20:59:21+03:00","dateModified":"2021-10-22T20:43:55+03:00","author":{"@type":"Person","name":"Лев Бондаренко"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и соб...","url":"https:\/\/habr.com\/ru\/post\/584100\/#post-content-body","about":["h_ios_dev","h_mobile_dev","h_swift","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/584100\/8e899d71aa92509cdd701036bc965550\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b74\/9e6\/b9f\/b749e6b9f7cc4bfc4ba603a8e34b8d7d.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/f6e\/2bb\/6fc\/f6e2bb6fce5fc19680d3a6047dd8f7af.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/463\/991\/6cf\/4639916cf7ec9b815a4217a2988d09e7.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b9c\/095\/053\/b9c095053f2ce3f9f294bd667169f26c.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d1a\/219\/4bd\/d1a2194bdcefde540cf1a1a3d884460f.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/ec5\/a3f\/0ca\/ec5a3f0caa86ad00aea4a480527bd7ac.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/5a3\/738\/7dd\/5a37387dd18dcf0014c4f02ffa6008ce.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2c3\/838\/8da\/2c38388da2e01a44d3df0d50cee7624d.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/66f\/7a1\/c9e\/66f7a1c9e0ed7325c770e9216762cebe.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/3a1\/bf3\/6b6\/3a1bf36b699887ef2bed06962e456239.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/254\/548\/38b\/25454838b35efb50b4c4811dc3a7249f.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/921\/67f\/7a3\/92167f7a36f661cde44c2ca4ffc95e9d.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/252\/0a2\/142\/2520a2142583466bdfeda81ddbf5ff88.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Обработка жестов в iOS" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Обработка жестов в iOS" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Обработка жестов в iOS" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/24d/39f/5e2/24d39f5e213f2a16d800890b6a926bb5.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/24d/39f/5e2/24d39f5e213f2a16d800890b6a926bb5.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/24d/39f/5e2/24d39f5e213f2a16d800890b6a926bb5.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/24d/39f/5e2/24d39f5e213f2a16d800890b6a926bb5.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/24d/39f/5e2/24d39f5e213f2a16d800890b6a926bb5.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="584100" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-19T17:59:21.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/584100/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/584100/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/24d/39f/5e2/24d39f5e213f2a16d800890b6a926bb5.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/584100/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/levbond/" title="levbond" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/b2e/4ba/650/b2e4ba650c52200f5affd6b079057e48.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/levbond/" class="tm-user-info__username">
      levbond
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-19T17:59:21.000Z" title="2021-10-19, 20:59">19  октября   в 20:59</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Обработка жестов в iOS</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/ios_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка под iOS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/mobile_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка мобильных приложений</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/swift/" class="tm-article-snippet__hubs-item-link"><span>Swift</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь сделать.</p><figure class="full-width "><img src="/img/image-loader.svg" height="590" data-src="https://habrastorage.org/getpro/habr/upload_files/b74/9e6/b9f/b749e6b9f7cc4bfc4ba603a8e34b8d7d.png" data-width="2254"/><figcaption></figcaption></figure><p><strong>Структура:</strong></p><ul><li><p>UIKit</p></li><li><p>Responder Chain</p></li><li><p>Main Event Loop</p></li><li><p>Gesture Recognizers</p></li><li><p>Hit testing</p></li><li><p>Разбор основных кейсов</p></li></ul><h2>UIKit</h2><p>Начнем с главного. Что такое ваш UIKit? Если посмотреть в официальную доку, то мы увидим такую инфу:</p><blockquote><p><em>The UIKit framework provides the required infrastructure for your iOS or tvOS apps. It provides the window and view architecture for implementing your interface, the event handling infrastructure for delivering Multi-Touch and other types of input to your app, and the main run loop needed to manage interactions among the user, the system, and your app.</em></p></blockquote><p>Так. Здесь мы узнали, что этот фреймворк помогает нам создавать архитектуру окон и вьюшек, инфраструктуру обработки событий, а также основной цикл выполнения. Давайте пройдемся по порядку.</p><h4>UIApplication, UIWindow, UIView - кто, зачем и почему?</h4><p>Наше приложение стартует с имплементации экземпляра класса для <a href="https://developer.apple.com/documentation/uikit/uiapplication" rel="noopener noreferrer nofollow">UIApplication</a>. Каждое iOS приложение имеет ровно один экземпляр <strong>UIApplication</strong>. Он маршрутизирует события пользователя, а также с помощью <strong>UIApplicationDelegate</strong> информирует о важных событиях (запуске приложения, не хватки памяти, завершении работы приложения).</p><figure class=""><img src="/img/image-loader.svg" height="160" data-src="https://habrastorage.org/getpro/habr/upload_files/f6e/2bb/6fc/f6e2bb6fce5fc19680d3a6047dd8f7af.png" data-width="300"/><figcaption></figcaption></figure><p>Давайте посмотрим как это выглядит в коде. Если бы мы юзали сториборды, то это происходило автоматически. UIApplicationMain проверяет, использует ли ваше приложение сториборды. Он знает, используете ли вы main storyboard и каково ее имя, просмотрев ключ Info.plist “Main storyboard file base name” (UIMainStoryboard- File)</p><p>Но мы попробуем все сделать кодом:</p><pre><code class="swift">// отмечаем ключевым словом @main для определения главной точки входа в программу
@main
class MainAppDelegate: UIResponder, UIApplicationDelegate {
    // определяем окно, которое будет главным.
    var window: UIWindow?
    
    // Метод UIApplicationDelegate. Вызывается тогда, когда приложение запустилось
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        let window = UIWindow(frame: UIScreen.main.bounds)
				window.rootViewController = ViewController() // Инициализируем главный вьюконтроллер
        window.makeKeyAndVisible() // устанавливаем это окно ключевым
        self.window = window

        return true
    }
}</code></pre><p>Получается:</p><ul><li><p>UIApplicationMain создает экземпляр UIApplication и сохраняет этот экземпляр. К которому позже можно обращаться через UIApplication.shared</p></li><li><p>Затем он создает экземпляр класса делегата приложения. Система знает что это за класс, потому что мы пометили его <strong>@main</strong> (в ранних версиях @<strong>UIApplicationMain</strong>)</p></li><li><p>UIApplicationMain вызывает у делегата приложения метод <strong>application(_:didFinish- LaunchingWithOptions:)</strong>.</p></li><li><p>Но интерфейс приложения не отображается, пока содержащее его window не станет ключевым окном приложения. Функция <strong>makeKeyAndVisible </strong>поможет нам</p></li></ul><p><em>Но начиная с iOS 13, функции AppDelegate были разделены между AppDelegate и SceneDelegate. Это результат новой функции поддержки многооконного режима, представленной в ОС iPad, которая разделяет работу AppDelegate на две части.</em></p><ul><li><p>UIApplicationMain вызывает у делегата приложения метод <strong>application(_:didFinish- LaunchingWithOptions:)</strong>.</p></li><li><p><strong>UIApplicationMain</strong> создает <strong>UISceneSession</strong>, <strong>UIWindowScene</strong> и экземпляр, который будет служить делегатом сцены окна</p></li><li><p>В Info.plist нужно указать (в виде строки) какой класс будет делегатом </p></li><li><p>UIApplicationMain проверяет, использует ли ваша начальная сцена сториборды. (В Info.plist нужно указать имя сториборда)</p></li><li><p>Если сцена имеет сториборд, то UIApplicationMain создает экземпляр UIWindow и назначает его делегатом сцены.</p></li><li><p>UIApplicationMain вызывает отображение интерфейса путем вызова метода экземпляра UIWindow <strong>makeKeyAndVisible</strong>.</p></li><li><p>В делегате сцены вызывается метод <strong>scene(_:willConnectTo:options:)</strong></p></li></ul><blockquote><p>Не ожидайте, что window может быть только одно. Есть такие окна <strong>UITextEffectsWindow</strong> и <strong>UIRemoteKeyboardWindow</strong>.</p></blockquote><p>Окей. Мы вроде разобрались как создается главный маршрутизатор всех событий. Но что такое эти события и как они выглядят?</p><p>Знакомьтесь. Это <a href="https://developer.apple.com/documentation/uikit/uievent" rel="noopener noreferrer nofollow">UIEvent</a>. Главный объект, который содержит много нужной инфы для обработки событий. Когда обнаруживается системное событие, такое как прикосновение к экрану, UIKit внутри создает экземпляры UIEvent и отправляет их в очередь системных событий (main event loop), вызывая <strong>UIApplication.shared.sendEvent()</strong>. </p><h4>UITouch</h4><p>Каждый экземпляр UIEvent содержит одно или несколько объектов UITouch. Для данного объекта UITouch могут произойти только четыре вещи. Они называются фазами касания и описываются свойством <strong>var phase</strong>: <strong>UITouch.Phase:</strong></p><ul><li><p>.<strong>began</strong> — Палец впервые коснулся экрана; этот экземпляр UITouch только что был создан. Это всегда первая фаза, которая наступает только один раз.</p></li><li><p>.<strong>moved </strong>— Палец двигается по экрану.</p></li><li><p>.<strong>stationary </strong>— Палец оставался на экране неподвижно. Для чего это нужно? Как только экземпляр UITouch был создан, он должен присутствовать каждый раз, когда прибывает UIEvent для этой последовательности мультитач. Таким образом, если UIEvent прибывает из-за того, что произошло что-то еще (например, новый палец коснулся экрана), UIEvent должен сообщить, что этот палец делал, даже если он ничего не делал</p></li><li><p><strong>.ended </strong>— Палец покинул экран. Как и .began, эта фаза наступает только один раз. Экземпляр UITouch теперь будет уничтожен и больше не будет отображаться в UIEvents для этой последовательности мультитача.</p></li></ul><p>По сути этих 4х фаз достаточно, чтобы описать все действия пальца. Но возможна еще одна фаза:</p><ul><li><p>.<strong>cancelled </strong>— Система прервала последовательность мультитача, потому что что-то прервало ее.<strong> </strong>Возможно, пользователь нажал кнопку «Домой» или кнопку блокировки экрана в середине последовательности. Возможно, появилось локальное уведомление.</p></li></ul><p><strong>UITouch</strong> также имеет такие свойства:</p><ul><li><p><strong>location(in:), previousLocation(in:) </strong>— Текущее и предыдущее местоположение этого касания относительно системы координат view.</p></li><li><p><strong>timestamp </strong>— Когда тач последний раз менялся. Прикосновение получает отметку времени, когда оно создается (.began) и каждый раз, когда оно перемещается (.moved)</p></li><li><p><strong>tapCount </strong>— Если два касания происходят примерно в одном и том же месте в быстрой последовательности, а первое короткое, второе можно охарактеризовать как повторение первого. Это разные сенсорные объекты, но второму будет назначено значение tapCount на единицу больше, чем у предыдущего</p></li><li><p><strong>view </strong>— вьюшка, c которой связано это прикосновение</p></li></ul><p>Когда UITouch впервые появляется (.began), ваше приложение определяет, с каким UIView оно связано. (Позже мы узнаем как это происходит). Затем это же UIView устанавливается как свойство var view сенсорного экрана и остается им. C этого момента этот UITouch всегда связан с этим view (до тех пор, пока этот палец не покинет экран).</p><h2>Main Event Loop</h2><p>Когда объект приложения получает событие из очереди событий, он отправляет его в window, в котором произошло пользовательское событие. Window отправляет событие в view, которое является для него наиболее подходящим обработчиком</p><p>Сразу после запуска приложение настраивает инфраструктуру для основного цикла событий</p><figure class=""><img src="/img/image-loader.svg" height="278" data-src="https://habrastorage.org/getpro/habr/upload_files/463/991/6cf/4639916cf7ec9b815a4217a2988d09e7.png" data-width="500"/><figcaption></figcaption></figure><p>Когда приложение запускается, оно также устанавливает основную группу объектов, которые отвечают за отрисовку UI и обработку событий. Эти основные объекты включают window и различные виды вьюшек.</p><p>Когда объект приложения получает событие из очереди событий, он отправляет его в window, в котором произошло пользовательское событие. Window отправляет событие в view, которое является для него наиболее подходящим обработчиком</p><p>Окей. Вроде все понятно. Мы узнали про главный маршрутизатор событий, узнали о самих событиях. Но как события доходят до точки исполнения?</p><h2>Responder Chain</h2><p>Экземпляры <a href="https://developer.apple.com/documentation/uikit/uiresponder" rel="noopener noreferrer nofollow">UIResponder</a> — основные обработчики событий в приложении. Почти все ключевые объекты являются респондерами (UIApplication, UIWindow, UIViewController, UIView).</p><figure class="full-width "><img src="/img/image-loader.svg" height="283" data-src="https://habrastorage.org/getpro/habr/upload_files/b9c/095/053/b9c095053f2ce3f9f294bd667169f26c.png" data-width="644"/><figcaption></figcaption></figure><p>Чтобы получать события, респондер должен реализовать соответствующие методы обработки событий и, в некоторых случаях, сообщить приложению, что оно может стать первым респондером </p><p>Респондеры получают необработанные данные о событии и должны либо обработать событие, либо переслать его другому объекту-респонденту. По связанному списку от репондера к респондеру.</p><figure class="full-width "><img src="/img/image-loader.svg" height="790" data-src="https://habrastorage.org/getpro/habr/upload_files/d1a/219/4bd/d1a2194bdcefde540cf1a1a3d884460f.png" data-width="1304"/><figcaption></figcaption></figure><p>Если первый респондер не может обработать сообщение о событии или действии, он пересылает его «следующему респондеру».  Если объект в цепочке респондента не может обработать событие или действие, он передает сообщение следующему респондеру в цепочке. Сообщение движется вверх по цепочке к объектам более высокого уровня, пока не будет обработано. Если он не обрабатывается, то приложение отбрасывает его.</p><figure class="full-width "><img src="/img/image-loader.svg" height="773" data-src="https://habrastorage.org/getpro/habr/upload_files/ec5/a3f/0ca/ec5a3f0caa86ad00aea4a480527bd7ac.png" data-width="1319"/><figcaption></figcaption></figure><p>У респондера есть несколько методов обработки событий:</p><ul><li><p><strong>touchesBegan(_:with:)</strong> — во view или window произошло одно или несколько новых касаний.</p></li><li><p><strong>touchesMoved(_:with:) </strong>— <em>Сообщает респонденту, когда одно или несколько касаний, связанных с событием, изменились.</em></p></li><li><p><strong>touchesEnded(_:with:) </strong>— Сообщает респонденту, когда один или несколько пальцев поднимаются из вида или окна.</p></li><li><p><strong>touchesCancelled(_:with:) — </strong>Сообщает респонденту, когда системное событие (например, системное предупреждение) отменяет последовательность касаний.</p></li></ul><p>Аргументы этих методов:</p><ul><li><p><strong>touches: Set&lt;UITouch></strong> — множество прикосновений. Если во множестве только одно касание, то мы получаем его. Если же во множестве много то выполнится first метод (набор неупорядочен, поэтому какой элемент будет первым система выберет произвольно).</p></li><li><p><strong>event: UIEvent?</strong> — сущность объекта UIEvent</p></li></ul><h2>Gesture Recognizer</h2><p>Процесс распознавания жестов довольно сложный механизм. Еще сложней, когда мы хотим обрабатывать разные типы жестов. Решением являются Gesture Recognizers (субкласс <a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer" rel="noopener noreferrer nofollow">UIGestureRecognizer</a>), которые стандартизируют общие жесты и позволяет разделять и инкапсулировать код для разных жестов в разные объекты. Благодаря распознавателям жестов нет необходимости создавать подкласс UIView только для того, чтобы реализовать интерпретацию касания.</p><p>Gesture Recognizer — это объект, задача которого обнаруживать, что последовательность мультитач приравнивается к одному конкретному типу жеста. Он прикреплен к UIView. Мы можем добавлять и удалять распознаватели:</p><ul><li><p>addGestureRecognizer(_:)</p></li><li><p>removeGestureRecognizer(_:)</p></li></ul><p>UIGestureRecognizer реализует четыре метода касания, но он не является респондером. Поэтому не участвует в responder chain.</p><p>По сути это обычный словарь, который хранит все жесты.</p><p>В кейсе ниже мы реализуем, используя распознаватель жестов, вьюху, которая позволяет перетаскивать себя в любом направлении одним пальцем.</p><pre><code class="swift">func viewDidLoad {
    super.viewDidLoad()
    let p = UIPanGestureRecognizer(target:self, action:#selector(dragging))
    self.v.addGestureRecognizer(p)
}
    
@objc func dragging(_ p : UIPanGestureRecognizer) {
	  let v = p.view!
    switch p.state {
    case .began, .changed:
        let delta = p.translation(in:v.superview)
        var c = v.center
        c.x += delta.x; c.y += delta.y
        v.center = c
        p.setTranslation(.zero, in: v.superview)
    default: break  
	}
}</code></pre><p>Window доставляет события касания в словарь распознавания жестов, прежде чем оно доставляет их в hit-testing view</p><h2>Закрепление доставки событий</h2><p>Таким образом давайте закрепим доставку тачей от точки прикосновения до точки управления событием:</p><ul><li><p>Когда появляется новое касание, приложение выполняет проверку нажатия, чтобы определить view, к которому прикоснулись. Это view будет навсегда связано с этим касанием и соответственно будет называться <strong>hit-test view</strong></p></li><li><p>Когда происходит другое касание приложение вызывает собственный метод sendEvent(<em>:), который в свою очередь вызывает sendEvent(</em>:) окна (window). Window прокладывает путь к прикосновению</p></li></ul><p>Но как этот путь прокладывается?</p><h2>Hit-Testing</h2><p>Hit Testing — это рекурсивный поиск среди всей иерархии вьюх к какой прикоснулся пользователь. iOS пытается определить, какой UIView является самой передней вьюшкой под пальцем пользователя, которая должна получить событие касания.</p><figure class="full-width "><img src="/img/image-loader.svg" height="1452" data-src="https://habrastorage.org/getpro/habr/upload_files/5a3/738/7dd/5a37387dd18dcf0014c4f02ffa6008ce.png" data-width="1241"/><figcaption></figcaption></figure><p>На диаграмме выше hit-testing выполняется каждый раз, когда палец касается экрана. И до того, как какое-либо средство распознавания представления или жеста получит объект UIEvent, представляющий событие, которому принадлежит касание. Полученная UIView становится firstResponder.</p><p>Метод hitTest(_: with :) реализует логику проверки касания исключительно для этой вьюхи. Если <strong>isUserInteractionEnabled</strong> представления имеет значение false, или его <strong>isHidden</strong> имеет значение true, или его <strong>alpha</strong> близка к 0,0, то hitTest возвращает nil, что означает, что ни эта вьюха, ни другая из её сабвьюх не могут быть вьюхой для следующего вызова <strong>hitTest. </strong></p><p>Алгоритм начинается с отправки сообщения экземпляру UIApplication путем вызова sendEvent (_ :). а UIApplication, в свою очередь, передает его UIWindow, вызывая его sendEvent (_ :). Затем UIWindow выполняет сложную логику проверки для каждого тача его иерархии вьюшек </p><p>Посмотрим в код:</p><pre><code class="swift">class CustomWindow: UIWindow {
    var childSubviews = [UIView]()
    
    override func sendEvent(_ event: UIEvent) {
        guard let touches = event.allTouches, let touch = touches.first else {
            return
        }
        
        let firstResponder: UIResponder = chHitTest(point: touch.location(in: self), with: event) ?? self
        
        switch touch.phase {
        case .began:
            firstResponder.touchesBegan(touches, with: event)
        case .moved:
            firstResponder.touchesMoved(touches, with: event)
        case .ended:
            firstResponder.touchesEnded(touches, with: event)
        default:
            break
        }
    }
    
    private func childHitTest(point: CGPoint, with event: UIEvent?) -> UIView? {
				if self.isHidden || !self.isUserInteractionEnabled ||
					 self.alpha &lt;= 0.01 else {
		        return nil
		    }
        for subview in childSubviews {
            if subview.frame.contains(point) {
                let nextPoint = subview.layer.convert(point, to: layer)
                
                return subview.hitTest(point: nextPoint, with: event)
            }
        }
        
        return nil
    }
}</code></pre><p>Также <a href="http://smnh.me/hit-testing-in-ios/" rel="noopener noreferrer nofollow">нашел</a> схему, которая описывает логику hit testing'а:</p><figure class="full-width "><img src="/img/image-loader.svg" height="944" data-src="https://habrastorage.org/getpro/habr/upload_files/2c3/838/8da/2c38388da2e01a44d3df0d50cee7624d.png" data-width="846"/><figcaption></figcaption></figure><h2>Разбор основных кейсов</h2><h4>1. Кейс с выпирающей вьюхой</h4><p>Кейс очень распространенный. О нем писал яндекс и много ребят на западных ресурсах.</p><p>Задача простая. Что будет, если мы нажмем на выпирающую область вьюхи C?</p><figure class="full-width "><img src="/img/image-loader.svg" height="590" data-src="https://habrastorage.org/getpro/habr/upload_files/66f/7a1/c9e/66f7a1c9e0ed7325c770e9216762cebe.png" data-width="582"/><figcaption></figcaption></figure><p>Если вспомнить доку, то ответ будет таким</p><blockquote><p>If a touch location is outside of a view’s bounds, the hitTest(_:with:) method ignores that view and all of its subviews. As a result, when a view’s clipsToBounds property is false, subviews outside of that view’s bounds are not returned even if they happen to contain the touch.</p></blockquote><p>Touch будет проигнорирован вью B. Его координаты не попадают в её область отрисовки. А значит, что самой глубокой вью, которая примет нажатие, будет view A.</p><p>В этом случае мы можем переписать вью и написать свой код</p><pre><code class="swift">override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
    // 1. 
    if let viewAvailable = findPointsInsideView(parent: self, point: point, event: event) {
        return viewAvailable
    }
    // 2. 
    if self.point(inside: point, with: event) {
        return self
    }
    
    return nil
}</code></pre><ol><li><p>Мы определяем, находится ли поинты внутри любых из сабвьюх основной супервьюхи.</p></li><li><p>Если мы не получаем ни одной, которое включает данную точку, мы проверяем, действительно ли это родительское представление получило обращение</p></li></ol><p>Ниже приведен вспомогательный метод, который проходит через сабвьюхи, и определяет, принадлежат ли поинты какой-либо из супервьюх.</p><pre><code class="swift">private func findPointsInsideView(parent: UIView, point: CGPoint, event: UIEvent?) -> UIView? {
    let allChilds = parent.subviews

    guard allChilds.count > 0 else {
        return nil
    }

    for chilView in allChilds.reversed() {
        let modifiedPoint = parent.convert(point, to: chilView)
        if chilView.point(inside: modifiedPoint, with: event){
            if let foundView = findPointsInsideView(parent: chilView, point: modifiedPoint, event: event) {
                return foundView
            } else {
                return chilView
            }
        }
    }
    
    return nil
}</code></pre><h4>2. Кейс с увеличением нажатия области кнопки</h4><p>Допустим мы решили увеличить область нажатия кнопки "Х". Пришел дизайнер и сказал, что сложно закрыть эту вьюшку. И нужно, не меняя размера, изменить область нажатия. Тач должен произойти в красной области, а UIButton должен это подхватить </p><figure class="full-width "><img src="/img/image-loader.svg" height="590" data-src="https://habrastorage.org/getpro/habr/upload_files/3a1/bf3/6b6/3a1bf36b699887ef2bed06962e456239.png" data-width="582"/><figcaption></figcaption></figure><p>Решение изменить область при тапе с помощью метода pont(inside:):</p><pre><code class="swift">override func point(inside point: CGPoint, with _: UIEvent?) -> Bool {
    let margin: CGFloat = 55
    let area = self.bounds.insetBy(dx: -margin, dy: -margin)
    return area.contains(point)
	}</code></pre><h4>3. Решение задачи с вырезанной внутри дыркой</h4><p>Как сделать так, чтобы при нажатии на контент внутри синей вьюшки обрабатывались события вьюшек, под ней лежащих? </p><p>Условие задачи — вызвать событие зеленой или желтой вьюшки, которые находятся в центре синей  </p><figure class="full-width "><img src="/img/image-loader.svg" height="590" data-src="https://habrastorage.org/getpro/habr/upload_files/254/548/38b/25454838b35efb50b4c4811dc3a7249f.png" data-width="582"/><figcaption></figcaption></figure><p>Ответ в коде:</p><pre><code class="swift">override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
	  for subview in subviews {
	      if subview.frame.contains(point) {
	          let nextPoint = subview.layer.convert(point, to: layer)
	
	          return subview.hitTest(nextPoint, with: event)
	      }
	  }
	
	  return self
}</code></pre><h4>4. Проход hitTest по слоям</h4><p>Как мы знаем hitTest работает только с вьюшками. Но это не совсем так.</p><p>Допустим у нас есть такой код</p><pre><code class="swift">let view1 = UIView(frame: CGRect(x: 100, y: 100, width: 200, height: 200))
view1.backgroundColor = .white
let layer = CALayer()
layer.backgroundColor = UIColor.green.cgColor
layer.frame = CGRect(x: 40, y: 10, width: 50, height: 50)
view1.layer.addSublayer(layer)

let layer2 = CALayer()
layer2.backgroundColor = UIColor.red.cgColor
layer2.frame = CGRect(x: 10, y: 50, width: 50, height: 50)
view1.layer.addSublayer(layer2)

let layer3 = CustomBlueLayer()
layer3.backgroundColor = UIColor.blue.cgColor
layer3.frame = CGRect(x: 60, y: 90, width: 50, height: 50)
view1.layer.addSublayer(layer3)

view.addSubview(view1)</code></pre><p>Есть 1 вьюшка и в ней 3 слоя.</p><figure class="full-width "><img src="/img/image-loader.svg" height="590" data-src="https://habrastorage.org/getpro/habr/upload_files/921/67f/7a3/92167f7a36f661cde44c2ca4ffc95e9d.png" data-width="582"/><figcaption></figcaption></figure><p>Но допустим я захочу увеличить один из слоев при таче. Для этого мне стоит переопределить hitTest UIWindow, чтобы ни один из слоев не потерялся</p><pre><code class="swift">extension UIWindow {
    open override func hitTest(_ point: CGPoint, with e: UIEvent?) -> UIView? {
        let lay = self.layer.hitTest(point)
        
        if lay is CustomBlueLayer {
            lay?.transform = CATransform3DScale(lay!.transform, 1.1, 1.1, 1.1)
        }
    
        return super.hitTest(point, with:e)
    }
}</code></pre><p>теперь при нажатии hitTest UIWindow проверяет условие наших слоев и выполняет трансформацию</p><figure class="full-width "><img src="/img/image-loader.svg" height="590" data-src="https://habrastorage.org/getpro/habr/upload_files/252/0a2/142/2520a2142583466bdfeda81ddbf5ff88.png" data-width="582"/><figcaption></figcaption></figure><p>Итого, в этой статье я попытался собрать общую информацию из статей и док, а ткже разобраться в некоторых аспектах сам. Соглашусь, что многие из кейсов специфичные, но все же знать, мне кажется, полезно.</p><h2>Ресурсы</h2><ul><li><p><a href="http://smnh.me/hit-testing-in-ios/" rel="noopener noreferrer nofollow">http://smnh.me/hit-testing-in-ios/</a></p></li><li><p><a href="https://iosdev12.blogspot.com/2020/09/hittest-ios-identify-view-being-hit.html" rel="noopener noreferrer nofollow">https://iosdev12.blogspot.com/2020/09/hittest-ios-identify-view-being-hit.html</a></p></li><li><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/Devpedia-CocoaApp/EventHandlingiPhone.html#//apple_ref/doc/uid/TP40009071-CH13-SW1" rel="noopener noreferrer nofollow">https://developer.apple.com/library/archive/documentation/General/Conceptual/Devpedia-CocoaApp/EventHandlingiPhone.html#//apple_ref/doc/uid/TP40009071-CH13-SW1</a></p></li><li><p><a href="https://useyourloaf.com/blog/what-does-main-do-in-swift-5.3/" rel="noopener noreferrer nofollow">https://useyourloaf.com/blog/what-does-main-do-in-swift-5.3/</a></p></li><li><p><a href="https://medium.com/@kalyan.parise/understanding-scene-delegate-app-delegate-7503d48c5445" rel="noopener noreferrer nofollow">https://medium.com/@kalyan.parise/understanding-scene-delegate-app-delegate-7503d48c5445</a></p></li><li><p><a href="https://swiftrocks.com/understanding-the-ios-responder-chain.html" rel="noopener noreferrer nofollow">https://swiftrocks.com/understanding-the-ios-responder-chain.html</a></p></li><li><p><a href="https://www.hackingwithswift.com/example-code/system/what-is-the-first-responder" rel="noopener noreferrer nofollow">https://www.hackingwithswift.com/example-code/system/what-is-the-first-responder</a></p></li></ul><p><strong>Цикл статей от яндекса</strong></p><ul><li><p><a href="https://medium.com/yandex-maps-mobile/tooltip-menu-for-every-view-1aede0d4d3e7" rel="noopener noreferrer nofollow">https://medium.com/yandex-maps-mobile/tooltip-menu-for-every-view-1aede0d4d3e7</a></p></li><li><p><a href="https://medium.com/yandex-maps-mobile/%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%BC-%D1%83%D0%B4%D0%B0%D1%80-%D1%81-hittest-542653d51a8c" rel="noopener noreferrer nofollow">https://medium.com/yandex-maps-mobile/держим-удар-с-hittest-542653d51a8c</a></p></li></ul><p>Подписывайтесь также на мой телеграм канал, где я делюсь всякими разными материалами))</p><p><a href="https://t.me/iosmakemecry" rel="noopener noreferrer nofollow">https://t.me/iosmakemecry</a></p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%5D" class="tm-tags-list__link">ios</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%5D" class="tm-tags-list__link">ios разработка</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%20development%5D" class="tm-tags-list__link">ios development</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bresponder%5D" class="tm-tags-list__link">responder</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bevent%20loop%5D" class="tm-tags-list__link">event loop</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/ios_dev/" class="tm-hubs-list__link">
    Разработка под iOS
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/mobile_dev/" class="tm-hubs-list__link">
    Разработка мобильных приложений
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/swift/" class="tm-hubs-list__link">
    Swift
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 10: ↑10 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 10: ↑10 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+10</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">2.5K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    33
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/levbond/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/b2e/4ba/650/b2e4ba650c52200f5affd6b079057e48.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 14 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    14
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">10</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Лев Бондаренко</span> <a href="/ru/users/levbond/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @levbond
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">iOS developer</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/584100/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 2 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/584100/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/584100/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"584100":{"id":"584100","timePublished":"2021-10-19T17:59:21+00:00","isCorporative":false,"lang":"ru","titleHtml":"Обработка жестов в iOS","leadData":{"textHtml":"\u003Cp\u003EПо обработке событий в iOS много разной интересной инфы, но хотелось бы структурировать и собрать все одну. Что я и попытался сделать.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F24d\u002F39f\u002F5e2\u002F24d39f5e213f2a16d800890b6a926bb5.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F24d\u002F39f\u002F5e2\u002F24d39f5e213f2a16d800890b6a926bb5.png","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":14,"votesCount":14},"rating":10,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"875623","alias":"levbond","fullname":"Лев Бондаренко","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fb2e\u002F4ba\u002F650\u002Fb2e4ba650c52200f5affd6b079057e48.jpg","speciality":"iOS developer"},"statistics":{"commentsCount":2,"favoritesCount":33,"readingCount":2479,"score":10,"votesCount":10},"hubs":[{"relatedData":null,"id":"548","alias":"ios_dev","type":"collective","title":"Разработка под iOS","titleHtml":"Разработка под iOS","isProfiled":true},{"relatedData":null,"id":"6345","alias":"mobile_dev","type":"collective","title":"Разработка мобильных приложений","titleHtml":"Разработка мобильных приложений","isProfiled":true},{"relatedData":null,"id":"19039","alias":"swift","type":"collective","title":"Swift","titleHtml":"Swift","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EВ разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь сделать.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"590\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb74\u002F9e6\u002Fb9f\u002Fb749e6b9f7cc4bfc4ba603a8e34b8d7d.png\" data-width=\"2254\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cstrong\u003EСтруктура:\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EUIKit\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EResponder Chain\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EMain Event Loop\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EGesture Recognizers\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EHit testing\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EРазбор основных кейсов\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EUIKit\u003C\u002Fh2\u003E\u003Cp\u003EНачнем с главного. Что такое ваш UIKit? Если посмотреть в официальную доку, то мы увидим такую инфу:\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003Cem\u003EThe UIKit framework provides the required infrastructure for your iOS or tvOS apps. It provides the window and view architecture for implementing your interface, the event handling infrastructure for delivering Multi-Touch and other types of input to your app, and the main run loop needed to manage interactions among the user, the system, and your app.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EТак. Здесь мы узнали, что этот фреймворк помогает нам создавать архитектуру окон и вьюшек, инфраструктуру обработки событий, а также основной цикл выполнения. Давайте пройдемся по порядку.\u003C\u002Fp\u003E\u003Ch4\u003EUIApplication, UIWindow, UIView - кто, зачем и почему?\u003C\u002Fh4\u003E\u003Cp\u003EНаше приложение стартует с имплементации экземпляра класса для \u003Ca href=\"https:\u002F\u002Fdeveloper.apple.com\u002Fdocumentation\u002Fuikit\u002Fuiapplication\" rel=\"noopener noreferrer nofollow\"\u003EUIApplication\u003C\u002Fa\u003E. Каждое iOS приложение имеет ровно один экземпляр \u003Cstrong\u003EUIApplication\u003C\u002Fstrong\u003E. Он маршрутизирует события пользователя, а также с помощью \u003Cstrong\u003EUIApplicationDelegate\u003C\u002Fstrong\u003E информирует о важных событиях (запуске приложения, не хватки памяти, завершении работы приложения).\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"160\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff6e\u002F2bb\u002F6fc\u002Ff6e2bb6fce5fc19680d3a6047dd8f7af.png\" data-width=\"300\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДавайте посмотрим как это выглядит в коде. Если бы мы юзали сториборды, то это происходило автоматически. UIApplicationMain проверяет, использует ли ваше приложение сториборды. Он знает, используете ли вы main storyboard и каково ее имя, просмотрев ключ Info.plist “Main storyboard file base name” (UIMainStoryboard- File)\u003C\u002Fp\u003E\u003Cp\u003EНо мы попробуем все сделать кодом:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003E\u002F\u002F отмечаем ключевым словом @main для определения главной точки входа в программу\n@main\nclass MainAppDelegate: UIResponder, UIApplicationDelegate {\n    \u002F\u002F определяем окно, которое будет главным.\n    var window: UIWindow?\n    \n    \u002F\u002F Метод UIApplicationDelegate. Вызывается тогда, когда приложение запустилось\n    func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -\u003E Bool {\n        let window = UIWindow(frame: UIScreen.main.bounds)\n\t\t\t\twindow.rootViewController = ViewController() \u002F\u002F Инициализируем главный вьюконтроллер\n        window.makeKeyAndVisible() \u002F\u002F устанавливаем это окно ключевым\n        self.window = window\n\n        return true\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПолучается:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EUIApplicationMain создает экземпляр UIApplication и сохраняет этот экземпляр. К которому позже можно обращаться через UIApplication.shared\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗатем он создает экземпляр класса делегата приложения. Система знает что это за класс, потому что мы пометили его \u003Cstrong\u003E@main\u003C\u002Fstrong\u003E (в ранних версиях @\u003Cstrong\u003EUIApplicationMain\u003C\u002Fstrong\u003E)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EUIApplicationMain вызывает у делегата приложения метод \u003Cstrong\u003Eapplication(_:didFinish- LaunchingWithOptions:)\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EНо интерфейс приложения не отображается, пока содержащее его window не станет ключевым окном приложения. Функция \u003Cstrong\u003EmakeKeyAndVisible \u003C\u002Fstrong\u003Eпоможет нам\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cem\u003EНо начиная с iOS 13, функции AppDelegate были разделены между AppDelegate и SceneDelegate. Это результат новой функции поддержки многооконного режима, представленной в ОС iPad, которая разделяет работу AppDelegate на две части.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EUIApplicationMain вызывает у делегата приложения метод \u003Cstrong\u003Eapplication(_:didFinish- LaunchingWithOptions:)\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EUIApplicationMain\u003C\u002Fstrong\u003E создает \u003Cstrong\u003EUISceneSession\u003C\u002Fstrong\u003E, \u003Cstrong\u003EUIWindowScene\u003C\u002Fstrong\u003E и экземпляр, который будет служить делегатом сцены окна\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ Info.plist нужно указать (в виде строки) какой класс будет делегатом \u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EUIApplicationMain проверяет, использует ли ваша начальная сцена сториборды. (В Info.plist нужно указать имя сториборда)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли сцена имеет сториборд, то UIApplicationMain создает экземпляр UIWindow и назначает его делегатом сцены.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EUIApplicationMain вызывает отображение интерфейса путем вызова метода экземпляра UIWindow \u003Cstrong\u003EmakeKeyAndVisible\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ делегате сцены вызывается метод \u003Cstrong\u003Escene(_:willConnectTo:options:)\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cblockquote\u003E\u003Cp\u003EНе ожидайте, что window может быть только одно. Есть такие окна \u003Cstrong\u003EUITextEffectsWindow\u003C\u002Fstrong\u003E и \u003Cstrong\u003EUIRemoteKeyboardWindow\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EОкей. Мы вроде разобрались как создается главный маршрутизатор всех событий. Но что такое эти события и как они выглядят?\u003C\u002Fp\u003E\u003Cp\u003EЗнакомьтесь. Это \u003Ca href=\"https:\u002F\u002Fdeveloper.apple.com\u002Fdocumentation\u002Fuikit\u002Fuievent\" rel=\"noopener noreferrer nofollow\"\u003EUIEvent\u003C\u002Fa\u003E. Главный объект, который содержит много нужной инфы для обработки событий. Когда обнаруживается системное событие, такое как прикосновение к экрану, UIKit внутри создает экземпляры UIEvent и отправляет их в очередь системных событий (main event loop), вызывая \u003Cstrong\u003EUIApplication.shared.sendEvent()\u003C\u002Fstrong\u003E. \u003C\u002Fp\u003E\u003Ch4\u003EUITouch\u003C\u002Fh4\u003E\u003Cp\u003EКаждый экземпляр UIEvent содержит одно или несколько объектов UITouch. Для данного объекта UITouch могут произойти только четыре вещи. Они называются фазами касания и описываются свойством \u003Cstrong\u003Evar phase\u003C\u002Fstrong\u003E: \u003Cstrong\u003EUITouch.Phase:\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E.\u003Cstrong\u003Ebegan\u003C\u002Fstrong\u003E — Палец впервые коснулся экрана; этот экземпляр UITouch только что был создан. Это всегда первая фаза, которая наступает только один раз.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E.\u003Cstrong\u003Emoved \u003C\u002Fstrong\u003E— Палец двигается по экрану.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E.\u003Cstrong\u003Estationary \u003C\u002Fstrong\u003E— Палец оставался на экране неподвижно. Для чего это нужно? Как только экземпляр UITouch был создан, он должен присутствовать каждый раз, когда прибывает UIEvent для этой последовательности мультитач. Таким образом, если UIEvent прибывает из-за того, что произошло что-то еще (например, новый палец коснулся экрана), UIEvent должен сообщить, что этот палец делал, даже если он ничего не делал\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003E.ended \u003C\u002Fstrong\u003E— Палец покинул экран. Как и .began, эта фаза наступает только один раз. Экземпляр UITouch теперь будет уничтожен и больше не будет отображаться в UIEvents для этой последовательности мультитача.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EПо сути этих 4х фаз достаточно, чтобы описать все действия пальца. Но возможна еще одна фаза:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E.\u003Cstrong\u003Ecancelled \u003C\u002Fstrong\u003E— Система прервала последовательность мультитача, потому что что-то прервало ее.\u003Cstrong\u003E \u003C\u002Fstrong\u003EВозможно, пользователь нажал кнопку «Домой» или кнопку блокировки экрана в середине последовательности. Возможно, появилось локальное уведомление.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cstrong\u003EUITouch\u003C\u002Fstrong\u003E также имеет такие свойства:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Elocation(in:), previousLocation(in:) \u003C\u002Fstrong\u003E— Текущее и предыдущее местоположение этого касания относительно системы координат view.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Etimestamp \u003C\u002Fstrong\u003E— Когда тач последний раз менялся. Прикосновение получает отметку времени, когда оно создается (.began) и каждый раз, когда оно перемещается (.moved)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EtapCount \u003C\u002Fstrong\u003E— Если два касания происходят примерно в одном и том же месте в быстрой последовательности, а первое короткое, второе можно охарактеризовать как повторение первого. Это разные сенсорные объекты, но второму будет назначено значение tapCount на единицу больше, чем у предыдущего\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eview \u003C\u002Fstrong\u003E— вьюшка, c которой связано это прикосновение\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EКогда UITouch впервые появляется (.began), ваше приложение определяет, с каким UIView оно связано. (Позже мы узнаем как это происходит). Затем это же UIView устанавливается как свойство var view сенсорного экрана и остается им. C этого момента этот UITouch всегда связан с этим view (до тех пор, пока этот палец не покинет экран).\u003C\u002Fp\u003E\u003Ch2\u003EMain Event Loop\u003C\u002Fh2\u003E\u003Cp\u003EКогда объект приложения получает событие из очереди событий, он отправляет его в window, в котором произошло пользовательское событие. Window отправляет событие в view, которое является для него наиболее подходящим обработчиком\u003C\u002Fp\u003E\u003Cp\u003EСразу после запуска приложение настраивает инфраструктуру для основного цикла событий\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"278\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F463\u002F991\u002F6cf\u002F4639916cf7ec9b815a4217a2988d09e7.png\" data-width=\"500\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EКогда приложение запускается, оно также устанавливает основную группу объектов, которые отвечают за отрисовку UI и обработку событий. Эти основные объекты включают window и различные виды вьюшек.\u003C\u002Fp\u003E\u003Cp\u003EКогда объект приложения получает событие из очереди событий, он отправляет его в window, в котором произошло пользовательское событие. Window отправляет событие в view, которое является для него наиболее подходящим обработчиком\u003C\u002Fp\u003E\u003Cp\u003EОкей. Вроде все понятно. Мы узнали про главный маршрутизатор событий, узнали о самих событиях. Но как события доходят до точки исполнения?\u003C\u002Fp\u003E\u003Ch2\u003EResponder Chain\u003C\u002Fh2\u003E\u003Cp\u003EЭкземпляры \u003Ca href=\"https:\u002F\u002Fdeveloper.apple.com\u002Fdocumentation\u002Fuikit\u002Fuiresponder\" rel=\"noopener noreferrer nofollow\"\u003EUIResponder\u003C\u002Fa\u003E — основные обработчики событий в приложении. Почти все ключевые объекты являются респондерами (UIApplication, UIWindow, UIViewController, UIView).\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"283\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb9c\u002F095\u002F053\u002Fb9c095053f2ce3f9f294bd667169f26c.png\" data-width=\"644\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЧтобы получать события, респондер должен реализовать соответствующие методы обработки событий и, в некоторых случаях, сообщить приложению, что оно может стать первым респондером \u003C\u002Fp\u003E\u003Cp\u003EРеспондеры получают необработанные данные о событии и должны либо обработать событие, либо переслать его другому объекту-респонденту. По связанному списку от репондера к респондеру.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"790\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd1a\u002F219\u002F4bd\u002Fd1a2194bdcefde540cf1a1a3d884460f.png\" data-width=\"1304\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЕсли первый респондер не может обработать сообщение о событии или действии, он пересылает его «следующему респондеру».  Если объект в цепочке респондента не может обработать событие или действие, он передает сообщение следующему респондеру в цепочке. Сообщение движется вверх по цепочке к объектам более высокого уровня, пока не будет обработано. Если он не обрабатывается, то приложение отбрасывает его.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"773\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fec5\u002Fa3f\u002F0ca\u002Fec5a3f0caa86ad00aea4a480527bd7ac.png\" data-width=\"1319\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EУ респондера есть несколько методов обработки событий:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EtouchesBegan(_:with:)\u003C\u002Fstrong\u003E — во view или window произошло одно или несколько новых касаний.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EtouchesMoved(_:with:) \u003C\u002Fstrong\u003E— \u003Cem\u003EСообщает респонденту, когда одно или несколько касаний, связанных с событием, изменились.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EtouchesEnded(_:with:) \u003C\u002Fstrong\u003E— Сообщает респонденту, когда один или несколько пальцев поднимаются из вида или окна.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EtouchesCancelled(_:with:) — \u003C\u002Fstrong\u003EСообщает респонденту, когда системное событие (например, системное предупреждение) отменяет последовательность касаний.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EАргументы этих методов:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Etouches: Set&lt;UITouch\u003E\u003C\u002Fstrong\u003E — множество прикосновений. Если во множестве только одно касание, то мы получаем его. Если же во множестве много то выполнится first метод (набор неупорядочен, поэтому какой элемент будет первым система выберет произвольно).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eevent: UIEvent?\u003C\u002Fstrong\u003E — сущность объекта UIEvent\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EGesture Recognizer\u003C\u002Fh2\u003E\u003Cp\u003EПроцесс распознавания жестов довольно сложный механизм. Еще сложней, когда мы хотим обрабатывать разные типы жестов. Решением являются Gesture Recognizers (субкласс \u003Ca href=\"https:\u002F\u002Fdeveloper.apple.com\u002Fdocumentation\u002Fuikit\u002Fuigesturerecognizer\" rel=\"noopener noreferrer nofollow\"\u003EUIGestureRecognizer\u003C\u002Fa\u003E), которые стандартизируют общие жесты и позволяет разделять и инкапсулировать код для разных жестов в разные объекты. Благодаря распознавателям жестов нет необходимости создавать подкласс UIView только для того, чтобы реализовать интерпретацию касания.\u003C\u002Fp\u003E\u003Cp\u003EGesture Recognizer — это объект, задача которого обнаруживать, что последовательность мультитач приравнивается к одному конкретному типу жеста. Он прикреплен к UIView. Мы можем добавлять и удалять распознаватели:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EaddGestureRecognizer(_:)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EremoveGestureRecognizer(_:)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EUIGestureRecognizer реализует четыре метода касания, но он не является респондером. Поэтому не участвует в responder chain.\u003C\u002Fp\u003E\u003Cp\u003EПо сути это обычный словарь, который хранит все жесты.\u003C\u002Fp\u003E\u003Cp\u003EВ кейсе ниже мы реализуем, используя распознаватель жестов, вьюху, которая позволяет перетаскивать себя в любом направлении одним пальцем.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Efunc viewDidLoad {\n    super.viewDidLoad()\n    let p = UIPanGestureRecognizer(target:self, action:#selector(dragging))\n    self.v.addGestureRecognizer(p)\n}\n    \n@objc func dragging(_ p : UIPanGestureRecognizer) {\n\t  let v = p.view!\n    switch p.state {\n    case .began, .changed:\n        let delta = p.translation(in:v.superview)\n        var c = v.center\n        c.x += delta.x; c.y += delta.y\n        v.center = c\n        p.setTranslation(.zero, in: v.superview)\n    default: break  \n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EWindow доставляет события касания в словарь распознавания жестов, прежде чем оно доставляет их в hit-testing view\u003C\u002Fp\u003E\u003Ch2\u003EЗакрепление доставки событий\u003C\u002Fh2\u003E\u003Cp\u003EТаким образом давайте закрепим доставку тачей от точки прикосновения до точки управления событием:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EКогда появляется новое касание, приложение выполняет проверку нажатия, чтобы определить view, к которому прикоснулись. Это view будет навсегда связано с этим касанием и соответственно будет называться \u003Cstrong\u003Ehit-test view\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКогда происходит другое касание приложение вызывает собственный метод sendEvent(\u003Cem\u003E:), который в свою очередь вызывает sendEvent(\u003C\u002Fem\u003E:) окна (window). Window прокладывает путь к прикосновению\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EНо как этот путь прокладывается?\u003C\u002Fp\u003E\u003Ch2\u003EHit-Testing\u003C\u002Fh2\u003E\u003Cp\u003EHit Testing — это рекурсивный поиск среди всей иерархии вьюх к какой прикоснулся пользователь. iOS пытается определить, какой UIView является самой передней вьюшкой под пальцем пользователя, которая должна получить событие касания.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"1452\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5a3\u002F738\u002F7dd\u002F5a37387dd18dcf0014c4f02ffa6008ce.png\" data-width=\"1241\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EНа диаграмме выше hit-testing выполняется каждый раз, когда палец касается экрана. И до того, как какое-либо средство распознавания представления или жеста получит объект UIEvent, представляющий событие, которому принадлежит касание. Полученная UIView становится firstResponder.\u003C\u002Fp\u003E\u003Cp\u003EМетод hitTest(_: with :) реализует логику проверки касания исключительно для этой вьюхи. Если \u003Cstrong\u003EisUserInteractionEnabled\u003C\u002Fstrong\u003E представления имеет значение false, или его \u003Cstrong\u003EisHidden\u003C\u002Fstrong\u003E имеет значение true, или его \u003Cstrong\u003Ealpha\u003C\u002Fstrong\u003E близка к 0,0, то hitTest возвращает nil, что означает, что ни эта вьюха, ни другая из её сабвьюх не могут быть вьюхой для следующего вызова \u003Cstrong\u003EhitTest. \u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EАлгоритм начинается с отправки сообщения экземпляру UIApplication путем вызова sendEvent (_ :). а UIApplication, в свою очередь, передает его UIWindow, вызывая его sendEvent (_ :). Затем UIWindow выполняет сложную логику проверки для каждого тача его иерархии вьюшек \u003C\u002Fp\u003E\u003Cp\u003EПосмотрим в код:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass CustomWindow: UIWindow {\n    var childSubviews = [UIView]()\n    \n    override func sendEvent(_ event: UIEvent) {\n        guard let touches = event.allTouches, let touch = touches.first else {\n            return\n        }\n        \n        let firstResponder: UIResponder = chHitTest(point: touch.location(in: self), with: event) ?? self\n        \n        switch touch.phase {\n        case .began:\n            firstResponder.touchesBegan(touches, with: event)\n        case .moved:\n            firstResponder.touchesMoved(touches, with: event)\n        case .ended:\n            firstResponder.touchesEnded(touches, with: event)\n        default:\n            break\n        }\n    }\n    \n    private func childHitTest(point: CGPoint, with event: UIEvent?) -\u003E UIView? {\n\t\t\t\tif self.isHidden || !self.isUserInteractionEnabled ||\n\t\t\t\t\t self.alpha &lt;= 0.01 else {\n\t\t        return nil\n\t\t    }\n        for subview in childSubviews {\n            if subview.frame.contains(point) {\n                let nextPoint = subview.layer.convert(point, to: layer)\n                \n                return subview.hitTest(point: nextPoint, with: event)\n            }\n        }\n        \n        return nil\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТакже \u003Ca href=\"http:\u002F\u002Fsmnh.me\u002Fhit-testing-in-ios\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eнашел\u003C\u002Fa\u003E схему, которая описывает логику hit testing'а:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"944\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2c3\u002F838\u002F8da\u002F2c38388da2e01a44d3df0d50cee7624d.png\" data-width=\"846\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Ch2\u003EРазбор основных кейсов\u003C\u002Fh2\u003E\u003Ch4\u003E1. Кейс с выпирающей вьюхой\u003C\u002Fh4\u003E\u003Cp\u003EКейс очень распространенный. О нем писал яндекс и много ребят на западных ресурсах.\u003C\u002Fp\u003E\u003Cp\u003EЗадача простая. Что будет, если мы нажмем на выпирающую область вьюхи C?\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"590\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F66f\u002F7a1\u002Fc9e\u002F66f7a1c9e0ed7325c770e9216762cebe.png\" data-width=\"582\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЕсли вспомнить доку, то ответ будет таким\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EIf a touch location is outside of a view’s bounds, the hitTest(_:with:) method ignores that view and all of its subviews. As a result, when a view’s clipsToBounds property is false, subviews outside of that view’s bounds are not returned even if they happen to contain the touch.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003ETouch будет проигнорирован вью B. Его координаты не попадают в её область отрисовки. А значит, что самой глубокой вью, которая примет нажатие, будет view A.\u003C\u002Fp\u003E\u003Cp\u003EВ этом случае мы можем переписать вью и написать свой код\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eoverride func hitTest(_ point: CGPoint, with event: UIEvent?) -\u003E UIView? {\n    \u002F\u002F 1. \n    if let viewAvailable = findPointsInsideView(parent: self, point: point, event: event) {\n        return viewAvailable\n    }\n    \u002F\u002F 2. \n    if self.point(inside: point, with: event) {\n        return self\n    }\n    \n    return nil\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EМы определяем, находится ли поинты внутри любых из сабвьюх основной супервьюхи.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли мы не получаем ни одной, которое включает данную точку, мы проверяем, действительно ли это родительское представление получило обращение\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EНиже приведен вспомогательный метод, который проходит через сабвьюхи, и определяет, принадлежат ли поинты какой-либо из супервьюх.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eprivate func findPointsInsideView(parent: UIView, point: CGPoint, event: UIEvent?) -\u003E UIView? {\n    let allChilds = parent.subviews\n\n    guard allChilds.count \u003E 0 else {\n        return nil\n    }\n\n    for chilView in allChilds.reversed() {\n        let modifiedPoint = parent.convert(point, to: chilView)\n        if chilView.point(inside: modifiedPoint, with: event){\n            if let foundView = findPointsInsideView(parent: chilView, point: modifiedPoint, event: event) {\n                return foundView\n            } else {\n                return chilView\n            }\n        }\n    }\n    \n    return nil\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003E2. Кейс с увеличением нажатия области кнопки\u003C\u002Fh4\u003E\u003Cp\u003EДопустим мы решили увеличить область нажатия кнопки \"Х\". Пришел дизайнер и сказал, что сложно закрыть эту вьюшку. И нужно, не меняя размера, изменить область нажатия. Тач должен произойти в красной области, а UIButton должен это подхватить \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"590\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3a1\u002Fbf3\u002F6b6\u002F3a1bf36b699887ef2bed06962e456239.png\" data-width=\"582\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EРешение изменить область при тапе с помощью метода pont(inside:):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eoverride func point(inside point: CGPoint, with _: UIEvent?) -\u003E Bool {\n    let margin: CGFloat = 55\n    let area = self.bounds.insetBy(dx: -margin, dy: -margin)\n    return area.contains(point)\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003E3. Решение задачи с вырезанной внутри дыркой\u003C\u002Fh4\u003E\u003Cp\u003EКак сделать так, чтобы при нажатии на контент внутри синей вьюшки обрабатывались события вьюшек, под ней лежащих? \u003C\u002Fp\u003E\u003Cp\u003EУсловие задачи — вызвать событие зеленой или желтой вьюшки, которые находятся в центре синей  \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"590\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F254\u002F548\u002F38b\u002F25454838b35efb50b4c4811dc3a7249f.png\" data-width=\"582\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EОтвет в коде:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eoverride func hitTest(_ point: CGPoint, with event: UIEvent?) -\u003E UIView? {\n\t  for subview in subviews {\n\t      if subview.frame.contains(point) {\n\t          let nextPoint = subview.layer.convert(point, to: layer)\n\t\n\t          return subview.hitTest(nextPoint, with: event)\n\t      }\n\t  }\n\t\n\t  return self\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003E4. Проход hitTest по слоям\u003C\u002Fh4\u003E\u003Cp\u003EКак мы знаем hitTest работает только с вьюшками. Но это не совсем так.\u003C\u002Fp\u003E\u003Cp\u003EДопустим у нас есть такой код\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet view1 = UIView(frame: CGRect(x: 100, y: 100, width: 200, height: 200))\nview1.backgroundColor = .white\nlet layer = CALayer()\nlayer.backgroundColor = UIColor.green.cgColor\nlayer.frame = CGRect(x: 40, y: 10, width: 50, height: 50)\nview1.layer.addSublayer(layer)\n\nlet layer2 = CALayer()\nlayer2.backgroundColor = UIColor.red.cgColor\nlayer2.frame = CGRect(x: 10, y: 50, width: 50, height: 50)\nview1.layer.addSublayer(layer2)\n\nlet layer3 = CustomBlueLayer()\nlayer3.backgroundColor = UIColor.blue.cgColor\nlayer3.frame = CGRect(x: 60, y: 90, width: 50, height: 50)\nview1.layer.addSublayer(layer3)\n\nview.addSubview(view1)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕсть 1 вьюшка и в ней 3 слоя.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"590\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F921\u002F67f\u002F7a3\u002F92167f7a36f661cde44c2ca4ffc95e9d.png\" data-width=\"582\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EНо допустим я захочу увеличить один из слоев при таче. Для этого мне стоит переопределить hitTest UIWindow, чтобы ни один из слоев не потерялся\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eextension UIWindow {\n    open override func hitTest(_ point: CGPoint, with e: UIEvent?) -\u003E UIView? {\n        let lay = self.layer.hitTest(point)\n        \n        if lay is CustomBlueLayer {\n            lay?.transform = CATransform3DScale(lay!.transform, 1.1, 1.1, 1.1)\n        }\n    \n        return super.hitTest(point, with:e)\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eтеперь при нажатии hitTest UIWindow проверяет условие наших слоев и выполняет трансформацию\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"590\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F252\u002F0a2\u002F142\u002F2520a2142583466bdfeda81ddbf5ff88.png\" data-width=\"582\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EИтого, в этой статье я попытался собрать общую информацию из статей и док, а ткже разобраться в некоторых аспектах сам. Соглашусь, что многие из кейсов специфичные, но все же знать, мне кажется, полезно.\u003C\u002Fp\u003E\u003Ch2\u003EРесурсы\u003C\u002Fh2\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"http:\u002F\u002Fsmnh.me\u002Fhit-testing-in-ios\u002F\" rel=\"noopener noreferrer nofollow\"\u003Ehttp:\u002F\u002Fsmnh.me\u002Fhit-testing-in-ios\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fiosdev12.blogspot.com\u002F2020\u002F09\u002Fhittest-ios-identify-view-being-hit.html\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fiosdev12.blogspot.com\u002F2020\u002F09\u002Fhittest-ios-identify-view-being-hit.html\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.apple.com\u002Flibrary\u002Farchive\u002Fdocumentation\u002FGeneral\u002FConceptual\u002FDevpedia-CocoaApp\u002FEventHandlingiPhone.html#\u002F\u002Fapple_ref\u002Fdoc\u002Fuid\u002FTP40009071-CH13-SW1\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fdeveloper.apple.com\u002Flibrary\u002Farchive\u002Fdocumentation\u002FGeneral\u002FConceptual\u002FDevpedia-CocoaApp\u002FEventHandlingiPhone.html#\u002F\u002Fapple_ref\u002Fdoc\u002Fuid\u002FTP40009071-CH13-SW1\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fuseyourloaf.com\u002Fblog\u002Fwhat-does-main-do-in-swift-5.3\u002F\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fuseyourloaf.com\u002Fblog\u002Fwhat-does-main-do-in-swift-5.3\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fmedium.com\u002F@kalyan.parise\u002Funderstanding-scene-delegate-app-delegate-7503d48c5445\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fmedium.com\u002F@kalyan.parise\u002Funderstanding-scene-delegate-app-delegate-7503d48c5445\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fswiftrocks.com\u002Funderstanding-the-ios-responder-chain.html\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fswiftrocks.com\u002Funderstanding-the-ios-responder-chain.html\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.hackingwithswift.com\u002Fexample-code\u002Fsystem\u002Fwhat-is-the-first-responder\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fwww.hackingwithswift.com\u002Fexample-code\u002Fsystem\u002Fwhat-is-the-first-responder\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003E\u003Cstrong\u003EЦикл статей от яндекса\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fmedium.com\u002Fyandex-maps-mobile\u002Ftooltip-menu-for-every-view-1aede0d4d3e7\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fmedium.com\u002Fyandex-maps-mobile\u002Ftooltip-menu-for-every-view-1aede0d4d3e7\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fmedium.com\u002Fyandex-maps-mobile\u002F%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%BC-%D1%83%D0%B4%D0%B0%D1%80-%D1%81-hittest-542653d51a8c\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fmedium.com\u002Fyandex-maps-mobile\u002Fдержим-удар-с-hittest-542653d51a8c\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EПодписывайтесь также на мой телеграм канал, где я делюсь всякими разными материалами))\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Ft.me\u002Fiosmakemecry\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Ft.me\u002Fiosmakemecry\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"ios"},{"titleHtml":"ios разработка"},{"titleHtml":"ios development"},{"titleHtml":"responder"},{"titleHtml":"event loop"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F24d\u002F39f\u002F5e2\u002F24d39f5e213f2a16d800890b6a926bb5.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F24d\u002F39f\u002F5e2\u002F24d39f5e213f2a16d800890b6a926bb5.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F584100\\\u002F\"},\"headline\":\"Обработка жестов в iOS\",\"datePublished\":\"2021-10-19T20:59:21+03:00\",\"dateModified\":\"2021-10-22T20:43:55+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Лев Бондаренко\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и соб...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F584100\\\u002F#post-content-body\",\"about\":[\"h_ios_dev\",\"h_mobile_dev\",\"h_swift\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F584100\\\u002F8e899d71aa92509cdd701036bc965550\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb74\\\u002F9e6\\\u002Fb9f\\\u002Fb749e6b9f7cc4bfc4ba603a8e34b8d7d.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ff6e\\\u002F2bb\\\u002F6fc\\\u002Ff6e2bb6fce5fc19680d3a6047dd8f7af.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F463\\\u002F991\\\u002F6cf\\\u002F4639916cf7ec9b815a4217a2988d09e7.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb9c\\\u002F095\\\u002F053\\\u002Fb9c095053f2ce3f9f294bd667169f26c.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd1a\\\u002F219\\\u002F4bd\\\u002Fd1a2194bdcefde540cf1a1a3d884460f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fec5\\\u002Fa3f\\\u002F0ca\\\u002Fec5a3f0caa86ad00aea4a480527bd7ac.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F5a3\\\u002F738\\\u002F7dd\\\u002F5a37387dd18dcf0014c4f02ffa6008ce.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2c3\\\u002F838\\\u002F8da\\\u002F2c38388da2e01a44d3df0d50cee7624d.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F66f\\\u002F7a1\\\u002Fc9e\\\u002F66f7a1c9e0ed7325c770e9216762cebe.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F3a1\\\u002Fbf3\\\u002F6b6\\\u002F3a1bf36b699887ef2bed06962e456239.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F254\\\u002F548\\\u002F38b\\\u002F25454838b35efb50b4c4811dc3a7249f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F921\\\u002F67f\\\u002F7a3\\\u002F92167f7a36f661cde44c2ca4ffc95e9d.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F252\\\u002F0a2\\\u002F142\\\u002F2520a2142583466bdfeda81ddbf5ff88.png\"]}","metaDescription":"В разработке приложений для iOS важно знать как работает система изнутри. По обработке событий много разной интересной инфы, но хотелось бы структурировать и собрать все в одну. Что я и попытаюсь...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"ios_dev,mobile_dev,swift"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
