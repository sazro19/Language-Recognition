<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/psb\/blog\/583532\/"},"headline":"Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect","datePublished":"2021-10-14T18:13:55+03:00","dateModified":"2021-10-15T08:38:59+03:00","author":{"@type":"Person","name":"WillianLike"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"В основном идея использования CI\/CD для iOS, да и для других платформ, &mdash; это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручну...","url":"https:\/\/habr.com\/ru\/company\/psb\/blog\/583532\/#post-content-body","about":["c_psb","h_ios_dev","h_devops","f_develop","f_admin"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/408\/357\/db0\/408357db04280e0758798a35b6ac0265.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/20b\/0ff\/9a8\/20b0ff9a8429638d04fc19b7482bd517.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d1a\/e45\/bad\/d1ae45bad3d492c117fc14dbf6b76aa3.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d26\/b9a\/1e3\/d26b9a1e31bef741bba73a25d53bca4f.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/6f0\/0c3\/19d\/6f00c319d53ca464cd12edc84e2dbc14.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/9ef\/9b8\/5f4\/9ef9b85f457b9b4e74e580b928ef7d04.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/30e\/3e4\/938\/30e3e4938de86934395da3522a502ce8.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/192\/2cd\/53a\/1922cd53aa198f1f5ddc209205d91846.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/f3c\/b0c\/6e7\/f3cb0c6e74e81eedaf2d2baf45947027.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/834\/4f5\/b6b\/8344f5b6bb13b622da1d7da0c3c24a6b.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/01a\/d02\/0e6\/01ad020e6067cfdf22b159f8d3fe1011.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="В основном идея использования CI/CD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="В основном идея использования CI/CD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="В основном идея использования CI/CD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="В основном идея использования CI/CD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="В основном идея использования CI/CD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/583532/2ed75169a548a9429ec7cbc9e747f158/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/583532/2ed75169a548a9429ec7cbc9e747f158/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/583532/2ed75169a548a9429ec7cbc9e747f158/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/583532/2ed75169a548a9429ec7cbc9e747f158/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/583532/2ed75169a548a9429ec7cbc9e747f158/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="583532" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-14T15:13:55.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/583532/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/psb/blog/583532/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/583532/2ed75169a548a9429ec7cbc9e747f158/" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/583532/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="psb" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/psb/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/e13/03f/9c3/e1303f9c36fc6bdde8117b4b67c9cc54.jpg" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">81.19</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/psb/profile/" class="tm-company-card__name">
        ПСБ
      </a> <div class="tm-company-card__description"></div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/WillianLike/" title="WillianLike" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/115/9f6/fb6/1159f6fb65625326ca045129df5615fe.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/WillianLike/" class="tm-user-info__username">
      WillianLike
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-14T15:13:55.000Z" title="2021-10-14, 18:13">14  октября   в 18:13</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/psb/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании ПСБ</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/ios_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка под iOS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/devops/" class="tm-article-snippet__hubs-item-link"><span>DevOps</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>В основном идея использования CI/CD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда растёт, хочется тратить время эффективнее, чем вручную собирать проект или объяснять новичкам, что же там с Code-signing нужно делать. </p><p>Пожалуй, самое рутинное и самое важное занятие, которое берёт на себя CI, — это прогон тестов. Нет зелёных тестов? В master не попадёшь. А с ростом команды вероятность того, что кто-то вольёт в master нерабочий код, будет только увеличиваться. Нужна автоматизация.</p><p>В этой статье я хочу подробно рассказать о пути настройки Gitlab CI + Fastlane + Firebase + Testflight. Примеры приводятся на основе одного проекта, в котором участвовали 10 разработчиков. В конце будут описаны проблемы, с которыми мы сталкивались, и их решения.</p><p>Для кого будет полезен этот опыт? Для всех, кому нужен CI/CD и кто сидит на Gitlab. Для Github будет другая связка, например с Travis, — остальные компоненты неизменны. В нашей команде все используют Gitlab CI, Fastlane вместо голого xcodebuild для быстроты и удобства разработки, Firebase и Testflight.</p><p>Если у нас бесплатный Gitlab и мы укладываемся в лимит Firebase, то получаем бесплатное решение по настройке CI/CD.</p><h3>Описание инструментов</h3><p><strong>Gitlab CI</strong> — это система автоматической сборки. Она занимается в том числе и отслеживанием изменений в репозитории, что важно для наших целей. Отслеживает событие, смотрит инструкции к нему, которые вы указали в файле <em>.gitlab-ci.yml. </em>Описанная в статье работа ведётся на ноутбуках разработчиков, есть выделенные машины на MacOS — их мы регистрируем в Gitlab CI.</p><p><strong>Fastlane </strong>— верхнеуровневое управление сборками с помощью команд в терминале. Для него есть <a href="https://docs.fastlane.tools/plugins/available-plugins/">много плагинов на сайте</a>, которые помогают выполнять задачи разного уровня: от генерации AppIcon до сборки проекта и публикации в AppStore. Плагины, как и сам Fastlane, написаны на ruby, поэтому и управлять этим инструментом придётся на ruby.</p><p>Gitlab CI посылает инструкции в виде shell-команд на раннер, в набор команд входит Fastlane. Таким образом, они взаимодействуют, выполняя каждая свои задачи.</p><p><strong>Firebase</strong> — система дистрибьютинга сборок, хорошее решение для быстрой доставки сборок до ваших тестировщиков. Мы используем Firebase App Distribution — он бесплатный и без ограничений на место.</p><p><strong>Code coverage</strong> — процент покрытия вашего кода тестами. Упрощённо можно привести к формуле:</p><p><em>количество скомпилированных строк кода, по которым пробежали тесты / общее количество скомпилированных строк кода) * 100%</em></p><h3>[Gitlab CI] Gitlab-runner</h3><p>Первое, что нам нужно сделать на пути самурая автоматизации, — это подружить наш mac с CI. Для этого на самом маке нужно выполнить пару команд:</p><ol><li><p><a href="https://docs.gitlab.com/runner/install/osx.html">Установить</a> программу gitlab-runner      на mac (можно с помощью Homebrew). <a href="https://brew.sh/index_ru">Ссылка на установку Homebrew</a>. </p><p>Вводим в терминал:</p><p><em>brew install gitlab-runner</em></p></li><li><p>Теперь надо зарегистрировать наш mac как раннер для CI:</p><p><em>gitlab-runner register</em></p></li></ol><p>После этого надо будет ввести URL до гитлаба, где хостимся.</p><p>Ещё понадобится токен для CI. Его можно получить, только будучи Owner’ом или Maintainer’ом проекта в настройках проекта. В Settings должен быть раздел CI/CD. Раздел Runners.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Раздел в настройках CI/CD" title="Раздел в настройках CI/CD" height="219" data-src="https://habrastorage.org/getpro/habr/upload_files/408/357/db0/408357db04280e0758798a35b6ac0265.png" data-width="1600"/><figcaption>Раздел в настройках CI/CD</figcaption></figure><figure class="full-width "><img src="/img/image-loader.svg" height="560" data-src="https://habrastorage.org/getpro/habr/upload_files/20b/0ff/9a8/20b0ff9a8429638d04fc19b7482bd517.png" data-width="1398"/><figcaption></figcaption></figure><p>Вводим токен туда.</p><p>Описание раннера ни на что не влияет, оно даётся только для справки.</p><p>Обратите внимание на теги раннера. Без тегов ничего не будет работать, нужен минимум один. По тегам можно фильтровать разные раннеры: например, один будет с доступом к сети и сможет выкладывать сборки, а другой — нет. Тогда можно обозначить разные теги для разных функций раннеров. Например, для одного впишем теги ios_tests,ios_firebase, а в другом — только ios_tests. И сможем разделять исполнителей по типу. </p><p>Тип исполнения для нас всегда будет shell.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="gitlab-runner register" title="gitlab-runner register" height="898" data-src="https://habrastorage.org/getpro/habr/upload_files/d1a/e45/bad/d1ae45bad3d492c117fc14dbf6b76aa3.png" data-width="1448"/><figcaption>gitlab-runner register</figcaption></figure><p>Зарегистрировали наш раннер. Теперь давайте посмотрим и убедимся, что он находится в том же списке Runners в настройках проекта.</p><figure class="full-width "><img src="/img/image-loader.svg" height="356" data-src="https://habrastorage.org/getpro/habr/upload_files/d26/b9a/1e3/d26b9a1e31bef741bba73a25d53bca4f.png" data-width="1550"/><figcaption></figcaption></figure><p>Восклицательный знак указывает, что раннер ещё не запущен и не готов к работе. Идём к следующему шагу.</p><p>Запускаем раннер. Выполняем команды в терминале:</p><pre><code>gitlab-runner install
gitlab-runner start</code></pre><p>Теперь наш раннер должен загореться зелёным в списке.</p><figure class="full-width "><img src="/img/image-loader.svg" height="376" data-src="https://habrastorage.org/getpro/habr/upload_files/6f0/0c3/19d/6f00c319d53ca464cd12edc84e2dbc14.png" data-width="1532"/><figcaption></figcaption></figure><p>У раннеров есть проблема с логами. Для того чтобы мы могли просматривать полный файл логов, нужно прописать максимальный размер. Для этого проходим по пути “<strong><em>~/.gitlab-runner/</em></strong>”. Там будет файл <strong><em>config.toml</em></strong>, в котором хранится вся информация о зарегистрированных раннерах, в нём нам нужно прописать параметр <strong><em>output_limit</em></strong>, — это максимальный размер в байтах хранимых логов в джобах. Для всех параметров есть <a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section">документация</a>, для output_limit написано: “Maximum build log size in kilobytes. Default is 4096 (4MB)”. То есть по умолчанию — 4 мегабайта. </p><p>Если на одной машине мы регистрируем несколько раннеров, например для разных IOS-проектов, то в каждом случае изначально указываются дефолтные параметры для всего. Значит, если мы хотим увеличить объём логов, надо дописывать в каждом случае.</p><p>Всё, что будет превышать этот порог, не будет залогировано и не будет отображаться в информации о джобах. Примерно так это должно выглядеть:</p><pre><code>[[runners]]
  output_limit = 500000
  name = "My first runner"
  url = "https://gitlab-01"
  token = "7qybRaWukobUuXYoiSMc"
  executor = "shell"
  [runners.custom_build_dir]
  [runners.cache]
    [runners.cache.s3]
    [runners.cache.gcs]
    [runners.cache.azure]</code></pre><p>Нужно быть аккуратным с логами в джобах, потому что один файл логов в среднем весит 37 Мб, он занимает много места. Все логи хранятся в гитлабе и увеличивают размер репозитория. Готово, Gitlab CI теперь может работать с раннером!</p><h3>Настройка Fastlane</h3><p>Установить Fastlane можно тоже через Homebrew (<a href="https://docs.fastlane.tools/getting-started/ios/setup/">документация</a>). Необходимо наличие ruby в системе, обычно он установлен в macos по дефолту. Набираем:</p><pre><code>brew install fastlane</code></pre><p>Открываем терминал, переходим в папку с проектом с помощью <strong>cd./path_to_project</strong> и выполняем команду</p><pre><code>fastlane init</code></pre><p>Сгенерится папка Fastlane с нужными файлами. Можно использовать Fastlane с помощью Swift: описывать лайны на Swift, а не на неизвестном DSL, — это упростит понимание скрипта для коллег (<a href="https://docs.fastlane.tools/getting-started/ios/fastlane-swift/">документация</a>). </p><p>Самый важный файл здесь — это Fastfile. Он состоит из lane. Каждый из них — отдельный сценарий Fastlane. Можно представить сам Fastlane как некий класс (в ООП), а lane — как его функции. Синтаксис довольно простой. </p><p>Разберём на примере lane для юнит-тестов. Для этого можно использовать разные плагины. Мы в компании выбрали scan как самый удобный и функциональный. Ниже пример кода. Если хотите, можете ознакомиться со всеми параметрами и их предназначением в <a href="https://docs.fastlane.tools/actions/scan/#parameters">подробном описании по плагину scan</a>. </p><pre><code>desc "Прогон юнит тестов для определенных схем. Пример вызова: fastlane unit_test scheme:CoreTests"
lane :unit_test do |options|
    scheme = options[:scheme]
    scan(
        scheme: scheme,
        device: "iPhone 11 Pro",
        fail_build: false,
        clean: true,
        derived_data_path: "./tests/derived",
        max_concurrent_simulators: "3",
        code_coverage: true,
        output_directory: "./tests/#{scheme}_report/",
        result_bundle: true
    )
end</code></pre><p>Получился lane, который запускает тесты для схемы CoreTests, которую мы берём из параметров вызова lane. Ему можно скармливать как схемы обычных таргетов, так и отдельные схемы под тесты. Передавать надо названия схем, а не сами таргеты.</p><p>В большинстве проектов один таргет, одна схема — и нет путаницы. Но при создании CI больших проектов, когда 30–40 конфигураций, а таргетов ещё больше, важно ориентироваться на правильные понятия. Таргет — это executable(buildable)-проект, у него есть описательная схема с Build Phase, Build Settings, General. Схемы — это инструкции, описывающие, как комбинировать таргеты. Например, одна схема для тестов может запускать несколько тестовых таргетов под собой. В основном плагины Fastlane работают со схемами для запуска.</p><figure class="full-width "><img src="/img/image-loader.svg" height="456" data-src="https://habrastorage.org/getpro/habr/upload_files/9ef/9b8/5f4/9ef9b85f457b9b4e74e580b928ef7d04.png" data-width="1180"/><figcaption></figcaption></figure><p>Дальше для проверки работоспособности lane введём в терминал команду:</p><pre><code>fastlane unit_test scheme:CoreTests</code></pre><p>В ответ мы увидим логи компиляции и сами логи Fastlane. По итогу получим папку <strong><em>./tests/CoreTests_report/</em></strong> с отчётом о тестировании в формате <strong><em>.xcresult</em></strong>. По дефолту плагин scan генерирует нам ещё два файла — <strong><em>report.html &amp; report.junit</em></strong>. Первый обычно используется для показа людям, а второй — для Gitlab CI в качестве отчёта тестирования, — об этом позже в разделе про артифакты в пайплайнах.</p><p>На основе сгенерированных отчётов можно проверять, были ли зафейленные тесты и в каких местах. У нас есть отдельный <a href="https://gist.github.com/yawillianpsb/8773ff01cb1f9390d5a03d54de27a508">скрипт на Swift</a>, который на основе report.junit проверяет наличие проваленных тестов и говорит, в каких фреймворках. </p><h3>Code coverage</h3><p>Также мы считаем покрытие тестами и на основе этих данных ограничиваем мерж в master. Это работает с помощью Fastlane. Он уже выдал нам <strong><em>.xcresult</em></strong>, и на его основе мы будем получать значение покрытия.</p><p><a href="http://docs.fastlane.tools/actions/xcov/#xcov">Плагин для Fastlane xcov</a> может выдавать разные форматы отчётов. Нам нужен json, так как нас интересует сам процент покрытия, а проще всего его получить из json.</p><pre><code>desc "Расчет тестового покрытия кода для указанных схем. Должно вызываться только после выполнения лейна unit_test. Пример вызова: fastlane code_coverage scheme:BaseTests"
lane :code_coverage do |options|
    scheme = options[:scheme]
    FileUtils.mv("../tests/#{scheme}_report/#{scheme}.xcresult", "../tests/derived/Logs/Test/#{scheme}.xcresult")
    begin
        FileUtils.rm_rf("../tests/#{scheme}_report/coverage_result")
    rescue
        puts "Folder alredy deleted"
    end
    xcov(
        workspace: "PSB.xcworkspace",
        scheme: scheme,
        derived_data_path: "./tests/derived",
        output_directory: "./tests/#{scheme}_report/coverage_result",
        html_report: false,
        markdown_report: false,
        json_report: true
    )
end</code></pre><p>В самом начале функции есть махинации с файлом <strong><em>.xcresult</em></strong> потому, что <strong><em>xcov</em></strong> требует, чтобы он находился в определённом месте иерархии папки <strong><em>derived</em></strong>. Поэтому мы переносим его в это место перед подсчётом code coverage. И желательно, чтобы папка <em>output_directory</em> была пуста, т. к. <strong><em>xcov</em></strong> не перезатирает отчёты, а просто падает, если видит, что в этой папке уже есть файлы с таким названием. </p><p>На выходе мы получим <strong><em>report.json</em></strong>, в котором содержится много информации, параметр coverage — это наш процент. Этот файл содержит информацию по общему coverage, каждому таргету, каждому файлу и каждому исполняемому скоупу.</p><pre><code>{
   "coverage":0.5167708082636994,
   "targets":[
      {
         "name":"SomeFramework.framework",
         "coverage":0.8335146898803046,
         "files":{
            
         }
      },
      {
         "name":"SomeFramework2.framework",
         "coverage":0.4323423536236234,
         "files":{
            
         }
      }
   ]
}</code></pre><p>Считывание ковеража в Gitlab CI динамическое. В настройках вы задаёте Regex-паттерн, который будет проверять в каждой строчке логов, подходит ли число под паттерн. Мы используем такой формат:</p><pre><code>\((\d+.\d+|\d+)\%\) covered</code></pre><p>С его помощью парсится вывод скрипта Swift. Подходят записи типа “(51.67%)covered”</p><p><a href="https://gist.github.com/yawillianpsb/fb51e7f1a957e903e27235e2864d2035">Наш скрипт написан на Swift</a>. Он нужен только для того, чтобы вывести coverage в нужном формате. Всё, что от него требуется, — чтобы какая-нибудь рандомная строчка в коде не попала под это regexp.</p><p>Мы используем .junit, потому что это стандартный формат отчётов о тестировании в Gitlab CI. Внутри пайплайнов можно увидеть, сколько и какие тесты прошли, а какие нет, информацию по ним, — для этого необходим отчёт junit. .xcresult, который в себе содержит намного больше информации, включая code coverage.</p><p>Сама настройка Regex находится в настройках проекта <strong>Settings -> CI/CD -> General pipelines</strong>, в графе<strong> Test coverage parsing</strong>. Подробнее про Regex можно почитать <a href="https://habr.com/ru/post/545150/">в этой статье.</a> Там же есть ссылка на сайты, в которых можно протестировать работу формулы (например, <a href="https://regex101.com/">тут</a>).</p><h3>Firebase deploy</h3><p>Теперь устанавливаем Firebase CLI, — это управление сборками в Firebase из командной строки. В обычном режиме разработчик идёт на сам сайт Firebase, закидывает туда сборки и управляет проектом, но это можно сделать с помощью командной строки. Для этого нам и нужен Firebase.</p><p>Мы используем бесплатный Firebase App Distribution (в Firebase есть другие платные фичи, которые не относятся к CI/CD). </p><p>Как настроить Google Firebase: <a href="https://firebase.google.com/docs/app-distribution/ios/distribute-fastlane">документация</a></p><p>Вот краткий план:</p><p>1. Устанавливаем плагин к Fastlane — Firebase.</p><p>2. Устанавливаем Firebase CLI.</p><p>3. Получаем токен учётной записи, у которой есть доступ в проект, куда мы будем отправлять наши сборки.</p><p>4. Вот lane, который будет отправлен в Firebase.</p><pre><code>def archive_project(scheme, forTestflight, filename)
    if forTestflight
        build_ios_app(
            workspace: "PSB.xcworkspace",
            configuration: scheme,
            scheme: scheme,
            silent: true,
            clean: true,
            output_directory: "./ipas",
            output_name: "#{filename}.ipa",
            export_options: "./ExportOptions.plist"
        )
    else
        build_ios_app(
            workspace: "PSB.xcworkspace",
            configuration: scheme,
            scheme: scheme,
            silent: true,
            clean: true,
            output_directory: "./ipas",
            output_name: "#{filename}.ipa",
            export_method: "development",
            include_bitcode: false
        )
    end
end</code></pre><p>Функция умеет собирать сборку для публикации в AppStore, для тестировщиков, для общего пользования. Они отличаются кастомными параметрами в ExportOptions. При указании export method: “development” ExportOptions генерируется автоматически. Для production ExportOptions надо описывать вручную. Можно приложить ссылки для production- и development-опций экспорта.</p><pre><code>def send_to_firebase(ipa_name, scheme)
    firebase_apps = {
        "Dev" => "1:1234567890:ios:0a1b2c3d4e5f67890",
        "PreProd" => "1:0987654321:ios:0a1b2c3d4e5f67890"
    }
    firebase_app_distribution(
        app: firebase_apps[scheme], # для разных схем разные айди
        # groups: "ВСЕМ",
        # testers: "tester@gmail.com",
        ipa_path: "./ipas/#{ipa_name}.ipa",
        firebase_cli_path: "/usr/local/bin/firebase",
        firebase_cli_token: "ваш токен",
        debug: true
    )
end</code></pre><p>Дальше можно объединить это в один lane или сделать отдельный для каждого действия, чтобы CI мог дёргать эти функции в каком угодно порядке. У нас это разделено.</p><pre><code>desc "Собрать проект с указанной схемой. Пример вызова: fastlane archive_project scheme:\"Dev\" filename:\"dev_1.2.3\""
lane :archive_project do |options|
    scheme = options[:scheme]
    filename = options[:filename]
    archive_project(scheme, false, filename)
end
desc "Собрать релизную сборку проекта. Пример вызова: fastlane archive_beta scheme:\"Prod\" filename:\"release_1.2.3\""
lane :archive_beta do |options|
    scheme = options[:scheme]
    filename = options[:filename]
    archive_project(scheme, true, filename)
end
desc "Отправить уже собранный архив ipa в фаербейз с указанным названием файла. Пример вызова: fastlane distribute_to_firebase filename:\"dev_1.2.3\" scheme:\"Dev\""
lane :distribute_to_firebase do |options|
    filename = options[:filename]
    scheme = options[:scheme]
    send_to_firebase(filename, scheme)
end</code></pre><p>Всё, что мы написали на Fastlane, нужно проверять с помощью консольных команд. Например, для публикации в Firebase можно выполнить две команды подряд:</p><pre><code>fastlane archive_project scheme:“Dev” filename:“dev_1.2.3”
fastlane distribute_to_firebase filename:“dev_1.2.3” scheme:“Dev”</code></pre><p>Эти же строки можно объединить в одну для удобства, поставив между ними “;”</p><pre><code>fastlane archive_project scheme:“Dev” filename:“dev_1.2.3”
fastlane distribute_to_firebase filename:“dev_1.2.3” scheme:“Dev”</code></pre><p>Для публикации используются git tags. Например, если мы для коммита запушим тег dev_1.72.44.TASK-123, то в Firebase отправится сборка с номером 1.72.44.TASK-123. Сами вызовы с указанием версии идут из gitlab-ci.yml. Если что-то пойдёт не так, джоба зафейлится и разработчику придёт уведомление об этом. Посмотрев на логи джобы, он увидит причину: например, проект удалили или что-то ещё серьёзное случилось. Firebase позволяет публиковать приложения с одинаковой версией.</p><h3>Testflight deploy для itunesconnect и отправки в AppStore</h3><p>Testflight — это система обработки сборок от Apple. В ней можно делать сборки для тестировщиков, а также релизить протестированные сборки. По схеме CI/CD она будет на уровне с Firebase, т. к. они взаимозаменяемы, только Firebase более удобен для дистрибуции тестовых сборок. А Testflight мы используем для релиза итоговых сборок для пользователей.</p><p>Firebase — для теста, потому что удобнее и быстрее. Testflight — для production, потому что релизить можно только через неё.</p><p>Мы загружаем наш артефакт в ItunesConnect, и сама система предоставляет нам возможность отправить его сразу в Testflight. Testflight даёт возможность скачивать приложения, над которыми работаем, прямо на айфон.</p><p>Основные этапы публикации в AppStore те же. Нам нужно собрать архив и отправить его, только теперь отправляем в AppStore. Тестировщик скачает Testflight и получит доступ к тому, что мы задеплоили. </p><p>Следующий этап — изменение версии сборки, чтобы мы могли разные сборки публиковать для тестировщиков. Например, разные команды делают сборки под себя и будут отличать их билд-версиями. Так вот, AppStore не позволит загрузить сборки с одинаковыми версиями, поэтому нужно автоматизировать изменение версии проекта.</p><p>Есть небольшой lane для изменения версии и номера билда с помощью Fastlane.</p><pre><code>desc "Меняет версию проекта на новую с валидацией самой версии. Допускается версия вида 1.56.45 или 1.34.21(12), где 12 - номер билда. Пример вызова: fastlane update_version version:\"1.46.45\""
lane :update_version do |options|
    git_tag_version = options[:version]
    puts git_tag_version
    major = ""
    minor = ""
    patch = ""
    build = ""
    errorMsg = "Wrong version number: \"#{git_tag_version}\"!\nPlease use versioning like {major_number}.{minor_number}.{patch_number}({build_number})\n or {major_number}.{minor_number}.{patch_number}"
    patternWithBuild = /\A(\d+).(\d+).(\d+)\((\d+)\)\z/
    pattern = /\A(\d+).(\d+).(\d+)\z/
    if match = patternWithBuild.match(git_tag_version)
        major, minor, patch, build = match.captures
    elsif match = pattern.match(git_tag_version)
        major, minor, patch = match.captures
    else
        UI.user_error!(errorMsg)
    end
    if major.to_s.empty? || minor.to_s.empty? || patch.to_s.empty?
        UI.user_error!(errorMsg)
    end
    if build.to_s.empty?
        build = "1"
    end
    version = "#{major}.#{minor}.#{patch}"
    increment_version_number_in_plist(version_number: "#{version}" , target: "PSB")
    increment_version_number_in_plist(version_number: "#{version}", target: "notificationService")
    increment_build_number_in_plist(build_number: "#{build}", target: "PSB")
    increment_build_number_in_plist(build_number: "#{build}", target: "notificationService")
end
desc "Меняет версию проекта на новую без валидации самой версии. Пример вызова: fastlane force_update_version version:\"1.46.45_TASK\""
lane :force_update_version do |options|
    git_tag_version = options[:version]
    puts git_tag_version
    increment_version_number_in_plist(version_number: "#{git_tag_version}" , target: "PSB")
    increment_version_number_in_plist(version_number: "#{git_tag_version}", target: "notificationService")
end</code></pre><p>Тут описаны два lane: один валидирует версию, чтобы она подходила для публикации в AppStore, второй может подставить в версию что угодно (ну или почти что угодно). Первый мы используем только для Testflight, а второй — для Firebase, т. к. Firebase позволяет писать буквы в версию и не придирчив к повторам.</p><p>Ещё нам понадобится сам lane публикации в AppStore: </p><pre><code>desc "Отправить уже собранный архив ipa в Testflight с указанным названием файла. Пример вызова: fastlane distribute_to_testflight itunes_username:\"email@gg.ru\" filename:\"release_1.2.3\""
lane :distribute_to_testflight do |options|
    username = options[:itunes_username]
    filename = options[:filename]
    puts "username #{username} and filename #{filename}"
    if username.to_s.empty? 
        UI.user_error!("Need to pass ITUNES_USERNAME to testflight lane")
    end
    upload_to_testflight(
        username: "#{username}",
        ipa: "./ipas/#{filename}.ipa",
        skip_waiting_for_build_processing: true
    )
end</code></pre><p>Lane несложный, поэтому тут нечего дополнять, просто передаём нужные параметры в плагин Fastlane. Порядок вызова lane для публикации в AppStore прост:</p><pre><code>fastlane update_version version:“$right_version”
fastlane archive_beta scheme:${scheme} filename:${filename}
fastlane distribute_to_testflight
itunes_username:”${ITUNES_USERNAME}” filename:${filename}</code></pre><p>Здесь $right_version — это желательно валидный номер версии. Если он будет невалидным, то lane провалится и на этом путь публикации закончится. ${ITUNES_USERNAME} — это email юзера, от имени которого мы будем публиковать архив в Testflight.</p><h3>[Gitlab CI].gitlab-ci.yml</h3><p>Теперь нужно описать правила, по которым у нас будут происходить взаимодействия ивентов в Gitlab и написанных скриптов. И имя ему  —  gitlab-ci.yml. Этот файл задаёт стандарт сборки и проверки приложения.</p><p>Это тот самый файл, который запускает все lane, считает нужные параметры, управляет артефактами. Один из его минусов(а может, и плюсов) — скрипты запускаются на bash. Поэтому переиспользование тут не совсем обычное. Об этом расскажу позже, но сначала ознакомимся с простыми примерами файла:</p><pre><code>stages:
  - test_stage
test_job:
  stage: test_stage
  tags:
    - ios_tests
  script:
    - echo "Hello world"</code></pre><p>Если мы запушим в репозиторий файл .gitlab-ci.yml с таким содержимым, то у нас будут на каждый ивент гитлаба создаваться джобы, которые будут запускать скрипт <em>echo “Hello world”.</em></p><figure class="full-width "><img src="/img/image-loader.svg" height="630" data-src="https://habrastorage.org/getpro/habr/upload_files/30e/3e4/938/30e3e4938de86934395da3522a502ce8.png" data-width="1600"/><figcaption></figcaption></figure><p>Сам по себе пайплайн прост:</p><figure class="full-width "><img src="/img/image-loader.svg" height="336" data-src="https://habrastorage.org/getpro/habr/upload_files/192/2cd/53a/1922cd53aa198f1f5ddc209205d91846.png" data-width="766"/><figcaption></figcaption></figure><p>Исполняемый код может находиться в трёх стадиях, они указаны по порядку:</p><ul><li><p>before_script</p></li><li><p>script</p></li><li><p>after_script</p></li></ul><p>Здесь мы и будем писать вызовы скриптов Fastlane, Swift и что душе угодно.</p><p><strong>Эксперименты с .gitlab-ci.yml</strong></p><p>Приведу немного примеров из личного опыта, чтобы объяснить, как мы настраиваем пайплайны под свои запросы.</p><p>Попробуем посмотреть, что будет с <a href="https://gist.github.com/yawillianpsb/e8f6558d32264dc049fa114cc448070c">таким файлом CI</a>, в котором 5 стадий и 8 джоб, и разберём, как это будет работать.</p><figure class="full-width "><img src="/img/image-loader.svg" height="367" data-src="https://habrastorage.org/getpro/habr/upload_files/f3c/b0c/6e7/f3cb0c6e74e81eedaf2d2baf45947027.png" data-width="1600"/><figcaption></figcaption></figure><p>Тут есть несколько правил:</p><ol><li><p>Пайплайны (pipeline) состоят из стадий (stage), а они в свою очередь — из джоб (job)</p></li><li><p>Каждая джоба может состоять только в одной стадии</p></li><li><p>Каждая стадия может содержать нескольких джоб, которые запускаются последовательно и параллельно. Значит, если у вас есть несколько раннеров, то <em>test_job1</em> и <em>test_job2</em> стартанули бы почти одновременно, не ожидая завершения друг друга</p></li><li><p> Стадии идут только последовательно, каждая перед стартом ожидает завершения всех джоб из предыдущей стадии</p></li><li><p>Если при выполнении джобы вызвалась команда <em>exit</em> с ненулевой ошибкой, то джоба фейлится: <em>exit 0</em> означает, что джоба успешно завершилась; любая другая цифра будет обозначать какую-то ошибку</p></li><li><p>Если в стадии одна из джоб зафейлилась без флага <em>allow_failure: true</em>, то следующая стадия не стартует. Для<em> test_job3</em> этот флаг включёен, а для <em>test_job5 </em>нет</p></li><li><p>Если в стадии несколько джоб и одна из них зафейлилась, то другие джобы стадии продолжают выполнение</p></li><li><p>В разных джобах можно писать coverage. Например, в джобе 1 мы написали coverage 0%, в джобе 2 получили 10%, и в джобе 4 написали 100%. Тогда общий coverage пайплайна будет считаться как среднее среди всех джоб (0 + 10 + 100) / 3. Это можно использовать, например, для мультимодульности. Создать стадию тестов и на этой стадии — по одной джобе на каждый фреймворк. Но можно сделать, как мы в компании, на уровне Xcode. У нас есть выделенная схема для юнит-тестов всех фреймворков, в которую добавлены все тестовые таргеты. Результатом тестирования этой схемы являются   прогнанные тесты в этих таргетах и средний coverage по ним</p></li><li><p>Coverage учитывается, даже если джоба зафейлилась</p></li><li><p>В джобе 8 выставлен флаг <em>when: on_failure</em>, — это значит, что джоба выполнится только в том случае, если пайплайн зафейлился. В случае если пайплайн прошёл без проблем, эта джоба не запустится. Такой флаг полезно ставить, например, в джобы, которые оповещают о зафейленном пайплайне</p></li><li><p>Порядок стадий в пайплайне зависит от их порядка в файле CI в фазе <em>stages:</em> первыми будут выполняться те, что находятся выше по порядку. Джобы — так же: чем выше вы их описали в файле, тем раньше они выполнятся в пайплайне</p></li></ol><p>В файле CI есть подобие наследования — так называемые <em>extends:</em>. Мы создаем шаблонную джобу, которую будем расширять нужными нам свойствами. </p><p>Важное замечание: если мы в шаблоне указали какой-то параметр, например <em>script</em> или <em>tags</em>, а не в джобе, которая расширяет этот шаблон, то если мы в джобе напишем собственный script, то исполнятся будет только тот, что написан в джобе. Переопределение полностью отменяет свойство шаблона. Например, мы хотим в конце каждой джобы выполнять какое-то действие, тогда можем это прописать в <em>before_script</em> шаблона, а в самих джобах исполняемые команды писать в фазу <em>script</em>.</p><p>А теперь реальный пример того, как мы гоняем тесты и считаем coverage. Рассмотрим <a href="https://gist.github.com/yawillianpsb/f4cbd38cccabe0d2f4b607735123d893"><strong><em>.gitlab-ci.yml</em></strong> такого вида</a> — сверху вниз по каждому пункту.</p><h4>Variables</h4><p>В файле .gitlab-ci.yml есть раздел с переменными, где мы можем задать кастомные свойства для всего файла. Также стоит учитывать, что помимо параметров, которые укажете в самом файле, вам будет доступен целый набор<a href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html"> Predefined CI/CD variables</a> и набор кастомных параметров, указанных в настройках проекта (Settings ⃗⃗→ CI/CD → Variables). Все три категории свойств будут доступны во всех ваших описываемых джобах внутри .gitlab-ci.yml.</p><h4>Stages</h4><p>Здесь мы указываем набор стадий для пайплайнов, пока что они просто обозначают, как джобы будут группироваться внутри пайплайнов.</p><h4>Jobs</h4><p>Расскажу подробнее про структуру джоб:</p><ul><li><p>extends — нужно, чтобы переиспользовать базовые вещи;</p></li><li><p>stage — указываем, в какой стадии участвует джоба. Внутри одной стадии они выполняются параллельно;</p></li><li><p>before script, script, after script — набор команд Shell в том порядке, в котором исполняются;</p></li><li><p>only/except — описывают, под какие правила попадает / точно не попадает джоба;</p></li><li><p>tags — теги, которыми мы пометили раннер, когда регистрировали его;</p></li><li><p>allow failure — свойство, которое разрешает / не разрешает зафейленную джобу, здесь можно указывать допустимые exit codes;</p></li><li><p>artifacts — будем использовать для хранения артефактов джобы.</p></li></ul><h3>Как дебажить</h3><p>Gitlab-runner предоставляет возможность запускать локально ваши джобы для их тестирования перед пушем в репозиторий, что упрощает жизнь. Для этого нужно выполнить команду</p><pre><code>gitlab-runner exec shell exec shell test_job1</code></pre><p>Команда выполнялась для <a href="https://gist.github.com/yawillianpsb/e8f6558d32264dc049fa114cc448070c">такого gitlab-ci.yml</a>.</p><figure class="full-width "><img src="/img/image-loader.svg" height="982" data-src="https://habrastorage.org/getpro/habr/upload_files/834/4f5/b6b/8344f5b6bb13b622da1d7da0c3c24a6b.png" data-width="1364"/><figcaption></figcaption></figure><p>У такого дебаггинга есть минус:  вам не будут доступны реальные глобальные переменные по типу CI_JOB_ID, CI_PIPELINE_ID, т. к. эти параметры передаются Gitlab на раннер. Но такой дебаггинг вполне сгодится для проверки работоспособности локальных скриптов. Вот ещё пример вывода глобальной переменной</p><figure class="full-width "><img src="/img/image-loader.svg" height="954" data-src="https://habrastorage.org/getpro/habr/upload_files/01a/d02/0e6/01ad020e6067cfdf22b159f8d3fe1011.png" data-width="1980"/><figcaption></figcaption></figure><h3>Итого</h3><ol><li><p>Мы научились настраивать Gitlab-runner на машине</p></li><li><p>Разобрались, как работает Fastlane</p></li><li><p>Можем написать lane, которые помогут: протестировать, собрать информацию о code coverage, собрать архив и отправить его в Firebase или Testflight</p></li></ol><p>Ещё раз повторим действия в командной строке:</p><ol><li><p>Устанавливаем gitlab-runner</p><p><code>brew install gitlab-runner</code></p></li><li><p>Делаем mac раннером для CI</p><p><code>gitlab-runner register</code></p></li><li><p>Запускаем раннер</p><p><code>gitlab-runner install</code></p><p><code>gitlab-runner start</code></p></li><li><p>Устанавливаем Fastlane</p><p><code>brew install fastlane</code></p></li><li><p>Папка Fastlane с нужными      файлами</p><p><code>fastlane init</code></p></li><li><p>Проверим      работоспособность lane</p><p><code>fastlane unit_test scheme:CoreTests</code></p></li><li><p>Публикуем в Firebase</p><p><code>fastlane archive_project scheme:“Dev” filename:“dev_1.2.3”</code></p><p><code>fastlane distribute_to_firebase filename:“dev_1.2.3” scheme:“Dev”</code></p></li><li><p>Вызов lane для публикации в AppStore</p><p><code>fastlane update_version version:“$right_version”</code></p><p><code>fastlane archive_beta scheme:${scheme} filename:${filename}</code></p><p><code>fastlane distribute_to_testflight</code></p><p><code>itunes_username:”${ITUNES_USERNAME}” filename:${filename}</code></p></li><li><p>Локально запустим джобы, чтобы тестировать их перед пушем в репозиторий</p><p><code>gitlab-runner exec shell exec shell test_job1</code></p></li></ol><p>Использование Gitlab CI + Fastlane + Firebase + Testflight обходится недорого. Можно иметь 2–3 машины и настроить работу.</p><p>Работа команды выглядит так:</p><ol><li><p>Разработчик сделал задачу, написал на неё тесты и отправил МР на код-ревью.         </p></li><li><p>Внутри МР CI/CD считает, не слишком ли низкий code coverage, и проверяет, собирается ли проект.                       </p></li><li><p>Отправив MP на ревью, разработчик ставит тег на последний коммит, например  dev_1.33.22.TASK-123 cicd         .                  </p></li><li><p>Он готовит сборку и отправляет ее в Firebase.                       </p></li><li><p>Из Firebase тестировщик скачивает сборку. Проверяет, получает ревью и   нужные апрувы.                  </p></li></ol><p>Мы готовы мержить: держим код в master и на ней запускается пайплайн обновления значения code coverage, чтобы уже другие MP не попадали в master с понижением.</p><p>Как видите, большую часть работы делает за нас Gitlab CI, а нам главное — расставить триггеры в правильных местах и настроить наш процесс сборки.</p><p>Документируйте настроенный CI/CD, научите всех пользоваться им, предлагайте идеи по автоматизации процессов и спрашивайте ваших коллег о болях. Возможно, пара скриптов, встроенных в CI/CD, сэкономят деньги для бизнеса или нервы ваших коллег.</p><p>Задавайте свои вопросы в комментариях!</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%5D" class="tm-tags-list__link">ios</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%20development%5D" class="tm-tags-list__link">ios development</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%5D" class="tm-tags-list__link">ios разработка</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bci%2Fcd%5D" class="tm-tags-list__link">ci/cd</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bdevops%5D" class="tm-tags-list__link">devops</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/psb/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании ПСБ
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/ios_dev/" class="tm-hubs-list__link">
    Разработка под iOS
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/devops/" class="tm-hubs-list__link">
    DevOps
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 12: ↑12 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 12: ↑12 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+12</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">2.8K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    35
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/psb/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/e13/03f/9c3/e1303f9c36fc6bdde8117b4b67c9cc54.jpg" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/psb/profile/" class="tm-company-snippet__title">ПСБ</a> <div class="tm-company-snippet__description">Компания</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <div class="tm-article-author__company-contacts"><a href="https://www.psbank.ru" rel="noopener" target="_blank" class="tm-article-author__contact">
      Сайт
    </a></div> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/WillianLike/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/115/9f6/fb6/1159f6fb65625326ca045129df5615fe.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 6 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    6
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">12</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/WillianLike/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @WillianLike
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">IOS developer</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/psb/blog/583532/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 6 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="1995-05-11T20:00:00.000Z" title="1995-05-12, 00:00">12  мая  1995</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="https://www.psbank.ru" target="_blank" class="tm-company-basic-info__link">
      www.psbank.ru
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    5 001–10 000 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2017-11-27T10:48:13.000Z" title="2017-11-27, 13:48">27  ноября  2017</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Представитель</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="/ru/users/chuvash/" class="tm-company-basic-info__link">
      Ларионов Владимир
    </a></dd></dl></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/psb/blog/583532/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/psb/blog/583532/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"583532":{"id":"583532","timePublished":"2021-10-14T15:13:55+00:00","isCorporative":true,"lang":"ru","titleHtml":"Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect","leadData":{"textHtml":"\u003Cp\u003EВ основном идея использования CI\u002FCD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда растёт, хочется тратить время эффективнее, чем вручную собирать проект или объяснять новичкам, что же там с Code-signing нужно делать. \u003C\u002Fp\u003E\u003Cp\u003EПожалуй, самое рутинное и самое важное занятие, которое берёт на себя CI, — это прогон тестов. Нет зелёных тестов? В master не попадёшь. А с ростом команды вероятность того, что кто-то вольёт в master нерабочий код, будет только увеличиваться. Нужна автоматизация.\u003C\u002Fp\u003E\u003Cp\u003EВ этой статье я хочу подробно рассказать о пути настройки Gitlab CI + Fastlane + Firebase + Testflight. Примеры приводятся на основе одного проекта, в котором участвовали 10 разработчиков. В конце будут описаны проблемы, с которыми мы сталкивались, и их решения.\u003C\u002Fp\u003E\u003Cp\u003EДля кого будет полезен этот опыт? Для всех, кому нужен CI\u002FCD и кто сидит на Gitlab. Для Github будет другая связка, например с Travis, — остальные компоненты неизменны. В нашей команде все используют Gitlab CI, Fastlane вместо голого xcodebuild для быстроты и удобства разработки, Firebase и Testflight.\u003C\u002Fp\u003E\u003Cp\u003EЕсли у нас бесплатный Gitlab и мы укладываемся в лимит Firebase, то получаем бесплатное решение по настройке CI\u002FCD.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":null},"editorVersion":"2.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":6,"votesCount":6},"rating":12,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1828787","alias":"WillianLike","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F115\u002F9f6\u002Ffb6\u002F1159f6fb65625326ca045129df5615fe.jpg","speciality":"IOS developer"},"statistics":{"commentsCount":6,"favoritesCount":35,"readingCount":2827,"score":12,"votesCount":12},"hubs":[{"relatedData":null,"id":"21292","alias":"psb","type":"corporative","title":"Блог компании ПСБ","titleHtml":"Блог компании ПСБ","isProfiled":false},{"relatedData":null,"id":"548","alias":"ios_dev","type":"collective","title":"Разработка под iOS","titleHtml":"Разработка под iOS","isProfiled":true},{"relatedData":null,"id":"20788","alias":"devops","type":"collective","title":"DevOps","titleHtml":"DevOps","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EВ основном идея использования CI\u002FCD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда растёт, хочется тратить время эффективнее, чем вручную собирать проект или объяснять новичкам, что же там с Code-signing нужно делать. \u003C\u002Fp\u003E\u003Cp\u003EПожалуй, самое рутинное и самое важное занятие, которое берёт на себя CI, — это прогон тестов. Нет зелёных тестов? В master не попадёшь. А с ростом команды вероятность того, что кто-то вольёт в master нерабочий код, будет только увеличиваться. Нужна автоматизация.\u003C\u002Fp\u003E\u003Cp\u003EВ этой статье я хочу подробно рассказать о пути настройки Gitlab CI + Fastlane + Firebase + Testflight. Примеры приводятся на основе одного проекта, в котором участвовали 10 разработчиков. В конце будут описаны проблемы, с которыми мы сталкивались, и их решения.\u003C\u002Fp\u003E\u003Cp\u003EДля кого будет полезен этот опыт? Для всех, кому нужен CI\u002FCD и кто сидит на Gitlab. Для Github будет другая связка, например с Travis, — остальные компоненты неизменны. В нашей команде все используют Gitlab CI, Fastlane вместо голого xcodebuild для быстроты и удобства разработки, Firebase и Testflight.\u003C\u002Fp\u003E\u003Cp\u003EЕсли у нас бесплатный Gitlab и мы укладываемся в лимит Firebase, то получаем бесплатное решение по настройке CI\u002FCD.\u003C\u002Fp\u003E\u003Ch3\u003EОписание инструментов\u003C\u002Fh3\u003E\u003Cp\u003E\u003Cstrong\u003EGitlab CI\u003C\u002Fstrong\u003E — это система автоматической сборки. Она занимается в том числе и отслеживанием изменений в репозитории, что важно для наших целей. Отслеживает событие, смотрит инструкции к нему, которые вы указали в файле \u003Cem\u003E.gitlab-ci.yml. \u003C\u002Fem\u003EОписанная в статье работа ведётся на ноутбуках разработчиков, есть выделенные машины на MacOS — их мы регистрируем в Gitlab CI.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EFastlane \u003C\u002Fstrong\u003E— верхнеуровневое управление сборками с помощью команд в терминале. Для него есть \u003Ca href=\"https:\u002F\u002Fdocs.fastlane.tools\u002Fplugins\u002Favailable-plugins\u002F\"\u003Eмного плагинов на сайте\u003C\u002Fa\u003E, которые помогают выполнять задачи разного уровня: от генерации AppIcon до сборки проекта и публикации в AppStore. Плагины, как и сам Fastlane, написаны на ruby, поэтому и управлять этим инструментом придётся на ruby.\u003C\u002Fp\u003E\u003Cp\u003EGitlab CI посылает инструкции в виде shell-команд на раннер, в набор команд входит Fastlane. Таким образом, они взаимодействуют, выполняя каждая свои задачи.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EFirebase\u003C\u002Fstrong\u003E — система дистрибьютинга сборок, хорошее решение для быстрой доставки сборок до ваших тестировщиков. Мы используем Firebase App Distribution — он бесплатный и без ограничений на место.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003ECode coverage\u003C\u002Fstrong\u003E — процент покрытия вашего кода тестами. Упрощённо можно привести к формуле:\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003Eколичество скомпилированных строк кода, по которым пробежали тесты \u002F общее количество скомпилированных строк кода) * 100%\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Ch3\u003E[Gitlab CI] Gitlab-runner\u003C\u002Fh3\u003E\u003Cp\u003EПервое, что нам нужно сделать на пути самурая автоматизации, — это подружить наш mac с CI. Для этого на самом маке нужно выполнить пару команд:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fdocs.gitlab.com\u002Frunner\u002Finstall\u002Fosx.html\"\u003EУстановить\u003C\u002Fa\u003E программу gitlab-runner      на mac (можно с помощью Homebrew). \u003Ca href=\"https:\u002F\u002Fbrew.sh\u002Findex_ru\"\u003EСсылка на установку Homebrew\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cp\u003EВводим в терминал:\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003Ebrew install gitlab-runner\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EТеперь надо зарегистрировать наш mac как раннер для CI:\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003Egitlab-runner register\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EПосле этого надо будет ввести URL до гитлаба, где хостимся.\u003C\u002Fp\u003E\u003Cp\u003EЕщё понадобится токен для CI. Его можно получить, только будучи Owner’ом или Maintainer’ом проекта в настройках проекта. В Settings должен быть раздел CI\u002FCD. Раздел Runners.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Раздел в настройках CI\u002FCD\" title=\"Раздел в настройках CI\u002FCD\" height=\"219\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F408\u002F357\u002Fdb0\u002F408357db04280e0758798a35b6ac0265.png\" data-width=\"1600\"\u002F\u003E\u003Cfigcaption\u003EРаздел в настройках CI\u002FCD\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"560\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F20b\u002F0ff\u002F9a8\u002F20b0ff9a8429638d04fc19b7482bd517.png\" data-width=\"1398\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВводим токен туда.\u003C\u002Fp\u003E\u003Cp\u003EОписание раннера ни на что не влияет, оно даётся только для справки.\u003C\u002Fp\u003E\u003Cp\u003EОбратите внимание на теги раннера. Без тегов ничего не будет работать, нужен минимум один. По тегам можно фильтровать разные раннеры: например, один будет с доступом к сети и сможет выкладывать сборки, а другой — нет. Тогда можно обозначить разные теги для разных функций раннеров. Например, для одного впишем теги ios_tests,ios_firebase, а в другом — только ios_tests. И сможем разделять исполнителей по типу. \u003C\u002Fp\u003E\u003Cp\u003EТип исполнения для нас всегда будет shell.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"gitlab-runner register\" title=\"gitlab-runner register\" height=\"898\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd1a\u002Fe45\u002Fbad\u002Fd1ae45bad3d492c117fc14dbf6b76aa3.png\" data-width=\"1448\"\u002F\u003E\u003Cfigcaption\u003Egitlab-runner register\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЗарегистрировали наш раннер. Теперь давайте посмотрим и убедимся, что он находится в том же списке Runners в настройках проекта.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"356\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd26\u002Fb9a\u002F1e3\u002Fd26b9a1e31bef741bba73a25d53bca4f.png\" data-width=\"1550\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВосклицательный знак указывает, что раннер ещё не запущен и не готов к работе. Идём к следующему шагу.\u003C\u002Fp\u003E\u003Cp\u003EЗапускаем раннер. Выполняем команды в терминале:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Egitlab-runner install\ngitlab-runner start\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТеперь наш раннер должен загореться зелёным в списке.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"376\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6f0\u002F0c3\u002F19d\u002F6f00c319d53ca464cd12edc84e2dbc14.png\" data-width=\"1532\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EУ раннеров есть проблема с логами. Для того чтобы мы могли просматривать полный файл логов, нужно прописать максимальный размер. Для этого проходим по пути “\u003Cstrong\u003E\u003Cem\u003E~\u002F.gitlab-runner\u002F\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E”. Там будет файл \u003Cstrong\u003E\u003Cem\u003Econfig.toml\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E, в котором хранится вся информация о зарегистрированных раннерах, в нём нам нужно прописать параметр \u003Cstrong\u003E\u003Cem\u003Eoutput_limit\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E, — это максимальный размер в байтах хранимых логов в джобах. Для всех параметров есть \u003Ca href=\"https:\u002F\u002Fdocs.gitlab.com\u002Frunner\u002Fconfiguration\u002Fadvanced-configuration.html#the-runners-section\"\u003Eдокументация\u003C\u002Fa\u003E, для output_limit написано: “Maximum build log size in kilobytes. Default is 4096 (4MB)”. То есть по умолчанию — 4 мегабайта. \u003C\u002Fp\u003E\u003Cp\u003EЕсли на одной машине мы регистрируем несколько раннеров, например для разных IOS-проектов, то в каждом случае изначально указываются дефолтные параметры для всего. Значит, если мы хотим увеличить объём логов, надо дописывать в каждом случае.\u003C\u002Fp\u003E\u003Cp\u003EВсё, что будет превышать этот порог, не будет залогировано и не будет отображаться в информации о джобах. Примерно так это должно выглядеть:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E[[runners]]\n  output_limit = 500000\n  name = \"My first runner\"\n  url = \"https:\u002F\u002Fgitlab-01\"\n  token = \"7qybRaWukobUuXYoiSMc\"\n  executor = \"shell\"\n  [runners.custom_build_dir]\n  [runners.cache]\n    [runners.cache.s3]\n    [runners.cache.gcs]\n    [runners.cache.azure]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНужно быть аккуратным с логами в джобах, потому что один файл логов в среднем весит 37 Мб, он занимает много места. Все логи хранятся в гитлабе и увеличивают размер репозитория. Готово, Gitlab CI теперь может работать с раннером!\u003C\u002Fp\u003E\u003Ch3\u003EНастройка Fastlane\u003C\u002Fh3\u003E\u003Cp\u003EУстановить Fastlane можно тоже через Homebrew (\u003Ca href=\"https:\u002F\u002Fdocs.fastlane.tools\u002Fgetting-started\u002Fios\u002Fsetup\u002F\"\u003Eдокументация\u003C\u002Fa\u003E). Необходимо наличие ruby в системе, обычно он установлен в macos по дефолту. Набираем:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Ebrew install fastlane\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОткрываем терминал, переходим в папку с проектом с помощью \u003Cstrong\u003Ecd.\u002Fpath_to_project\u003C\u002Fstrong\u003E и выполняем команду\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Efastlane init\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EСгенерится папка Fastlane с нужными файлами. Можно использовать Fastlane с помощью Swift: описывать лайны на Swift, а не на неизвестном DSL, — это упростит понимание скрипта для коллег (\u003Ca href=\"https:\u002F\u002Fdocs.fastlane.tools\u002Fgetting-started\u002Fios\u002Ffastlane-swift\u002F\"\u003Eдокументация\u003C\u002Fa\u003E). \u003C\u002Fp\u003E\u003Cp\u003EСамый важный файл здесь — это Fastfile. Он состоит из lane. Каждый из них — отдельный сценарий Fastlane. Можно представить сам Fastlane как некий класс (в ООП), а lane — как его функции. Синтаксис довольно простой. \u003C\u002Fp\u003E\u003Cp\u003EРазберём на примере lane для юнит-тестов. Для этого можно использовать разные плагины. Мы в компании выбрали scan как самый удобный и функциональный. Ниже пример кода. Если хотите, можете ознакомиться со всеми параметрами и их предназначением в \u003Ca href=\"https:\u002F\u002Fdocs.fastlane.tools\u002Factions\u002Fscan\u002F#parameters\"\u003Eподробном описании по плагину scan\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Edesc \"Прогон юнит тестов для определенных схем. Пример вызова: fastlane unit_test scheme:CoreTests\"\nlane :unit_test do |options|\n    scheme = options[:scheme]\n    scan(\n        scheme: scheme,\n        device: \"iPhone 11 Pro\",\n        fail_build: false,\n        clean: true,\n        derived_data_path: \".\u002Ftests\u002Fderived\",\n        max_concurrent_simulators: \"3\",\n        code_coverage: true,\n        output_directory: \".\u002Ftests\u002F#{scheme}_report\u002F\",\n        result_bundle: true\n    )\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПолучился lane, который запускает тесты для схемы CoreTests, которую мы берём из параметров вызова lane. Ему можно скармливать как схемы обычных таргетов, так и отдельные схемы под тесты. Передавать надо названия схем, а не сами таргеты.\u003C\u002Fp\u003E\u003Cp\u003EВ большинстве проектов один таргет, одна схема — и нет путаницы. Но при создании CI больших проектов, когда 30–40 конфигураций, а таргетов ещё больше, важно ориентироваться на правильные понятия. Таргет — это executable(buildable)-проект, у него есть описательная схема с Build Phase, Build Settings, General. Схемы — это инструкции, описывающие, как комбинировать таргеты. Например, одна схема для тестов может запускать несколько тестовых таргетов под собой. В основном плагины Fastlane работают со схемами для запуска.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"456\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F9ef\u002F9b8\u002F5f4\u002F9ef9b85f457b9b4e74e580b928ef7d04.png\" data-width=\"1180\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДальше для проверки работоспособности lane введём в терминал команду:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Efastlane unit_test scheme:CoreTests\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ ответ мы увидим логи компиляции и сами логи Fastlane. По итогу получим папку \u003Cstrong\u003E\u003Cem\u003E.\u002Ftests\u002FCoreTests_report\u002F\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E с отчётом о тестировании в формате \u003Cstrong\u003E\u003Cem\u003E.xcresult\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E. По дефолту плагин scan генерирует нам ещё два файла — \u003Cstrong\u003E\u003Cem\u003Ereport.html &amp; report.junit\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E. Первый обычно используется для показа людям, а второй — для Gitlab CI в качестве отчёта тестирования, — об этом позже в разделе про артифакты в пайплайнах.\u003C\u002Fp\u003E\u003Cp\u003EНа основе сгенерированных отчётов можно проверять, были ли зафейленные тесты и в каких местах. У нас есть отдельный \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Fyawillianpsb\u002F8773ff01cb1f9390d5a03d54de27a508\"\u003Eскрипт на Swift\u003C\u002Fa\u003E, который на основе report.junit проверяет наличие проваленных тестов и говорит, в каких фреймворках. \u003C\u002Fp\u003E\u003Ch3\u003ECode coverage\u003C\u002Fh3\u003E\u003Cp\u003EТакже мы считаем покрытие тестами и на основе этих данных ограничиваем мерж в master. Это работает с помощью Fastlane. Он уже выдал нам \u003Cstrong\u003E\u003Cem\u003E.xcresult\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E, и на его основе мы будем получать значение покрытия.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"http:\u002F\u002Fdocs.fastlane.tools\u002Factions\u002Fxcov\u002F#xcov\"\u003EПлагин для Fastlane xcov\u003C\u002Fa\u003E может выдавать разные форматы отчётов. Нам нужен json, так как нас интересует сам процент покрытия, а проще всего его получить из json.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Edesc \"Расчет тестового покрытия кода для указанных схем. Должно вызываться только после выполнения лейна unit_test. Пример вызова: fastlane code_coverage scheme:BaseTests\"\nlane :code_coverage do |options|\n    scheme = options[:scheme]\n    FileUtils.mv(\"..\u002Ftests\u002F#{scheme}_report\u002F#{scheme}.xcresult\", \"..\u002Ftests\u002Fderived\u002FLogs\u002FTest\u002F#{scheme}.xcresult\")\n    begin\n        FileUtils.rm_rf(\"..\u002Ftests\u002F#{scheme}_report\u002Fcoverage_result\")\n    rescue\n        puts \"Folder alredy deleted\"\n    end\n    xcov(\n        workspace: \"PSB.xcworkspace\",\n        scheme: scheme,\n        derived_data_path: \".\u002Ftests\u002Fderived\",\n        output_directory: \".\u002Ftests\u002F#{scheme}_report\u002Fcoverage_result\",\n        html_report: false,\n        markdown_report: false,\n        json_report: true\n    )\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ самом начале функции есть махинации с файлом \u003Cstrong\u003E\u003Cem\u003E.xcresult\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E потому, что \u003Cstrong\u003E\u003Cem\u003Excov\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E требует, чтобы он находился в определённом месте иерархии папки \u003Cstrong\u003E\u003Cem\u003Ederived\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E. Поэтому мы переносим его в это место перед подсчётом code coverage. И желательно, чтобы папка \u003Cem\u003Eoutput_directory\u003C\u002Fem\u003E была пуста, т. к. \u003Cstrong\u003E\u003Cem\u003Excov\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E не перезатирает отчёты, а просто падает, если видит, что в этой папке уже есть файлы с таким названием. \u003C\u002Fp\u003E\u003Cp\u003EНа выходе мы получим \u003Cstrong\u003E\u003Cem\u003Ereport.json\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E, в котором содержится много информации, параметр coverage — это наш процент. Этот файл содержит информацию по общему coverage, каждому таргету, каждому файлу и каждому исполняемому скоупу.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E{\n   \"coverage\":0.5167708082636994,\n   \"targets\":[\n      {\n         \"name\":\"SomeFramework.framework\",\n         \"coverage\":0.8335146898803046,\n         \"files\":{\n            \n         }\n      },\n      {\n         \"name\":\"SomeFramework2.framework\",\n         \"coverage\":0.4323423536236234,\n         \"files\":{\n            \n         }\n      }\n   ]\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EСчитывание ковеража в Gitlab CI динамическое. В настройках вы задаёте Regex-паттерн, который будет проверять в каждой строчке логов, подходит ли число под паттерн. Мы используем такой формат:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E\\((\\d+.\\d+|\\d+)\\%\\) covered\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EС его помощью парсится вывод скрипта Swift. Подходят записи типа “(51.67%)covered”\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Fyawillianpsb\u002Ffb51e7f1a957e903e27235e2864d2035\"\u003EНаш скрипт написан на Swift\u003C\u002Fa\u003E. Он нужен только для того, чтобы вывести coverage в нужном формате. Всё, что от него требуется, — чтобы какая-нибудь рандомная строчка в коде не попала под это regexp.\u003C\u002Fp\u003E\u003Cp\u003EМы используем .junit, потому что это стандартный формат отчётов о тестировании в Gitlab CI. Внутри пайплайнов можно увидеть, сколько и какие тесты прошли, а какие нет, информацию по ним, — для этого необходим отчёт junit. .xcresult, который в себе содержит намного больше информации, включая code coverage.\u003C\u002Fp\u003E\u003Cp\u003EСама настройка Regex находится в настройках проекта \u003Cstrong\u003ESettings -\u003E CI\u002FCD -\u003E General pipelines\u003C\u002Fstrong\u003E, в графе\u003Cstrong\u003E Test coverage parsing\u003C\u002Fstrong\u003E. Подробнее про Regex можно почитать \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F545150\u002F\"\u003Eв этой статье.\u003C\u002Fa\u003E Там же есть ссылка на сайты, в которых можно протестировать работу формулы (например, \u003Ca href=\"https:\u002F\u002Fregex101.com\u002F\"\u003Eтут\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Ch3\u003EFirebase deploy\u003C\u002Fh3\u003E\u003Cp\u003EТеперь устанавливаем Firebase CLI, — это управление сборками в Firebase из командной строки. В обычном режиме разработчик идёт на сам сайт Firebase, закидывает туда сборки и управляет проектом, но это можно сделать с помощью командной строки. Для этого нам и нужен Firebase.\u003C\u002Fp\u003E\u003Cp\u003EМы используем бесплатный Firebase App Distribution (в Firebase есть другие платные фичи, которые не относятся к CI\u002FCD). \u003C\u002Fp\u003E\u003Cp\u003EКак настроить Google Firebase: \u003Ca href=\"https:\u002F\u002Ffirebase.google.com\u002Fdocs\u002Fapp-distribution\u002Fios\u002Fdistribute-fastlane\"\u003Eдокументация\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cp\u003EВот краткий план:\u003C\u002Fp\u003E\u003Cp\u003E1. Устанавливаем плагин к Fastlane — Firebase.\u003C\u002Fp\u003E\u003Cp\u003E2. Устанавливаем Firebase CLI.\u003C\u002Fp\u003E\u003Cp\u003E3. Получаем токен учётной записи, у которой есть доступ в проект, куда мы будем отправлять наши сборки.\u003C\u002Fp\u003E\u003Cp\u003E4. Вот lane, который будет отправлен в Firebase.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Edef archive_project(scheme, forTestflight, filename)\n    if forTestflight\n        build_ios_app(\n            workspace: \"PSB.xcworkspace\",\n            configuration: scheme,\n            scheme: scheme,\n            silent: true,\n            clean: true,\n            output_directory: \".\u002Fipas\",\n            output_name: \"#{filename}.ipa\",\n            export_options: \".\u002FExportOptions.plist\"\n        )\n    else\n        build_ios_app(\n            workspace: \"PSB.xcworkspace\",\n            configuration: scheme,\n            scheme: scheme,\n            silent: true,\n            clean: true,\n            output_directory: \".\u002Fipas\",\n            output_name: \"#{filename}.ipa\",\n            export_method: \"development\",\n            include_bitcode: false\n        )\n    end\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EФункция умеет собирать сборку для публикации в AppStore, для тестировщиков, для общего пользования. Они отличаются кастомными параметрами в ExportOptions. При указании export method: “development” ExportOptions генерируется автоматически. Для production ExportOptions надо описывать вручную. Можно приложить ссылки для production- и development-опций экспорта.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Edef send_to_firebase(ipa_name, scheme)\n    firebase_apps = {\n        \"Dev\" =\u003E \"1:1234567890:ios:0a1b2c3d4e5f67890\",\n        \"PreProd\" =\u003E \"1:0987654321:ios:0a1b2c3d4e5f67890\"\n    }\n    firebase_app_distribution(\n        app: firebase_apps[scheme], # для разных схем разные айди\n        # groups: \"ВСЕМ\",\n        # testers: \"tester@gmail.com\",\n        ipa_path: \".\u002Fipas\u002F#{ipa_name}.ipa\",\n        firebase_cli_path: \"\u002Fusr\u002Flocal\u002Fbin\u002Ffirebase\",\n        firebase_cli_token: \"ваш токен\",\n        debug: true\n    )\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EДальше можно объединить это в один lane или сделать отдельный для каждого действия, чтобы CI мог дёргать эти функции в каком угодно порядке. У нас это разделено.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Edesc \"Собрать проект с указанной схемой. Пример вызова: fastlane archive_project scheme:\\\"Dev\\\" filename:\\\"dev_1.2.3\\\"\"\nlane :archive_project do |options|\n    scheme = options[:scheme]\n    filename = options[:filename]\n    archive_project(scheme, false, filename)\nend\ndesc \"Собрать релизную сборку проекта. Пример вызова: fastlane archive_beta scheme:\\\"Prod\\\" filename:\\\"release_1.2.3\\\"\"\nlane :archive_beta do |options|\n    scheme = options[:scheme]\n    filename = options[:filename]\n    archive_project(scheme, true, filename)\nend\ndesc \"Отправить уже собранный архив ipa в фаербейз с указанным названием файла. Пример вызова: fastlane distribute_to_firebase filename:\\\"dev_1.2.3\\\" scheme:\\\"Dev\\\"\"\nlane :distribute_to_firebase do |options|\n    filename = options[:filename]\n    scheme = options[:scheme]\n    send_to_firebase(filename, scheme)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВсё, что мы написали на Fastlane, нужно проверять с помощью консольных команд. Например, для публикации в Firebase можно выполнить две команды подряд:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Efastlane archive_project scheme:“Dev” filename:“dev_1.2.3”\nfastlane distribute_to_firebase filename:“dev_1.2.3” scheme:“Dev”\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭти же строки можно объединить в одну для удобства, поставив между ними “;”\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Efastlane archive_project scheme:“Dev” filename:“dev_1.2.3”\nfastlane distribute_to_firebase filename:“dev_1.2.3” scheme:“Dev”\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EДля публикации используются git tags. Например, если мы для коммита запушим тег dev_1.72.44.TASK-123, то в Firebase отправится сборка с номером 1.72.44.TASK-123. Сами вызовы с указанием версии идут из gitlab-ci.yml. Если что-то пойдёт не так, джоба зафейлится и разработчику придёт уведомление об этом. Посмотрев на логи джобы, он увидит причину: например, проект удалили или что-то ещё серьёзное случилось. Firebase позволяет публиковать приложения с одинаковой версией.\u003C\u002Fp\u003E\u003Ch3\u003ETestflight deploy для itunesconnect и отправки в AppStore\u003C\u002Fh3\u003E\u003Cp\u003ETestflight — это система обработки сборок от Apple. В ней можно делать сборки для тестировщиков, а также релизить протестированные сборки. По схеме CI\u002FCD она будет на уровне с Firebase, т. к. они взаимозаменяемы, только Firebase более удобен для дистрибуции тестовых сборок. А Testflight мы используем для релиза итоговых сборок для пользователей.\u003C\u002Fp\u003E\u003Cp\u003EFirebase — для теста, потому что удобнее и быстрее. Testflight — для production, потому что релизить можно только через неё.\u003C\u002Fp\u003E\u003Cp\u003EМы загружаем наш артефакт в ItunesConnect, и сама система предоставляет нам возможность отправить его сразу в Testflight. Testflight даёт возможность скачивать приложения, над которыми работаем, прямо на айфон.\u003C\u002Fp\u003E\u003Cp\u003EОсновные этапы публикации в AppStore те же. Нам нужно собрать архив и отправить его, только теперь отправляем в AppStore. Тестировщик скачает Testflight и получит доступ к тому, что мы задеплоили. \u003C\u002Fp\u003E\u003Cp\u003EСледующий этап — изменение версии сборки, чтобы мы могли разные сборки публиковать для тестировщиков. Например, разные команды делают сборки под себя и будут отличать их билд-версиями. Так вот, AppStore не позволит загрузить сборки с одинаковыми версиями, поэтому нужно автоматизировать изменение версии проекта.\u003C\u002Fp\u003E\u003Cp\u003EЕсть небольшой lane для изменения версии и номера билда с помощью Fastlane.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Edesc \"Меняет версию проекта на новую с валидацией самой версии. Допускается версия вида 1.56.45 или 1.34.21(12), где 12 - номер билда. Пример вызова: fastlane update_version version:\\\"1.46.45\\\"\"\nlane :update_version do |options|\n    git_tag_version = options[:version]\n    puts git_tag_version\n    major = \"\"\n    minor = \"\"\n    patch = \"\"\n    build = \"\"\n    errorMsg = \"Wrong version number: \\\"#{git_tag_version}\\\"!\\nPlease use versioning like {major_number}.{minor_number}.{patch_number}({build_number})\\n or {major_number}.{minor_number}.{patch_number}\"\n    patternWithBuild = \u002F\\A(\\d+).(\\d+).(\\d+)\\((\\d+)\\)\\z\u002F\n    pattern = \u002F\\A(\\d+).(\\d+).(\\d+)\\z\u002F\n    if match = patternWithBuild.match(git_tag_version)\n        major, minor, patch, build = match.captures\n    elsif match = pattern.match(git_tag_version)\n        major, minor, patch = match.captures\n    else\n        UI.user_error!(errorMsg)\n    end\n    if major.to_s.empty? || minor.to_s.empty? || patch.to_s.empty?\n        UI.user_error!(errorMsg)\n    end\n    if build.to_s.empty?\n        build = \"1\"\n    end\n    version = \"#{major}.#{minor}.#{patch}\"\n    increment_version_number_in_plist(version_number: \"#{version}\" , target: \"PSB\")\n    increment_version_number_in_plist(version_number: \"#{version}\", target: \"notificationService\")\n    increment_build_number_in_plist(build_number: \"#{build}\", target: \"PSB\")\n    increment_build_number_in_plist(build_number: \"#{build}\", target: \"notificationService\")\nend\ndesc \"Меняет версию проекта на новую без валидации самой версии. Пример вызова: fastlane force_update_version version:\\\"1.46.45_TASK\\\"\"\nlane :force_update_version do |options|\n    git_tag_version = options[:version]\n    puts git_tag_version\n    increment_version_number_in_plist(version_number: \"#{git_tag_version}\" , target: \"PSB\")\n    increment_version_number_in_plist(version_number: \"#{git_tag_version}\", target: \"notificationService\")\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут описаны два lane: один валидирует версию, чтобы она подходила для публикации в AppStore, второй может подставить в версию что угодно (ну или почти что угодно). Первый мы используем только для Testflight, а второй — для Firebase, т. к. Firebase позволяет писать буквы в версию и не придирчив к повторам.\u003C\u002Fp\u003E\u003Cp\u003EЕщё нам понадобится сам lane публикации в AppStore: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Edesc \"Отправить уже собранный архив ipa в Testflight с указанным названием файла. Пример вызова: fastlane distribute_to_testflight itunes_username:\\\"email@gg.ru\\\" filename:\\\"release_1.2.3\\\"\"\nlane :distribute_to_testflight do |options|\n    username = options[:itunes_username]\n    filename = options[:filename]\n    puts \"username #{username} and filename #{filename}\"\n    if username.to_s.empty? \n        UI.user_error!(\"Need to pass ITUNES_USERNAME to testflight lane\")\n    end\n    upload_to_testflight(\n        username: \"#{username}\",\n        ipa: \".\u002Fipas\u002F#{filename}.ipa\",\n        skip_waiting_for_build_processing: true\n    )\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ELane несложный, поэтому тут нечего дополнять, просто передаём нужные параметры в плагин Fastlane. Порядок вызова lane для публикации в AppStore прост:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Efastlane update_version version:“$right_version”\nfastlane archive_beta scheme:${scheme} filename:${filename}\nfastlane distribute_to_testflight\nitunes_username:”${ITUNES_USERNAME}” filename:${filename}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗдесь $right_version — это желательно валидный номер версии. Если он будет невалидным, то lane провалится и на этом путь публикации закончится. ${ITUNES_USERNAME} — это email юзера, от имени которого мы будем публиковать архив в Testflight.\u003C\u002Fp\u003E\u003Ch3\u003E[Gitlab CI].gitlab-ci.yml\u003C\u002Fh3\u003E\u003Cp\u003EТеперь нужно описать правила, по которым у нас будут происходить взаимодействия ивентов в Gitlab и написанных скриптов. И имя ему  —  gitlab-ci.yml. Этот файл задаёт стандарт сборки и проверки приложения.\u003C\u002Fp\u003E\u003Cp\u003EЭто тот самый файл, который запускает все lane, считает нужные параметры, управляет артефактами. Один из его минусов(а может, и плюсов) — скрипты запускаются на bash. Поэтому переиспользование тут не совсем обычное. Об этом расскажу позже, но сначала ознакомимся с простыми примерами файла:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Estages:\n  - test_stage\ntest_job:\n  stage: test_stage\n  tags:\n    - ios_tests\n  script:\n    - echo \"Hello world\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕсли мы запушим в репозиторий файл .gitlab-ci.yml с таким содержимым, то у нас будут на каждый ивент гитлаба создаваться джобы, которые будут запускать скрипт \u003Cem\u003Eecho “Hello world”.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"630\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F30e\u002F3e4\u002F938\u002F30e3e4938de86934395da3522a502ce8.png\" data-width=\"1600\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСам по себе пайплайн прост:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"336\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F192\u002F2cd\u002F53a\u002F1922cd53aa198f1f5ddc209205d91846.png\" data-width=\"766\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EИсполняемый код может находиться в трёх стадиях, они указаны по порядку:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003Ebefore_script\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Escript\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eafter_script\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EЗдесь мы и будем писать вызовы скриптов Fastlane, Swift и что душе угодно.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EЭксперименты с .gitlab-ci.yml\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EПриведу немного примеров из личного опыта, чтобы объяснить, как мы настраиваем пайплайны под свои запросы.\u003C\u002Fp\u003E\u003Cp\u003EПопробуем посмотреть, что будет с \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Fyawillianpsb\u002Fe8f6558d32264dc049fa114cc448070c\"\u003Eтаким файлом CI\u003C\u002Fa\u003E, в котором 5 стадий и 8 джоб, и разберём, как это будет работать.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"367\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff3c\u002Fb0c\u002F6e7\u002Ff3cb0c6e74e81eedaf2d2baf45947027.png\" data-width=\"1600\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EТут есть несколько правил:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EПайплайны (pipeline) состоят из стадий (stage), а они в свою очередь — из джоб (job)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКаждая джоба может состоять только в одной стадии\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКаждая стадия может содержать нескольких джоб, которые запускаются последовательно и параллельно. Значит, если у вас есть несколько раннеров, то \u003Cem\u003Etest_job1\u003C\u002Fem\u003E и \u003Cem\u003Etest_job2\u003C\u002Fem\u003E стартанули бы почти одновременно, не ожидая завершения друг друга\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E Стадии идут только последовательно, каждая перед стартом ожидает завершения всех джоб из предыдущей стадии\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли при выполнении джобы вызвалась команда \u003Cem\u003Eexit\u003C\u002Fem\u003E с ненулевой ошибкой, то джоба фейлится: \u003Cem\u003Eexit 0\u003C\u002Fem\u003E означает, что джоба успешно завершилась; любая другая цифра будет обозначать какую-то ошибку\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли в стадии одна из джоб зафейлилась без флага \u003Cem\u003Eallow_failure: true\u003C\u002Fem\u003E, то следующая стадия не стартует. Для\u003Cem\u003E test_job3\u003C\u002Fem\u003E этот флаг включёен, а для \u003Cem\u003Etest_job5 \u003C\u002Fem\u003Eнет\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли в стадии несколько джоб и одна из них зафейлилась, то другие джобы стадии продолжают выполнение\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ разных джобах можно писать coverage. Например, в джобе 1 мы написали coverage 0%, в джобе 2 получили 10%, и в джобе 4 написали 100%. Тогда общий coverage пайплайна будет считаться как среднее среди всех джоб (0 + 10 + 100) \u002F 3. Это можно использовать, например, для мультимодульности. Создать стадию тестов и на этой стадии — по одной джобе на каждый фреймворк. Но можно сделать, как мы в компании, на уровне Xcode. У нас есть выделенная схема для юнит-тестов всех фреймворков, в которую добавлены все тестовые таргеты. Результатом тестирования этой схемы являются   прогнанные тесты в этих таргетах и средний coverage по ним\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003ECoverage учитывается, даже если джоба зафейлилась\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ джобе 8 выставлен флаг \u003Cem\u003Ewhen: on_failure\u003C\u002Fem\u003E, — это значит, что джоба выполнится только в том случае, если пайплайн зафейлился. В случае если пайплайн прошёл без проблем, эта джоба не запустится. Такой флаг полезно ставить, например, в джобы, которые оповещают о зафейленном пайплайне\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПорядок стадий в пайплайне зависит от их порядка в файле CI в фазе \u003Cem\u003Estages:\u003C\u002Fem\u003E первыми будут выполняться те, что находятся выше по порядку. Джобы — так же: чем выше вы их описали в файле, тем раньше они выполнятся в пайплайне\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EВ файле CI есть подобие наследования — так называемые \u003Cem\u003Eextends:\u003C\u002Fem\u003E. Мы создаем шаблонную джобу, которую будем расширять нужными нам свойствами. \u003C\u002Fp\u003E\u003Cp\u003EВажное замечание: если мы в шаблоне указали какой-то параметр, например \u003Cem\u003Escript\u003C\u002Fem\u003E или \u003Cem\u003Etags\u003C\u002Fem\u003E, а не в джобе, которая расширяет этот шаблон, то если мы в джобе напишем собственный script, то исполнятся будет только тот, что написан в джобе. Переопределение полностью отменяет свойство шаблона. Например, мы хотим в конце каждой джобы выполнять какое-то действие, тогда можем это прописать в \u003Cem\u003Ebefore_script\u003C\u002Fem\u003E шаблона, а в самих джобах исполняемые команды писать в фазу \u003Cem\u003Escript\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cp\u003EА теперь реальный пример того, как мы гоняем тесты и считаем coverage. Рассмотрим \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Fyawillianpsb\u002Ff4cbd38cccabe0d2f4b607735123d893\"\u003E\u003Cstrong\u003E\u003Cem\u003E.gitlab-ci.yml\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E такого вида\u003C\u002Fa\u003E — сверху вниз по каждому пункту.\u003C\u002Fp\u003E\u003Ch4\u003EVariables\u003C\u002Fh4\u003E\u003Cp\u003EВ файле .gitlab-ci.yml есть раздел с переменными, где мы можем задать кастомные свойства для всего файла. Также стоит учитывать, что помимо параметров, которые укажете в самом файле, вам будет доступен целый набор\u003Ca href=\"https:\u002F\u002Fdocs.gitlab.com\u002Fee\u002Fci\u002Fvariables\u002Fpredefined_variables.html\"\u003E Predefined CI\u002FCD variables\u003C\u002Fa\u003E и набор кастомных параметров, указанных в настройках проекта (Settings ⃗⃗→ CI\u002FCD → Variables). Все три категории свойств будут доступны во всех ваших описываемых джобах внутри .gitlab-ci.yml.\u003C\u002Fp\u003E\u003Ch4\u003EStages\u003C\u002Fh4\u003E\u003Cp\u003EЗдесь мы указываем набор стадий для пайплайнов, пока что они просто обозначают, как джобы будут группироваться внутри пайплайнов.\u003C\u002Fp\u003E\u003Ch4\u003EJobs\u003C\u002Fh4\u003E\u003Cp\u003EРасскажу подробнее про структуру джоб:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003Eextends — нужно, чтобы переиспользовать базовые вещи;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Estage — указываем, в какой стадии участвует джоба. Внутри одной стадии они выполняются параллельно;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Ebefore script, script, after script — набор команд Shell в том порядке, в котором исполняются;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eonly\u002Fexcept — описывают, под какие правила попадает \u002F точно не попадает джоба;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Etags — теги, которыми мы пометили раннер, когда регистрировали его;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eallow failure — свойство, которое разрешает \u002F не разрешает зафейленную джобу, здесь можно указывать допустимые exit codes;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eartifacts — будем использовать для хранения артефактов джобы.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch3\u003EКак дебажить\u003C\u002Fh3\u003E\u003Cp\u003EGitlab-runner предоставляет возможность запускать локально ваши джобы для их тестирования перед пушем в репозиторий, что упрощает жизнь. Для этого нужно выполнить команду\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Egitlab-runner exec shell exec shell test_job1\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКоманда выполнялась для \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Fyawillianpsb\u002Fe8f6558d32264dc049fa114cc448070c\"\u003Eтакого gitlab-ci.yml\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"982\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F834\u002F4f5\u002Fb6b\u002F8344f5b6bb13b622da1d7da0c3c24a6b.png\" data-width=\"1364\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EУ такого дебаггинга есть минус:  вам не будут доступны реальные глобальные переменные по типу CI_JOB_ID, CI_PIPELINE_ID, т. к. эти параметры передаются Gitlab на раннер. Но такой дебаггинг вполне сгодится для проверки работоспособности локальных скриптов. Вот ещё пример вывода глобальной переменной\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"954\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F01a\u002Fd02\u002F0e6\u002F01ad020e6067cfdf22b159f8d3fe1011.png\" data-width=\"1980\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Ch3\u003EИтого\u003C\u002Fh3\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EМы научились настраивать Gitlab-runner на машине\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EРазобрались, как работает Fastlane\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EМожем написать lane, которые помогут: протестировать, собрать информацию о code coverage, собрать архив и отправить его в Firebase или Testflight\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EЕщё раз повторим действия в командной строке:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EУстанавливаем gitlab-runner\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Ebrew install gitlab-runner\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EДелаем mac раннером для CI\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Egitlab-runner register\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЗапускаем раннер\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Egitlab-runner install\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Egitlab-runner start\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EУстанавливаем Fastlane\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Ebrew install fastlane\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПапка Fastlane с нужными      файлами\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efastlane init\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПроверим      работоспособность lane\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efastlane unit_test scheme:CoreTests\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EПубликуем в Firebase\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efastlane archive_project scheme:“Dev” filename:“dev_1.2.3”\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efastlane distribute_to_firebase filename:“dev_1.2.3” scheme:“Dev”\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВызов lane для публикации в AppStore\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efastlane update_version version:“$right_version”\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efastlane archive_beta scheme:${scheme} filename:${filename}\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Efastlane distribute_to_testflight\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Eitunes_username:”${ITUNES_USERNAME}” filename:${filename}\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЛокально запустим джобы, чтобы тестировать их перед пушем в репозиторий\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003Egitlab-runner exec shell exec shell test_job1\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EИспользование Gitlab CI + Fastlane + Firebase + Testflight обходится недорого. Можно иметь 2–3 машины и настроить работу.\u003C\u002Fp\u003E\u003Cp\u003EРабота команды выглядит так:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EРазработчик сделал задачу, написал на неё тесты и отправил МР на код-ревью.         \u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВнутри МР CI\u002FCD считает, не слишком ли низкий code coverage, и проверяет, собирается ли проект.                       \u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EОтправив MP на ревью, разработчик ставит тег на последний коммит, например  dev_1.33.22.TASK-123 cicd         .                  \u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EОн готовит сборку и отправляет ее в Firebase.                       \u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EИз Firebase тестировщик скачивает сборку. Проверяет, получает ревью и   нужные апрувы.                  \u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EМы готовы мержить: держим код в master и на ней запускается пайплайн обновления значения code coverage, чтобы уже другие MP не попадали в master с понижением.\u003C\u002Fp\u003E\u003Cp\u003EКак видите, большую часть работы делает за нас Gitlab CI, а нам главное — расставить триггеры в правильных местах и настроить наш процесс сборки.\u003C\u002Fp\u003E\u003Cp\u003EДокументируйте настроенный CI\u002FCD, научите всех пользоваться им, предлагайте идеи по автоматизации процессов и спрашивайте ваших коллег о болях. Возможно, пара скриптов, встроенных в CI\u002FCD, сэкономят деньги для бизнеса или нервы ваших коллег.\u003C\u002Fp\u003E\u003Cp\u003EЗадавайте свои вопросы в комментариях!\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"ios"},{"titleHtml":"ios development"},{"titleHtml":"ios разработка"},{"titleHtml":"ci\u002Fcd"},{"titleHtml":"devops"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F583532\u002F2ed75169a548a9429ec7cbc9e747f158\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F583532\u002F2ed75169a548a9429ec7cbc9e747f158\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpsb\\\u002Fblog\\\u002F583532\\\u002F\"},\"headline\":\"Как мы автоматизируем iOS: настройка Gitlab CI + Fastlane + Firebase + ItunesConnect\",\"datePublished\":\"2021-10-14T18:13:55+03:00\",\"dateModified\":\"2021-10-15T08:38:59+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"WillianLike\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"В основном идея использования CI\\\u002FCD для iOS, да и для других платформ, &mdash; это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручну...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpsb\\\u002Fblog\\\u002F583532\\\u002F#post-content-body\",\"about\":[\"c_psb\",\"h_ios_dev\",\"h_devops\",\"f_develop\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F408\\\u002F357\\\u002Fdb0\\\u002F408357db04280e0758798a35b6ac0265.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F20b\\\u002F0ff\\\u002F9a8\\\u002F20b0ff9a8429638d04fc19b7482bd517.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd1a\\\u002Fe45\\\u002Fbad\\\u002Fd1ae45bad3d492c117fc14dbf6b76aa3.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd26\\\u002Fb9a\\\u002F1e3\\\u002Fd26b9a1e31bef741bba73a25d53bca4f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F6f0\\\u002F0c3\\\u002F19d\\\u002F6f00c319d53ca464cd12edc84e2dbc14.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F9ef\\\u002F9b8\\\u002F5f4\\\u002F9ef9b85f457b9b4e74e580b928ef7d04.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F30e\\\u002F3e4\\\u002F938\\\u002F30e3e4938de86934395da3522a502ce8.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F192\\\u002F2cd\\\u002F53a\\\u002F1922cd53aa198f1f5ddc209205d91846.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ff3c\\\u002Fb0c\\\u002F6e7\\\u002Ff3cb0c6e74e81eedaf2d2baf45947027.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F834\\\u002F4f5\\\u002Fb6b\\\u002F8344f5b6bb13b622da1d7da0c3c24a6b.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F01a\\\u002Fd02\\\u002F0e6\\\u002F01ad020e6067cfdf22b159f8d3fe1011.png\"]}","metaDescription":"В основном идея использования CI\u002FCD для iOS, да и для других платформ, — это автоматизация рутинной работы. Когда мы работаем над одним приложением, можем вручную собирать небольшой проект. Но команда...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"psb":{"alias":"psb","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002Fe13\u002F03f\u002F9c3\u002Fe1303f9c36fc6bdde8117b4b67c9cc54.jpg","titleHtml":"ПСБ","descriptionHtml":null,"relatedData":null,"statistics":{"postsCount":34,"newsCount":0,"vacanciesCount":88,"employeesCount":17,"careerRating":null,"subscribersCount":90,"rating":81.19,"invest":null},"foundationDate":{"year":"1995","month":"05","day":"12"},"location":{"city":{"id":"447159","title":"Москва"},"region":{"id":"1885","title":"Москва и Московская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"https:\u002F\u002Fwww.psbank.ru","staffNumber":"5 001–10 000 человек","registrationDate":"2017-11-27T10:48:13+00:00","representativeUser":{"alias":"chuvash","fullname":"Ларионов Владимир"},"contacts":[{"title":"Сайт","url":"https:\u002F\u002Fwww.psbank.ru"}],"settings":{"analyticsSettings":[],"branding":null,"status":"active"},"metadata":{"titleHtml":"ПСБ, Москва -  с 12 мая 1995 г.","title":"ПСБ, Москва -  с 12 мая 1995 г.","keywords":["Программирование","Администрирование баз данных","Карьера в IT-индустрии","Разработка под iOS","DevOps"],"descriptionHtml":"34 статьи от авторов компании ПСБ","description":"34 статьи от авторов компании ПСБ"},"aDeskSettings":null,"careerAlias":"psb","maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
