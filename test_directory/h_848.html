<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>React: простое и эффективное решение для управления состоянием приложений / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/timeweb\/blog\/582320\/"},"headline":"React: простое и эффективное решение для управления состоянием приложений","datePublished":"2021-10-08T09:08:13+03:00","dateModified":"2021-10-08T09:08:13+03:00","author":{"@type":"Person","name":"Igor Agapov"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Привет, друзья! В этом небольшом &quot;туториале&quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений. Н...","url":"https:\/\/habr.com\/ru\/company\/timeweb\/blog\/582320\/#post-content-body","about":["c_timeweb","h_webdev","h_javascript","h_programming","h_reactjs","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/582320\/2182e9d4ddd1f43cdac976bdcf6c60ad\/","https:\/\/habrastorage.org\/webt\/4q\/dj\/sj\/4qdjsje-cdcxxlo7dj9n2thrvke.png","https:\/\/habrastorage.org\/webt\/gz\/_o\/yx\/gz_oyx9xhm_7wvpydh1uk1wc3wy.jpeg","https:\/\/habrastorage.org\/webt\/wn\/cq\/lp\/wncqlp9abeml4npwzsybuvhzcta.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="React: простое и эффективное решение для управления состоянием приложений" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="React: простое и эффективное решение для управления состоянием приложений" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="React: простое и эффективное решение для управления состоянием приложений" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Привет, друзья!
В этом небольшом &amp;quot;туториале&amp;quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений.
Немного забегая вперед,..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Привет, друзья!
В этом небольшом &amp;quot;туториале&amp;quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений.
Немного забегая вперед,..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Привет, друзья!
В этом небольшом &amp;quot;туториале&amp;quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений.
Немного забегая вперед,..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Привет, друзья!
В этом небольшом &amp;quot;туториале&amp;quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений.
Немного забегая вперед,..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Привет, друзья!
В этом небольшом &amp;quot;туториале&amp;quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений.
Немного забегая вперед,..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/webt/4q/dj/sj/4qdjsje-cdcxxlo7dj9n2thrvke.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/webt/4q/dj/sj/4qdjsje-cdcxxlo7dj9n2thrvke.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/webt/4q/dj/sj/4qdjsje-cdcxxlo7dj9n2thrvke.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/webt/4q/dj/sj/4qdjsje-cdcxxlo7dj9n2thrvke.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/webt/4q/dj/sj/4qdjsje-cdcxxlo7dj9n2thrvke.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="582320" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-08T06:08:13.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/582320/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/timeweb/blog/582320/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/webt/4q/dj/sj/4qdjsje-cdcxxlo7dj9n2thrvke.png" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="timeweb" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/timeweb/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/b5b/7e1/c48/b5b7e1c4819388606f1a3c7ed1d2373a.jpg" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">1167.97</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/timeweb/profile/" class="tm-company-card__name">
        Timeweb
      </a> <div class="tm-company-card__description">Хостинг, VDS и ИТ-инфраструктура</div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/aio350/" title="aio350" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/076/1e1/2c6/0761e12c6ea091cb6170c185394fae64.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/aio350/" class="tm-user-info__username">
      aio350
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-08T06:08:13.000Z" title="2021-10-08, 09:08">8  октября   в 09:08</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>React: простое и эффективное решение для управления состоянием приложений</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/timeweb/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании Timeweb</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/webdev/" class="tm-article-snippet__hubs-item-link"><span>Разработка веб-сайтов</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/javascript/" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/reactjs/" class="tm-article-snippet__hubs-item-link"><span>ReactJS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/4q/dj/sj/4qdjsje-cdcxxlo7dj9n2thrvke.png"/><br/>
<p><br/>
Привет, друзья!</p><br/>
<p>В этом небольшом "туториале" я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием <code>React-приложений</code>.</p><br/>
<p>Немного забегая вперед, скажу, что решение получилось чуть менее производительным, чем "классическое" сочетание хука <code>useReducer()</code> и инструментов, предоставляемых <code>Context API</code> (которые, собственно, и составляют ядро решения).</p><br/>
<p>Решение представляет собой результат нескольких экспериментов, направленных на максимальное упрощение работы с контекстом <code>React</code>, и во многом вдохновлено <a href="https://vuex.vuejs.org/ru/guide/"><code>Vuex</code></a> — официальным инструментом для управления состоянием <code>Vue-приложений</code>.</p><br/>
<p>Решение не является законченным и находится в стадии активной разработки, поэтому приветствуются любые замечания и предложения, любая конструктивная критика.</p><br/>
<p>Пока мне не представилось возможности испытать решение в "полевых условиях" (я намерен сделать это при первом удобном случае), но кажется, что оно подойдет для разработки приложений любой сложности при соблюдении двух важных условий:</p><a name="habracut"></a><br/>
<ol>
<li>В хранилище (<code>store</code>) должно храниться только глобальное состояние. Я не буду утомлять вас рассуждениями на тему "Что такое состояние приложения? Какое состояние является локальным, а какое глобальным?" и т.д. Лично я исхожу из предположения, что любое состояние является локальным, пока не доказано обратное, т.е. пока не возникнет необходимости в его распределении между автономными компонентами.</li>
<li>Провайдер контекста должен размещаться максимально близко к компонентам, потребляющим контекст. Это называется коллокацией (collocation) или размещением совместного состояния. Логика принятия решения о том, каким является состояние и где его размещать выглядит примерно так:</li>
</ol><br/>
<img src="https://habrastorage.org/r/w780q1/webt/gz/_o/yx/gz_oyx9xhm_7wvpydh1uk1wc3wy.jpeg" data-src="https://habrastorage.org/webt/gz/_o/yx/gz_oyx9xhm_7wvpydh1uk1wc3wy.jpeg" data-blurred="true"/><br/>
<p><br/>
Исходный код проекта находится <a href="https://github.com/harryheman/react-simple-context">здесь</a>.</p><br/>
<p>Песочница:</p><br/>
<div class="oembed"><div class="tm-iframe_temp" data-src="https://embedd.srv.habr.com/iframe/615fdf7fedd610f626b80cb1" data-style="" id="615fdf7fedd610f626b80cb1" width=""></div></div><br/>
<p><em>Обратите внимание</em>: статья рассчитана на разработчиков, который имеют некоторый опыт работы с <code>React</code>, уставших от <code>Redux</code> и иже с ним 😃</p><br/>
<h2 id="rezultat">Результат</h2><br/>
<p>Давайте начнем с того, что мы хотим получить на выходе. И почему не воспользоваться готовыми решениями? Другими словами, зачем нам изобретать велосипед, когда, казалось бы, все давно придумано умными людьми?</p><br/>
<p>Объясню простыми… кодом. Предположим, что мы хотим разработать "тудушку" со следующим функционалом:</p><br/>
<ul>
<li>получение задач от сервера — асинхронная операция;</li>
<li>добавление в список новой задачи — синхронная;</li>
<li>обновление задачи: ее текста, состояния завершенности и состояния редактирования — синхронные;</li>
<li>удаление задачи из списка — синхронная;</li>
<li>фильтрация задач в списке: отображение всех, только завершенных или только активных задач — синхронная;</li>
<li>завершение всех активных задач — синхронная;</li>
<li>удаление всех завершенных задач — синхронная;</li>
<li>сохранение задач на сервере (в базе данных) — асинхронная;</li>
<li>отображение статистики: общее количество, количество завершенных и количество активных задач, а также процент активных задач — синхронная;</li>
<li>получение сообщений: о загрузке задач с сервера, сохранении задач в БД или возникшей ошибке — асинхронная.</li>
</ul><br/>
<p>Если реализовать этот функционал, следуя всем канонам современного <a href="https://redux.js.org/"><code>Redux</code></a> в лице <a href="https://redux-toolkit.js.org/"><code>Redux Toolkit</code></a>, то код хранилища получится следующим:</p><br/>
<pre><code class="javascript">import {
 configureStore,
 createAsyncThunk,
 createEntityAdapter,
 createSelector,
 createSlice
} from '@reduxjs/toolkit'
// Утилита для выполнения HTTP-запросов
import axios from 'axios'

// Адрес сервера
const SERVER_URL = 'http://localhost:5000/todos'

// Так называемый адаптер сущностей (entity adapter) (для задач)
const todoAdapter = createEntityAdapter()

// Начальное состояние (для задач)
const initialTodoState = todoAdapter.getInitialState({
 // статус приложения
 status: 'idle',
 // статус сообщения
 message: {}
})

// Так называемый преобразователь (thunk) -
// асинхронная операция для получения задач от сервера
export const fetchTodos = createAsyncThunk('todos/fetchTodos', async () => {
 try {
   // получаем данные
   const { data: todos } = await axios(SERVER_URL)
   // возвращаем задачи и сообщение об успехе
   return {
     todos,
     message: { type: 'success', text: 'Todos loaded' }
   }
 } catch (err) {
   console.error(err.toJSON())
   // возвращаем сообщение об ошибке
   return {
     message: { type: 'error', text: 'Something went wrong' }
   }
 }
})

// Асинхронная операция для сохранения задач в БД
export const saveTodos = createAsyncThunk(
 'todos/saveTodos',
 async (newTodos) => {
   try {
     // получаем существующие задачи
     const { data: existingTodos } = await axios(SERVER_URL)

     // перебираем их
     for (const todo of existingTodos) {
       // формируем `URL` текущей задачи
       const todoUrl = `${SERVER_URL}/${todo.id}`

       // определяем, имеется ли существующая задача среди новых
       const commonTodo = newTodos.find((_todo) => _todo.id === todo.id)

       // если имеется
       if (commonTodo) {
         // определяем наличие изменений
         if (
           !Object.entries(commonTodo).every(
             ([key, value]) => value === todo[key]
           )
         ) {
           // если изменения есть, обновляем задачу на сервере,
           await axios.put(todoUrl, commonTodo)
         }
       } else {
         // если не имеется
         // удаляем задачу на сервере
         await axios.delete(todoUrl)
       }
     }

     // теперь перебираем новые задачи и сравниваем их с существующими
     for (const todo of newTodos) {
       // если новой задачи нет среди существующих
       // значит, она действительно новая
       if (!existingTodos.find((_todo) => _todo.id === todo.id)) {
         // сохраняем ее в БД
         await axios.post(SERVER_URL, todo)
       }
     }
     // возвращаем сообщение об успехе
     return { type: 'success', text: 'Todos saved' }
   } catch (err) {
     console.error(err.toJSON())
     // возвращаем сообщение об ошибке
     return {
       type: 'error',
       text: 'Something went wrong'
     }
   }
 }
)

// Асинхронная операция для выполнения искусственной задержки -
// она нужна для отображения сообщения в течение указанного времени
export const giveMeSomeTime = createAsyncThunk(
 'todos/giveMeSomeTime',
 async (ms) =>
   await new Promise((resolve) => {
     const timerId = setTimeout(() => {
       resolve()
       clearTimeout(timerId)
     }, ms)
   })
)

// Так называемая часть или срез состояния (для задач)
const todoSlice = createSlice({
 // название
 name: 'todos',
 // начальное состояние в виде нормализованной структуры
 initialState: initialTodoState,
 // обычные редукторы
 reducers: {
   // для добавления задачи
   addTodo: todoAdapter.addOne,
   // для обновления задачи
   updateTodo: todoAdapter.updateOne,
   // для удаления задачи
   removeTodo: todoAdapter.removeOne,
   // для завершения всех активных задач
   completeAllTodos(state) {
     Object.values(state.entities).forEach((todo) => {
       todo.done = true
     })
   },
   // для удаления всех завершенных задач
   clearCompletedTodos(state) {
     const completedTodoIds = Object.values(state.entities)
       .filter((todo) => todo.done)
       .map((todo) => todo.id)
     todoAdapter.removeMany(state, completedTodoIds)
   }
 },
 // дополнительные редукторы для обработки результатов асинхронных операций
 extraReducers: (builder) => {
   builder
     // запрос на получение задач от сервера находится в процессе выполнения
     .addCase(fetchTodos.pending, (state) => {
       // обновляем индикатор загрузки
       state.status = 'loading'
     })
     // запрос выполнен
     .addCase(fetchTodos.fulfilled, (state, { payload }) => {
       if (payload.todos) {
         // обновляем состояние задач
         todoAdapter.setAll(state, payload.todos)
       }
       // записываем сообщение
       state.message = payload.message
       // обновляем индикатор загрузки
       state.status = 'idle'
     })
     // запрос на сохранение задач в БД находится в процессе выполнения
     .addCase(saveTodos.pending, (state) => {
       // обновляем индикатор загрузки
       state.status = 'loading'
     })
     // запрос выполнен
     .addCase(saveTodos.fulfilled, (state, { payload }) => {
       // записываем сообщение
       state.message = payload
       // обновляем индикатор загрузки
       state.status = 'idle'
     })
     // запрос на выполнение задержки выполнен
     .addCase(giveMeSomeTime.fulfilled, (state) => {
       // очищаем сообщение
       state.message = {}
     })
 }
})

// Операции для работы с задачами
export const {
 addTodo,
 updateTodo,
 removeTodo,
 completeAllTodos,
 clearCompletedTodos
} = todoSlice.actions

// Начальное состояние (для фильтра)
const initialFilterState = {
 status: 'all'
}

// Часть состояния (для фильтра)
const filterSlice = createSlice({
 // название
 name: 'filter',
 // начальное состояние
 initialState: initialFilterState,
 // обычные редукторы
 reducers: {
   // для установки значения фильтра
   setFilter(state, action) {
     state.status = action.payload
   }
 }
})

// Операция для установки значения фильтра
export const { setFilter } = filterSlice.actions

// Так называемые селекторы для выборки всех задач и их общего количества
export const { selectAll, selectTotal } = todoAdapter.getSelectors(
 (state) => state.todos
)

// Селектор для выборки задач на основе текущего состояния фильтра
export const selectFilteredTodos = createSelector(
 selectAll,
 (state) => state.filter,
 (todos, filter) => {
   const { status } = filter
   if (status === 'all') return todos
   return status === 'active'
     ? todos.filter((todo) => !todo.done)
     : todos.filter((todo) => todo.done)
 }
)

// Селектор для выборки статистики
export const selectTodoStats = createSelector(
 selectAll,
 selectTotal,
 (todos, total) => {
   const completed = todos.filter((todo) => todo.done).length
   const active = total - completed
   const percent = total === 0 ? 0 : Math.round((active / total) * 100)

   return {
     total,
     completed,
     active,
     percent
   }
 }
)

// Хранилище
export const store = configureStore({
 reducer: {
   todos: todoSlice.reducer,
   filter: filterSlice.reducer
 }
})</code></pre><br/>
<p>Слишком много кода, но очень мало смысла. И это продвинутый <code>Redux</code>! На работе вам, скорее всего, приходится (или еще придется) возиться со старым-добрым "магическим" <code>Redux</code> (и классовыми компонентами, будь они неладны).</p><br/>
<p>Если переписать функционал тудушки, используя сочетание <code>useReducer()</code> и <code>Context API</code> (а также парочки "хаков"), код получится примерно таким:</p><br/>
<pre><code class="javascript">import { createContext, useContext, useReducer, useMemo } from 'react'
import axios from 'axios'

const SERVER_URL = 'http://localhost:5000/todos'

// Константы
const SET_TODOS = 'SET_TODOS'
const SET_STATUS = 'SET_STATUS'
const ADD_TODO = 'ADD_TODO'
const UPDATE_TODO = 'UPDATE_TODO'
const REMOVE_TODO = 'REMOVE_TODO'
const COMPLETE_TODOS = 'COMPLETE_TODOS'
const CLEAR_COMPLETED = 'CLEAR_COMPLETED'
const SET_FILTER = 'SET_FILTER'
const SET_MESSAGE = 'SET_MESSAGE'

// Редуктор
const reducer = (state, { type, payload }) => {
 switch (type) {
   case SET_TODOS:
     return {
       ...state,
       todos: payload
     }
   case SET_STATUS:
     return {
       ...state,
       status: payload
     }
   case ADD_TODO:
     return { ...state, todos: state.todos.concat(payload) }
   case UPDATE_TODO:
     return {
       ...state,
       todos: state.todos.map((todo) =>
         todo.id === payload.id ? { ...todo, ...payload.changes } : todo
       )
     }
   case REMOVE_TODO:
     return {
       ...state,
       todos: state.todos.filter((todo) => todo.id !== payload)
     }
   case COMPLETE_TODOS:
     return { ...state, todos: state.todos.map((todo) => todo.done === true) }
   case CLEAR_COMPLETED:
     return {
       ...state,
       todos: state.todos.filter((todo) => todo.done === true)
     }
   case SET_FILTER:
     return {
       ...state,
       filter: payload
     }
   case SET_MESSAGE:
     return {
       ...state,
       message: payload
     }
   default:
     return state
 }
}

// Задержка
const giveMeSomeTime = async () =>
 await new Promise((resolve) => {
   const timerId = setTimeout(() => {
     resolve()
     clearTimeout(timerId)
   }, 2000)
 })

// Так называемый создатель операций (хак номер раз)
const createActions = (dispatch) => ({
 setTodos: (todos) => ({
   type: SET_TODOS,
   payload: todos
 }),
 setStatus: (status) => ({
   type: SET_STATUS,
   payload: status
 }),
 addTodo: (todo) => ({
   type: ADD_TODO,
   payload: todo
 }),
 updateTodo: (payload) => ({
   type: UPDATE_TODO,
   payload
 }),
 removeTodo: (todoId) => ({
   type: REMOVE_TODO,
   payload: todoId
 }),
 completeTodos: () => ({
   type: COMPLETE_TODOS
 }),
 clearCompleted: () => ({
   type: COMPLETE_TODOS
 }),
 setFilter: (filter) => ({
   type: SET_FILTER,
   payload: filter
 }),
 setMessage: (message) => ({
   type: SET_MESSAGE,
   payload: message
 }),
 async fetchTodos() {
   dispatch(this.setStatus('loading'))

   try {
     const { data: todos } = await axios(SERVER_URL)

     dispatch(this.setTodos(todos))

     dispatch(
       this.setMessage({ type: 'success', text: 'Todos loaded' })
     )
   } catch (err) {
     console.error(err.toJSON())

     dispatch(
       this.setMessage({
         type: 'error',
         text: 'Something went wrong'
       })
     )
   } finally {
     dispatch(this.setStatus('idle'))

     await giveMeSomeTime()

     dispatch(this.setMessage({}))
   }
 },
 async saveTodos(newTodos) {
   dispatch(this.setStatus('loading'))

   try {
     const { data: existingTodos } = await axios(SERVER_URL)

     for (const todo of existingTodos) {
       const todoUrl = `${SERVER_URL}/${todo.id}`

       const commonTodo = newTodos.find((_todo) => _todo.id === todo.id)

       if (commonTodo) {
         if (
           !Object.entries(commonTodo).every(
             ([key, value]) => value === todo[key]
           )
         ) {
           await axios.put(todoUrl, commonTodo)
         }
       } else {
         await axios.delete(todoUrl)
       }
     }

     for (const todo of newTodos) {
       if (!existingTodos.find((_todo) => _todo.id === todo.id)) {
         await axios.post(SERVER_URL, todo)
       }
     }

     dispatch(
       this.setMessage({ type: 'success', text: 'Todos saved' })
     )
   } catch (err) {
     console.error(err.toJSON())

     dispatch(
       this.setMessage({
         type: 'error',
         text: 'Something went wrong'
       })
     )
   } finally {
     dispatch(this.setStatus('idle'))

     await giveMeSomeTime()

     dispatch(this.setMessage({}))
   }
 }
})

// Так называемый создатель селекторов (хак номер два)
const createSelectors = (state) => ({
 selectFilteredTodos() {
   const { todos, filter } = state
   if (filter === 'all') return todos
   return filter === 'active'
     ? todos.filter((todo) => !todo.done)
     : todos.filter((todo) => todo.done)
 },
 selectTodoStats() {
   const { todos } = state
   const { length } = todos

   const completed = todos.filter((todo) => todo.done).length
   const active = length - completed
   const percent = length === 0 ? 0 : Math.round((active / length) * 100)

   return {
     total: length,
     completed,
     active,
     percent
   }
 }
})

// Начальное состояние
const initialState = {
 todos: [],
 status: 'idle',
 filter: 'all',
 message: {}
}

// Контекcт
const Context = createContext()

// Провайдер контекста
export const Provider = ({ children }) => {
 const [state, dispatch] = useReducer(reducer, initialState)

 // Небольшая оптимизация, возможно, преждевременная
 // это зависит от размера и сложности приложения
 // и может быть определено только опытным путем
 const actions = useMemo(() => createActions(dispatch), [])
 const selectors = createSelectors(state)

 return (
   &lt;Context.Provider value={{ state, dispatch, actions, selectors }}>
     {children}
   &lt;/Context.Provider>
 )
}

// Хук для потребления контекста
export const useAppContext = () => useContext(Context)</code></pre><br/>
<p>Намного лучше как с точки зрения читаемости кода, так и, что особенно важно, с точки зрения производительности. Но константы! В принципе, без них можно обойтись. Но редуктор! Кажется, что без редуктора обойтись нельзя. Или все-таки можно? Вполне. А что насчет диспетчера? Можно ли обойтись без него? Нет, без диспетчера обойтись не получится, потому что управлять состоянием <code>React-приложения</code> можно только через него. Но его, как мы увидим дальше, совсем не обязательно использовать в явном виде.</p><br/>
<p>Если переписать функционал тудушки с помощью решения, которое мы еще не рассматривали, но скоро рассмотрим, то код хранилища получится следующим:</p><br/>
<pre><code class="javascript">import axios from 'axios'
axios.defaults.baseURL = 'http://localhost:5000/todos'

const sleep = (ms) =>
 new Promise((resolve) => {
   const timerId = setTimeout(() => {
     resolve()
     clearTimeout(timerId)
   }, ms)
 })

const store = {
 state: {
   todos: [],
   status: 'idle',
   filter: 'all',
   message: {}
 },
 setters: {
   setStatus: (_, status) => ({ status }),
   setMessage: (_, message) => ({ message }),
   setTodos: (_, newTodos) => ({ todos: newTodos }),
   addTodo: ({ todos }, newTodo) => ({ todos: todos.concat(newTodo) }),
   updateTodo: ({ todos }, { id, changes }) => ({
     todos: todos.map((todo) =>
       todo.id === id
         ? {
             ...todo,
             ...changes
           }
         : todo
     )
   }),
   removeTodo: ({ todos }, todoId) => {
     return {
       todos: todos.filter((todo) => todo.id !== todoId)
     }
   },
   completeTodos: ({ todos }) => ({
     todos: todos.map((todo) => ({ ...todo, done: true }))
   }),
   clearCompleted: ({ todos }) => ({ todos: todos.filter((todo) => !todo.done) }),
   setFilter: (_, filter) => ({ filter })
 },
 getters: {
   getFilteredTodos: ({ todos, filter }) => {
     if (filter === 'all') return todos
     return filter === 'active'
       ? todos.filter((todo) => !todo.done)
       : todos.filter((todo) => todo.done)
   },
   getTodoStats: ({ todos }) => {
     const { length } = todos

     const completed = todos.filter((todo) => todo.done).length
     const active = length - completed
     const percent = length === 0 ? 0 : Math.round((active / length) * 100)

     return {
       total: length,
       completed,
       active,
       percent
     }
 },
 actions: {
   async fetchTodos({ setStatus, setTodos, setMessage }) {
     setStatus('loading')

     try {
       const { data } = await axios()
       setTodos(data)
       setMessage({
         type: 'success',
         text: 'Todos received'
       })
     } catch (err) {
       console.error(err.toJSON())
       setMessage({
         type: 'error',
         text: 'Something went wrong'
       })
     } finally {
       setStatus('idle')
       await sleep(1000)
       setMessage({})
     }
   },
   async saveTodos({ setStatus, setMessage }, newTodos) {
     setStatus('loading')
     try {
       const { data: existingTodos } = await axios()

       for (const todo of existingTodos) {
         const commonTodo = newTodos.find((_todo) => _todo.id === todo.id)

         if (commonTodo) {
           if (
             !Object.entries(commonTodo).every(
               ([key, value]) => value === todo[key]
             )
           ) {
             await axios.put(todo.id, commonTodo)
           }
         } else {
           await axios.delete(todo.id)
         }
       }

       for (const todo of newTodos) {
         if (!existingTodos.find((_todo) => _todo.id === todo.id)) {
           await axios.post('/', todo)
         }
       }

       setMessage({ type: 'success', text: 'Todos saved' })
     } catch (err) {
       console.error(err.toJSON())
       setMessage({
         type: 'error',
         text: 'Something went wrong'
       })
     } finally {
       setStatus('idle')
       await sleep(1000)
       setMessage({})
     }
   }
 }
}</code></pre><br/>
<p>Если "разнести" сеттеры, геттеры и экшены по отдельным файлам, то код хранилища получится таким:</p><br/>
<pre><code class="javascript">import { unpackModule } from './context'
import * as setters from './setters'
import * as getters from './getters'
import * as actions from './actions'

const store = {
 state: {
   todos: [],
   status: 'idle',
   filter: 'all',
   message: {}
 },
 setters: unpackModule(setters),
 getters: unpackModule(getters),
 actions: unpackModule(actions)
}</code></pre><br/>
<p>То, что доктор прописал. Теперь давайте обо всем по порядку.</p><br/>
<h2 id="koncepciya">Концепция</h2><br/>
<p>Давайте рассуждать вслух.</p><br/>
<p>Для хранения состояния и операций для работы с ним нам требуется некая гибкая и легко изменяемая структура. В <code>JavaScript</code> нет более подходящей структуры, чем объект. Назовем этот объект хранилищем — <code>store</code>.</p><br/>
<p>Структура хранилища по возможности должна оставаться плоской, т.е. одноуровневой: это сильно упростит логику обновления состояния.</p><br/>
<p>Далее, нам нужны операции для изменения состояния. Состояние может меняться синхронно и асинхронно, поэтому имеет смысл дифференцировать операции соответствующим образом. Назовем синхронные операции сеттерами (<code>setters</code>), а асинхронные — экшенами (<code>actions</code>).</p><br/>
<p>Какую сигнатуру должны иметь сеттеры и экшены?</p><br/>
<p>Очевидно, что сеттеры должны принимать какие-то параметры и иметь <em>прямой</em> доступ к состоянию для его изменения. Возвращать сеттеры должны модифицированное состояние в виде части глобального состояния, т.е. объект с ключом, соответствующим определенной части глобального состояния. Я пока не нашел более простого способа для корректной идентификации части модифицируемого сеттером состояния. Схематично это можно представить следующим образом:</p><br/>
<pre><code class="javascript">setSomething: (state, args) => ({ stateSlice: newState })
// или
setSomething(state, args) {
 return {
   stateSlice: newState
 }
}
// мне больше нравится первый вариант</code></pre><br/>
<p>Или, когда сеттер не использует состояние:</p><br/>
<pre><code class="javascript">setSomething: (_, args) => ({ stateSlice: newState })</code></pre><br/>
<p>Или, когда название аргумента совпадает с названием части глобального состояния (ключом объекта состояния):</p><br/>
<pre><code class="javascript">setSomething: (_, arg) => ({ arg })</code></pre><br/>
<p><em>Обратите внимание</em>:</p><br/>
<ul>
<li>первым параметром, принимаемым сеттером, всегда является состояние</li>
<li>сеттеру может передаваться любое количество аргументов</li>
<li>сеттер всегда должен возвращать объект определенной формы (о которой говорилось выше)</li>
</ul><br/>
<p>Экшены также могут принимать любое количество параметров, но не имеют прямого доступа к состоянию. Доступ экшенов к состоянию опосредован сеттерами, т.е. экшены меняют состояние только через сеттеры. Экшены не должны ничего возвращать. Сигнатура:</p><br/>
<pre><code class="javascript">async fetchSomething(setters, args) {
 const result = await fetchSomething(args)
 setters.setSomething(result)
}</code></pre><br/>
<p>Наконец, нам нужны операции для извлечения части состояния или вычисления производных данных. Назовем эти операции геттерами — <code>getters</code>.</p><br/>
<p>Геттеры могут принимать любое количество параметров и имеют <em>прямой</em> доступ к состоянию. Поскольку цель геттеров — даже не столько извлечение части состояния (потому что мы можем делать это напрямую из состояния, содержащегося в контексте), сколько вычисление производных данных, имеет смысл передавать геттерам состояние в распакованном виде, т.е. в виде отдельных частей. Также, поскольку геттеры могут использоваться для производства сложных вычислений, имеет смысл передавать им другие геттеры (<code>DRY</code>). Возвращать геттеры должны часть состояния или производные данные. Сигнатура:</p><br/>
<pre><code class="javascript">getSomething: ({ stateSlice1, stateSlice2, ...stateSliceN, getters }) => stateSice | derivedData</code></pre><br/>
<p><em>Обратите внимание</em>: геттеры не должны модифицировать состояние.</p><br/>
<p>Теперь поговорим о том, как добиться правильной сигнатуры операций.</p><br/>
<h2 id="realizaciya">Реализация</h2><br/>
<p>После определения, хранилище передается в функцию <code>createSimpleContext()</code>, которая возвращает массив с двумя элементами: провайдером контекста и хуком для его потребления:</p><br/>
<pre><code class="javascript">const store = {
 state: {
   todos: [],
   status: 'idle',
   filter: 'all',
   message: {}
 },
 setters: unpackModule(setters),
 getters: unpackModule(getters),
 actions: unpackModule(actions)
}

export const [SimpleProvider, useSimpleContext] = createSimpleContext(store)</code></pre><br/>
<p><em>Ремарка</em>: функция <code>unpackModule()</code> — это простая утилита для преобразования модуля в объект, которая выглядит так:</p><br/>
<pre><code class="javascript">export const unpackModule = (module) => {
 const obj = {}
 for (const key in module) {
   for (const _key in module[key]) {
     obj[_key] = module[key][_key]
   }
 }
 return obj
}</code></pre><br/>
<p>Если сеттеры, например, импортируются как обычный объект, то у нас нет необходимости прибегать к помощи <code>unpackModule()</code>:</p><br/>
<pre><code class="javascript">import { setters } from './setters'
import { getters } from './getters'
import { actions } from './actions'

const store = {
 state: {
   todos: [],
   status: 'idle',
   filter: 'all',
   message: {}
 },
 setters,
 getters,
 actions
}</code></pre><br/>
<p>Если мы импортируем сеттеры по отдельности, их необходимо распаковать:</p><br/>
<pre><code class="javascript">import { appSetters, todoSetters, filterSetters } from './setters'
import { getters } from './getters'
import { actions } from './actions'

const store = {
 state: {
   todos: [],
   status: 'idle',
   filter: 'all',
   message: {}
 },
 setters: {
   ...appSetters,
   ...todoSetters,
   ...filterSetters
 },
 getters,
 actions
}</code></pre><br/>
<p>Что происходит в <code>createSimpleContext()</code>? Вот как выглядит ее код:</p><br/>
<pre><code class="javascript">import { createContext, useContext, useState, useMemo } from 'react'
import {
 createSetters,
 createGetters,
 createActions,
 unpackModule
} from './utils'

// Функция принимает хранилище
export default function createSimpleContext(store) {
 // Создаем контекст
 const SimpleContext = createContext()

 // Создаем провайдер
 // Функция принимает дочерние компоненты
 const SimpleProvider = ({ children }) => {
   const [simpleState, setSimpleState] = useState(store.state)

   // мемоизация вычисления сеттеров и экшенов
   // является безопасной, поскольку они являются иммутабельными
   // здесь у вас может возникнуть вопрос о том, как сеттер получает свежее состояние
   // обратите внимание на то, что передается в функцию `createSetters()` в качестве второго аргумента
   const setters = useMemo(
     () => createSetters(store.setters, setSimpleState),
     // eslint-disable-next-line
     []
   )
   const actions = useMemo(
     () => createActions(store.actions, setters),
     // eslint-disable-next-line
     []
   )
   // я пока не придумал способа мемоизировать вычисление геттеров с сохранением возможности получения ими всегда акутального состояния
   const getters = createGetters(store.getters, simpleState)

   return (
     // Мы вполне можем управлять состоянием напрямую через `simpleState` и `setSimpleState()`,
     // но лучше этого не делать во избежание путаницы между глобальными и локальными операциями.
     // Этим же объясняется то, что сеттеры, геттеры и экшены лучше не распаковывать
     // при передаче в контекст: мы видим, например, `setters.setTodos()` и сразу понимаем,
     // что имеем дело с глобальным состоянием
     &lt;SimpleContext.Provider
       value={{
         simpleState,
         setSimpleState,
         setters,
         getters,
         actions
       }}
     >
       {children}
     &lt;/SimpleContext.Provider>
   )
 }

 // Хук для потребления контекста
 const useSimpleContext = () => useContext(SimpleContext)

 return [SimpleProvider, useSimpleContext]
}

export { unpackModule }</code></pre><br/>
<p>Самой простой функцией из числа утилит для преобразования операций является <code>createActions()</code>. С нее и начнем:</p><br/>
<pre><code class="javascript">// Функция принимает экшены и сеттеры
export const createActions = (_actions, setters) => {
 const actions = {}
 // Просто передаем каждому экшену сеттеры в качестве первого аргумента.
 // Полагаю, здесь мы применяем такой паттерн проектирования, как декоратор,
 // т.е. декорируем экшены с помощью дополнительного параметра.
 // Другими словами, мы увеличиваем "арность" функции
 for (const key in _actions) {
   actions[key] = (...args) => _actions[key](setters, ...args)
 }
 return actions
}</code></pre><br/>
<p><em>Обратите внимание</em>: порядок вызова утилит имеет принципиальное значение. <code>createActions()</code> должны передаваться декорированные сеттеры.</p><br/>
<p>Теперь рассмотрим <code>createGetters()</code>:</p><br/>
<pre><code class="javascript">// По сути, все то же самое, за исключением того,
// что мы декорируем геттеры дважды:
// в первый раз мы передаем им состояние в качестве первого аргумента,
// во второй раз в качестве первого аргумента им передается распакованное состояние и преобразованные геттеры
const createGetters = (_getters, state) => {
 const getters = {}
 for (const key in _getters) {
   getters[key] = (...args) => _getters[key](state, ...args)
 }
 for (const key in _getters) {
   getters[key] = (...args) => _getters[key]({ ...state, getters }, ...args)
 }
 return getters
}</code></pre><br/>
<p>Самое интересное происходит в функции <code>createSetters()</code>:</p><br/>
<pre><code class="javascript">const createSetters = (_setters, setState) => {
 const setters = {}
 for (const key in _setters) {
   setters[key] = (...args) => {
     setState((state) => {
       const newState = _setters[key](state, ...args)
       return {
         ...state,
         ...newState
       }
     })
   }
 }
 return setters
}</code></pre><br/>
<p>Здесь мы также модифицируем сеттеры, но не просто передаем им состояние в качестве первого аргумента, а вычисляем новую часть состояния на основе (гарантированно) свежего состояния, которое при вызове получает колбек <code>setState()</code>:</p><br/>
<pre><code class="javascript">setState((state) => {
 const newState = setters[key](state, ...args)
 return {
   ...state,
   ...newState
 }
})</code></pre><br/>
<p>Вот почему так важно, чтобы сеттер возвращал объект с ключом (или несколькими ключами), соответствующими ключам объекта состояния. Значения совпадающих ключей (части состояния) перезаписываются новыми значениями.</p><br/>
<p>Вот и все. Для доступа к состоянию и операциям необходимо обернуть компоненты в провайдер контекста и вызвать хук <code>useSimpleContext()</code> в нужном компоненте:</p><br/>
<pre><code class="javascript">import { SimpleProvider } from './context'

render(
 &lt;React.StrictMode>
   &lt;SimpleProvider>
     &lt;App />
   &lt;/SimpleProvider>
 &lt;/React.StrictMode>,
 document.getElementById('root')
)

const { simpleState, setSimpleState, setters, getters, actions } = useSimpleContext()</code></pre><br/>
<p>Так что, как видите, мы вовсе не изобретали велосипед заново, а всего лишь сделали его немного лучше. Как я отмечал в начале статьи, ездить велосипед после этого стал немного медленнее (поскольку слегка потяжелел), но это только при разгоне. Зато выглядеть велосипед стал круче, да и "апгрейдить" его стало легче 😃</p><br/>
<p>Пожалуй, это все, чем я хотел поделиться с вами в данной статье. Буду рад любой форме обратной связи.</p><br/>
<p>Благодарю за внимание и хорошего дня!</p><br/>
<hr/><br/>
<p><a href="https://cloud.timeweb.com/?utm_source=habr&amp;utm_medium=banner&amp;utm_campaign=cloud&amp;utm_content=direct&amp;utm_term=low"><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/wn/cq/lp/wncqlp9abeml4npwzsybuvhzcta.png"/></a></p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bjavascript%5D" class="tm-tags-list__link">javascript</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Breact%5D" class="tm-tags-list__link">react</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Breactjs%5D" class="tm-tags-list__link">reactjs</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Breact.js%5D" class="tm-tags-list__link">react.js</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bstate%5D" class="tm-tags-list__link">state</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bstate%20management%5D" class="tm-tags-list__link">state management</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bcollocation%5D" class="tm-tags-list__link">collocation</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bstate%20collocation%5D" class="tm-tags-list__link">state collocation</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bredux%5D" class="tm-tags-list__link">redux</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bvuex%5D" class="tm-tags-list__link">vuex</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">состояние</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC%5D" class="tm-tags-list__link">управление состоянием</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9%5D" class="tm-tags-list__link">совместное размещение состояний</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D0%BB%D0%BB%D0%BE%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%5D" class="tm-tags-list__link">коллокация</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/timeweb/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании Timeweb
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/webdev/" class="tm-hubs-list__link">
    Разработка веб-сайтов
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/javascript/" class="tm-hubs-list__link">
    JavaScript
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/reactjs/" class="tm-hubs-list__link">
    ReactJS
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 13: ↑7 и ↓6</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 13: ↑7 и ↓6" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+1</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">5.1K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    46
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/timeweb/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/b5b/7e1/c48/b5b7e1c4819388606f1a3c7ed1d2373a.jpg" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/timeweb/profile/" class="tm-company-snippet__title">Timeweb</a> <div class="tm-company-snippet__description">Хостинг, VDS и ИТ-инфраструктура</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <!----> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/aio350/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/076/1e1/2c6/0761e12c6ea091cb6170c185394fae64.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 160 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    74
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">22</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Igor Agapov</span> <a href="/ru/users/aio350/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @aio350
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">JavaScript Developer</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/timeweb/blog/582320/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 3 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2006-05-24T20:00:00.000Z" title="2006-05-25, 00:00">25  мая  2006</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="https://timeweb.com/ru/?utm_source=habr.com&amp;utm_medium=smo" target="_blank" class="tm-company-basic-info__link">
      timeweb.com
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    201–500 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2011-08-11T14:17:04.000Z" title="2011-08-11, 18:17">11  августа  2011</time></dd></dl> <!----></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/timeweb/blog/582320/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/timeweb/blog/582320/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"582320":{"id":"582320","timePublished":"2021-10-08T06:08:13+00:00","isCorporative":true,"lang":"ru","titleHtml":"React: простое и эффективное решение для управления состоянием приложений","leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F4q\u002Fdj\u002Fsj\u002F4qdjsje-cdcxxlo7dj9n2thrvke.png\"\u003E\u003Cbr\u003E\r\n\u003Cp\u003E\u003Cbr\u003E\r\nПривет, друзья!\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EВ этом небольшом &quot;туториале&quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием \u003Ccode\u003EReact-приложений\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EНемного забегая вперед, скажу, что решение получилось чуть менее производительным, чем &quot;классическое&quot; сочетание хука \u003Ccode\u003EuseReducer()\u003C\u002Fcode\u003E и инструментов, предоставляемых \u003Ccode\u003EContext API\u003C\u002Fcode\u003E (которые, собственно, и составляют ядро решения).\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EРешение представляет собой результат нескольких экспериментов, направленных на максимальное упрощение работы с контекстом \u003Ccode\u003EReact\u003C\u002Fcode\u003E, и во многом вдохновлено \u003Ca href=\"https:\u002F\u002Fvuex.vuejs.org\u002Fru\u002Fguide\u002F\" rel=\"nofollow noopener noreferrer\"\u003E\u003Ccode\u003EVuex\u003C\u002Fcode\u003E\u003C\u002Fa\u003E — официальным инструментом для управления состоянием \u003Ccode\u003EVue-приложений\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EРешение не является законченным и находится в стадии активной разработки, поэтому приветствуются любые замечания и предложения, любая конструктивная критика.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EПока мне не представилось возможности испытать решение в &quot;полевых условиях&quot; (я намерен сделать это при первом удобном случае), но кажется, что оно подойдет для разработки приложений любой сложности при соблюдении двух важных условий:\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":74,"votesCount":160},"rating":22,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2147423","alias":"aio350","fullname":"Igor Agapov","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F076\u002F1e1\u002F2c6\u002F0761e12c6ea091cb6170c185394fae64.jpg","speciality":"JavaScript Developer"},"statistics":{"commentsCount":3,"favoritesCount":46,"readingCount":5107,"score":1,"votesCount":13},"hubs":[{"relatedData":null,"id":"17357","alias":"timeweb","type":"corporative","title":"Блог компании Timeweb","titleHtml":"Блог компании Timeweb","isProfiled":false},{"relatedData":null,"id":"91","alias":"webdev","type":"collective","title":"Разработка веб-сайтов","titleHtml":"Разработка веб-сайтов","isProfiled":true},{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"19327","alias":"reactjs","type":"collective","title":"ReactJS","titleHtml":"ReactJS","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F4q\u002Fdj\u002Fsj\u002F4qdjsje-cdcxxlo7dj9n2thrvke.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cbr\u002F\u003E\r\nПривет, друзья!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом небольшом \"туториале\" я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием \u003Ccode\u003EReact-приложений\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНемного забегая вперед, скажу, что решение получилось чуть менее производительным, чем \"классическое\" сочетание хука \u003Ccode\u003EuseReducer()\u003C\u002Fcode\u003E и инструментов, предоставляемых \u003Ccode\u003EContext API\u003C\u002Fcode\u003E (которые, собственно, и составляют ядро решения).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРешение представляет собой результат нескольких экспериментов, направленных на максимальное упрощение работы с контекстом \u003Ccode\u003EReact\u003C\u002Fcode\u003E, и во многом вдохновлено \u003Ca href=\"https:\u002F\u002Fvuex.vuejs.org\u002Fru\u002Fguide\u002F\"\u003E\u003Ccode\u003EVuex\u003C\u002Fcode\u003E\u003C\u002Fa\u003E — официальным инструментом для управления состоянием \u003Ccode\u003EVue-приложений\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРешение не является законченным и находится в стадии активной разработки, поэтому приветствуются любые замечания и предложения, любая конструктивная критика.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПока мне не представилось возможности испытать решение в \"полевых условиях\" (я намерен сделать это при первом удобном случае), но кажется, что оно подойдет для разработки приложений любой сложности при соблюдении двух важных условий:\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EВ хранилище (\u003Ccode\u003Estore\u003C\u002Fcode\u003E) должно храниться только глобальное состояние. Я не буду утомлять вас рассуждениями на тему \"Что такое состояние приложения? Какое состояние является локальным, а какое глобальным?\" и т.д. Лично я исхожу из предположения, что любое состояние является локальным, пока не доказано обратное, т.е. пока не возникнет необходимости в его распределении между автономными компонентами.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПровайдер контекста должен размещаться максимально близко к компонентам, потребляющим контекст. Это называется коллокацией (collocation) или размещением совместного состояния. Логика принятия решения о том, каким является состояние и где его размещать выглядит примерно так:\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002Fgz\u002F_o\u002Fyx\u002Fgz_oyx9xhm_7wvpydh1uk1wc3wy.jpeg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fgz\u002F_o\u002Fyx\u002Fgz_oyx9xhm_7wvpydh1uk1wc3wy.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cbr\u002F\u003E\r\nИсходный код проекта находится \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fharryheman\u002Freact-simple-context\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПесочница:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fembedd.srv.habr.com\u002Fiframe\u002F615fdf7fedd610f626b80cb1\" data-style=\"\" id=\"615fdf7fedd610f626b80cb1\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EОбратите внимание\u003C\u002Fem\u003E: статья рассчитана на разработчиков, который имеют некоторый опыт работы с \u003Ccode\u003EReact\u003C\u002Fcode\u003E, уставших от \u003Ccode\u003ERedux\u003C\u002Fcode\u003E и иже с ним 😃\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"rezultat\"\u003EРезультат\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте начнем с того, что мы хотим получить на выходе. И почему не воспользоваться готовыми решениями? Другими словами, зачем нам изобретать велосипед, когда, казалось бы, все давно придумано умными людьми?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОбъясню простыми… кодом. Предположим, что мы хотим разработать \"тудушку\" со следующим функционалом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eполучение задач от сервера — асинхронная операция;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдобавление в список новой задачи — синхронная;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eобновление задачи: ее текста, состояния завершенности и состояния редактирования — синхронные;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eудаление задачи из списка — синхронная;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eфильтрация задач в списке: отображение всех, только завершенных или только активных задач — синхронная;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eзавершение всех активных задач — синхронная;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eудаление всех завершенных задач — синхронная;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eсохранение задач на сервере (в базе данных) — асинхронная;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eотображение статистики: общее количество, количество завершенных и количество активных задач, а также процент активных задач — синхронная;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eполучение сообщений: о загрузке задач с сервера, сохранении задач в БД или возникшей ошибке — асинхронная.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли реализовать этот функционал, следуя всем канонам современного \u003Ca href=\"https:\u002F\u002Fredux.js.org\u002F\"\u003E\u003Ccode\u003ERedux\u003C\u002Fcode\u003E\u003C\u002Fa\u003E в лице \u003Ca href=\"https:\u002F\u002Fredux-toolkit.js.org\u002F\"\u003E\u003Ccode\u003ERedux Toolkit\u003C\u002Fcode\u003E\u003C\u002Fa\u003E, то код хранилища получится следующим:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport {\n configureStore,\n createAsyncThunk,\n createEntityAdapter,\n createSelector,\n createSlice\n} from '@reduxjs\u002Ftoolkit'\n\u002F\u002F Утилита для выполнения HTTP-запросов\nimport axios from 'axios'\n\n\u002F\u002F Адрес сервера\nconst SERVER_URL = 'http:\u002F\u002Flocalhost:5000\u002Ftodos'\n\n\u002F\u002F Так называемый адаптер сущностей (entity adapter) (для задач)\nconst todoAdapter = createEntityAdapter()\n\n\u002F\u002F Начальное состояние (для задач)\nconst initialTodoState = todoAdapter.getInitialState({\n \u002F\u002F статус приложения\n status: 'idle',\n \u002F\u002F статус сообщения\n message: {}\n})\n\n\u002F\u002F Так называемый преобразователь (thunk) -\n\u002F\u002F асинхронная операция для получения задач от сервера\nexport const fetchTodos = createAsyncThunk('todos\u002FfetchTodos', async () =\u003E {\n try {\n   \u002F\u002F получаем данные\n   const { data: todos } = await axios(SERVER_URL)\n   \u002F\u002F возвращаем задачи и сообщение об успехе\n   return {\n     todos,\n     message: { type: 'success', text: 'Todos loaded' }\n   }\n } catch (err) {\n   console.error(err.toJSON())\n   \u002F\u002F возвращаем сообщение об ошибке\n   return {\n     message: { type: 'error', text: 'Something went wrong' }\n   }\n }\n})\n\n\u002F\u002F Асинхронная операция для сохранения задач в БД\nexport const saveTodos = createAsyncThunk(\n 'todos\u002FsaveTodos',\n async (newTodos) =\u003E {\n   try {\n     \u002F\u002F получаем существующие задачи\n     const { data: existingTodos } = await axios(SERVER_URL)\n\n     \u002F\u002F перебираем их\n     for (const todo of existingTodos) {\n       \u002F\u002F формируем `URL` текущей задачи\n       const todoUrl = `${SERVER_URL}\u002F${todo.id}`\n\n       \u002F\u002F определяем, имеется ли существующая задача среди новых\n       const commonTodo = newTodos.find((_todo) =\u003E _todo.id === todo.id)\n\n       \u002F\u002F если имеется\n       if (commonTodo) {\n         \u002F\u002F определяем наличие изменений\n         if (\n           !Object.entries(commonTodo).every(\n             ([key, value]) =\u003E value === todo[key]\n           )\n         ) {\n           \u002F\u002F если изменения есть, обновляем задачу на сервере,\n           await axios.put(todoUrl, commonTodo)\n         }\n       } else {\n         \u002F\u002F если не имеется\n         \u002F\u002F удаляем задачу на сервере\n         await axios.delete(todoUrl)\n       }\n     }\n\n     \u002F\u002F теперь перебираем новые задачи и сравниваем их с существующими\n     for (const todo of newTodos) {\n       \u002F\u002F если новой задачи нет среди существующих\n       \u002F\u002F значит, она действительно новая\n       if (!existingTodos.find((_todo) =\u003E _todo.id === todo.id)) {\n         \u002F\u002F сохраняем ее в БД\n         await axios.post(SERVER_URL, todo)\n       }\n     }\n     \u002F\u002F возвращаем сообщение об успехе\n     return { type: 'success', text: 'Todos saved' }\n   } catch (err) {\n     console.error(err.toJSON())\n     \u002F\u002F возвращаем сообщение об ошибке\n     return {\n       type: 'error',\n       text: 'Something went wrong'\n     }\n   }\n }\n)\n\n\u002F\u002F Асинхронная операция для выполнения искусственной задержки -\n\u002F\u002F она нужна для отображения сообщения в течение указанного времени\nexport const giveMeSomeTime = createAsyncThunk(\n 'todos\u002FgiveMeSomeTime',\n async (ms) =\u003E\n   await new Promise((resolve) =\u003E {\n     const timerId = setTimeout(() =\u003E {\n       resolve()\n       clearTimeout(timerId)\n     }, ms)\n   })\n)\n\n\u002F\u002F Так называемая часть или срез состояния (для задач)\nconst todoSlice = createSlice({\n \u002F\u002F название\n name: 'todos',\n \u002F\u002F начальное состояние в виде нормализованной структуры\n initialState: initialTodoState,\n \u002F\u002F обычные редукторы\n reducers: {\n   \u002F\u002F для добавления задачи\n   addTodo: todoAdapter.addOne,\n   \u002F\u002F для обновления задачи\n   updateTodo: todoAdapter.updateOne,\n   \u002F\u002F для удаления задачи\n   removeTodo: todoAdapter.removeOne,\n   \u002F\u002F для завершения всех активных задач\n   completeAllTodos(state) {\n     Object.values(state.entities).forEach((todo) =\u003E {\n       todo.done = true\n     })\n   },\n   \u002F\u002F для удаления всех завершенных задач\n   clearCompletedTodos(state) {\n     const completedTodoIds = Object.values(state.entities)\n       .filter((todo) =\u003E todo.done)\n       .map((todo) =\u003E todo.id)\n     todoAdapter.removeMany(state, completedTodoIds)\n   }\n },\n \u002F\u002F дополнительные редукторы для обработки результатов асинхронных операций\n extraReducers: (builder) =\u003E {\n   builder\n     \u002F\u002F запрос на получение задач от сервера находится в процессе выполнения\n     .addCase(fetchTodos.pending, (state) =\u003E {\n       \u002F\u002F обновляем индикатор загрузки\n       state.status = 'loading'\n     })\n     \u002F\u002F запрос выполнен\n     .addCase(fetchTodos.fulfilled, (state, { payload }) =\u003E {\n       if (payload.todos) {\n         \u002F\u002F обновляем состояние задач\n         todoAdapter.setAll(state, payload.todos)\n       }\n       \u002F\u002F записываем сообщение\n       state.message = payload.message\n       \u002F\u002F обновляем индикатор загрузки\n       state.status = 'idle'\n     })\n     \u002F\u002F запрос на сохранение задач в БД находится в процессе выполнения\n     .addCase(saveTodos.pending, (state) =\u003E {\n       \u002F\u002F обновляем индикатор загрузки\n       state.status = 'loading'\n     })\n     \u002F\u002F запрос выполнен\n     .addCase(saveTodos.fulfilled, (state, { payload }) =\u003E {\n       \u002F\u002F записываем сообщение\n       state.message = payload\n       \u002F\u002F обновляем индикатор загрузки\n       state.status = 'idle'\n     })\n     \u002F\u002F запрос на выполнение задержки выполнен\n     .addCase(giveMeSomeTime.fulfilled, (state) =\u003E {\n       \u002F\u002F очищаем сообщение\n       state.message = {}\n     })\n }\n})\n\n\u002F\u002F Операции для работы с задачами\nexport const {\n addTodo,\n updateTodo,\n removeTodo,\n completeAllTodos,\n clearCompletedTodos\n} = todoSlice.actions\n\n\u002F\u002F Начальное состояние (для фильтра)\nconst initialFilterState = {\n status: 'all'\n}\n\n\u002F\u002F Часть состояния (для фильтра)\nconst filterSlice = createSlice({\n \u002F\u002F название\n name: 'filter',\n \u002F\u002F начальное состояние\n initialState: initialFilterState,\n \u002F\u002F обычные редукторы\n reducers: {\n   \u002F\u002F для установки значения фильтра\n   setFilter(state, action) {\n     state.status = action.payload\n   }\n }\n})\n\n\u002F\u002F Операция для установки значения фильтра\nexport const { setFilter } = filterSlice.actions\n\n\u002F\u002F Так называемые селекторы для выборки всех задач и их общего количества\nexport const { selectAll, selectTotal } = todoAdapter.getSelectors(\n (state) =\u003E state.todos\n)\n\n\u002F\u002F Селектор для выборки задач на основе текущего состояния фильтра\nexport const selectFilteredTodos = createSelector(\n selectAll,\n (state) =\u003E state.filter,\n (todos, filter) =\u003E {\n   const { status } = filter\n   if (status === 'all') return todos\n   return status === 'active'\n     ? todos.filter((todo) =\u003E !todo.done)\n     : todos.filter((todo) =\u003E todo.done)\n }\n)\n\n\u002F\u002F Селектор для выборки статистики\nexport const selectTodoStats = createSelector(\n selectAll,\n selectTotal,\n (todos, total) =\u003E {\n   const completed = todos.filter((todo) =\u003E todo.done).length\n   const active = total - completed\n   const percent = total === 0 ? 0 : Math.round((active \u002F total) * 100)\n\n   return {\n     total,\n     completed,\n     active,\n     percent\n   }\n }\n)\n\n\u002F\u002F Хранилище\nexport const store = configureStore({\n reducer: {\n   todos: todoSlice.reducer,\n   filter: filterSlice.reducer\n }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСлишком много кода, но очень мало смысла. И это продвинутый \u003Ccode\u003ERedux\u003C\u002Fcode\u003E! На работе вам, скорее всего, приходится (или еще придется) возиться со старым-добрым \"магическим\" \u003Ccode\u003ERedux\u003C\u002Fcode\u003E (и классовыми компонентами, будь они неладны).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли переписать функционал тудушки, используя сочетание \u003Ccode\u003EuseReducer()\u003C\u002Fcode\u003E и \u003Ccode\u003EContext API\u003C\u002Fcode\u003E (а также парочки \"хаков\"), код получится примерно таким:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { createContext, useContext, useReducer, useMemo } from 'react'\nimport axios from 'axios'\n\nconst SERVER_URL = 'http:\u002F\u002Flocalhost:5000\u002Ftodos'\n\n\u002F\u002F Константы\nconst SET_TODOS = 'SET_TODOS'\nconst SET_STATUS = 'SET_STATUS'\nconst ADD_TODO = 'ADD_TODO'\nconst UPDATE_TODO = 'UPDATE_TODO'\nconst REMOVE_TODO = 'REMOVE_TODO'\nconst COMPLETE_TODOS = 'COMPLETE_TODOS'\nconst CLEAR_COMPLETED = 'CLEAR_COMPLETED'\nconst SET_FILTER = 'SET_FILTER'\nconst SET_MESSAGE = 'SET_MESSAGE'\n\n\u002F\u002F Редуктор\nconst reducer = (state, { type, payload }) =\u003E {\n switch (type) {\n   case SET_TODOS:\n     return {\n       ...state,\n       todos: payload\n     }\n   case SET_STATUS:\n     return {\n       ...state,\n       status: payload\n     }\n   case ADD_TODO:\n     return { ...state, todos: state.todos.concat(payload) }\n   case UPDATE_TODO:\n     return {\n       ...state,\n       todos: state.todos.map((todo) =\u003E\n         todo.id === payload.id ? { ...todo, ...payload.changes } : todo\n       )\n     }\n   case REMOVE_TODO:\n     return {\n       ...state,\n       todos: state.todos.filter((todo) =\u003E todo.id !== payload)\n     }\n   case COMPLETE_TODOS:\n     return { ...state, todos: state.todos.map((todo) =\u003E todo.done === true) }\n   case CLEAR_COMPLETED:\n     return {\n       ...state,\n       todos: state.todos.filter((todo) =\u003E todo.done === true)\n     }\n   case SET_FILTER:\n     return {\n       ...state,\n       filter: payload\n     }\n   case SET_MESSAGE:\n     return {\n       ...state,\n       message: payload\n     }\n   default:\n     return state\n }\n}\n\n\u002F\u002F Задержка\nconst giveMeSomeTime = async () =\u003E\n await new Promise((resolve) =\u003E {\n   const timerId = setTimeout(() =\u003E {\n     resolve()\n     clearTimeout(timerId)\n   }, 2000)\n })\n\n\u002F\u002F Так называемый создатель операций (хак номер раз)\nconst createActions = (dispatch) =\u003E ({\n setTodos: (todos) =\u003E ({\n   type: SET_TODOS,\n   payload: todos\n }),\n setStatus: (status) =\u003E ({\n   type: SET_STATUS,\n   payload: status\n }),\n addTodo: (todo) =\u003E ({\n   type: ADD_TODO,\n   payload: todo\n }),\n updateTodo: (payload) =\u003E ({\n   type: UPDATE_TODO,\n   payload\n }),\n removeTodo: (todoId) =\u003E ({\n   type: REMOVE_TODO,\n   payload: todoId\n }),\n completeTodos: () =\u003E ({\n   type: COMPLETE_TODOS\n }),\n clearCompleted: () =\u003E ({\n   type: COMPLETE_TODOS\n }),\n setFilter: (filter) =\u003E ({\n   type: SET_FILTER,\n   payload: filter\n }),\n setMessage: (message) =\u003E ({\n   type: SET_MESSAGE,\n   payload: message\n }),\n async fetchTodos() {\n   dispatch(this.setStatus('loading'))\n\n   try {\n     const { data: todos } = await axios(SERVER_URL)\n\n     dispatch(this.setTodos(todos))\n\n     dispatch(\n       this.setMessage({ type: 'success', text: 'Todos loaded' })\n     )\n   } catch (err) {\n     console.error(err.toJSON())\n\n     dispatch(\n       this.setMessage({\n         type: 'error',\n         text: 'Something went wrong'\n       })\n     )\n   } finally {\n     dispatch(this.setStatus('idle'))\n\n     await giveMeSomeTime()\n\n     dispatch(this.setMessage({}))\n   }\n },\n async saveTodos(newTodos) {\n   dispatch(this.setStatus('loading'))\n\n   try {\n     const { data: existingTodos } = await axios(SERVER_URL)\n\n     for (const todo of existingTodos) {\n       const todoUrl = `${SERVER_URL}\u002F${todo.id}`\n\n       const commonTodo = newTodos.find((_todo) =\u003E _todo.id === todo.id)\n\n       if (commonTodo) {\n         if (\n           !Object.entries(commonTodo).every(\n             ([key, value]) =\u003E value === todo[key]\n           )\n         ) {\n           await axios.put(todoUrl, commonTodo)\n         }\n       } else {\n         await axios.delete(todoUrl)\n       }\n     }\n\n     for (const todo of newTodos) {\n       if (!existingTodos.find((_todo) =\u003E _todo.id === todo.id)) {\n         await axios.post(SERVER_URL, todo)\n       }\n     }\n\n     dispatch(\n       this.setMessage({ type: 'success', text: 'Todos saved' })\n     )\n   } catch (err) {\n     console.error(err.toJSON())\n\n     dispatch(\n       this.setMessage({\n         type: 'error',\n         text: 'Something went wrong'\n       })\n     )\n   } finally {\n     dispatch(this.setStatus('idle'))\n\n     await giveMeSomeTime()\n\n     dispatch(this.setMessage({}))\n   }\n }\n})\n\n\u002F\u002F Так называемый создатель селекторов (хак номер два)\nconst createSelectors = (state) =\u003E ({\n selectFilteredTodos() {\n   const { todos, filter } = state\n   if (filter === 'all') return todos\n   return filter === 'active'\n     ? todos.filter((todo) =\u003E !todo.done)\n     : todos.filter((todo) =\u003E todo.done)\n },\n selectTodoStats() {\n   const { todos } = state\n   const { length } = todos\n\n   const completed = todos.filter((todo) =\u003E todo.done).length\n   const active = length - completed\n   const percent = length === 0 ? 0 : Math.round((active \u002F length) * 100)\n\n   return {\n     total: length,\n     completed,\n     active,\n     percent\n   }\n }\n})\n\n\u002F\u002F Начальное состояние\nconst initialState = {\n todos: [],\n status: 'idle',\n filter: 'all',\n message: {}\n}\n\n\u002F\u002F Контекcт\nconst Context = createContext()\n\n\u002F\u002F Провайдер контекста\nexport const Provider = ({ children }) =\u003E {\n const [state, dispatch] = useReducer(reducer, initialState)\n\n \u002F\u002F Небольшая оптимизация, возможно, преждевременная\n \u002F\u002F это зависит от размера и сложности приложения\n \u002F\u002F и может быть определено только опытным путем\n const actions = useMemo(() =\u003E createActions(dispatch), [])\n const selectors = createSelectors(state)\n\n return (\n   &lt;Context.Provider value={{ state, dispatch, actions, selectors }}\u003E\n     {children}\n   &lt;\u002FContext.Provider\u003E\n )\n}\n\n\u002F\u002F Хук для потребления контекста\nexport const useAppContext = () =\u003E useContext(Context)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНамного лучше как с точки зрения читаемости кода, так и, что особенно важно, с точки зрения производительности. Но константы! В принципе, без них можно обойтись. Но редуктор! Кажется, что без редуктора обойтись нельзя. Или все-таки можно? Вполне. А что насчет диспетчера? Можно ли обойтись без него? Нет, без диспетчера обойтись не получится, потому что управлять состоянием \u003Ccode\u003EReact-приложения\u003C\u002Fcode\u003E можно только через него. Но его, как мы увидим дальше, совсем не обязательно использовать в явном виде.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли переписать функционал тудушки с помощью решения, которое мы еще не рассматривали, но скоро рассмотрим, то код хранилища получится следующим:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport axios from 'axios'\naxios.defaults.baseURL = 'http:\u002F\u002Flocalhost:5000\u002Ftodos'\n\nconst sleep = (ms) =\u003E\n new Promise((resolve) =\u003E {\n   const timerId = setTimeout(() =\u003E {\n     resolve()\n     clearTimeout(timerId)\n   }, ms)\n })\n\nconst store = {\n state: {\n   todos: [],\n   status: 'idle',\n   filter: 'all',\n   message: {}\n },\n setters: {\n   setStatus: (_, status) =\u003E ({ status }),\n   setMessage: (_, message) =\u003E ({ message }),\n   setTodos: (_, newTodos) =\u003E ({ todos: newTodos }),\n   addTodo: ({ todos }, newTodo) =\u003E ({ todos: todos.concat(newTodo) }),\n   updateTodo: ({ todos }, { id, changes }) =\u003E ({\n     todos: todos.map((todo) =\u003E\n       todo.id === id\n         ? {\n             ...todo,\n             ...changes\n           }\n         : todo\n     )\n   }),\n   removeTodo: ({ todos }, todoId) =\u003E {\n     return {\n       todos: todos.filter((todo) =\u003E todo.id !== todoId)\n     }\n   },\n   completeTodos: ({ todos }) =\u003E ({\n     todos: todos.map((todo) =\u003E ({ ...todo, done: true }))\n   }),\n   clearCompleted: ({ todos }) =\u003E ({ todos: todos.filter((todo) =\u003E !todo.done) }),\n   setFilter: (_, filter) =\u003E ({ filter })\n },\n getters: {\n   getFilteredTodos: ({ todos, filter }) =\u003E {\n     if (filter === 'all') return todos\n     return filter === 'active'\n       ? todos.filter((todo) =\u003E !todo.done)\n       : todos.filter((todo) =\u003E todo.done)\n   },\n   getTodoStats: ({ todos }) =\u003E {\n     const { length } = todos\n\n     const completed = todos.filter((todo) =\u003E todo.done).length\n     const active = length - completed\n     const percent = length === 0 ? 0 : Math.round((active \u002F length) * 100)\n\n     return {\n       total: length,\n       completed,\n       active,\n       percent\n     }\n },\n actions: {\n   async fetchTodos({ setStatus, setTodos, setMessage }) {\n     setStatus('loading')\n\n     try {\n       const { data } = await axios()\n       setTodos(data)\n       setMessage({\n         type: 'success',\n         text: 'Todos received'\n       })\n     } catch (err) {\n       console.error(err.toJSON())\n       setMessage({\n         type: 'error',\n         text: 'Something went wrong'\n       })\n     } finally {\n       setStatus('idle')\n       await sleep(1000)\n       setMessage({})\n     }\n   },\n   async saveTodos({ setStatus, setMessage }, newTodos) {\n     setStatus('loading')\n     try {\n       const { data: existingTodos } = await axios()\n\n       for (const todo of existingTodos) {\n         const commonTodo = newTodos.find((_todo) =\u003E _todo.id === todo.id)\n\n         if (commonTodo) {\n           if (\n             !Object.entries(commonTodo).every(\n               ([key, value]) =\u003E value === todo[key]\n             )\n           ) {\n             await axios.put(todo.id, commonTodo)\n           }\n         } else {\n           await axios.delete(todo.id)\n         }\n       }\n\n       for (const todo of newTodos) {\n         if (!existingTodos.find((_todo) =\u003E _todo.id === todo.id)) {\n           await axios.post('\u002F', todo)\n         }\n       }\n\n       setMessage({ type: 'success', text: 'Todos saved' })\n     } catch (err) {\n       console.error(err.toJSON())\n       setMessage({\n         type: 'error',\n         text: 'Something went wrong'\n       })\n     } finally {\n       setStatus('idle')\n       await sleep(1000)\n       setMessage({})\n     }\n   }\n }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли \"разнести\" сеттеры, геттеры и экшены по отдельным файлам, то код хранилища получится таким:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { unpackModule } from '.\u002Fcontext'\nimport * as setters from '.\u002Fsetters'\nimport * as getters from '.\u002Fgetters'\nimport * as actions from '.\u002Factions'\n\nconst store = {\n state: {\n   todos: [],\n   status: 'idle',\n   filter: 'all',\n   message: {}\n },\n setters: unpackModule(setters),\n getters: unpackModule(getters),\n actions: unpackModule(actions)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТо, что доктор прописал. Теперь давайте обо всем по порядку.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"koncepciya\"\u003EКонцепция\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте рассуждать вслух.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля хранения состояния и операций для работы с ним нам требуется некая гибкая и легко изменяемая структура. В \u003Ccode\u003EJavaScript\u003C\u002Fcode\u003E нет более подходящей структуры, чем объект. Назовем этот объект хранилищем — \u003Ccode\u003Estore\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСтруктура хранилища по возможности должна оставаться плоской, т.е. одноуровневой: это сильно упростит логику обновления состояния.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДалее, нам нужны операции для изменения состояния. Состояние может меняться синхронно и асинхронно, поэтому имеет смысл дифференцировать операции соответствующим образом. Назовем синхронные операции сеттерами (\u003Ccode\u003Esetters\u003C\u002Fcode\u003E), а асинхронные — экшенами (\u003Ccode\u003Eactions\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКакую сигнатуру должны иметь сеттеры и экшены?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОчевидно, что сеттеры должны принимать какие-то параметры и иметь \u003Cem\u003Eпрямой\u003C\u002Fem\u003E доступ к состоянию для его изменения. Возвращать сеттеры должны модифицированное состояние в виде части глобального состояния, т.е. объект с ключом, соответствующим определенной части глобального состояния. Я пока не нашел более простого способа для корректной идентификации части модифицируемого сеттером состояния. Схематично это можно представить следующим образом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EsetSomething: (state, args) =\u003E ({ stateSlice: newState })\n\u002F\u002F или\nsetSomething(state, args) {\n return {\n   stateSlice: newState\n }\n}\n\u002F\u002F мне больше нравится первый вариант\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИли, когда сеттер не использует состояние:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EsetSomething: (_, args) =\u003E ({ stateSlice: newState })\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИли, когда название аргумента совпадает с названием части глобального состояния (ключом объекта состояния):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EsetSomething: (_, arg) =\u003E ({ arg })\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EОбратите внимание\u003C\u002Fem\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eпервым параметром, принимаемым сеттером, всегда является состояние\u003C\u002Fli\u003E\r\n\u003Cli\u003Eсеттеру может передаваться любое количество аргументов\u003C\u002Fli\u003E\r\n\u003Cli\u003Eсеттер всегда должен возвращать объект определенной формы (о которой говорилось выше)\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭкшены также могут принимать любое количество параметров, но не имеют прямого доступа к состоянию. Доступ экшенов к состоянию опосредован сеттерами, т.е. экшены меняют состояние только через сеттеры. Экшены не должны ничего возвращать. Сигнатура:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Easync fetchSomething(setters, args) {\n const result = await fetchSomething(args)\n setters.setSomething(result)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНаконец, нам нужны операции для извлечения части состояния или вычисления производных данных. Назовем эти операции геттерами — \u003Ccode\u003Egetters\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГеттеры могут принимать любое количество параметров и имеют \u003Cem\u003Eпрямой\u003C\u002Fem\u003E доступ к состоянию. Поскольку цель геттеров — даже не столько извлечение части состояния (потому что мы можем делать это напрямую из состояния, содержащегося в контексте), сколько вычисление производных данных, имеет смысл передавать геттерам состояние в распакованном виде, т.е. в виде отдельных частей. Также, поскольку геттеры могут использоваться для производства сложных вычислений, имеет смысл передавать им другие геттеры (\u003Ccode\u003EDRY\u003C\u002Fcode\u003E). Возвращать геттеры должны часть состояния или производные данные. Сигнатура:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EgetSomething: ({ stateSlice1, stateSlice2, ...stateSliceN, getters }) =\u003E stateSice | derivedData\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EОбратите внимание\u003C\u002Fem\u003E: геттеры не должны модифицировать состояние.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь поговорим о том, как добиться правильной сигнатуры операций.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"realizaciya\"\u003EРеализация\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПосле определения, хранилище передается в функцию \u003Ccode\u003EcreateSimpleContext()\u003C\u002Fcode\u003E, которая возвращает массив с двумя элементами: провайдером контекста и хуком для его потребления:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst store = {\n state: {\n   todos: [],\n   status: 'idle',\n   filter: 'all',\n   message: {}\n },\n setters: unpackModule(setters),\n getters: unpackModule(getters),\n actions: unpackModule(actions)\n}\n\nexport const [SimpleProvider, useSimpleContext] = createSimpleContext(store)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EРемарка\u003C\u002Fem\u003E: функция \u003Ccode\u003EunpackModule()\u003C\u002Fcode\u003E — это простая утилита для преобразования модуля в объект, которая выглядит так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eexport const unpackModule = (module) =\u003E {\n const obj = {}\n for (const key in module) {\n   for (const _key in module[key]) {\n     obj[_key] = module[key][_key]\n   }\n }\n return obj\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли сеттеры, например, импортируются как обычный объект, то у нас нет необходимости прибегать к помощи \u003Ccode\u003EunpackModule()\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { setters } from '.\u002Fsetters'\nimport { getters } from '.\u002Fgetters'\nimport { actions } from '.\u002Factions'\n\nconst store = {\n state: {\n   todos: [],\n   status: 'idle',\n   filter: 'all',\n   message: {}\n },\n setters,\n getters,\n actions\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли мы импортируем сеттеры по отдельности, их необходимо распаковать:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { appSetters, todoSetters, filterSetters } from '.\u002Fsetters'\nimport { getters } from '.\u002Fgetters'\nimport { actions } from '.\u002Factions'\n\nconst store = {\n state: {\n   todos: [],\n   status: 'idle',\n   filter: 'all',\n   message: {}\n },\n setters: {\n   ...appSetters,\n   ...todoSetters,\n   ...filterSetters\n },\n getters,\n actions\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧто происходит в \u003Ccode\u003EcreateSimpleContext()\u003C\u002Fcode\u003E? Вот как выглядит ее код:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { createContext, useContext, useState, useMemo } from 'react'\nimport {\n createSetters,\n createGetters,\n createActions,\n unpackModule\n} from '.\u002Futils'\n\n\u002F\u002F Функция принимает хранилище\nexport default function createSimpleContext(store) {\n \u002F\u002F Создаем контекст\n const SimpleContext = createContext()\n\n \u002F\u002F Создаем провайдер\n \u002F\u002F Функция принимает дочерние компоненты\n const SimpleProvider = ({ children }) =\u003E {\n   const [simpleState, setSimpleState] = useState(store.state)\n\n   \u002F\u002F мемоизация вычисления сеттеров и экшенов\n   \u002F\u002F является безопасной, поскольку они являются иммутабельными\n   \u002F\u002F здесь у вас может возникнуть вопрос о том, как сеттер получает свежее состояние\n   \u002F\u002F обратите внимание на то, что передается в функцию `createSetters()` в качестве второго аргумента\n   const setters = useMemo(\n     () =\u003E createSetters(store.setters, setSimpleState),\n     \u002F\u002F eslint-disable-next-line\n     []\n   )\n   const actions = useMemo(\n     () =\u003E createActions(store.actions, setters),\n     \u002F\u002F eslint-disable-next-line\n     []\n   )\n   \u002F\u002F я пока не придумал способа мемоизировать вычисление геттеров с сохранением возможности получения ими всегда акутального состояния\n   const getters = createGetters(store.getters, simpleState)\n\n   return (\n     \u002F\u002F Мы вполне можем управлять состоянием напрямую через `simpleState` и `setSimpleState()`,\n     \u002F\u002F но лучше этого не делать во избежание путаницы между глобальными и локальными операциями.\n     \u002F\u002F Этим же объясняется то, что сеттеры, геттеры и экшены лучше не распаковывать\n     \u002F\u002F при передаче в контекст: мы видим, например, `setters.setTodos()` и сразу понимаем,\n     \u002F\u002F что имеем дело с глобальным состоянием\n     &lt;SimpleContext.Provider\n       value={{\n         simpleState,\n         setSimpleState,\n         setters,\n         getters,\n         actions\n       }}\n     \u003E\n       {children}\n     &lt;\u002FSimpleContext.Provider\u003E\n   )\n }\n\n \u002F\u002F Хук для потребления контекста\n const useSimpleContext = () =\u003E useContext(SimpleContext)\n\n return [SimpleProvider, useSimpleContext]\n}\n\nexport { unpackModule }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСамой простой функцией из числа утилит для преобразования операций является \u003Ccode\u003EcreateActions()\u003C\u002Fcode\u003E. С нее и начнем:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Функция принимает экшены и сеттеры\nexport const createActions = (_actions, setters) =\u003E {\n const actions = {}\n \u002F\u002F Просто передаем каждому экшену сеттеры в качестве первого аргумента.\n \u002F\u002F Полагаю, здесь мы применяем такой паттерн проектирования, как декоратор,\n \u002F\u002F т.е. декорируем экшены с помощью дополнительного параметра.\n \u002F\u002F Другими словами, мы увеличиваем \"арность\" функции\n for (const key in _actions) {\n   actions[key] = (...args) =\u003E _actions[key](setters, ...args)\n }\n return actions\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EОбратите внимание\u003C\u002Fem\u003E: порядок вызова утилит имеет принципиальное значение. \u003Ccode\u003EcreateActions()\u003C\u002Fcode\u003E должны передаваться декорированные сеттеры.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь рассмотрим \u003Ccode\u003EcreateGetters()\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F По сути, все то же самое, за исключением того,\n\u002F\u002F что мы декорируем геттеры дважды:\n\u002F\u002F в первый раз мы передаем им состояние в качестве первого аргумента,\n\u002F\u002F во второй раз в качестве первого аргумента им передается распакованное состояние и преобразованные геттеры\nconst createGetters = (_getters, state) =\u003E {\n const getters = {}\n for (const key in _getters) {\n   getters[key] = (...args) =\u003E _getters[key](state, ...args)\n }\n for (const key in _getters) {\n   getters[key] = (...args) =\u003E _getters[key]({ ...state, getters }, ...args)\n }\n return getters\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСамое интересное происходит в функции \u003Ccode\u003EcreateSetters()\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst createSetters = (_setters, setState) =\u003E {\n const setters = {}\n for (const key in _setters) {\n   setters[key] = (...args) =\u003E {\n     setState((state) =\u003E {\n       const newState = _setters[key](state, ...args)\n       return {\n         ...state,\n         ...newState\n       }\n     })\n   }\n }\n return setters\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗдесь мы также модифицируем сеттеры, но не просто передаем им состояние в качестве первого аргумента, а вычисляем новую часть состояния на основе (гарантированно) свежего состояния, которое при вызове получает колбек \u003Ccode\u003EsetState()\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EsetState((state) =\u003E {\n const newState = setters[key](state, ...args)\n return {\n   ...state,\n   ...newState\n }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВот почему так важно, чтобы сеттер возвращал объект с ключом (или несколькими ключами), соответствующими ключам объекта состояния. Значения совпадающих ключей (части состояния) перезаписываются новыми значениями.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВот и все. Для доступа к состоянию и операциям необходимо обернуть компоненты в провайдер контекста и вызвать хук \u003Ccode\u003EuseSimpleContext()\u003C\u002Fcode\u003E в нужном компоненте:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eimport { SimpleProvider } from '.\u002Fcontext'\n\nrender(\n &lt;React.StrictMode\u003E\n   &lt;SimpleProvider\u003E\n     &lt;App \u002F\u003E\n   &lt;\u002FSimpleProvider\u003E\n &lt;\u002FReact.StrictMode\u003E,\n document.getElementById('root')\n)\n\nconst { simpleState, setSimpleState, setters, getters, actions } = useSimpleContext()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что, как видите, мы вовсе не изобретали велосипед заново, а всего лишь сделали его немного лучше. Как я отмечал в начале статьи, ездить велосипед после этого стал немного медленнее (поскольку слегка потяжелел), но это только при разгоне. Зато выглядеть велосипед стал круче, да и \"апгрейдить\" его стало легче 😃\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПожалуй, это все, чем я хотел поделиться с вами в данной статье. Буду рад любой форме обратной связи.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБлагодарю за внимание и хорошего дня!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fcloud.timeweb.com\u002F?utm_source=habr&amp;utm_medium=banner&amp;utm_campaign=cloud&amp;utm_content=direct&amp;utm_term=low\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fwn\u002Fcq\u002Flp\u002Fwncqlp9abeml4npwzsybuvhzcta.png\"\u002F\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"javascript"},{"titleHtml":"react"},{"titleHtml":"reactjs"},{"titleHtml":"react.js"},{"titleHtml":"state"},{"titleHtml":"state management"},{"titleHtml":"collocation"},{"titleHtml":"state collocation"},{"titleHtml":"redux"},{"titleHtml":"vuex"},{"titleHtml":"состояние"},{"titleHtml":"управление состоянием"},{"titleHtml":"совместное размещение состояний"},{"titleHtml":"коллокация"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F4q\u002Fdj\u002Fsj\u002F4qdjsje-cdcxxlo7dj9n2thrvke.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F4q\u002Fdj\u002Fsj\u002F4qdjsje-cdcxxlo7dj9n2thrvke.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Ftimeweb\\\u002Fblog\\\u002F582320\\\u002F\"},\"headline\":\"React: простое и эффективное решение для управления состоянием приложений\",\"datePublished\":\"2021-10-08T09:08:13+03:00\",\"dateModified\":\"2021-10-08T09:08:13+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Igor Agapov\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Привет, друзья! В этом небольшом &quot;туториале&quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений. Н...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Ftimeweb\\\u002Fblog\\\u002F582320\\\u002F#post-content-body\",\"about\":[\"c_timeweb\",\"h_webdev\",\"h_javascript\",\"h_programming\",\"h_reactjs\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F582320\\\u002F2182e9d4ddd1f43cdac976bdcf6c60ad\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F4q\\\u002Fdj\\\u002Fsj\\\u002F4qdjsje-cdcxxlo7dj9n2thrvke.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fgz\\\u002F_o\\\u002Fyx\\\u002Fgz_oyx9xhm_7wvpydh1uk1wc3wy.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fwn\\\u002Fcq\\\u002Flp\\\u002Fwncqlp9abeml4npwzsybuvhzcta.png\"]}","metaDescription":"Привет, друзья!\r\nВ этом небольшом &quot;туториале&quot; я хочу показать вам, как реализовать простое, но эффективное решение для управления состоянием React-приложений.\r\nНемного забегая вперед,...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"timeweb":{"alias":"timeweb","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002Fb5b\u002F7e1\u002Fc48\u002Fb5b7e1c4819388606f1a3c7ed1d2373a.jpg","titleHtml":"Timeweb","descriptionHtml":"Хостинг, VDS и ИТ-инфраструктура","relatedData":null,"statistics":{"postsCount":304,"newsCount":3,"vacanciesCount":2,"employeesCount":36,"careerRating":null,"subscribersCount":512,"rating":1167.97,"invest":null},"foundationDate":{"year":"2006","month":"05","day":"25"},"location":{"city":{"id":"447733","title":"Санкт-Петербург"},"region":{"id":"1948","title":"Санкт-Петербург и область"},"country":{"id":"168","title":"Россия"}},"siteUrl":"https:\u002F\u002Ftimeweb.com\u002Fru\u002F?utm_source=habr.com&utm_medium=smo","staffNumber":"201–500 человек","registrationDate":"2011-08-11T14:17:04+00:00","representativeUser":null,"contacts":[],"settings":{"analyticsSettings":[{"type":"ga","trackingId":"UA-52903813-5"}],"branding":null,"status":"active"},"metadata":{"titleHtml":"Timeweb, Санкт-Петербург - Хостинг, VDS и ИТ-инфраструктура с 25 мая 2006 г.","title":"Timeweb, Санкт-Петербург - Хостинг, VDS и ИТ-инфраструктура с 25 мая 2006 г.","keywords":["Научно-популярное","Программирование","Читальный зал","JavaScript","Разработка веб-сайтов"],"descriptionHtml":"304 статьи от авторов компании Timeweb","description":"304 статьи от авторов компании Timeweb"},"aDeskSettings":null,"careerAlias":"hrtimewebru","maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
