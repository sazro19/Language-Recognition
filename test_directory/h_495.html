<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Пишем свой блокчейн / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/583606\/"},"headline":"Пишем свой блокчейн","datePublished":"2021-10-15T10:08:11+03:00","dateModified":"2021-10-15T11:08:55+03:00","author":{"@type":"Person","name":"urticazoku"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять...","url":"https:\/\/habr.com\/ru\/post\/583606\/#post-content-body","about":["h_python","h_programming","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/583606\/50af8ebd279fc8c74cedb83f0414827b\/","https:\/\/habrastorage.org\/webt\/59\/d4\/79\/59d479e1ed4da475699339.jpeg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/cc3\/902\/b38\/cc3902b389b6bd708e4f2498e662206a.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/c5f\/7b6\/e1e\/c5f7b6e1ebccfc373f3a3e19ddfe80be.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/088\/03d\/65c\/08803d65c9955d73e59c89122fdd058e.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/11d\/128\/e19\/11d128e19b1de58a3b8faab8a46bb2e6.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Пишем свой блокчейн" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Пишем свой блокчейн" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Пишем свой блокчейн" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять блокчейн непросто - по крайней мере,..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять блокчейн непросто - по крайней мере,..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять блокчейн непросто - по крайней мере,..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять блокчейн непросто - по крайней мере,..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять блокчейн непросто - по крайней мере,..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="583606" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-15T07:08:11.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/583606/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/583606/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/583606/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/urticazoku/" title="urticazoku" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/668/5ff/baf/6685ffbaff7df8ed99dd8702e17f95e3.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/urticazoku/" class="tm-user-info__username">
      urticazoku
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-15T07:08:11.000Z" title="2021-10-15, 10:08">15  октября   в 10:08</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Пишем свой блокчейн</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/python/" class="tm-article-snippet__hubs-item-link"><span>Python</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div><div class="tm-article-snippet__label"><span>
        Tutorial
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://medium.com/@vanflymen/learn-blockchains-by-building-one-117428612f46" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Daniel van Flymen
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/webt/59/d4/79/59d479e1ed4da475699339.jpeg" width="1800" height="931" data-src="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg" data-blurred="true"/><figcaption></figcaption></figure><p>Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.</p><p>Но понять блокчейн непросто - по крайней мере, не для меня. Я пробирался через тупые видео, следовал руководствам и разочаровывался из-за слишком малого количества примеров.</p><p>Мне нравится учиться на практике. Это заставляет меня заниматься предметом на уровне кода, что разжигает любопытство. Если вы сделаете то же самое, в конце этого руководства у вас будет работающий блокчейн с твердым пониманием того, как он работает.</p><p><strong>Прежде, чем начать</strong></p><p>Помните, что блокчейн – неизменяемая, последовательная цепочка записей, называемых блоками. Они могут содержать транзакции, файлы или любые данные. Важно, что они соединены друг с другом с помощью хэша.</p><p>Если вы не знаете, что такое хэш, вот <a href="https://learncryptography.com/hash-functions/what-are-hash-functions" rel="noopener noreferrer nofollow">объяснение</a>.</p><p><strong>На кого рассчитано это руководство?</strong> Вам должно быть комфортно читать и писать базовый код на Python, а также иметь некоторое представление о том, как работают HTTP-запросы, поскольку мы будем общаться с нашей цепочкой блоков через HTTP.</p><p><strong>Что мне нужно?</strong> Убедитесь, что установлен Python 3.6 + (вместе с pip). Вам также потребуется установить Flask и замечательную библиотеку requests:</p><pre><code class="python"> pip install Flask==0.12.2 requests==2.18.4 </code></pre><p>Вам также понадобится HTTP-клиент, например Postman или cURL. Но все подойдет.</p><p>Исходный код доступен <a href="https://github.com/dvf/blockchain" rel="noopener noreferrer nofollow">здесь</a>.</p><p><strong>Шаг 1. Создание блокчейна</strong></p><p>Откройте свой любимый текстовый редактор или IDE, лично я люблю PyCharm. Создайте новый файл с именем blockchain.py. Мы будем использовать только один файл, но, если вы потеряетесь, всегда можете обратиться к <a href="https://github.com/dvf/blockchain" rel="noopener noreferrer nofollow">исходному коду</a>.</p><p><em>Представление блокчейна</em></p><p>Мы создадим класс Blockchain, конструктор которого создает начальный пустой список (для хранения нашей цепочки блоков), другой - для хранения транзакций. Вот план нашего класса:</p><pre><code class="python">class Blockchain(object):
    def __init__(self):
        self.chain = []
        self.current_transactions = []
        
    def new_block(self):
        # Creates a new Block and adds it to the chain
        pass
    
    def new_transaction(self):
        # Adds a new transaction to the list of transactions
        pass
    
    @staticmethod
    def hash(block):
        # Hashes a Block
        pass

    @property
    def last_block(self):
        # Returns the last Block in the chain
        pass</code></pre><p>Наш класс Blockchain отвечает за управление цепочкой. Он будет хранить транзакции и иметь несколько вспомогательных методов для добавления новых блоков в цепочку. Давайте начнем конкретизировать некоторые методы.</p><p><em>Как выглядит блок?</em></p><p>Каждый блок имеет индекс, временную метку (во времени Unix), список транзакций, доказательство (подробнее об этом позже) и хэш предыдущего блока.</p><p>Вот пример того, как выглядит отдельный блок:</p><pre><code class="python">block = {
    'index': 1,
    'timestamp': 1506057125.900785,
    'transactions': [
        {
            'sender': "8527147fe1f5426f9dd545de4b27ee00",
            'recipient': "a77f5cdfa2934df3954a5c7c7da5df1f",
            'amount': 5,
        }
    ],
    'proof': 324984774000,
    'previous_hash': "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
}</code></pre><p>На этом этапе идея цепочки должна стать очевидной - каждый новый блок содержит в себе хэш предыдущего блока. Это очень важно, <strong>потому что это то, что обеспечивает неизменяемость блокчейна</strong>: если злоумышленник повредил более ранний блок в цепочке, то все последующие блоки будут содержать неправильный хэш.</p><p>Есть смысл? Если нет, привыкните - это основная идея, лежащая в основе блокчейна.</p><p><em>Добавление транзакций в блок</em></p><p>Нам понадобится способ добавления транзакций в блок. За это отвечает наш метод new_transaction(), и он довольно прост:</p><pre><code class="python">class Blockchain(object):
    ...
    
    def new_transaction(self, sender, recipient, amount):
        """
        Creates a new transaction to go into the next mined Block
        :param sender: &lt;str> Address of the Sender
        :param recipient: &lt;str> Address of the Recipient
        :param amount: &lt;int> Amount
        :return: &lt;int> The index of the Block that will hold this transaction
        """

        self.current_transactions.append({
            'sender': sender,
            'recipient': recipient,
            'amount': amount,
        })

        return self.last_block['index'] + 1</code></pre><p>После добавления транзакции в список он возвращает индекс блока, в который будет добавлена ​​транзакция - следующего блока, который будет добыт. Это будет полезно позже, для пользователя, отправляющего транзакцию.</p><p><em>Создание новых блоков</em></p><p>Когда наш экземпляр Blockchain будет создан, нам нужно будет засеять его генезисным блоком - блоком без предшественников. Нам также нужно будет добавить «доказательство» к нашему генезис-блоку, которое является результатом майнинга (или доказательства работы). Подробнее о майнинге поговорим позже.</p><p>Помимо создания генезис-блока в нашем конструкторе, мы также конкретизируем методы для new_block(), new_transaction() и hash():</p><pre><code class="python">import hashlib
import json
from time import time


class Blockchain(object):
    def __init__(self):
        self.current_transactions = []
        self.chain = []

        # Create the genesis block
        self.new_block(previous_hash=1, proof=100)

    def new_block(self, proof, previous_hash=None):
        """
        Create a new Block in the Blockchain
        :param proof: &lt;int> The proof given by the Proof of Work algorithm
        :param previous_hash: (Optional) &lt;str> Hash of previous Block
        :return: &lt;dict> New Block
        """

        block = {
            'index': len(self.chain) + 1,
            'timestamp': time(),
            'transactions': self.current_transactions,
            'proof': proof,
            'previous_hash': previous_hash or self.hash(self.chain[-1]),
        }

        # Reset the current list of transactions
        self.current_transactions = []

        self.chain.append(block)
        return block

    def new_transaction(self, sender, recipient, amount):
        """
        Creates a new transaction to go into the next mined Block
        :param sender: &lt;str> Address of the Sender
        :param recipient: &lt;str> Address of the Recipient
        :param amount: &lt;int> Amount
        :return: &lt;int> The index of the Block that will hold this transaction
        """
        self.current_transactions.append({
            'sender': sender,
            'recipient': recipient,
            'amount': amount,
        })

        return self.last_block['index'] + 1

    @property
    def last_block(self):
        return self.chain[-1]

    @staticmethod
    def hash(block):
        """
        Creates a SHA-256 hash of a Block
        :param block: &lt;dict> Block
        :return: &lt;str>
        """

        # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes
        block_string = json.dumps(block, sort_keys=True).encode()
        return hashlib.sha256(block_string).hexdigest()
  </code></pre><p>Вышеупомянутое должно быть понятно - я добавил несколько комментариев и строк документации. Мы почти закончили с представлением нашей цепочки блоков. Но вам должно быть интересно, как создаются или добываются новые блоки.</p><p><em>Понимание доказательства работы</em></p><p>Алгоритм Proof of Work (PoW) - это то, как новые блоки создаются или добываются в цепочке блоков. Цель PoW - найти число, которое решает проблему. <strong>Число должно быть трудно найти, но легко проверить</strong> - с точки зрения вычислений - кем угодно в сети. Это основная идея Proof of Work.</p><p>Мы рассмотрим очень простой пример, который поможет понять это.</p><p>Давайте решим, что хэш одного целого числа, x умноженного на другое, y должен заканчиваться на 0. Так, hash(x * y) = ac23dc...0. И для этого упрощенного примера давайте примем x = 5. Реализация этого в Python:</p><pre><code class="python">from hashlib import sha256
x = 5
y = 0  # We don't know what y should be yet...
while sha256(f'{x*y}'.encode()).hexdigest()[-1] != "0":
    y += 1
print(f'The solution is y = {y}')</code></pre><p>Решение здесь y = 21. Поскольку созданный хэш заканчивается на 0:</p><pre><code class="python">hash(5 * 21) = 1253e9373e...5e3600155e860</code></pre><p>В Биткойне алгоритм Proof of Work называется Hashcash. И он не слишком отличается от нашего базового примера выше. Это алгоритм, который майнеры пытаются решить, чтобы создать новый блок. Как правило, сложность определяется количеством символов, которые ищутся в строке. Затем майнеры награждаются за свое решение получением монеты - в транзакции.</p><p>Сеть способна легко проверить их решение.</p><p><em>Внедрение базового доказательства работы</em></p><p>Давайте реализуем аналогичный алгоритм для нашего блокчейна. Наше правило будет аналогично приведенному выше примеру:</p><p>Найдите число p, при хешировании которого с решением предыдущего блока получается хэш с 4 ведущими 0.</p><pre><code class="python">import hashlib
import json

from time import time
from uuid import uuid4


class Blockchain(object):
    ...
        
    def proof_of_work(self, last_proof):
        """
        Simple Proof of Work Algorithm:
         - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p'
         - p is the previous proof, and p' is the new proof
        :param last_proof: &lt;int>
        :return: &lt;int>
        """

        proof = 0
        while self.valid_proof(last_proof, proof) is False:
            proof += 1

        return proof

    @staticmethod
    def valid_proof(last_proof, proof):
        """
        Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?
        :param last_proof: &lt;int> Previous Proof
        :param proof: &lt;int> Current Proof
        :return: &lt;bool> True if correct, False if not.
        """

        guess = f'{last_proof}{proof}'.encode()
        guess_hash = hashlib.sha256(guess).hexdigest()
        return guess_hash[:4] == "0000"</code></pre><p>Чтобы отрегулировать сложность алгоритма, мы можем изменить количество ведущих нулей. Но 4 достаточно. Вы обнаружите, что добавление одного ведущего нуля значительно увеличивает время, необходимое для поиска решения.</p><p>Наш класс почти готов, и мы готовы начать с ним взаимодействовать с помощью HTTP-запросов.</p><p><strong>Шаг 2: Блокчейн как API</strong></p><p>Мы собираемся использовать Python Flask Framework. Это фреймворк, который упрощает сопоставление конечных точек с функциями Python. Это позволяет нам общаться с нашей цепочкой блоков через Интернет, используя HTTP-запросы.</p><p>Мы создадим три метода:</p><p>/transactions/new создать новую транзакцию в блоке</p><p>/mine чтобы сказать нашему серверу майнить новый блок.</p><p>/chain чтобы вернуть полную цепочку блоков.</p><p><em>Настройка Flask</em></p><p>Наш «сервер» сформирует единый узел в нашей сети блокчейнов. Создадим шаблонный код:</p><pre><code class="python">import hashlib
import json
from textwrap import dedent
from time import time
from uuid import uuid4

from flask import Flask


class Blockchain(object):
    ...


# Instantiate our Node
app = Flask(__name__)

# Generate a globally unique address for this node
node_identifier = str(uuid4()).replace('-', '')

# Instantiate the Blockchain
blockchain = Blockchain()


@app.route('/mine', methods=['GET'])
def mine():
    return "We'll mine a new Block"
  
@app.route('/transactions/new', methods=['POST'])
def new_transaction():
    return "We'll add a new transaction"

@app.route('/chain', methods=['GET'])
def full_chain():
    response = {
        'chain': blockchain.chain,
        'length': len(blockchain.chain),
    }
    return jsonify(response), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)</code></pre><p>Краткое объяснение того, что мы добавили выше:</p><p>Строка 15: создает экземпляр нашего узла. Узнайте больше о Flask <a href="http://flask.pocoo.org/docs/0.12/quickstart/#a-minimal-application" rel="noopener noreferrer nofollow">здесь</a>.</p><p>Строка 18: создание случайного имени для нашего узла.</p><p>Строка 21: создание экземпляра нашего Blockchain класса.</p><p>Строка 24–26: создание /mine конечной точки, которая является GET-запросом.</p><p>Строка 28–30: создание /transactions/new конечную точку, которая является POST-запросом, поскольку мы будем отправлять ей данные.</p><p>Строка 32–38: Создайте /chain конечную точку, которая возвращает полную цепочку блоков.</p><p>Строка 40–41: запускает сервер на порту 5000.</p><p><em>Конечная точка транзакций</em></p><p>Так будет выглядеть запрос на транзакцию. Это то, что пользователь отправляет на сервер:</p><pre><code class="python">{
 "sender": "my address",
 "recipient": "someone else's address",
 "amount": 5
}</code></pre><p>Поскольку у нас уже есть метод класса для добавления транзакций в блок, остальное легко. Напишем функцию добавления транзакций:</p><pre><code class="python">import hashlib
import json
from textwrap import dedent
from time import time
from uuid import uuid4

from flask import Flask, jsonify, request

...

@app.route('/transactions/new', methods=['POST'])
def new_transaction():
    values = request.get_json()

    # Check that the required fields are in the POST'ed data
    required = ['sender', 'recipient', 'amount']
    if not all(k in values for k in required):
        return 'Missing values', 400

    # Create a new Transaction
    index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount'])

    response = {'message': f'Transaction will be added to Block {index}'}
    return jsonify(response), 201</code></pre><p><em>Конечная точка майнинга</em></p><p>Наша конечная точка майнинга - это место, где происходит волшебство, и это легко. Она должна делать три вещи:</p><p>1.      Рассчитать Proof of Work</p><p>2.      Наградить майнера (нас), добавив транзакцию, дающую нам 1 монету.</p><p>3.      Создать новый блок, добавив его в цепочку</p><pre><code class="python">import hashlib
import json

from time import time
from uuid import uuid4

from flask import Flask, jsonify, request

...

@app.route('/mine', methods=['GET'])
def mine():
    # We run the proof of work algorithm to get the next proof...
    last_block = blockchain.last_block
    last_proof = last_block['proof']
    proof = blockchain.proof_of_work(last_proof)

    # We must receive a reward for finding the proof.
    # The sender is "0" to signify that this node has mined a new coin.
    blockchain.new_transaction(
        sender="0",
        recipient=node_identifier,
        amount=1,
    )

    # Forge the new Block by adding it to the chain
    previous_hash = blockchain.hash(last_block)
    block = blockchain.new_block(proof, previous_hash)

    response = {
        'message': "New Block Forged",
        'index': block['index'],
        'transactions': block['transactions'],
        'proof': block['proof'],
        'previous_hash': block['previous_hash'],
    }
    return jsonify(response), 200</code></pre><p>Обратите внимание, что получателем добытого блока является адрес нашего узла. И большая часть того, что мы здесь сделали, - это просто взаимодействие с методами нашего класса Blockchain. На этом мы закончили и можем начать взаимодействие с нашей цепочкой блоков.</p><p><strong>Шаг 3: Взаимодействие с нашей цепочкой блоков</strong></p><p>Вы можете использовать старый простой cURL или Postman для взаимодействия с нашим API по сети.</p><p>Запустите сервер:</p><pre><code class="python">$ python blockchain.py
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</code></pre><p>Попробуем добыть блок, запросив http://localhost:5000/mine:</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Используем Postman отправить GET-запрос" title="Используем Postman отправить GET-запрос" height="501" data-src="https://habrastorage.org/getpro/habr/upload_files/cc3/902/b38/cc3902b389b6bd708e4f2498e662206a.png" data-width="700"/><figcaption>Используем Postman отправить GET-запрос</figcaption></figure><p>Давайте создадим новую транзакцию, сделав POST-запрос к http://localhost:5000/transactions/new, содержащему нашу структуру транзакции:</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Используем Postman отправить POST-запрос" title="Используем Postman отправить POST-запрос" height="472" data-src="https://habrastorage.org/getpro/habr/upload_files/c5f/7b6/e1e/c5f7b6e1ebccfc373f3a3e19ddfe80be.png" data-width="700"/><figcaption>Используем Postman отправить POST-запрос</figcaption></figure><p>Если вы не используете Postman, вы можете сделать аналогичный запрос с помощью cURL:</p><pre><code class="bash">$ curl -X POST -H "Content-Type: application/json" -d '{
 "sender": "d4ee26eee15148ee92c6cd394edd974e",
 "recipient": "someone-other-address",
 "amount": 5
}' "http://localhost:5000/transactions/new"</code></pre><p>Я перезапустил свой сервер и добыл два блока, всего получилось 3. Давайте проверим всю цепочку, запросив http://localhost:5000/chain:</p><pre><code class="python">{
  "chain": [
    {
      "index": 1,
      "previous_hash": 1,
      "proof": 100,
      "timestamp": 1506280650.770839,
      "transactions": []
    },
    {
      "index": 2,
      "previous_hash": "c099bc...bfb7",
      "proof": 35293,
      "timestamp": 1506280664.717925,
      "transactions": [
        {
          "amount": 1,
          "recipient": "8bbcb347e0634905b0cac7955bae152b",
          "sender": "0"
        }
      ]
    },
    {
      "index": 3,
      "previous_hash": "eff91a...10f2",
      "proof": 35089,
      "timestamp": 1506280666.1086972,
      "transactions": [
        {
          "amount": 1,
          "recipient": "8bbcb347e0634905b0cac7955bae152b",
          "sender": "0"
        }
      ]
    }
  ],
  "length": 3
}</code></pre><p><strong>Шаг 4: консенсус</strong></p><p>Это очень круто. У нас есть базовая цепочка блоков, которая принимает транзакции и позволяет нам добывать новые блоки. Но весь смысл блокчейна в том, что они должны быть децентрализованными . И если они децентрализованы, как мы можем гарантировать, что все они отражают одну и ту же цепочку? Это называется проблемой консенсуса, и нам придется реализовать алгоритм консенсуса, если мы хотим, чтобы в нашей сети было более одного узла.</p><p><em>Регистрация новых узлов</em></p><p>Прежде чем мы сможем реализовать алгоритм консенсуса, нам нужен способ сообщить узлу о соседних узлах в сети. Каждый узел в нашей сети должен вести реестр других узлов в сети. Таким образом, нам понадобится еще несколько конечных точек:</p><p>/nodes/register принять список новых узлов в виде URL-адресов.</p><p>/nodes/resolve для реализации нашего алгоритма консенсуса, который разрешает любые конфликты, чтобы гарантировать, что узел имеет правильную цепочку.</p><p>Нам нужно будет изменить конструктор нашей цепочки блоков и предоставить метод для регистрации узлов:</p><pre><code class="python">...
from urllib.parse import urlparse
...


class Blockchain(object):
    def __init__(self):
        ...
        self.nodes = set()
        ...

    def register_node(self, address):
        """
        Add a new node to the list of nodes
        :param address: &lt;str> Address of node. Eg. 'http://192.168.0.5:5000'
        :return: None
        """

        parsed_url = urlparse(address)
        self.nodes.add(parsed_url.netloc)</code></pre><p>Обратите внимание, что мы использовали set() для хранения списка узлов. Это дешевый способ гарантировать, что добавление новых узлов идемпотентно, то есть независимо от того, сколько раз мы добавляем конкретный узел, он появляется только один раз.</p><p><em>Реализация алгоритма консенсуса</em></p><p>Как уже упоминалось, конфликт возникает, когда один узел имеет цепочку, отличную от другой. Чтобы решить эту проблему, мы примем правило, что самая длинная действительная цепочка является авторитетной. Другими словами, де-факто самая длинная цепочка в сети. Используя этот алгоритм, мы достигаем консенсуса между узлами в нашей сети.</p><pre><code class="python">...
import requests


class Blockchain(object)
    ...
    
    def valid_chain(self, chain):
        """
        Determine if a given blockchain is valid
        :param chain: &lt;list> A blockchain
        :return: &lt;bool> True if valid, False if not
        """

        last_block = chain[0]
        current_index = 1

        while current_index &lt; len(chain):
            block = chain[current_index]
            print(f'{last_block}')
            print(f'{block}')
            print("\n-----------\n")
            # Check that the hash of the block is correct
            if block['previous_hash'] != self.hash(last_block):
                return False

            # Check that the Proof of Work is correct
            if not self.valid_proof(last_block['proof'], block['proof']):
                return False

            last_block = block
            current_index += 1

        return True

    def resolve_conflicts(self):
        """
        This is our Consensus Algorithm, it resolves conflicts
        by replacing our chain with the longest one in the network.
        :return: &lt;bool> True if our chain was replaced, False if not
        """

        neighbours = self.nodes
        new_chain = None

        # We're only looking for chains longer than ours
        max_length = len(self.chain)

        # Grab and verify the chains from all the nodes in our network
        for node in neighbours:
            response = requests.get(f'http://{node}/chain')

            if response.status_code == 200:
                length = response.json()['length']
                chain = response.json()['chain']

                # Check if the length is longer and the chain is valid
                if length > max_length and self.valid_chain(chain):
                    max_length = length
                    new_chain = chain

        # Replace our chain if we discovered a new, valid chain longer than ours
        if new_chain:
            self.chain = new_chain
            return True

        return False</code></pre><p>Первый метод valid_chain() отвечает за проверку правильности цепочки путем обхода каждого блока и проверки как хэша, так и доказательства.</p><p>resolve_conflicts() - это метод, который просматривает все наши соседние узлы, загружает их цепочки и проверяет их, используя описанный выше метод<strong>. Если найдена допустимая цепочка, длина которой больше нашей, мы заменяем нашу.</strong></p><p>Давайте зарегистрируем две конечные точки в нашем API, одну для добавления соседних узлов, а другую для разрешения конфликтов:</p><pre><code class="python">@app.route('/nodes/register', methods=['POST'])
def register_nodes():
    values = request.get_json()

    nodes = values.get('nodes')
    if nodes is None:
        return "Error: Please supply a valid list of nodes", 400

    for node in nodes:
        blockchain.register_node(node)

    response = {
        'message': 'New nodes have been added',
        'total_nodes': list(blockchain.nodes),
    }
    return jsonify(response), 201


@app.route('/nodes/resolve', methods=['GET'])
def consensus():
    replaced = blockchain.resolve_conflicts()

    if replaced:
        response = {
            'message': 'Our chain was replaced',
            'new_chain': blockchain.chain
        }
    else:
        response = {
            'message': 'Our chain is authoritative',
            'chain': blockchain.chain
        }

    return jsonify(response), 200</code></pre><p>На этом этапе вы можете взять другую машину, если хотите, и развернуть разные узлы в своей сети. Или запустите процессы, используя разные порты на одной машине. Я развернул еще один узел на своей машине, на другом порту, и зарегистрировал его на моем текущем узле. Таким образом, у меня есть два узла: http://localhost:5000 и http://localhost:5001.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Регистрация нового узла" title="Регистрация нового узла" height="397" data-src="https://habrastorage.org/getpro/habr/upload_files/088/03d/65c/08803d65c9955d73e59c89122fdd058e.png" data-width="700"/><figcaption>Регистрация нового узла</figcaption></figure><p>Затем я добыл несколько новых блоков на узле 2, чтобы цепочка была длиннее. После этого я вызвал /nodes/resolve узел 1, где цепочка была заменена алгоритмом консенсуса:</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Алгоритм консенсуса" title="Алгоритм консенсуса" height="445" data-src="https://habrastorage.org/getpro/habr/upload_files/11d/128/e19/11d128e19b1de58a3b8faab8a46bb2e6.png" data-width="700"/><figcaption>Алгоритм консенсуса</figcaption></figure><p>На этом все ... Соберите вместе друзей, чтобы они помогли протестировать ваш блокчейн.</p><p>Надеюсь, это вдохновило вас на создание чего-то нового. Я в восторге от криптовалют, потому что считаю, что блокчейн быстро изменят наши представления об экономике, правительстве и ведении учета.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%5D" class="tm-tags-list__link">блокчейн</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpython%5D" class="tm-tags-list__link">python</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">программирование</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/python/" class="tm-hubs-list__link">
    Python
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 12: ↑12 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 12: ↑12 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+12</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">8.7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    126
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/urticazoku/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/668/5ff/baf/6685ffbaff7df8ed99dd8702e17f95e3.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 136 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    103.7
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">69.8</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/urticazoku/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @urticazoku
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <button type="submit" class="tm-user-card__button btn btn_transparent btn_small">
      Задонатить
    </button> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/583606/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 21 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/583606/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/583606/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"583606":{"id":"583606","timePublished":"2021-10-15T07:08:11+00:00","isCorporative":false,"lang":"ru","titleHtml":"Пишем свой блокчейн","leadData":{"textHtml":"\u003Cp\u003EВы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.\u003C\u002Fp\u003E\u003Cp\u003EНо понять блокчейн непросто - по крайней мере, не для меня. Я пробирался через тупые видео, следовал руководствам и разочаровывался из-за слишком малого количества примеров.\u003C\u002Fp\u003E\u003Cp\u003EМне нравится учиться на практике. Это заставляет меня заниматься предметом на уровне кода, что разжигает любопытство. Если вы сделаете то же самое, в конце этого руководства у вас будет работающий блокчейн с твердым пониманием того, как он работает.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F59\u002Fd4\u002F79\u002F59d479e1ed4da475699339.jpeg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F59\u002Fd4\u002F79\u002F59d479e1ed4da475699339.jpeg","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Daniel van Flymen","originalUrl":"https:\u002F\u002Fmedium.com\u002F@vanflymen\u002Flearn-blockchains-by-building-one-117428612f46"}},{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":103.7,"votesCount":136},"rating":69.8,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":"urticazoku","paymentWebmoney":null},"id":"262357","alias":"urticazoku","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F668\u002F5ff\u002Fbaf\u002F6685ffbaff7df8ed99dd8702e17f95e3.jpg","speciality":"Пользователь"},"statistics":{"commentsCount":21,"favoritesCount":126,"readingCount":8676,"score":12,"votesCount":12},"hubs":[{"relatedData":null,"id":"340","alias":"python","type":"collective","title":"Python","titleHtml":"Python","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002F59\u002Fd4\u002F79\u002F59d479e1ed4da475699339.jpeg\" width=\"1800\" height=\"931\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F59\u002Fd4\u002F79\u002F59d479e1ed4da475699339.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.\u003C\u002Fp\u003E\u003Cp\u003EНо понять блокчейн непросто - по крайней мере, не для меня. Я пробирался через тупые видео, следовал руководствам и разочаровывался из-за слишком малого количества примеров.\u003C\u002Fp\u003E\u003Cp\u003EМне нравится учиться на практике. Это заставляет меня заниматься предметом на уровне кода, что разжигает любопытство. Если вы сделаете то же самое, в конце этого руководства у вас будет работающий блокчейн с твердым пониманием того, как он работает.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EПрежде, чем начать\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EПомните, что блокчейн – неизменяемая, последовательная цепочка записей, называемых блоками. Они могут содержать транзакции, файлы или любые данные. Важно, что они соединены друг с другом с помощью хэша.\u003C\u002Fp\u003E\u003Cp\u003EЕсли вы не знаете, что такое хэш, вот \u003Ca href=\"https:\u002F\u002Flearncryptography.com\u002Fhash-functions\u002Fwhat-are-hash-functions\" rel=\"noopener noreferrer nofollow\"\u003Eобъяснение\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EНа кого рассчитано это руководство?\u003C\u002Fstrong\u003E Вам должно быть комфортно читать и писать базовый код на Python, а также иметь некоторое представление о том, как работают HTTP-запросы, поскольку мы будем общаться с нашей цепочкой блоков через HTTP.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EЧто мне нужно?\u003C\u002Fstrong\u003E Убедитесь, что установлен Python 3.6 + (вместе с pip). Вам также потребуется установить Flask и замечательную библиотеку requests:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E pip install Flask==0.12.2 requests==2.18.4 \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВам также понадобится HTTP-клиент, например Postman или cURL. Но все подойдет.\u003C\u002Fp\u003E\u003Cp\u003EИсходный код доступен \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdvf\u002Fblockchain\" rel=\"noopener noreferrer nofollow\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EШаг 1. Создание блокчейна\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EОткройте свой любимый текстовый редактор или IDE, лично я люблю PyCharm. Создайте новый файл с именем blockchain.py. Мы будем использовать только один файл, но, если вы потеряетесь, всегда можете обратиться к \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdvf\u002Fblockchain\" rel=\"noopener noreferrer nofollow\"\u003Eисходному коду\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EПредставление блокчейна\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EМы создадим класс Blockchain, конструктор которого создает начальный пустой список (для хранения нашей цепочки блоков), другой - для хранения транзакций. Вот план нашего класса:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass Blockchain(object):\n    def __init__(self):\n        self.chain = []\n        self.current_transactions = []\n        \n    def new_block(self):\n        # Creates a new Block and adds it to the chain\n        pass\n    \n    def new_transaction(self):\n        # Adds a new transaction to the list of transactions\n        pass\n    \n    @staticmethod\n    def hash(block):\n        # Hashes a Block\n        pass\n\n    @property\n    def last_block(self):\n        # Returns the last Block in the chain\n        pass\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНаш класс Blockchain отвечает за управление цепочкой. Он будет хранить транзакции и иметь несколько вспомогательных методов для добавления новых блоков в цепочку. Давайте начнем конкретизировать некоторые методы.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EКак выглядит блок?\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EКаждый блок имеет индекс, временную метку (во времени Unix), список транзакций, доказательство (подробнее об этом позже) и хэш предыдущего блока.\u003C\u002Fp\u003E\u003Cp\u003EВот пример того, как выглядит отдельный блок:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eblock = {\n    'index': 1,\n    'timestamp': 1506057125.900785,\n    'transactions': [\n        {\n            'sender': \"8527147fe1f5426f9dd545de4b27ee00\",\n            'recipient': \"a77f5cdfa2934df3954a5c7c7da5df1f\",\n            'amount': 5,\n        }\n    ],\n    'proof': 324984774000,\n    'previous_hash': \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНа этом этапе идея цепочки должна стать очевидной - каждый новый блок содержит в себе хэш предыдущего блока. Это очень важно, \u003Cstrong\u003Eпотому что это то, что обеспечивает неизменяемость блокчейна\u003C\u002Fstrong\u003E: если злоумышленник повредил более ранний блок в цепочке, то все последующие блоки будут содержать неправильный хэш.\u003C\u002Fp\u003E\u003Cp\u003EЕсть смысл? Если нет, привыкните - это основная идея, лежащая в основе блокчейна.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EДобавление транзакций в блок\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EНам понадобится способ добавления транзакций в блок. За это отвечает наш метод new_transaction(), и он довольно прост:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass Blockchain(object):\n    ...\n    \n    def new_transaction(self, sender, recipient, amount):\n        \"\"\"\n        Creates a new transaction to go into the next mined Block\n        :param sender: &lt;str\u003E Address of the Sender\n        :param recipient: &lt;str\u003E Address of the Recipient\n        :param amount: &lt;int\u003E Amount\n        :return: &lt;int\u003E The index of the Block that will hold this transaction\n        \"\"\"\n\n        self.current_transactions.append({\n            'sender': sender,\n            'recipient': recipient,\n            'amount': amount,\n        })\n\n        return self.last_block['index'] + 1\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПосле добавления транзакции в список он возвращает индекс блока, в который будет добавлена ​​транзакция - следующего блока, который будет добыт. Это будет полезно позже, для пользователя, отправляющего транзакцию.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСоздание новых блоков\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EКогда наш экземпляр Blockchain будет создан, нам нужно будет засеять его генезисным блоком - блоком без предшественников. Нам также нужно будет добавить «доказательство» к нашему генезис-блоку, которое является результатом майнинга (или доказательства работы). Подробнее о майнинге поговорим позже.\u003C\u002Fp\u003E\u003Cp\u003EПомимо создания генезис-блока в нашем конструкторе, мы также конкретизируем методы для new_block(), new_transaction() и hash():\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport hashlib\nimport json\nfrom time import time\n\n\nclass Blockchain(object):\n    def __init__(self):\n        self.current_transactions = []\n        self.chain = []\n\n        # Create the genesis block\n        self.new_block(previous_hash=1, proof=100)\n\n    def new_block(self, proof, previous_hash=None):\n        \"\"\"\n        Create a new Block in the Blockchain\n        :param proof: &lt;int\u003E The proof given by the Proof of Work algorithm\n        :param previous_hash: (Optional) &lt;str\u003E Hash of previous Block\n        :return: &lt;dict\u003E New Block\n        \"\"\"\n\n        block = {\n            'index': len(self.chain) + 1,\n            'timestamp': time(),\n            'transactions': self.current_transactions,\n            'proof': proof,\n            'previous_hash': previous_hash or self.hash(self.chain[-1]),\n        }\n\n        # Reset the current list of transactions\n        self.current_transactions = []\n\n        self.chain.append(block)\n        return block\n\n    def new_transaction(self, sender, recipient, amount):\n        \"\"\"\n        Creates a new transaction to go into the next mined Block\n        :param sender: &lt;str\u003E Address of the Sender\n        :param recipient: &lt;str\u003E Address of the Recipient\n        :param amount: &lt;int\u003E Amount\n        :return: &lt;int\u003E The index of the Block that will hold this transaction\n        \"\"\"\n        self.current_transactions.append({\n            'sender': sender,\n            'recipient': recipient,\n            'amount': amount,\n        })\n\n        return self.last_block['index'] + 1\n\n    @property\n    def last_block(self):\n        return self.chain[-1]\n\n    @staticmethod\n    def hash(block):\n        \"\"\"\n        Creates a SHA-256 hash of a Block\n        :param block: &lt;dict\u003E Block\n        :return: &lt;str\u003E\n        \"\"\"\n\n        # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes\n        block_string = json.dumps(block, sort_keys=True).encode()\n        return hashlib.sha256(block_string).hexdigest()\n  \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВышеупомянутое должно быть понятно - я добавил несколько комментариев и строк документации. Мы почти закончили с представлением нашей цепочки блоков. Но вам должно быть интересно, как создаются или добываются новые блоки.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EПонимание доказательства работы\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EАлгоритм Proof of Work (PoW) - это то, как новые блоки создаются или добываются в цепочке блоков. Цель PoW - найти число, которое решает проблему. \u003Cstrong\u003EЧисло должно быть трудно найти, но легко проверить\u003C\u002Fstrong\u003E - с точки зрения вычислений - кем угодно в сети. Это основная идея Proof of Work.\u003C\u002Fp\u003E\u003Cp\u003EМы рассмотрим очень простой пример, который поможет понять это.\u003C\u002Fp\u003E\u003Cp\u003EДавайте решим, что хэш одного целого числа, x умноженного на другое, y должен заканчиваться на 0. Так, hash(x * y) = ac23dc...0. И для этого упрощенного примера давайте примем x = 5. Реализация этого в Python:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efrom hashlib import sha256\nx = 5\ny = 0  # We don't know what y should be yet...\nwhile sha256(f'{x*y}'.encode()).hexdigest()[-1] != \"0\":\n    y += 1\nprint(f'The solution is y = {y}')\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EРешение здесь y = 21. Поскольку созданный хэш заканчивается на 0:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ehash(5 * 21) = 1253e9373e...5e3600155e860\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ Биткойне алгоритм Proof of Work называется Hashcash. И он не слишком отличается от нашего базового примера выше. Это алгоритм, который майнеры пытаются решить, чтобы создать новый блок. Как правило, сложность определяется количеством символов, которые ищутся в строке. Затем майнеры награждаются за свое решение получением монеты - в транзакции.\u003C\u002Fp\u003E\u003Cp\u003EСеть способна легко проверить их решение.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EВнедрение базового доказательства работы\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EДавайте реализуем аналогичный алгоритм для нашего блокчейна. Наше правило будет аналогично приведенному выше примеру:\u003C\u002Fp\u003E\u003Cp\u003EНайдите число p, при хешировании которого с решением предыдущего блока получается хэш с 4 ведущими 0.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport hashlib\nimport json\n\nfrom time import time\nfrom uuid import uuid4\n\n\nclass Blockchain(object):\n    ...\n        \n    def proof_of_work(self, last_proof):\n        \"\"\"\n        Simple Proof of Work Algorithm:\n         - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p'\n         - p is the previous proof, and p' is the new proof\n        :param last_proof: &lt;int\u003E\n        :return: &lt;int\u003E\n        \"\"\"\n\n        proof = 0\n        while self.valid_proof(last_proof, proof) is False:\n            proof += 1\n\n        return proof\n\n    @staticmethod\n    def valid_proof(last_proof, proof):\n        \"\"\"\n        Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?\n        :param last_proof: &lt;int\u003E Previous Proof\n        :param proof: &lt;int\u003E Current Proof\n        :return: &lt;bool\u003E True if correct, False if not.\n        \"\"\"\n\n        guess = f'{last_proof}{proof}'.encode()\n        guess_hash = hashlib.sha256(guess).hexdigest()\n        return guess_hash[:4] == \"0000\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЧтобы отрегулировать сложность алгоритма, мы можем изменить количество ведущих нулей. Но 4 достаточно. Вы обнаружите, что добавление одного ведущего нуля значительно увеличивает время, необходимое для поиска решения.\u003C\u002Fp\u003E\u003Cp\u003EНаш класс почти готов, и мы готовы начать с ним взаимодействовать с помощью HTTP-запросов.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EШаг 2: Блокчейн как API\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EМы собираемся использовать Python Flask Framework. Это фреймворк, который упрощает сопоставление конечных точек с функциями Python. Это позволяет нам общаться с нашей цепочкой блоков через Интернет, используя HTTP-запросы.\u003C\u002Fp\u003E\u003Cp\u003EМы создадим три метода:\u003C\u002Fp\u003E\u003Cp\u003E\u002Ftransactions\u002Fnew создать новую транзакцию в блоке\u003C\u002Fp\u003E\u003Cp\u003E\u002Fmine чтобы сказать нашему серверу майнить новый блок.\u003C\u002Fp\u003E\u003Cp\u003E\u002Fchain чтобы вернуть полную цепочку блоков.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EНастройка Flask\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EНаш «сервер» сформирует единый узел в нашей сети блокчейнов. Создадим шаблонный код:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport hashlib\nimport json\nfrom textwrap import dedent\nfrom time import time\nfrom uuid import uuid4\n\nfrom flask import Flask\n\n\nclass Blockchain(object):\n    ...\n\n\n# Instantiate our Node\napp = Flask(__name__)\n\n# Generate a globally unique address for this node\nnode_identifier = str(uuid4()).replace('-', '')\n\n# Instantiate the Blockchain\nblockchain = Blockchain()\n\n\n@app.route('\u002Fmine', methods=['GET'])\ndef mine():\n    return \"We'll mine a new Block\"\n  \n@app.route('\u002Ftransactions\u002Fnew', methods=['POST'])\ndef new_transaction():\n    return \"We'll add a new transaction\"\n\n@app.route('\u002Fchain', methods=['GET'])\ndef full_chain():\n    response = {\n        'chain': blockchain.chain,\n        'length': len(blockchain.chain),\n    }\n    return jsonify(response), 200\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКраткое объяснение того, что мы добавили выше:\u003C\u002Fp\u003E\u003Cp\u003EСтрока 15: создает экземпляр нашего узла. Узнайте больше о Flask \u003Ca href=\"http:\u002F\u002Fflask.pocoo.org\u002Fdocs\u002F0.12\u002Fquickstart\u002F#a-minimal-application\" rel=\"noopener noreferrer nofollow\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EСтрока 18: создание случайного имени для нашего узла.\u003C\u002Fp\u003E\u003Cp\u003EСтрока 21: создание экземпляра нашего Blockchain класса.\u003C\u002Fp\u003E\u003Cp\u003EСтрока 24–26: создание \u002Fmine конечной точки, которая является GET-запросом.\u003C\u002Fp\u003E\u003Cp\u003EСтрока 28–30: создание \u002Ftransactions\u002Fnew конечную точку, которая является POST-запросом, поскольку мы будем отправлять ей данные.\u003C\u002Fp\u003E\u003Cp\u003EСтрока 32–38: Создайте \u002Fchain конечную точку, которая возвращает полную цепочку блоков.\u003C\u002Fp\u003E\u003Cp\u003EСтрока 40–41: запускает сервер на порту 5000.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EКонечная точка транзакций\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EТак будет выглядеть запрос на транзакцию. Это то, что пользователь отправляет на сервер:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E{\n \"sender\": \"my address\",\n \"recipient\": \"someone else's address\",\n \"amount\": 5\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПоскольку у нас уже есть метод класса для добавления транзакций в блок, остальное легко. Напишем функцию добавления транзакций:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport hashlib\nimport json\nfrom textwrap import dedent\nfrom time import time\nfrom uuid import uuid4\n\nfrom flask import Flask, jsonify, request\n\n...\n\n@app.route('\u002Ftransactions\u002Fnew', methods=['POST'])\ndef new_transaction():\n    values = request.get_json()\n\n    # Check that the required fields are in the POST'ed data\n    required = ['sender', 'recipient', 'amount']\n    if not all(k in values for k in required):\n        return 'Missing values', 400\n\n    # Create a new Transaction\n    index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount'])\n\n    response = {'message': f'Transaction will be added to Block {index}'}\n    return jsonify(response), 201\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cem\u003EКонечная точка майнинга\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EНаша конечная точка майнинга - это место, где происходит волшебство, и это легко. Она должна делать три вещи:\u003C\u002Fp\u003E\u003Cp\u003E1.      Рассчитать Proof of Work\u003C\u002Fp\u003E\u003Cp\u003E2.      Наградить майнера (нас), добавив транзакцию, дающую нам 1 монету.\u003C\u002Fp\u003E\u003Cp\u003E3.      Создать новый блок, добавив его в цепочку\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport hashlib\nimport json\n\nfrom time import time\nfrom uuid import uuid4\n\nfrom flask import Flask, jsonify, request\n\n...\n\n@app.route('\u002Fmine', methods=['GET'])\ndef mine():\n    # We run the proof of work algorithm to get the next proof...\n    last_block = blockchain.last_block\n    last_proof = last_block['proof']\n    proof = blockchain.proof_of_work(last_proof)\n\n    # We must receive a reward for finding the proof.\n    # The sender is \"0\" to signify that this node has mined a new coin.\n    blockchain.new_transaction(\n        sender=\"0\",\n        recipient=node_identifier,\n        amount=1,\n    )\n\n    # Forge the new Block by adding it to the chain\n    previous_hash = blockchain.hash(last_block)\n    block = blockchain.new_block(proof, previous_hash)\n\n    response = {\n        'message': \"New Block Forged\",\n        'index': block['index'],\n        'transactions': block['transactions'],\n        'proof': block['proof'],\n        'previous_hash': block['previous_hash'],\n    }\n    return jsonify(response), 200\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОбратите внимание, что получателем добытого блока является адрес нашего узла. И большая часть того, что мы здесь сделали, - это просто взаимодействие с методами нашего класса Blockchain. На этом мы закончили и можем начать взаимодействие с нашей цепочкой блоков.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EШаг 3: Взаимодействие с нашей цепочкой блоков\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EВы можете использовать старый простой cURL или Postman для взаимодействия с нашим API по сети.\u003C\u002Fp\u003E\u003Cp\u003EЗапустите сервер:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E$ python blockchain.py\n* Running on http:\u002F\u002F127.0.0.1:5000\u002F (Press CTRL+C to quit)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПопробуем добыть блок, запросив http:\u002F\u002Flocalhost:5000\u002Fmine:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Используем Postman отправить GET-запрос\" title=\"Используем Postman отправить GET-запрос\" height=\"501\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcc3\u002F902\u002Fb38\u002Fcc3902b389b6bd708e4f2498e662206a.png\" data-width=\"700\"\u002F\u003E\u003Cfigcaption\u003EИспользуем Postman отправить GET-запрос\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДавайте создадим новую транзакцию, сделав POST-запрос к http:\u002F\u002Flocalhost:5000\u002Ftransactions\u002Fnew, содержащему нашу структуру транзакции:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Используем Postman отправить POST-запрос\" title=\"Используем Postman отправить POST-запрос\" height=\"472\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc5f\u002F7b6\u002Fe1e\u002Fc5f7b6e1ebccfc373f3a3e19ddfe80be.png\" data-width=\"700\"\u002F\u003E\u003Cfigcaption\u003EИспользуем Postman отправить POST-запрос\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЕсли вы не используете Postman, вы можете сделать аналогичный запрос с помощью cURL:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E$ curl -X POST -H \"Content-Type: application\u002Fjson\" -d '{\n \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\",\n \"recipient\": \"someone-other-address\",\n \"amount\": 5\n}' \"http:\u002F\u002Flocalhost:5000\u002Ftransactions\u002Fnew\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЯ перезапустил свой сервер и добыл два блока, всего получилось 3. Давайте проверим всю цепочку, запросив http:\u002F\u002Flocalhost:5000\u002Fchain:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E{\n  \"chain\": [\n    {\n      \"index\": 1,\n      \"previous_hash\": 1,\n      \"proof\": 100,\n      \"timestamp\": 1506280650.770839,\n      \"transactions\": []\n    },\n    {\n      \"index\": 2,\n      \"previous_hash\": \"c099bc...bfb7\",\n      \"proof\": 35293,\n      \"timestamp\": 1506280664.717925,\n      \"transactions\": [\n        {\n          \"amount\": 1,\n          \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\",\n          \"sender\": \"0\"\n        }\n      ]\n    },\n    {\n      \"index\": 3,\n      \"previous_hash\": \"eff91a...10f2\",\n      \"proof\": 35089,\n      \"timestamp\": 1506280666.1086972,\n      \"transactions\": [\n        {\n          \"amount\": 1,\n          \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\",\n          \"sender\": \"0\"\n        }\n      ]\n    }\n  ],\n  \"length\": 3\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cstrong\u003EШаг 4: консенсус\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EЭто очень круто. У нас есть базовая цепочка блоков, которая принимает транзакции и позволяет нам добывать новые блоки. Но весь смысл блокчейна в том, что они должны быть децентрализованными . И если они децентрализованы, как мы можем гарантировать, что все они отражают одну и ту же цепочку? Это называется проблемой консенсуса, и нам придется реализовать алгоритм консенсуса, если мы хотим, чтобы в нашей сети было более одного узла.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EРегистрация новых узлов\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EПрежде чем мы сможем реализовать алгоритм консенсуса, нам нужен способ сообщить узлу о соседних узлах в сети. Каждый узел в нашей сети должен вести реестр других узлов в сети. Таким образом, нам понадобится еще несколько конечных точек:\u003C\u002Fp\u003E\u003Cp\u003E\u002Fnodes\u002Fregister принять список новых узлов в виде URL-адресов.\u003C\u002Fp\u003E\u003Cp\u003E\u002Fnodes\u002Fresolve для реализации нашего алгоритма консенсуса, который разрешает любые конфликты, чтобы гарантировать, что узел имеет правильную цепочку.\u003C\u002Fp\u003E\u003Cp\u003EНам нужно будет изменить конструктор нашей цепочки блоков и предоставить метод для регистрации узлов:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E...\nfrom urllib.parse import urlparse\n...\n\n\nclass Blockchain(object):\n    def __init__(self):\n        ...\n        self.nodes = set()\n        ...\n\n    def register_node(self, address):\n        \"\"\"\n        Add a new node to the list of nodes\n        :param address: &lt;str\u003E Address of node. Eg. 'http:\u002F\u002F192.168.0.5:5000'\n        :return: None\n        \"\"\"\n\n        parsed_url = urlparse(address)\n        self.nodes.add(parsed_url.netloc)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОбратите внимание, что мы использовали set() для хранения списка узлов. Это дешевый способ гарантировать, что добавление новых узлов идемпотентно, то есть независимо от того, сколько раз мы добавляем конкретный узел, он появляется только один раз.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EРеализация алгоритма консенсуса\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EКак уже упоминалось, конфликт возникает, когда один узел имеет цепочку, отличную от другой. Чтобы решить эту проблему, мы примем правило, что самая длинная действительная цепочка является авторитетной. Другими словами, де-факто самая длинная цепочка в сети. Используя этот алгоритм, мы достигаем консенсуса между узлами в нашей сети.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E...\nimport requests\n\n\nclass Blockchain(object)\n    ...\n    \n    def valid_chain(self, chain):\n        \"\"\"\n        Determine if a given blockchain is valid\n        :param chain: &lt;list\u003E A blockchain\n        :return: &lt;bool\u003E True if valid, False if not\n        \"\"\"\n\n        last_block = chain[0]\n        current_index = 1\n\n        while current_index &lt; len(chain):\n            block = chain[current_index]\n            print(f'{last_block}')\n            print(f'{block}')\n            print(\"\\n-----------\\n\")\n            # Check that the hash of the block is correct\n            if block['previous_hash'] != self.hash(last_block):\n                return False\n\n            # Check that the Proof of Work is correct\n            if not self.valid_proof(last_block['proof'], block['proof']):\n                return False\n\n            last_block = block\n            current_index += 1\n\n        return True\n\n    def resolve_conflicts(self):\n        \"\"\"\n        This is our Consensus Algorithm, it resolves conflicts\n        by replacing our chain with the longest one in the network.\n        :return: &lt;bool\u003E True if our chain was replaced, False if not\n        \"\"\"\n\n        neighbours = self.nodes\n        new_chain = None\n\n        # We're only looking for chains longer than ours\n        max_length = len(self.chain)\n\n        # Grab and verify the chains from all the nodes in our network\n        for node in neighbours:\n            response = requests.get(f'http:\u002F\u002F{node}\u002Fchain')\n\n            if response.status_code == 200:\n                length = response.json()['length']\n                chain = response.json()['chain']\n\n                # Check if the length is longer and the chain is valid\n                if length \u003E max_length and self.valid_chain(chain):\n                    max_length = length\n                    new_chain = chain\n\n        # Replace our chain if we discovered a new, valid chain longer than ours\n        if new_chain:\n            self.chain = new_chain\n            return True\n\n        return False\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПервый метод valid_chain() отвечает за проверку правильности цепочки путем обхода каждого блока и проверки как хэша, так и доказательства.\u003C\u002Fp\u003E\u003Cp\u003Eresolve_conflicts() - это метод, который просматривает все наши соседние узлы, загружает их цепочки и проверяет их, используя описанный выше метод\u003Cstrong\u003E. Если найдена допустимая цепочка, длина которой больше нашей, мы заменяем нашу.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EДавайте зарегистрируем две конечные точки в нашем API, одну для добавления соседних узлов, а другую для разрешения конфликтов:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"python\"\u003E@app.route('\u002Fnodes\u002Fregister', methods=['POST'])\ndef register_nodes():\n    values = request.get_json()\n\n    nodes = values.get('nodes')\n    if nodes is None:\n        return \"Error: Please supply a valid list of nodes\", 400\n\n    for node in nodes:\n        blockchain.register_node(node)\n\n    response = {\n        'message': 'New nodes have been added',\n        'total_nodes': list(blockchain.nodes),\n    }\n    return jsonify(response), 201\n\n\n@app.route('\u002Fnodes\u002Fresolve', methods=['GET'])\ndef consensus():\n    replaced = blockchain.resolve_conflicts()\n\n    if replaced:\n        response = {\n            'message': 'Our chain was replaced',\n            'new_chain': blockchain.chain\n        }\n    else:\n        response = {\n            'message': 'Our chain is authoritative',\n            'chain': blockchain.chain\n        }\n\n    return jsonify(response), 200\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНа этом этапе вы можете взять другую машину, если хотите, и развернуть разные узлы в своей сети. Или запустите процессы, используя разные порты на одной машине. Я развернул еще один узел на своей машине, на другом порту, и зарегистрировал его на моем текущем узле. Таким образом, у меня есть два узла: http:\u002F\u002Flocalhost:5000 и http:\u002F\u002Flocalhost:5001.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Регистрация нового узла\" title=\"Регистрация нового узла\" height=\"397\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F088\u002F03d\u002F65c\u002F08803d65c9955d73e59c89122fdd058e.png\" data-width=\"700\"\u002F\u003E\u003Cfigcaption\u003EРегистрация нового узла\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЗатем я добыл несколько новых блоков на узле 2, чтобы цепочка была длиннее. После этого я вызвал \u002Fnodes\u002Fresolve узел 1, где цепочка была заменена алгоритмом консенсуса:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Алгоритм консенсуса\" title=\"Алгоритм консенсуса\" height=\"445\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F11d\u002F128\u002Fe19\u002F11d128e19b1de58a3b8faab8a46bb2e6.png\" data-width=\"700\"\u002F\u003E\u003Cfigcaption\u003EАлгоритм консенсуса\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EНа этом все ... Соберите вместе друзей, чтобы они помогли протестировать ваш блокчейн.\u003C\u002Fp\u003E\u003Cp\u003EНадеюсь, это вдохновило вас на создание чего-то нового. Я в восторге от криптовалют, потому что считаю, что блокчейн быстро изменят наши представления об экономике, правительстве и ведении учета.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"блокчейн"},{"titleHtml":"python"},{"titleHtml":"программирование"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F59\u002Fd4\u002F79\u002F59d479e1ed4da475699339.jpeg","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F59\u002Fd4\u002F79\u002F59d479e1ed4da475699339.jpeg","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F583606\\\u002F\"},\"headline\":\"Пишем свой блокчейн\",\"datePublished\":\"2021-10-15T10:08:11+03:00\",\"dateModified\":\"2021-10-15T11:08:55+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"urticazoku\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F583606\\\u002F#post-content-body\",\"about\":[\"h_python\",\"h_programming\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F583606\\\u002F50af8ebd279fc8c74cedb83f0414827b\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F59\\\u002Fd4\\\u002F79\\\u002F59d479e1ed4da475699339.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fcc3\\\u002F902\\\u002Fb38\\\u002Fcc3902b389b6bd708e4f2498e662206a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fc5f\\\u002F7b6\\\u002Fe1e\\\u002Fc5f7b6e1ebccfc373f3a3e19ddfe80be.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F088\\\u002F03d\\\u002F65c\\\u002F08803d65c9955d73e59c89122fdd058e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F11d\\\u002F128\\\u002Fe19\\\u002F11d128e19b1de58a3b8faab8a46bb2e6.png\"]}","metaDescription":"Вы здесь, потому что, как и я, взволнованы ростом криптовалют. И хотите знать, как работает блокчейн - фундаментальную технологию, лежащую в его основе.Но понять блокчейн непросто - по крайней мере,...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"python,programming"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
