<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Размышления об идеальной архитектуре для JavaScript / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/584502\/"},"headline":"Размышления об идеальной архитектуре для JavaScript","datePublished":"2021-10-20T12:14:11+03:00","dateModified":"2021-10-20T12:14:11+03:00","author":{"@type":"Person","name":"Michael Borislav"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, рез...","url":"https:\/\/habr.com\/ru\/post\/584502\/#post-content-body","about":["h_javascript","h_analysis_design","h_nodejs","h_oop","h_typescript","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/584502\/c690802d180dbfc09d25ec5949a3a0ab\/"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Размышления об идеальной архитектуре для JavaScript" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Размышления об идеальной архитектуре для JavaScript" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Размышления об идеальной архитектуре для JavaScript" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты,..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты,..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты,..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты,..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты,..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/584502/c690802d180dbfc09d25ec5949a3a0ab/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/584502/c690802d180dbfc09d25ec5949a3a0ab/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/584502/c690802d180dbfc09d25ec5949a3a0ab/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/584502/c690802d180dbfc09d25ec5949a3a0ab/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/584502/c690802d180dbfc09d25ec5949a3a0ab/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="584502" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-20T09:14:11.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/584502/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/584502/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/584502/c690802d180dbfc09d25ec5949a3a0ab/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/awerlogus/" title="awerlogus" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/6d8/9f7/f2f/6d89f7f2fe218803de61a5050ff30fd3.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/awerlogus/" class="tm-user-info__username">
      awerlogus
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-20T09:14:11.000Z" title="2021-10-20, 12:14">20  октября   в 12:14</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Размышления об идеальной архитектуре для JavaScript</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/javascript/" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/analysis_design/" class="tm-article-snippet__hubs-item-link"><span>Анализ и проектирование систем</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/nodejs/" class="tm-article-snippet__hubs-item-link"><span>Node.JS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/oop/" class="tm-article-snippet__hubs-item-link"><span>ООП</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/typescript/" class="tm-article-snippet__hubs-item-link"><span>TypeScript</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Из песочницы
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты, позволяющие вести работу дистанционно. На прототип сервиса, до того простоявший несколько лет практически без дела, из ниоткуда свалился ежедневный трафик в 2000 человек, что породило необходимость начинать в ускоренном темпе развивать продукт и делать деньги.</p><p><em>Спойлер: миллионерами мы так и не стали.</em></p><p>По мере роста объема и связности кода, становилось все труднее держать логику целиком в голове и, соответственно, гарантировать, что после очередных внесенных изменений ни один из вариантов использования не отвалится. И вот, в один прекрасный момент, было решено начать покрывать код тестами. Так началась история поиска идеальной архитектуры.</p><p><em>Спойлер: тестами код мы тоже так и не покрыли.</em></p><p>Давид Хейнемейер Ханссон, создатель фреймворка Ruby on Rails, в своей статье <a href="https://dhh.dk/2014/test-induced-design-damage.html" rel="noopener noreferrer nofollow">Test-induced design damage</a> утверждает, что те архитектурные изменения, которые необходимо внести в проект, чтобы сделать возможным написание unit тестов для контроллеров, настолько сильно бьют по остальным характеристикам кода, что лучше отказаться от этой идеи в пользу интеграционных тестов.</p><p>Реально ли придумать такую архитектуру, которая не заставляла бы чем-то жертвовать? Это можно выяснить при помощи научного метода. Сначала необходимо проанализировать имеющиеся зоны боли, а затем попытаться наложить на код такие ограничения и правила, которые бы исправили ситуацию. На каждой последующей итерации ограничения либо добавляются, либо пересматриваются. Сложность состоит в том, что неправильные решения могут стать причиной появления еще большего числа зон боли. В этом болоте можно увязнуть надолго. Лучший способ проверить адекватность любой гипотезы — поставить эксперимент. И на чем же еще стоит экспериментировать, как не на рабочем проекте?</p><p><em>Спойлер: в итоге мы переписали проект 6 раз. Все ради науки.</em></p><h2>Глубокая аналитика текущей ситуации</h2><p>Как известно, все возможные подходы к программированию были придуманы еще в 60е годы разработчиками на LISP. Все новые, по заверениям авторов, разработки, чаще всего, либо заново открывают давно забытое, либо комбинируют уже имеющееся. Время от времени, еще изобретаются надстройки, но они, как показывает практика, не получают особой популярности и долго не живут. Привет аспектно-ориентированному программированию.</p><p>Чтобы собрать архитектуру мечты, нужно понять, какими преимуществами и недостатками обладают уже существующие парадигмы программирования, и каких целей они стремятся достичь. Также рассмотрим, каких результатов ожидает бизнес.</p><h3>Требования бизнеса</h3><p>Можно ли не заставлять бизнес выбирать два пункта из трех — "Быстро, качественно, недорого"? Чтобы ответить на этот вопрос, нужно разобраться, в чем причины нарушения каждого из пунктов.</p><h4>Быстро</h4><p>Зачастую, на этапе разработки начальной версии продукта, фичи выкатываются очень стремительно. Затем, по мере увеличения объема кода, скорость начинает замедляться. Все чаще приходится признавать, что на предыдущих этапах были приняты неверные решения, и что имеющихся возможностей расширения системы, если они вообще закладывались, недостаточно. В такие моменты появляется выбор: воткнуть костыль, или переписать часть системы так, чтобы она гармонично подходила под новые требования? При принятии решения хорошо помогает вопрос: сколько из грядущих изменений будут опираться на этот участок логики? Если навалить поверх костыля еще кода, то все равно этот костыль, в скором времени, придется раскопать и переписать нормально вместе со всей надстройкой. Если, конечно, вы не ставите целью превращение проекта в тотальный хаос. И чем больше будет навалено сверху кода, тем бóльшая когнитивная нагрузка ляжет на разработчика, который займется переписыванием. Это может привести, в лучшем случае, к невнимательности и появлению новых багов, а в худшем — к выгоранию и дальнейшему падению скорости разработки.</p><p>В динамически развивающемся продукте не может существовать конечных решений. Раньше, по неопытности, я старался придерживаться <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8/%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8" rel="noopener noreferrer nofollow">принципа открытости-закрытости</a>, создавая абстракции, в рамки которых, как мне казалось, должны уложиться все последующие изменения в системе. Опыт показал, что  при первой же необходимости изменить или дополнить имеющееся поведение, эти абстракции приходится выкидывать, полностью или частично, заменяя их новыми. Тогда получается, что максимальной гибкости системы можно достичь только путем тотального отказа от подобного оверинжиниринга. Чрезмерное использование инверсии зависимостей, <a href="https://habr.com/ru/post/227753" rel="noopener noreferrer nofollow">метаданных</a>, преждевременные попытки сделать решение переиспользуемым. Все это, на самом деле, приносит больше вреда, чем пользы. Конечно, добиться абсолютной гибкости кода так же невозможно, как невозможно в одно мгновение изменить спецификацию, чтобы учесть все новые требования. Зато можно не плодить лишнего, чтобы потом не пришлось тратить время на избавление от всего этого.</p><h4>Качественно</h4><p>Качество кода, в большинстве своем, зависит от опыта разработчиков и строгости используемого набора анализаторов. Хороший код должен быть понятным, гибким, безопасным и, по возможности, коротким. Желательно еще, чтобы запускался. Правильная архитектура при помощи правил структурирует мышление, помогая сеньорам поддерживать качество кода на высоком уровне. Джунов и миддлов, время от времени, все равно придется корректировать.</p><p>Однако, это все касается внутреннего устройства кодовой базы. Бизнес же интересует, чтобы все работало безошибочно и, по возможности, быстро. Большинство компаний пытаются снизить число ошибок при помощи добавления тестирования. Оно, безусловно, важно, ведь позволяет, при внесении в код изменений, быть уверенными, что старая логика не поломается. К сожалению, тестирование не может помочь отыскать ошибочные состояния, в которые, при определенной последовательности вызовов, может попасть программа, и которые не были учтены разработчиками. Найти их можно только при помощи моделирования и автоматизированной проверки полученной модели на непротиворечивость. Сейчас у всех на слуху язык спецификаций TLA+, который нацелен на моделирование параллельных систем. Можно ли как-то адаптировать его для описания распределенных систем на JavaScript, или же придется использовать что-то другое? Вопрос требует изучения.</p><h4>Недорого</h4><p>Наши знакомые недавно пожаловались, что двухкратное увеличение штата разработчиков совсем не увеличило скорость разработки их продукта. Секрет кроется в функции роста сложности процессов. Во сколько раз больше людей и, соответственно, денег потребуется, чтобы поддерживать вдвое более сложную систему на плаву? В 2 раза больше? В 4? Или, может, в 20 раз? Все зависит от объема технического долга и архитектуры. Допустим, команда регулярно уделяла внимание качеству кода, и технический долг стремится к нулю. Тогда остается сравнивать лишь архитектурные подходы. Хороший подход сохраняет максимальную простоту и предсказуемость системы, что позволяет дольше удерживать в голове полную картину происходящего и, соответственно, управлять процессами силами меньшего числа разработчиков. А это значит, что пропадает необходимость нанимать кучу макак на поддержку. Все высвободившиеся деньги можно и нужно будет потратить на оплату услуг высококвалифицированных хранителей тайн совершенной архитектуры — нас с вами. Недорого разработать продукт не получится 😎.</p><h3>Уровни разработки</h3><p>Наконец, переходим к технической части.</p><p>Разработка любого продукта всегда осуществляется на двух параллельных уровнях: уровне прецедентов и уровне реализации. Оба они описывают поведение программы, разница лишь в степени абстракции. </p><p>Когда происходит составление спецификации системы, ее поведение в деталях выражается при помощи натурального языка. Представим, что мы решили написать консольное приложение для управления списком задач. Тогда часть спецификации может выглядеть примерно так: "Программа выполняется в бесконечном цикле. На каждой итерации цикла необходимо очистить консоль, вывести текущий список задач и запрос на ввод команды, а затем считать введенную пользователем строку. Если команда не может быть распознана, необходимо вывести сообщение об ошибке и запросить подтверждение пользователя. Команда '.' завершает работу программы. За добавление новой задачи отвечает команда '+'. Оставшаяся часть введенной строки — текст задачи. Когда пользователь пытается добавить новую задачу, необходимо очистить текст задачи от пробельных символов слева и справа. Если полученная строка является пустой, оповестить пользователя об ошибке. Иначе добавить новую задачу в список.". Это есть уровень прецедентов.</p><p>На втором уровне, уровне реализации, в случае, например, объектно-ориентированного программирования с использованием разрекламированного подхода CQRS, часть, занимающаяся обработкой пользовательского ввода будет выглядеть следующим образом: "Вызвана команда AskUserForInput, обработкой которой занимается AskUserForInputHandler. Он ожидает ввода пользователя и выбрасывает событие NewUserInput, на которое подписан слушатель, вызывающий команду HandleUserInput, обрабатываемую классом HandleUserInputHandler. Он проверяет, равна ли строка символу '.', и, если да, выбрасывает событие ProgramEnd. Иначе проверяет, начинается ли строка со знака '+', и если нет, выбрасывает событие UnknownCommandInput, на которое подписан слушатель, вызывающий команду NotifyUserAboutUnknownInput, обработкой которой занимается NotifyUserAboutUnknownInputHandler, выводящий сообщение об ошибке на экран. Если же команда начинается со знака '+', то выбрасывается событие AddCommandInvoked, на которую подписан слушатель, вызывающий команду HandleAddCommand, обрабатываемую классом HandleAddCommandHandler, который отрезает крайний левый '+', а затем очищает пробельные символы слева и справа...". Кто, не дочитав, посмотрел в конец?</p><p>Как можно было убедиться, описание логики на уровне реализации оказалось невероятно раздуто и замусорено лексикой, которая отсутствует в спецификации. Так как на проектирование системы на обоих уровнях необходимо потратить время, то будет выгодно, если уровень реализации будет максимально тонок и близок к уровню прецедентов. В идеале, код должен читаться практически как английский текст спецификации.</p><p>Также хочется отметить еще одну распространенную проблему — разорванность логики. Причиной этого является желание чрезмерно разделять код. Шины команд и событий, рушащие связь между вызывающим и вызываемым кодом, инверсия зависимостей там, где это не надо, попытки писать функции длиной не более 10 строк. Не спорю, короткие функции, выполняющие одно действие, это хорошо. Но что если одно действие выполняет большая функция? Стоит ли ее разбивать на маленькие функции, задача которых размыта? Должно ли это зависеть от того, возможно ли эту маленькую функцию переиспользовать? А что насчет принципа единственности ответственности? Где гарантия, что вынесенный блок кода не потребуется изменить только для одного из потребителей? На самом деле, высосанные из пальца функции выявить очень легко — им сложно придумать простое название. Обычно получается что-то в духе <code>addRoomWatchdogIfOnlyBotClientsLeftInRoom</code> или <code>canSendMessageToSocketOrCanStoreItInQueue</code>.</p><p>Если подытожить все сказанное выше, то промежуточный вариант идеального кода, реализующего спецификацию, должен выглядеть как-то так:</p><pre><code class="javascript">async function runProgram () {
  while (true) {
    clearConsole()

    writeTodoItems()

    const input = await readLine('Write the next command: ')

    if (input === '.') { return }
    
    if (input.startsWith('+')) {
      const text = input.substring(1).trim()

      if (text.length === 0) {
        await notify('Can not add an empty item')

        continue
      }

      addTodoItem(text)

      continue
    }

    await notify('Wrong command')
  }
}</code></pre><p>Потом, когда команд станет больше, обработку каждой из них можно будет вынести в отдельную функцию.</p><h3>Типизация</h3><p>Как некоторые уже заметили, в представленном выше коде не хватает типов. Я сторонник статической типизации, однако, мне не нравится "Горизонтальная" природа TypeScript. Так как информация о типах размещается на той же строке, что и исполняемый код, то, чтобы уложиться в ширину экрана, во многих местах приходится одну строку разбивать на несколько. Особенно часто и сильно от этого страдают объявления функций — некоторые строки получаются длиннее других до 20-30 раз, что не добавляет читаемости. </p><p>Я уже высказывался в одной из дискуссий на Github, где сразу набежали хейтеры и меня заминусовали, что дальнейшее развитие TypeScript, как языка программирования, бессмысленно, ведь их компилятор научился проверять в <code>.js</code> файлах типы, описанные через JsDoc. Теперь ничего не надо компилировать, да еще и декларации типов расположены на отдельной строке. Все, о чем можно было мечтать. Если вы уже пишете проект на TypeScript, то тратить время на переписывание не стоит, а вот новые проекты определенно следует попробовать типизировать через JsDoc.</p><p>Давайте добавим декларацию типов к нашей функции.</p><pre><code class="javascript">/** @type {() => Promise&lt;void>} */
async function runProgram () {
...
}</code></pre><p>Также понадобится определить, в каком формате в системе будут храниться задачи.</p><pre><code class="javascript">/**
 * @typedef {{
 *   text: string
 *   id: number
 * }} Item
 */</code></pre><h3>Возможность тестирования</h3><p>Основным условием для обеспечения возможности unit-тестирования полученного кода является добавление механизма инверсии зависимостей. Он позволит подменять реализации функций для тестового и рабочего окружений. Чтобы использовать этот механизм правильно, следует разобраться, какие именно участки кода должны быть заменяемыми, и как правильно все организовать.</p><p>В объектно-ориентированных системах друг в друга пробрасываются сервисы. Это требует затрат времени на проектирование иерархии зависимостей и, в целом, вообще является оверинжинирингом. На самом деле, в подмене нуждаются только те функции, которые производят побочные эффекты. Наборы таких функций, будем называть их алгебрами эффектов, можно разделить на два вида — фасады и репозитории. Технически, работа с ними ничем не отличается. Разные названия нужны лишь для того, чтобы показать разное назначение — репозитории предоставляют доступ к состоянию, а фасады являются прослойкой между вычислениями и внешней средой. </p><p>С точки зрения JavaScript, алгебры <s>на множестве всех типов</s> это просто объекты, поля которых являются функциями. Также стоит отметить, что набор операций алгебры образует встраиваемый предметно-ориентированный язык, конкретная реализация которого называется интерпретатором. Договоримся, что, когда будем говорить об уровне типов, будем использовать слово "Алгебра", а когда о runtime объектах, удовлетворяющих типу алгебры — "Интерпретатор".</p><p>Отдельно стоит обратить внимание на работу с состоянием программы, хранящимся в памяти процесса. В процедурной парадигме, функции, когда им требуется доступ к состоянию, обращаются напрямую к глобальным переменным. Намного удобнее спрятать эти переменные за репозиториями, что позволит работать с ними так же, как и с другими побочными эффектами.</p><p>В случае нашего консольного приложения, будет необходим фасад для взаимодействия с консолью и два репозитория — первый даст возможность хранить и получать объект задачи по ее идентификатору, а второй будет представлять собой счетчик, хранящий уникальный идентификатор следующей добавляемой задачи — аналог автоинкрементируемого id в базах данных. Все остальные вычисления можно описать статически, на основе представленных выше трех алгебр. Под статическим описанием вычислений следует понимать не статические методы классов, а обычные функции, к которым другие, такие же вычисления, могут обращаться напрямую, без инверсии зависимостей.</p><p>Итак, достаточно выделить набор функций, порождающих все возможные побочные эффекты программы, а затем, на его основе, статически описать требуемую логику. В этом деле важно правильно выбирать уровень абстракции, на котором будут находиться эффекты. Например, если стоит задача вывода логов в консоль, с отображением времени их появления, то разумно будет выделить два фасада — первый, отвечающий за работу с консолью, и второй, возвращающий текущую дату, что также является побочным эффектом. Само вычисление, которое будет использовать эти фасады, может быть объявлено статическим. Второй пример — работа с базой данных. Здесь можно рассматривать эффекты на уровне выполнения произвольных sql запросов, или же подняться на уровень выше и обозначить, в качестве эффектов, множество необходимых вызовов, для которых уже существуют заранее подготовленные запросы. Второй способ выгоднее, так как в тестовой реализации интерпретатора не придется заниматься парсингом sql.</p><p>Следующий вопрос — как именно производить инъекцию зависимостей. В объектно-ориентированном подходе все зависимости передаются в сервисы через конструктор и сохраняются в полях. Это не удобно, так как вынуждает использовать устаревшую модель программирования, основанную на прототипах. Особенно доставляет боль тот факт, что методы классов теряют контекст, если попробовать их передать в функцию высшего порядка. Чтобы это обойти, приходится писать конструкции вида</p><pre><code class="javascript">const result = array.map(this.myFacade.doSomething.bind(this.myFacade))</code></pre><p>Это прекрасно лечится заменой классов на замыкания. Однако, есть еще одна проблема: зависимости по прежнему передаются списком, и доступ к каждой зависимости происходит через ее собственный параметр функции. Если для выполнения действий требуются 5-10 зависимостей, то код, отвечающий за инстанцирование, будет по объему примерно равен самой логике программы. В Tagless Final решили эту проблему, предложив просто объединить все фасады и репозитории в один объект при помощи spread оператора. Тогда этот объект всех объектов будет удовлетворять любому требуемому объединению алгебр эффектов, о котором известно в программе.</p><h2>Описание алгебр эффектов</h2><p>Ладно, давайте посмотрим на алгебру репозитория, хранящего задачи</p><pre><code class="javascript">/** @typedef {{ hasTodoItem(id: number): boolean }} HasTodoItem */

/** @typedef {{ removeTodoItem(id: number): void }} RemoveTodoItem */

/** @typedef {{ getTodoItems(): ReadonlyArray&lt;Item> }} GetTodoItems */

/** @typedef {{ addTodoItem(id: number, item: Item): void }} AddTodoItem */

/**
 * @typedef {(
 *  &amp; HasTodoItem
 *  &amp; AddTodoItem
 *  &amp; GetTodoItems
 *  &amp; RemoveTodoItem
 * )} TodoItemsRepository
 */</code></pre><p>Здесь мы можем наблюдать список из 4 алгебр операций. Каждая такая алгебра содержит в себе всего одно поле-функцию. Затем, при помощи операции объединения типов, из этих 4 алгебр получается одна алгебра репозитория, содержащая в себе 4 операции. 4(1) -> 1(4).</p><p>Аналогичным образом объявим алгебры для репозитория-счетчика идентификаторов:</p><pre><code class="javascript">/** @typedef {{ getNextTodoId(): number }} GetNextTodoId */

/** @typedef {{ incrementNextTodoId(): void }} IncrementNextTodoId */

/**
 * @typedef {(
 *  &amp; GetNextTodoId
 *  &amp; IncrementNextTodoId
 * )} TodoIdsRepository
 */</code></pre><p>И фасада логирования:</p><pre><code class="javascript">/** @typedef {{ clearConsole(): void }} ClearConsole */

/** @typedef {{ write(message: string): void }} Write */

/** @typedef {{ readLine(question: string): Promise }} ReadLine */

/**
 * @typedef {(
 *  &amp; Write
 *  &amp; ReadLine
 *  &amp; ClearConsole
 * )} ConsoleFacade
 */</code></pre><p>Далее, когда все алгебры фасадов и репозиториев готовы, наступает время объединить их в алгебры сервисов. Принцип прост — если несколько алгебр не могут использоваться друг без друга, то они должны быть объединены. В нашем случае, репозиторий, хранящий задачи, не рационально использовать без репозитория, хранящего идентификатор следующей задачи.</p><pre><code class="javascript">/**
 * @typedef {(
 *  &amp; TodoIdsRepository
 *  &amp; TodoItemsRepository
 * )} TodoItemsAlgebra
 */</code></pre><p>Фасад консоли может быть использован сам по себе, так что в состав сервиса консоли входит только он один.</p><pre><code class="javascript">/**
 * @typedef {(
 *  &amp; ConsoleFacade
 * )} ConsoleAlgebra
 */</code></pre><p>И последний этап — объединить все алгебры сервисов в единую алгебру приложения. </p><pre><code class="javascript">/**
 * @typedef {(
 *  &amp; ConsoleAlgebra
 *  &amp; TodoItemsAlgebra
 * )} Program
 */</code></pre><h3>Реализация интерпретаторов</h3><p>Теперь, когда есть алгебры, можно реализовать интерпретаторы, которые будут использоваться в рабочем запуске приложения.</p><p>Интерпретатор репозитория задач</p><pre><code class="javascript">/** @type {Map&lt;number, Item>} */
const items = new Map()

/** @type {TodoItemsRepository} */
const todoItemsRepository = {
  getTodoItems: () => Array.from(items.values()),
  addTodoItem: (id, item) => item.set(id, item),
  removeTodoItem: id => items.delete(id),
  hasTodoItem: id => items.has(id),
}</code></pre><p>Интерпретатор, хранящий идентификатор для следующей задачи</p><pre><code class="javascript">/** @type {number} */
let nextId = startTodoId

/** @type {TodoIdsRepository['getNextTodoId']} */
function getNextTodoId () { return nextId }

/** @type {TodoIdsRepository['incrementNextTodoId']} */
function incrementNextTodoId () { nextId = nextId + 1 }

/** @type {TodoIdsRepository} */
const todoIdsRepository = {
  incrementNextTodoId,
  getNextTodoId,
}</code></pre><p>Интерпретатор для фасада консоли</p><pre><code class="javascript">const c = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

/** @type {ConsoleFacade['write']} */
function write (message) {
  c.write(message)
}

/** @type {ConsoleFacade['readLine']} */
function readLine (question) {
  return new Promise(resolve => {
    c.question(question, resolve)
  })
}

/** @type {ConsoleFacade['clearConsole']} */
function clearConsole () {
  console.clear()
}

/** @type {ConsoleFacade} */
const consoleFacade = { readLine, write, clearConsole }</code></pre><p>Теперь, по аналогии с алгебрами, создадим интерпретаторы для сервисов</p><pre><code class="javascript">/** @type {TodoItemsAlgebra} */
const todoItemsAlgebra = {
  ...todoItemsRepository,
  ...todoIdsRepository,
}

/** @type {ConsoleAlgebra} */ 
const consoleAlgebra = { 
  ...consoleFacade 
} </code></pre><p>И интерпретатор приложения</p><pre><code class="javascript">/** @type {Program} */
const program = {
  ...todoItemsAlgebra,
  ...consoleAlgebra,
}</code></pre><h3>Философия UNIX</h3><p>Часто приходится слышать мнение, что программы стоит проектировать в соответствии с философией UNIX. Когда начинаешь узнавать, в чем, по мнению говорящего, она заключается — в ответ слышишь: "Нужно писать маленькие программы, которые делают одно дело, но делают его лучше остальных". Подобная трактовка этой философии уже успела завести человечество в ад микросервисов, из которого, пока, мало кто хочет выбираться.</p><p>Что же упущено здесь из виду? Давайте посмотрим на две программы, которые являются эталонными представителями философии UNIX — grep и sed. Какими еще особенностями они обладают, помимо того, что выполняют единственную задачу? Во-первых, они ничего не знают друг про друга. Чтобы использовать несколько независимых программ вместе, их достаточно просто объединить при помощи слоя высшего порядка, которым выступает Shell, в случае UNIX. Получается красивая двуслойная архитектура — множество независимых приложений, на нижнем уровне, объединяются в одно на верхнем. Сравните это с графом асинхронно взаимодействующих друг с другом микросервисов. Или хотя-бы с иерархией объектно-ориентированных сервисов, взаимодействующих точно так же, но синхронно.</p><p>Так как все в нашем мире фрактально, можно опустить эту же двуслойную методологию на уровень монолитного приложения. Вместо приложений будут независимые сервисы, а заменой Shell станет обычный код на JavaScript. Если посмотреть еще глубже, то можно заметить, что алгебры внутри сервиса тоже независимы. И даже отдельные операции ничего не знают друг о друге.</p><h3>Вычисления</h3><p>Теперь, когда интерпретаторы готовы, можно на их основе реализовать вычисления. </p><p>Вычисления делятся на два вида: сервисные и прецедентные. Сервисные вычисления строятся на основе алгебры сервиса, что позволяет легко переиспользовать их в других проектах. Так как сервисы полностью независимы друг от друга, то для этого достаточно просто скопировать папку с сервисом в нужный проект и подключить алгебру сервиса к алгебре приложения, а интерпретатор сервиса к интерпретатору приложения. Вычисления прецедентов являются, с точки зрения описанного в предыдущем разделе, вторым, верхним, слоем архитектуры, который объединяет все сервисы воедино. Они зависят от алгебры приложения.</p><p>Давайте, для примера, реализуем сервисное вычисление, добавляющее в список новую задачу.</p><pre><code class="javascript">/** @type {(P: TodoItemsAlgebra) => (text: string) => void} */
const addTodoItem = P => text => {
  const id = P.getNextTodoId()

  /** @type {Item} */
  const item = { id, text }

  P.addTodoItem(id, item)

  P.incrementNextTodoId()
}</code></pre><p>Вычисление принимает, в качестве единственного параметра, интерпретатор, удовлетворяющий алгебре сервиса, а затем возвращает функцию, принимающую текст задачи и выполняющую действия по ее добавлению. Сначала вызывается операция <code>getNextTodoId</code>, являющаяся частью интерпретатора, и возвращающая идентификатор для новой задачи. Затем строится объект задачи и добавляется к списку при помощи операции <code>addTodoItem</code>. Чтобы в следующий раз задача создавалась уже с новым идентификатором, необходимо его инкрементировать, вызвав <code>incrementNextTodoId</code>. </p><p>Важно отметить, что на данном этапе можно отбросить знание о том, что операции принадлежат к разным репозиториям. Поэтому я намеренно опустил, что <code>addTodoItem</code>, например, принадлежит к <code>TodoItemsRepository</code>.</p><p>Чтобы использовать данное вычисление, достаточно передать в него любой интерпретатор, удовлетворяющий алгебре <code>TodoItemsAlgebra</code>. Это может быть сервисный интерпретатор, либо же интерпретатор приложения, так как множество операций сервисной алгебры является подмножеством операций алгебры приложения.</p><pre><code class="javascript">addTodoItem(todoItemsAlgebra)('task1')
// Is equal to
addTodoItem(program)('task1')</code></pre><p>Обычно, сервисные интерпретаторы напрямую используются только при тестировании сервисных вычислений, чтобы не создавать за зря интерпретатор приложения.</p><p>В вычислениях интерпретатор намеренно помещается первым, отдельно от остальных параметров, чтобы это вычисление можно было использовать в бесточечной нотации. Представим, у нас есть массив текстов для задач. Тогда их все можно добавить следующим образом:</p><pre><code class="javascript">const texts = ['task1', 'task2']

texts.forEach(text => addTodoItem(program)(text))</code></pre><p>Как можно заметить, применение анонимной функции здесь излишне, так как результатом <code>addTodoItem(program)</code> уже является функция, принимающая текст и добавляющая задачу. Поэтому вызов можно упростить:</p><pre><code class="javascript">texts.forEach(addTodoItem(program))</code></pre><p>Если бы интерпретатор не передавался отдельно, то, в этом случае, анонимную функцию создать все-же пришлось бы.</p><p>Также на уровне сервисных вычислений, но теперь уже на основе сервиса консоли, возможно реализовать функцию <code>notify</code>, оповещающую пользователя о чем-либо.</p><pre><code class="javascript">/** @type {(P: ConsoleAlgebra) => (text: string) => Promise&lt;void>} */
const notify = P => async text => {
  P.write('\n' + text + '\n')

  await P.readLine('Press enter to continue')
}</code></pre><p>Она выводит сообщение на экран, обрамляя его символами новой строки, а затем ожидает подтверждение от пользователя.</p><p>Чтобы вывести задачи на экран, необходимо обратиться сразу к двум сервисам: сервису задач и сервису консоли. Это значит, что такое вычисление будет прецедентным, зависящим от алгебры приложения.</p><pre><code class="javascript">/** @type {(P: Program) => (item: Item) => void} */
const writeTodoItem = P => item => P.write(`${item.id}) ${item.text}\n`)

/** @type {(P: Program) => () => void} */
const writeTodoItems = P => () => {
  const items = P.getTodoItems()

  if (items.length === 0) {
    P.write('TODO list is empty\n')
  } else {
    P.write('TODO items list:\n')

    items.forEach(writeTodoItem(P))
  }
}</code></pre><p>При написании кода было учтено, что вывод каждой отдельной задачи можно также представить в виде самостоятельного вычисления. Технически, оно зависит только от сервиса консоли, но его логика настолько специфична, что вряд-ли оно может понадобиться кому-то, кто будет переиспользовать этот сервис в другом приложении. Поэтому вычисление было решено объявить прецедентным.</p><p>Также, когда одни вычисления вызываются другими, в них передается не какой-то конкретный интерпретатор, а тот, который был помещен в вызывающее вычисление сверху. Получается такая картина: существуют какие-то вычисления, находящиеся на самом верху иерархии вызовов. В веб-приложениях, например, это контроллеры, а в консольных приложениях это может быть функция, запускающая основной цикл выполнения, как в нашем случае. В эти вычисления, при запуске, инфраструктурный код помещает какой-то интерпретатор, рабочий или тестовый. И они далее, не зная, какой именно интерпретатор был передан на этот раз, затем передают его вниз по иерархии вызовов.</p><p>В данном конкретном случае, вычисление <code>writeTodoItems</code> принимает интерпретатор через параметр <code>P</code>, а затем передает его во <code>writeTodoItem</code>:</p><pre><code class="javascript">items.forEach(writeTodoItem(P))</code></pre><p>Осталось переписать самую главную функцию, чтобы она соответствовала новым правилам.</p><pre><code class="javascript">/** @type {(P: Program) => () => Promise&lt;void>} */
async function runProgram = P => () => {
  while (true) {
    P.clearConsole()

    writeTodoItems(P)()

    const input = await P.readLine('Write the next command: ')

    if (input === '.') { return }
    
    if (input.startsWith('+')) {
      const text = input.substring(1).trim()

      if (text.length === 0) {
        await notify(P)('Can not add an empty item')

        continue
      }

      addTodoItem(P)(text)

      continue
    }

    await notify(P)('Wrong command')
  }
}</code></pre><p>Все побочные эффекты, которые ранее могли быть выполнены напрямую, теперь проксируются через интерпретатор. Там, где требуется более сложная логика, интерпретатор передается в вычисления, которые берут часть работы на себя. А вот внешне код выглядит почти так же, как и выглядел ранее.</p><p>Последнее, что остается — на инфраструктурном уровне запустить алгоритм.</p><pre><code class="javascript">runProgram(program)()</code></pre><p>Вот, как действительно должна выглядеть разработка программ по философии UNIX.</p><h3>Итоги</h3><p>Подведем итоги, выделив три правила:</p><ol><li><p>Побочные эффекты должны быть абстрагированы встраиваемым предметно-ориентированным языком, выраженным алгеброй на множестве всех типов.</p></li><li><p>Отдельные алгебры, которые не могут использоваться в отрыве друг от друга, должны быть объединены в сервисы. Алгебры сервисов должны быть объединены в алгебру приложения.</p></li><li><p>Все вычисления, основанные на полученном предметно-ориентированном языке, должны делиться на два вида: сервисные вычисления, которые зависят от алгебры сервиса, и вычисления прецедентов, зависящие от алгебры приложения.</p></li></ol><p>Для желающих глубже разобраться я создал репозиторий с кодом рассмотренной программы и даже чуть больше: <a href="https://github.com/awerlogus/todo-app-example" rel="noopener noreferrer nofollow">awerlogus/todo-app-example</a>.</p><p>Забыл сказать — на данный момент подход называется "Восьмая архитектура". После пятой архитектуры нам стало лень придумывать имена, и мы стали просто обозначать все новые архитектуры по порядковому номеру. Если есть идеи, как можно назвать получше — предлагайте в комментариях.</p><p>В следующей статье поговорим про написание тестов для вычислений. </p><p>Благодарю за внимание.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%5D" class="tm-tags-list__link">архитектура</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%20%D0%BF%D0%BE%5D" class="tm-tags-list__link">архитектура по</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bjavascript%5D" class="tm-tags-list__link">javascript</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bnode.js%5D" class="tm-tags-list__link">node.js</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bnodejs%5D" class="tm-tags-list__link">nodejs</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Btypescript%5D" class="tm-tags-list__link">typescript</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BE%D0%BE%D0%BF%5D" class="tm-tags-list__link">ооп</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%84%D0%BF%5D" class="tm-tags-list__link">фп</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bts%5D" class="tm-tags-list__link">ts</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/javascript/" class="tm-hubs-list__link">
    JavaScript
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/analysis_design/" class="tm-hubs-list__link">
    Анализ и проектирование систем
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/nodejs/" class="tm-hubs-list__link">
    Node.JS
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/oop/" class="tm-hubs-list__link">
    ООП
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/typescript/" class="tm-hubs-list__link">
    TypeScript
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 10: ↑9 и ↓1</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 10: ↑9 и ↓1" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+8</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">7.8K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    59
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/awerlogus/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/6d8/9f7/f2f/6d89f7f2fe218803de61a5050ff30fd3.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 6 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    6
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">8.1</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Michael Borislav</span> <a href="/ru/users/awerlogus/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @awerlogus
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Senior software engineer</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/584502/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 24 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/584502/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/584502/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"584502":{"id":"584502","timePublished":"2021-10-20T09:14:11+00:00","isCorporative":false,"lang":"ru","titleHtml":"Размышления об идеальной архитектуре для JavaScript","leadData":{"textHtml":"\u003Cp\u003EВ 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты, позволяющие вести работу дистанционно. На прототип сервиса, до того простоявший несколько лет практически без дела, из ниоткуда свалился ежедневный трафик в 2000 человек, что породило необходимость начинать в ускоренном темпе развивать продукт и делать деньги.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСпойлер: миллионерами мы так и не стали.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EПо мере роста объема и связности кода, становилось все труднее держать логику целиком в голове и, соответственно, гарантировать, что после очередных внесенных изменений ни один из вариантов использования не отвалится. И вот, в один прекрасный момент, было решено начать покрывать код тестами. Так началась история поиска идеальной архитектуры.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСпойлер: тестами код мы тоже так и не покрыли.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EДавид Хейнемейер Ханссон, создатель фреймворка Ruby on Rails, в своей статье \u003Ca href=\"https:\u002F\u002Fdhh.dk\u002F2014\u002Ftest-induced-design-damage.html\" rel=\"noopener noreferrer nofollow\"\u003ETest-induced design damage\u003C\u002Fa\u003E утверждает, что те архитектурные изменения, которые необходимо внести в проект, чтобы сделать возможным написание unit тестов для контроллеров, настолько сильно бьют по остальным характеристикам кода, что лучше отказаться от этой идеи в пользу интеграционных тестов.\u003C\u002Fp\u003E\u003Cp\u003EРеально ли придумать такую архитектуру, которая не заставляла бы чем-то жертвовать? \u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fee4\u002Fece\u002F6d3\u002Fee4ece6d382ee5cf3df38d44472b754e.jpg","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"scoreStats":{"score":6,"votesCount":6},"rating":8.1,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2753495","alias":"awerlogus","fullname":"Michael Borislav","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F6d8\u002F9f7\u002Ff2f\u002F6d89f7f2fe218803de61a5050ff30fd3.png","speciality":"Senior software engineer"},"statistics":{"commentsCount":24,"favoritesCount":59,"readingCount":7765,"score":8,"votesCount":10},"hubs":[{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"relatedData":null,"id":"397","alias":"analysis_design","type":"collective","title":"Анализ и проектирование систем","titleHtml":"Анализ и проектирование систем","isProfiled":true},{"relatedData":null,"id":"17110","alias":"nodejs","type":"collective","title":"Node.JS","titleHtml":"Node.JS","isProfiled":true},{"relatedData":null,"id":"17719","alias":"oop","type":"collective","title":"ООП","titleHtml":"ООП","isProfiled":true},{"relatedData":null,"id":"21370","alias":"typescript","type":"collective","title":"TypeScript","titleHtml":"TypeScript","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EВ 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты, позволяющие вести работу дистанционно. На прототип сервиса, до того простоявший несколько лет практически без дела, из ниоткуда свалился ежедневный трафик в 2000 человек, что породило необходимость начинать в ускоренном темпе развивать продукт и делать деньги.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСпойлер: миллионерами мы так и не стали.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EПо мере роста объема и связности кода, становилось все труднее держать логику целиком в голове и, соответственно, гарантировать, что после очередных внесенных изменений ни один из вариантов использования не отвалится. И вот, в один прекрасный момент, было решено начать покрывать код тестами. Так началась история поиска идеальной архитектуры.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСпойлер: тестами код мы тоже так и не покрыли.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EДавид Хейнемейер Ханссон, создатель фреймворка Ruby on Rails, в своей статье \u003Ca href=\"https:\u002F\u002Fdhh.dk\u002F2014\u002Ftest-induced-design-damage.html\" rel=\"noopener noreferrer nofollow\"\u003ETest-induced design damage\u003C\u002Fa\u003E утверждает, что те архитектурные изменения, которые необходимо внести в проект, чтобы сделать возможным написание unit тестов для контроллеров, настолько сильно бьют по остальным характеристикам кода, что лучше отказаться от этой идеи в пользу интеграционных тестов.\u003C\u002Fp\u003E\u003Cp\u003EРеально ли придумать такую архитектуру, которая не заставляла бы чем-то жертвовать? Это можно выяснить при помощи научного метода. Сначала необходимо проанализировать имеющиеся зоны боли, а затем попытаться наложить на код такие ограничения и правила, которые бы исправили ситуацию. На каждой последующей итерации ограничения либо добавляются, либо пересматриваются. Сложность состоит в том, что неправильные решения могут стать причиной появления еще большего числа зон боли. В этом болоте можно увязнуть надолго. Лучший способ проверить адекватность любой гипотезы — поставить эксперимент. И на чем же еще стоит экспериментировать, как не на рабочем проекте?\u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСпойлер: в итоге мы переписали проект 6 раз. Все ради науки.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Ch2\u003EГлубокая аналитика текущей ситуации\u003C\u002Fh2\u003E\u003Cp\u003EКак известно, все возможные подходы к программированию были придуманы еще в 60е годы разработчиками на LISP. Все новые, по заверениям авторов, разработки, чаще всего, либо заново открывают давно забытое, либо комбинируют уже имеющееся. Время от времени, еще изобретаются надстройки, но они, как показывает практика, не получают особой популярности и долго не живут. Привет аспектно-ориентированному программированию.\u003C\u002Fp\u003E\u003Cp\u003EЧтобы собрать архитектуру мечты, нужно понять, какими преимуществами и недостатками обладают уже существующие парадигмы программирования, и каких целей они стремятся достичь. Также рассмотрим, каких результатов ожидает бизнес.\u003C\u002Fp\u003E\u003Ch3\u003EТребования бизнеса\u003C\u002Fh3\u003E\u003Cp\u003EМожно ли не заставлять бизнес выбирать два пункта из трех — \"Быстро, качественно, недорого\"? Чтобы ответить на этот вопрос, нужно разобраться, в чем причины нарушения каждого из пунктов.\u003C\u002Fp\u003E\u003Ch4\u003EБыстро\u003C\u002Fh4\u003E\u003Cp\u003EЗачастую, на этапе разработки начальной версии продукта, фичи выкатываются очень стремительно. Затем, по мере увеличения объема кода, скорость начинает замедляться. Все чаще приходится признавать, что на предыдущих этапах были приняты неверные решения, и что имеющихся возможностей расширения системы, если они вообще закладывались, недостаточно. В такие моменты появляется выбор: воткнуть костыль, или переписать часть системы так, чтобы она гармонично подходила под новые требования? При принятии решения хорошо помогает вопрос: сколько из грядущих изменений будут опираться на этот участок логики? Если навалить поверх костыля еще кода, то все равно этот костыль, в скором времени, придется раскопать и переписать нормально вместе со всей надстройкой. Если, конечно, вы не ставите целью превращение проекта в тотальный хаос. И чем больше будет навалено сверху кода, тем бóльшая когнитивная нагрузка ляжет на разработчика, который займется переписыванием. Это может привести, в лучшем случае, к невнимательности и появлению новых багов, а в худшем — к выгоранию и дальнейшему падению скорости разработки.\u003C\u002Fp\u003E\u003Cp\u003EВ динамически развивающемся продукте не может существовать конечных решений. Раньше, по неопытности, я старался придерживаться \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8\u002F%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8\" rel=\"noopener noreferrer nofollow\"\u003Eпринципа открытости-закрытости\u003C\u002Fa\u003E, создавая абстракции, в рамки которых, как мне казалось, должны уложиться все последующие изменения в системе. Опыт показал, что  при первой же необходимости изменить или дополнить имеющееся поведение, эти абстракции приходится выкидывать, полностью или частично, заменяя их новыми. Тогда получается, что максимальной гибкости системы можно достичь только путем тотального отказа от подобного оверинжиниринга. Чрезмерное использование инверсии зависимостей, \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F227753\" rel=\"noopener noreferrer nofollow\"\u003Eметаданных\u003C\u002Fa\u003E, преждевременные попытки сделать решение переиспользуемым. Все это, на самом деле, приносит больше вреда, чем пользы. Конечно, добиться абсолютной гибкости кода так же невозможно, как невозможно в одно мгновение изменить спецификацию, чтобы учесть все новые требования. Зато можно не плодить лишнего, чтобы потом не пришлось тратить время на избавление от всего этого.\u003C\u002Fp\u003E\u003Ch4\u003EКачественно\u003C\u002Fh4\u003E\u003Cp\u003EКачество кода, в большинстве своем, зависит от опыта разработчиков и строгости используемого набора анализаторов. Хороший код должен быть понятным, гибким, безопасным и, по возможности, коротким. Желательно еще, чтобы запускался. Правильная архитектура при помощи правил структурирует мышление, помогая сеньорам поддерживать качество кода на высоком уровне. Джунов и миддлов, время от времени, все равно придется корректировать.\u003C\u002Fp\u003E\u003Cp\u003EОднако, это все касается внутреннего устройства кодовой базы. Бизнес же интересует, чтобы все работало безошибочно и, по возможности, быстро. Большинство компаний пытаются снизить число ошибок при помощи добавления тестирования. Оно, безусловно, важно, ведь позволяет, при внесении в код изменений, быть уверенными, что старая логика не поломается. К сожалению, тестирование не может помочь отыскать ошибочные состояния, в которые, при определенной последовательности вызовов, может попасть программа, и которые не были учтены разработчиками. Найти их можно только при помощи моделирования и автоматизированной проверки полученной модели на непротиворечивость. Сейчас у всех на слуху язык спецификаций TLA+, который нацелен на моделирование параллельных систем. Можно ли как-то адаптировать его для описания распределенных систем на JavaScript, или же придется использовать что-то другое? Вопрос требует изучения.\u003C\u002Fp\u003E\u003Ch4\u003EНедорого\u003C\u002Fh4\u003E\u003Cp\u003EНаши знакомые недавно пожаловались, что двухкратное увеличение штата разработчиков совсем не увеличило скорость разработки их продукта. Секрет кроется в функции роста сложности процессов. Во сколько раз больше людей и, соответственно, денег потребуется, чтобы поддерживать вдвое более сложную систему на плаву? В 2 раза больше? В 4? Или, может, в 20 раз? Все зависит от объема технического долга и архитектуры. Допустим, команда регулярно уделяла внимание качеству кода, и технический долг стремится к нулю. Тогда остается сравнивать лишь архитектурные подходы. Хороший подход сохраняет максимальную простоту и предсказуемость системы, что позволяет дольше удерживать в голове полную картину происходящего и, соответственно, управлять процессами силами меньшего числа разработчиков. А это значит, что пропадает необходимость нанимать кучу макак на поддержку. Все высвободившиеся деньги можно и нужно будет потратить на оплату услуг высококвалифицированных хранителей тайн совершенной архитектуры — нас с вами. Недорого разработать продукт не получится 😎.\u003C\u002Fp\u003E\u003Ch3\u003EУровни разработки\u003C\u002Fh3\u003E\u003Cp\u003EНаконец, переходим к технической части.\u003C\u002Fp\u003E\u003Cp\u003EРазработка любого продукта всегда осуществляется на двух параллельных уровнях: уровне прецедентов и уровне реализации. Оба они описывают поведение программы, разница лишь в степени абстракции. \u003C\u002Fp\u003E\u003Cp\u003EКогда происходит составление спецификации системы, ее поведение в деталях выражается при помощи натурального языка. Представим, что мы решили написать консольное приложение для управления списком задач. Тогда часть спецификации может выглядеть примерно так: \"Программа выполняется в бесконечном цикле. На каждой итерации цикла необходимо очистить консоль, вывести текущий список задач и запрос на ввод команды, а затем считать введенную пользователем строку. Если команда не может быть распознана, необходимо вывести сообщение об ошибке и запросить подтверждение пользователя. Команда '.' завершает работу программы. За добавление новой задачи отвечает команда '+'. Оставшаяся часть введенной строки — текст задачи. Когда пользователь пытается добавить новую задачу, необходимо очистить текст задачи от пробельных символов слева и справа. Если полученная строка является пустой, оповестить пользователя об ошибке. Иначе добавить новую задачу в список.\". Это есть уровень прецедентов.\u003C\u002Fp\u003E\u003Cp\u003EНа втором уровне, уровне реализации, в случае, например, объектно-ориентированного программирования с использованием разрекламированного подхода CQRS, часть, занимающаяся обработкой пользовательского ввода будет выглядеть следующим образом: \"Вызвана команда AskUserForInput, обработкой которой занимается AskUserForInputHandler. Он ожидает ввода пользователя и выбрасывает событие NewUserInput, на которое подписан слушатель, вызывающий команду HandleUserInput, обрабатываемую классом HandleUserInputHandler. Он проверяет, равна ли строка символу '.', и, если да, выбрасывает событие ProgramEnd. Иначе проверяет, начинается ли строка со знака '+', и если нет, выбрасывает событие UnknownCommandInput, на которое подписан слушатель, вызывающий команду NotifyUserAboutUnknownInput, обработкой которой занимается NotifyUserAboutUnknownInputHandler, выводящий сообщение об ошибке на экран. Если же команда начинается со знака '+', то выбрасывается событие AddCommandInvoked, на которую подписан слушатель, вызывающий команду HandleAddCommand, обрабатываемую классом HandleAddCommandHandler, который отрезает крайний левый '+', а затем очищает пробельные символы слева и справа...\". Кто, не дочитав, посмотрел в конец?\u003C\u002Fp\u003E\u003Cp\u003EКак можно было убедиться, описание логики на уровне реализации оказалось невероятно раздуто и замусорено лексикой, которая отсутствует в спецификации. Так как на проектирование системы на обоих уровнях необходимо потратить время, то будет выгодно, если уровень реализации будет максимально тонок и близок к уровню прецедентов. В идеале, код должен читаться практически как английский текст спецификации.\u003C\u002Fp\u003E\u003Cp\u003EТакже хочется отметить еще одну распространенную проблему — разорванность логики. Причиной этого является желание чрезмерно разделять код. Шины команд и событий, рушащие связь между вызывающим и вызываемым кодом, инверсия зависимостей там, где это не надо, попытки писать функции длиной не более 10 строк. Не спорю, короткие функции, выполняющие одно действие, это хорошо. Но что если одно действие выполняет большая функция? Стоит ли ее разбивать на маленькие функции, задача которых размыта? Должно ли это зависеть от того, возможно ли эту маленькую функцию переиспользовать? А что насчет принципа единственности ответственности? Где гарантия, что вынесенный блок кода не потребуется изменить только для одного из потребителей? На самом деле, высосанные из пальца функции выявить очень легко — им сложно придумать простое название. Обычно получается что-то в духе \u003Ccode\u003EaddRoomWatchdogIfOnlyBotClientsLeftInRoom\u003C\u002Fcode\u003E или \u003Ccode\u003EcanSendMessageToSocketOrCanStoreItInQueue\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЕсли подытожить все сказанное выше, то промежуточный вариант идеального кода, реализующего спецификацию, должен выглядеть как-то так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Easync function runProgram () {\n  while (true) {\n    clearConsole()\n\n    writeTodoItems()\n\n    const input = await readLine('Write the next command: ')\n\n    if (input === '.') { return }\n    \n    if (input.startsWith('+')) {\n      const text = input.substring(1).trim()\n\n      if (text.length === 0) {\n        await notify('Can not add an empty item')\n\n        continue\n      }\n\n      addTodoItem(text)\n\n      continue\n    }\n\n    await notify('Wrong command')\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПотом, когда команд станет больше, обработку каждой из них можно будет вынести в отдельную функцию.\u003C\u002Fp\u003E\u003Ch3\u003EТипизация\u003C\u002Fh3\u003E\u003Cp\u003EКак некоторые уже заметили, в представленном выше коде не хватает типов. Я сторонник статической типизации, однако, мне не нравится \"Горизонтальная\" природа TypeScript. Так как информация о типах размещается на той же строке, что и исполняемый код, то, чтобы уложиться в ширину экрана, во многих местах приходится одну строку разбивать на несколько. Особенно часто и сильно от этого страдают объявления функций — некоторые строки получаются длиннее других до 20-30 раз, что не добавляет читаемости. \u003C\u002Fp\u003E\u003Cp\u003EЯ уже высказывался в одной из дискуссий на Github, где сразу набежали хейтеры и меня заминусовали, что дальнейшее развитие TypeScript, как языка программирования, бессмысленно, ведь их компилятор научился проверять в \u003Ccode\u003E.js\u003C\u002Fcode\u003E файлах типы, описанные через JsDoc. Теперь ничего не надо компилировать, да еще и декларации типов расположены на отдельной строке. Все, о чем можно было мечтать. Если вы уже пишете проект на TypeScript, то тратить время на переписывание не стоит, а вот новые проекты определенно следует попробовать типизировать через JsDoc.\u003C\u002Fp\u003E\u003Cp\u003EДавайте добавим декларацию типов к нашей функции.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {() =\u003E Promise&lt;void\u003E} *\u002F\nasync function runProgram () {\n...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТакже понадобится определить, в каком формате в системе будут храниться задачи.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F**\n * @typedef {{\n *   text: string\n *   id: number\n * }} Item\n *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EВозможность тестирования\u003C\u002Fh3\u003E\u003Cp\u003EОсновным условием для обеспечения возможности unit-тестирования полученного кода является добавление механизма инверсии зависимостей. Он позволит подменять реализации функций для тестового и рабочего окружений. Чтобы использовать этот механизм правильно, следует разобраться, какие именно участки кода должны быть заменяемыми, и как правильно все организовать.\u003C\u002Fp\u003E\u003Cp\u003EВ объектно-ориентированных системах друг в друга пробрасываются сервисы. Это требует затрат времени на проектирование иерархии зависимостей и, в целом, вообще является оверинжинирингом. На самом деле, в подмене нуждаются только те функции, которые производят побочные эффекты. Наборы таких функций, будем называть их алгебрами эффектов, можно разделить на два вида — фасады и репозитории. Технически, работа с ними ничем не отличается. Разные названия нужны лишь для того, чтобы показать разное назначение — репозитории предоставляют доступ к состоянию, а фасады являются прослойкой между вычислениями и внешней средой. \u003C\u002Fp\u003E\u003Cp\u003EС точки зрения JavaScript, алгебры \u003Cs\u003Eна множестве всех типов\u003C\u002Fs\u003E это просто объекты, поля которых являются функциями. Также стоит отметить, что набор операций алгебры образует встраиваемый предметно-ориентированный язык, конкретная реализация которого называется интерпретатором. Договоримся, что, когда будем говорить об уровне типов, будем использовать слово \"Алгебра\", а когда о runtime объектах, удовлетворяющих типу алгебры — \"Интерпретатор\".\u003C\u002Fp\u003E\u003Cp\u003EОтдельно стоит обратить внимание на работу с состоянием программы, хранящимся в памяти процесса. В процедурной парадигме, функции, когда им требуется доступ к состоянию, обращаются напрямую к глобальным переменным. Намного удобнее спрятать эти переменные за репозиториями, что позволит работать с ними так же, как и с другими побочными эффектами.\u003C\u002Fp\u003E\u003Cp\u003EВ случае нашего консольного приложения, будет необходим фасад для взаимодействия с консолью и два репозитория — первый даст возможность хранить и получать объект задачи по ее идентификатору, а второй будет представлять собой счетчик, хранящий уникальный идентификатор следующей добавляемой задачи — аналог автоинкрементируемого id в базах данных. Все остальные вычисления можно описать статически, на основе представленных выше трех алгебр. Под статическим описанием вычислений следует понимать не статические методы классов, а обычные функции, к которым другие, такие же вычисления, могут обращаться напрямую, без инверсии зависимостей.\u003C\u002Fp\u003E\u003Cp\u003EИтак, достаточно выделить набор функций, порождающих все возможные побочные эффекты программы, а затем, на его основе, статически описать требуемую логику. В этом деле важно правильно выбирать уровень абстракции, на котором будут находиться эффекты. Например, если стоит задача вывода логов в консоль, с отображением времени их появления, то разумно будет выделить два фасада — первый, отвечающий за работу с консолью, и второй, возвращающий текущую дату, что также является побочным эффектом. Само вычисление, которое будет использовать эти фасады, может быть объявлено статическим. Второй пример — работа с базой данных. Здесь можно рассматривать эффекты на уровне выполнения произвольных sql запросов, или же подняться на уровень выше и обозначить, в качестве эффектов, множество необходимых вызовов, для которых уже существуют заранее подготовленные запросы. Второй способ выгоднее, так как в тестовой реализации интерпретатора не придется заниматься парсингом sql.\u003C\u002Fp\u003E\u003Cp\u003EСледующий вопрос — как именно производить инъекцию зависимостей. В объектно-ориентированном подходе все зависимости передаются в сервисы через конструктор и сохраняются в полях. Это не удобно, так как вынуждает использовать устаревшую модель программирования, основанную на прототипах. Особенно доставляет боль тот факт, что методы классов теряют контекст, если попробовать их передать в функцию высшего порядка. Чтобы это обойти, приходится писать конструкции вида\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst result = array.map(this.myFacade.doSomething.bind(this.myFacade))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭто прекрасно лечится заменой классов на замыкания. Однако, есть еще одна проблема: зависимости по прежнему передаются списком, и доступ к каждой зависимости происходит через ее собственный параметр функции. Если для выполнения действий требуются 5-10 зависимостей, то код, отвечающий за инстанцирование, будет по объему примерно равен самой логике программы. В Tagless Final решили эту проблему, предложив просто объединить все фасады и репозитории в один объект при помощи spread оператора. Тогда этот объект всех объектов будет удовлетворять любому требуемому объединению алгебр эффектов, о котором известно в программе.\u003C\u002Fp\u003E\u003Ch2\u003EОписание алгебр эффектов\u003C\u002Fh2\u003E\u003Cp\u003EЛадно, давайте посмотрим на алгебру репозитория, хранящего задачи\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @typedef {{ hasTodoItem(id: number): boolean }} HasTodoItem *\u002F\n\n\u002F** @typedef {{ removeTodoItem(id: number): void }} RemoveTodoItem *\u002F\n\n\u002F** @typedef {{ getTodoItems(): ReadonlyArray&lt;Item\u003E }} GetTodoItems *\u002F\n\n\u002F** @typedef {{ addTodoItem(id: number, item: Item): void }} AddTodoItem *\u002F\n\n\u002F**\n * @typedef {(\n *  &amp; HasTodoItem\n *  &amp; AddTodoItem\n *  &amp; GetTodoItems\n *  &amp; RemoveTodoItem\n * )} TodoItemsRepository\n *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗдесь мы можем наблюдать список из 4 алгебр операций. Каждая такая алгебра содержит в себе всего одно поле-функцию. Затем, при помощи операции объединения типов, из этих 4 алгебр получается одна алгебра репозитория, содержащая в себе 4 операции. 4(1) -\u003E 1(4).\u003C\u002Fp\u003E\u003Cp\u003EАналогичным образом объявим алгебры для репозитория-счетчика идентификаторов:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @typedef {{ getNextTodoId(): number }} GetNextTodoId *\u002F\n\n\u002F** @typedef {{ incrementNextTodoId(): void }} IncrementNextTodoId *\u002F\n\n\u002F**\n * @typedef {(\n *  &amp; GetNextTodoId\n *  &amp; IncrementNextTodoId\n * )} TodoIdsRepository\n *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ фасада логирования:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @typedef {{ clearConsole(): void }} ClearConsole *\u002F\n\n\u002F** @typedef {{ write(message: string): void }} Write *\u002F\n\n\u002F** @typedef {{ readLine(question: string): Promise }} ReadLine *\u002F\n\n\u002F**\n * @typedef {(\n *  &amp; Write\n *  &amp; ReadLine\n *  &amp; ClearConsole\n * )} ConsoleFacade\n *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EДалее, когда все алгебры фасадов и репозиториев готовы, наступает время объединить их в алгебры сервисов. Принцип прост — если несколько алгебр не могут использоваться друг без друга, то они должны быть объединены. В нашем случае, репозиторий, хранящий задачи, не рационально использовать без репозитория, хранящего идентификатор следующей задачи.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F**\n * @typedef {(\n *  &amp; TodoIdsRepository\n *  &amp; TodoItemsRepository\n * )} TodoItemsAlgebra\n *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EФасад консоли может быть использован сам по себе, так что в состав сервиса консоли входит только он один.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F**\n * @typedef {(\n *  &amp; ConsoleFacade\n * )} ConsoleAlgebra\n *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ последний этап — объединить все алгебры сервисов в единую алгебру приложения. \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F**\n * @typedef {(\n *  &amp; ConsoleAlgebra\n *  &amp; TodoItemsAlgebra\n * )} Program\n *\u002F\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EРеализация интерпретаторов\u003C\u002Fh3\u003E\u003Cp\u003EТеперь, когда есть алгебры, можно реализовать интерпретаторы, которые будут использоваться в рабочем запуске приложения.\u003C\u002Fp\u003E\u003Cp\u003EИнтерпретатор репозитория задач\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {Map&lt;number, Item\u003E} *\u002F\nconst items = new Map()\n\n\u002F** @type {TodoItemsRepository} *\u002F\nconst todoItemsRepository = {\n  getTodoItems: () =\u003E Array.from(items.values()),\n  addTodoItem: (id, item) =\u003E item.set(id, item),\n  removeTodoItem: id =\u003E items.delete(id),\n  hasTodoItem: id =\u003E items.has(id),\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИнтерпретатор, хранящий идентификатор для следующей задачи\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {number} *\u002F\nlet nextId = startTodoId\n\n\u002F** @type {TodoIdsRepository['getNextTodoId']} *\u002F\nfunction getNextTodoId () { return nextId }\n\n\u002F** @type {TodoIdsRepository['incrementNextTodoId']} *\u002F\nfunction incrementNextTodoId () { nextId = nextId + 1 }\n\n\u002F** @type {TodoIdsRepository} *\u002F\nconst todoIdsRepository = {\n  incrementNextTodoId,\n  getNextTodoId,\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИнтерпретатор для фасада консоли\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst c = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\n\n\u002F** @type {ConsoleFacade['write']} *\u002F\nfunction write (message) {\n  c.write(message)\n}\n\n\u002F** @type {ConsoleFacade['readLine']} *\u002F\nfunction readLine (question) {\n  return new Promise(resolve =\u003E {\n    c.question(question, resolve)\n  })\n}\n\n\u002F** @type {ConsoleFacade['clearConsole']} *\u002F\nfunction clearConsole () {\n  console.clear()\n}\n\n\u002F** @type {ConsoleFacade} *\u002F\nconst consoleFacade = { readLine, write, clearConsole }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТеперь, по аналогии с алгебрами, создадим интерпретаторы для сервисов\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {TodoItemsAlgebra} *\u002F\nconst todoItemsAlgebra = {\n  ...todoItemsRepository,\n  ...todoIdsRepository,\n}\n\n\u002F** @type {ConsoleAlgebra} *\u002F \nconst consoleAlgebra = { \n  ...consoleFacade \n} \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ интерпретатор приложения\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {Program} *\u002F\nconst program = {\n  ...todoItemsAlgebra,\n  ...consoleAlgebra,\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EФилософия UNIX\u003C\u002Fh3\u003E\u003Cp\u003EЧасто приходится слышать мнение, что программы стоит проектировать в соответствии с философией UNIX. Когда начинаешь узнавать, в чем, по мнению говорящего, она заключается — в ответ слышишь: \"Нужно писать маленькие программы, которые делают одно дело, но делают его лучше остальных\". Подобная трактовка этой философии уже успела завести человечество в ад микросервисов, из которого, пока, мало кто хочет выбираться.\u003C\u002Fp\u003E\u003Cp\u003EЧто же упущено здесь из виду? Давайте посмотрим на две программы, которые являются эталонными представителями философии UNIX — grep и sed. Какими еще особенностями они обладают, помимо того, что выполняют единственную задачу? Во-первых, они ничего не знают друг про друга. Чтобы использовать несколько независимых программ вместе, их достаточно просто объединить при помощи слоя высшего порядка, которым выступает Shell, в случае UNIX. Получается красивая двуслойная архитектура — множество независимых приложений, на нижнем уровне, объединяются в одно на верхнем. Сравните это с графом асинхронно взаимодействующих друг с другом микросервисов. Или хотя-бы с иерархией объектно-ориентированных сервисов, взаимодействующих точно так же, но синхронно.\u003C\u002Fp\u003E\u003Cp\u003EТак как все в нашем мире фрактально, можно опустить эту же двуслойную методологию на уровень монолитного приложения. Вместо приложений будут независимые сервисы, а заменой Shell станет обычный код на JavaScript. Если посмотреть еще глубже, то можно заметить, что алгебры внутри сервиса тоже независимы. И даже отдельные операции ничего не знают друг о друге.\u003C\u002Fp\u003E\u003Ch3\u003EВычисления\u003C\u002Fh3\u003E\u003Cp\u003EТеперь, когда интерпретаторы готовы, можно на их основе реализовать вычисления. \u003C\u002Fp\u003E\u003Cp\u003EВычисления делятся на два вида: сервисные и прецедентные. Сервисные вычисления строятся на основе алгебры сервиса, что позволяет легко переиспользовать их в других проектах. Так как сервисы полностью независимы друг от друга, то для этого достаточно просто скопировать папку с сервисом в нужный проект и подключить алгебру сервиса к алгебре приложения, а интерпретатор сервиса к интерпретатору приложения. Вычисления прецедентов являются, с точки зрения описанного в предыдущем разделе, вторым, верхним, слоем архитектуры, который объединяет все сервисы воедино. Они зависят от алгебры приложения.\u003C\u002Fp\u003E\u003Cp\u003EДавайте, для примера, реализуем сервисное вычисление, добавляющее в список новую задачу.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {(P: TodoItemsAlgebra) =\u003E (text: string) =\u003E void} *\u002F\nconst addTodoItem = P =\u003E text =\u003E {\n  const id = P.getNextTodoId()\n\n  \u002F** @type {Item} *\u002F\n  const item = { id, text }\n\n  P.addTodoItem(id, item)\n\n  P.incrementNextTodoId()\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВычисление принимает, в качестве единственного параметра, интерпретатор, удовлетворяющий алгебре сервиса, а затем возвращает функцию, принимающую текст задачи и выполняющую действия по ее добавлению. Сначала вызывается операция \u003Ccode\u003EgetNextTodoId\u003C\u002Fcode\u003E, являющаяся частью интерпретатора, и возвращающая идентификатор для новой задачи. Затем строится объект задачи и добавляется к списку при помощи операции \u003Ccode\u003EaddTodoItem\u003C\u002Fcode\u003E. Чтобы в следующий раз задача создавалась уже с новым идентификатором, необходимо его инкрементировать, вызвав \u003Ccode\u003EincrementNextTodoId\u003C\u002Fcode\u003E. \u003C\u002Fp\u003E\u003Cp\u003EВажно отметить, что на данном этапе можно отбросить знание о том, что операции принадлежат к разным репозиториям. Поэтому я намеренно опустил, что \u003Ccode\u003EaddTodoItem\u003C\u002Fcode\u003E, например, принадлежит к \u003Ccode\u003ETodoItemsRepository\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЧтобы использовать данное вычисление, достаточно передать в него любой интерпретатор, удовлетворяющий алгебре \u003Ccode\u003ETodoItemsAlgebra\u003C\u002Fcode\u003E. Это может быть сервисный интерпретатор, либо же интерпретатор приложения, так как множество операций сервисной алгебры является подмножеством операций алгебры приложения.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EaddTodoItem(todoItemsAlgebra)('task1')\n\u002F\u002F Is equal to\naddTodoItem(program)('task1')\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОбычно, сервисные интерпретаторы напрямую используются только при тестировании сервисных вычислений, чтобы не создавать за зря интерпретатор приложения.\u003C\u002Fp\u003E\u003Cp\u003EВ вычислениях интерпретатор намеренно помещается первым, отдельно от остальных параметров, чтобы это вычисление можно было использовать в бесточечной нотации. Представим, у нас есть массив текстов для задач. Тогда их все можно добавить следующим образом:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econst texts = ['task1', 'task2']\n\ntexts.forEach(text =\u003E addTodoItem(program)(text))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКак можно заметить, применение анонимной функции здесь излишне, так как результатом \u003Ccode\u003EaddTodoItem(program)\u003C\u002Fcode\u003E уже является функция, принимающая текст и добавляющая задачу. Поэтому вызов можно упростить:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Etexts.forEach(addTodoItem(program))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕсли бы интерпретатор не передавался отдельно, то, в этом случае, анонимную функцию создать все-же пришлось бы.\u003C\u002Fp\u003E\u003Cp\u003EТакже на уровне сервисных вычислений, но теперь уже на основе сервиса консоли, возможно реализовать функцию \u003Ccode\u003Enotify\u003C\u002Fcode\u003E, оповещающую пользователя о чем-либо.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {(P: ConsoleAlgebra) =\u003E (text: string) =\u003E Promise&lt;void\u003E} *\u002F\nconst notify = P =\u003E async text =\u003E {\n  P.write('\\n' + text + '\\n')\n\n  await P.readLine('Press enter to continue')\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОна выводит сообщение на экран, обрамляя его символами новой строки, а затем ожидает подтверждение от пользователя.\u003C\u002Fp\u003E\u003Cp\u003EЧтобы вывести задачи на экран, необходимо обратиться сразу к двум сервисам: сервису задач и сервису консоли. Это значит, что такое вычисление будет прецедентным, зависящим от алгебры приложения.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {(P: Program) =\u003E (item: Item) =\u003E void} *\u002F\nconst writeTodoItem = P =\u003E item =\u003E P.write(`${item.id}) ${item.text}\\n`)\n\n\u002F** @type {(P: Program) =\u003E () =\u003E void} *\u002F\nconst writeTodoItems = P =\u003E () =\u003E {\n  const items = P.getTodoItems()\n\n  if (items.length === 0) {\n    P.write('TODO list is empty\\n')\n  } else {\n    P.write('TODO items list:\\n')\n\n    items.forEach(writeTodoItem(P))\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПри написании кода было учтено, что вывод каждой отдельной задачи можно также представить в виде самостоятельного вычисления. Технически, оно зависит только от сервиса консоли, но его логика настолько специфична, что вряд-ли оно может понадобиться кому-то, кто будет переиспользовать этот сервис в другом приложении. Поэтому вычисление было решено объявить прецедентным.\u003C\u002Fp\u003E\u003Cp\u003EТакже, когда одни вычисления вызываются другими, в них передается не какой-то конкретный интерпретатор, а тот, который был помещен в вызывающее вычисление сверху. Получается такая картина: существуют какие-то вычисления, находящиеся на самом верху иерархии вызовов. В веб-приложениях, например, это контроллеры, а в консольных приложениях это может быть функция, запускающая основной цикл выполнения, как в нашем случае. В эти вычисления, при запуске, инфраструктурный код помещает какой-то интерпретатор, рабочий или тестовый. И они далее, не зная, какой именно интерпретатор был передан на этот раз, затем передают его вниз по иерархии вызовов.\u003C\u002Fp\u003E\u003Cp\u003EВ данном конкретном случае, вычисление \u003Ccode\u003EwriteTodoItems\u003C\u002Fcode\u003E принимает интерпретатор через параметр \u003Ccode\u003EP\u003C\u002Fcode\u003E, а затем передает его во \u003Ccode\u003EwriteTodoItem\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eitems.forEach(writeTodoItem(P))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОсталось переписать самую главную функцию, чтобы она соответствовала новым правилам.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F** @type {(P: Program) =\u003E () =\u003E Promise&lt;void\u003E} *\u002F\nasync function runProgram = P =\u003E () =\u003E {\n  while (true) {\n    P.clearConsole()\n\n    writeTodoItems(P)()\n\n    const input = await P.readLine('Write the next command: ')\n\n    if (input === '.') { return }\n    \n    if (input.startsWith('+')) {\n      const text = input.substring(1).trim()\n\n      if (text.length === 0) {\n        await notify(P)('Can not add an empty item')\n\n        continue\n      }\n\n      addTodoItem(P)(text)\n\n      continue\n    }\n\n    await notify(P)('Wrong command')\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВсе побочные эффекты, которые ранее могли быть выполнены напрямую, теперь проксируются через интерпретатор. Там, где требуется более сложная логика, интерпретатор передается в вычисления, которые берут часть работы на себя. А вот внешне код выглядит почти так же, как и выглядел ранее.\u003C\u002Fp\u003E\u003Cp\u003EПоследнее, что остается — на инфраструктурном уровне запустить алгоритм.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003ErunProgram(program)()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВот, как действительно должна выглядеть разработка программ по философии UNIX.\u003C\u002Fp\u003E\u003Ch3\u003EИтоги\u003C\u002Fh3\u003E\u003Cp\u003EПодведем итоги, выделив три правила:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EПобочные эффекты должны быть абстрагированы встраиваемым предметно-ориентированным языком, выраженным алгеброй на множестве всех типов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EОтдельные алгебры, которые не могут использоваться в отрыве друг от друга, должны быть объединены в сервисы. Алгебры сервисов должны быть объединены в алгебру приложения.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВсе вычисления, основанные на полученном предметно-ориентированном языке, должны делиться на два вида: сервисные вычисления, которые зависят от алгебры сервиса, и вычисления прецедентов, зависящие от алгебры приложения.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003EДля желающих глубже разобраться я создал репозиторий с кодом рассмотренной программы и даже чуть больше: \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fawerlogus\u002Ftodo-app-example\" rel=\"noopener noreferrer nofollow\"\u003Eawerlogus\u002Ftodo-app-example\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЗабыл сказать — на данный момент подход называется \"Восьмая архитектура\". После пятой архитектуры нам стало лень придумывать имена, и мы стали просто обозначать все новые архитектуры по порядковому номеру. Если есть идеи, как можно назвать получше — предлагайте в комментариях.\u003C\u002Fp\u003E\u003Cp\u003EВ следующей статье поговорим про написание тестов для вычислений. \u003C\u002Fp\u003E\u003Cp\u003EБлагодарю за внимание.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"архитектура"},{"titleHtml":"архитектура по"},{"titleHtml":"javascript"},{"titleHtml":"node.js"},{"titleHtml":"nodejs"},{"titleHtml":"typescript"},{"titleHtml":"ооп"},{"titleHtml":"фп"},{"titleHtml":"ts"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F584502\u002Fc690802d180dbfc09d25ec5949a3a0ab\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F584502\u002Fc690802d180dbfc09d25ec5949a3a0ab\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F584502\\\u002F\"},\"headline\":\"Размышления об идеальной архитектуре для JavaScript\",\"datePublished\":\"2021-10-20T12:14:11+03:00\",\"dateModified\":\"2021-10-20T12:14:11+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Michael Borislav\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, рез...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F584502\\\u002F#post-content-body\",\"about\":[\"h_javascript\",\"h_analysis_design\",\"h_nodejs\",\"h_oop\",\"h_typescript\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F584502\\\u002Fc690802d180dbfc09d25ec5949a3a0ab\\\u002F\"]}","metaDescription":"В 2020 году, в конце марта, меня пригласили писать бэк на Node.JS для сервиса видеоконференций. Тогда, во времена начала очередного витка мирового спектакля, резко возрос спрос на инструменты,...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"javascript,analysis_design,nodejs,oop,typescript"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
