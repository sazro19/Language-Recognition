<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Написание компилятора на Haskell + LLVM / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/581234\/"},"headline":"Написание компилятора на Haskell + LLVM","datePublished":"2021-10-06T23:13:47+03:00","dateModified":"2021-10-07T23:29:31+03:00","author":{"@type":"Person","name":"Игорь Бесчастнов"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C\/C++, в одном pet-project использовал Haskell. С таким багажо...","url":"https:\/\/habr.com\/ru\/post\/581234\/#post-content-body","about":["h_haskell","h_compilers","h_funcprog","h_DIY","f_develop","f_popsci"],"image":["https:\/\/habr.com\/share\/publication\/581234\/ca3b6122a243d82baaa04127f3cc62b7\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/1c1\/e91\/60f\/1c1e9160f3dec79f1fbc97f0765bf229.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Написание компилятора на Haskell + LLVM" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Написание компилятора на Haskell + LLVM" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Написание компилятора на Haskell + LLVM" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C/C++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C/C++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C/C++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C/C++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C/C++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/8bf/9da/8ab/8bf9da8ab2389bff724179f9ad0073bf.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/8bf/9da/8ab/8bf9da8ab2389bff724179f9ad0073bf.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/8bf/9da/8ab/8bf9da8ab2389bff724179f9ad0073bf.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/8bf/9da/8ab/8bf9da8ab2389bff724179f9ad0073bf.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/8bf/9da/8ab/8bf9da8ab2389bff724179f9ad0073bf.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="581234" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-06T20:13:47.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/581234/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/581234/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/8bf/9da/8ab/8bf9da8ab2389bff724179f9ad0073bf.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/581234/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/VoidDruid/" title="VoidDruid" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/ede/702/5ad/ede7025adfbe23f77b0cbd09e7feb966.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/VoidDruid/" class="tm-user-info__username">
      VoidDruid
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-06T20:13:47.000Z" title="2021-10-06, 23:13">6  октября   в 23:13</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Написание компилятора на Haskell + LLVM</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/haskell/" class="tm-article-snippet__hubs-item-link"><span>Haskell</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/compilers/" class="tm-article-snippet__hubs-item-link"><span>Компиляторы</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/funcprog/" class="tm-article-snippet__hubs-item-link"><span>Функциональное программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/DIY/" class="tm-article-snippet__hubs-item-link"><span>DIY или Сделай сам</span> <!----></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Tutorial
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C/C++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание <strong>компилятора на основе LLVM</strong> - зачем и что получилось я уже рассказывал в <a href="https://habr.com/ru/post/508828/" rel="noopener noreferrer nofollow">предыдущей статье</a>.</p><p>Эту статью я пишу для тех, кто так же, как и я, заинтересован в изучении Haskell, создании собственных языков программирования, или хочет поиграться с LLVM, но не знает с какого конца подойти к задаче.</p><p>Я кратко расскажу про необходимый <strong>минимум знаний Haskell</strong>, про свои <strong>ошибки и к каким решениям я пришел</strong> - а так же про решения, о которых я узнал позже - и как их можно интегрировать в ваш pet-компилятор. На всё это я по возможности дам <strong>ссылки на изучение</strong>.</p><figure class="full-width "><img src="/img/image-loader.svg" height="850" data-src="https://habrastorage.org/getpro/habr/upload_files/1c1/e91/60f/1c1e9160f3dec79f1fbc97f0765bf229.png" data-width="1890"/><figcaption></figcaption></figure><hr/><h3>Оглавление</h3><ol><li><p><a href="#part-1" rel="noopener noreferrer nofollow">Haskell - настраиваем проект и необходимые знания языка</a></p></li><li><p><a href="#part-2" rel="noopener noreferrer nofollow">Основы языка - синтаксис, парсер, AST</a></p></li><li><p><a href="#part-3" rel="noopener noreferrer nofollow">Кодогенерация с LLVM</a></p></li><li><p><a href="#part-4" rel="noopener noreferrer nofollow">Заключение</a></p></li></ol><blockquote><p>Код из этой статьи, разложенный по шагам: <a href="https://github.com/VoidDruid/habr-hs-llvm" rel="noopener noreferrer nofollow">https://github.com/VoidDruid/habr-hs-llvm</a></p></blockquote><p>Репозиторий по этой ссылке можно использовать как "интерактивный учебник" в паре со статьей.</p><a class="anchor" name="part-1" id="part-1"></a><h2>Haskell -  необходимые знания языка и настройка проекта</h2><p>Как можно понять из вступления к статье - я в haskell совершенно не специалист. Эта статья - не мастер-класс по разработке компиляторов и не учебник по этому языку, а скорее практическое пособие на тему того, как подойти к жутко звучащей задаче - написанию компилятора на хаскеле, и не пойти на дно из-за "наслоения сложности". Далее я пошагово разберу этот процесс на примере <a href="https://github.com/VoidDruid/grit" rel="noopener noreferrer nofollow">своей дипломной работы</a>, выкинув некоторые фичи, не нужные в рамках этой статьи (декораторы, например).</p><p>Благодаря этому проекту и нескольким после него я сильно продвинулся в haskell, но к началу работы над компилятором я успел написать на этом языке только <a href="https://github.com/VoidDruid/telemonitor" rel="noopener noreferrer nofollow">telegram-бота</a>, который помогает мне мониторить личный сервер. Для программистов примерно с такими же базовыми познаниями в хаскеле написана эта статья. В дальнейшем я рассчитываю, что вы знаете (хотя можно разобраться и по ходу):</p><ul><li><p>Базовый синтаксис языка</p></li><li><p>Модули и импорты</p></li><li><p>Как <em>работать</em> с монадами (не обязательно уметь писать свои), хотя бы поверхностно</p></li><li><p>do-нотация</p></li><li><p>IO монада</p></li><li><p>Рекурсия, частичное применение функций, объявление типов</p></li><li><p><em>Желательно</em>: typeclasses, алгебраические типы данных, records</p></li></ul><p>Я попытаюсь объяснить, зачем и как используется каждая фича языка, указанная в пункте "<em>желательно</em>", но будет проще, если вы с ними знакомы.</p><p>Собирать проект мы будем с помощью stack - установить его довольно просто (<a href="https://docs.haskellstack.org/en/stable/README/#how-to-install" rel="noopener noreferrer nofollow">инструкция</a>), пользоваться тоже. Создавать проект с нуля не придется - можно клонировать <a href="https://github.com/VoidDruid/habr-hs-llvm" rel="noopener noreferrer nofollow">этот репозиторий</a>, и идти в нем по шагам параллельно со статьей (readme есть в каждой папке плюс глобальный - ознакомьтесь с ними, чтоб упростить сборку и запуск кода). Или можно делать все самостоятельно, все же создав новый проект - с помощью самого stack (<a href="https://docs.haskellstack.org/en/stable/README/#start-your-new-project" rel="noopener noreferrer nofollow">инструкция</a>) или используя этот <a href="https://github.com/ProjectTemplates/haskell-simple" rel="noopener noreferrer nofollow">шаблон для cookiecutter</a>.</p><blockquote><p><a href="https://eax.me/haskell-stack/" rel="noopener noreferrer nofollow">Неплохая статья</a> для начинающих про stack на русском</p><p>Книга про haskell на английском, которую можно использовать как <a href="http://learnyouahaskell.com/chapters" rel="noopener noreferrer nofollow">онлайн-справочник</a>  </p></blockquote><p>Если вы решили работать со статьей совместно с кодом из репозитория с пошаговым разбором, то перед тем как мы пойдем дальше, зайдите в папку <code>step-00</code>, и запустите <code>stack run</code>. Если программа с вами поздоровалась, то мы готовы идти дальше. Сейчас мы находимся в директории <code>step-00</code>, соответствующей <code>ШАГ 0</code>. В дальнейшем, переходы к следующему шагу (и, соответственно, к другой папке с кодом) будут отмечены именно так - <code>ШАГ Х</code>.</p><a class="anchor" name="part-2" id="part-2"></a><h2>Основы языка - синтаксис, парсер, AST</h2><h3>Базовый парсинг</h3><p><code>ШАГ 1</code></p><p>Первое, что мы попробуем сделать - это написать простой парсер. В стандартной библиотеке хаскеля есть отличный модуль <em>Parsec</em> (Parser Combinators - <a href="https://hackage.haskell.org/package/parsec" rel="noopener noreferrer nofollow">описание и документация</a>; <a href="https://www.stephendiehl.com/llvm/#chapter-2-parser-and-ast" rel="noopener noreferrer nofollow">туториал, по которому учился я</a>), позволяющий в декларативном стиле описывать парсеры. Для сборки необходимо добавить его в <code>.cabal</code> файл в секцию <code>build-depends</code>.</p><blockquote><p><a href="https://habr.com/ru/post/50337/" rel="noopener noreferrer nofollow">Туториал</a> по Parsec на русском</p></blockquote><p>На данном этапе, весь код все еще будет помещаться в модуле <code>Main</code>. Добавим несколько импортов:</p><pre><code class="haskell">import Text.Parsec (parse)
import Text.Parsec.String (Parser)
import Text.Parsec.Language (emptyDef)
import qualified Text.Parsec.Token as Tok</code></pre><p>Что мы импортировали:</p><ul><li><p><code>parse</code> - функция, прогоняющая парсер на входном потоке данных</p></li><li><p><code>Parser</code> - определение типа простого парсера, принимающего на вход строки</p></li><li><p><code>emptyDef</code> - "пустое" определение синтаксиса языка, на основе которого мы сделаем свое</p></li><li><p><code>Text.Parsec.Token</code> - основной модуль с функциями-парсерами</p></li></ul><p>Создадим новое определение лексера, с помощью функции <code>makeTokenParser</code>, передав ей на вход определение синтаксиса нашего языка:</p><pre><code class="haskell">lexer :: Tok.TokenParser ()
lexer = Tok.makeTokenParser style
  where
  ops = [ "+", "*", "-", "/"]
  names = ["if", "else"]
  style = emptyDef {
  Tok.commentLine = "//"
  , Tok.commentStart = "/*"
  , Tok.commentEnd = "*/"
  , Tok.caseSensitive = True
  , Tok.reservedOpNames = ops
  , Tok.reservedNames = names
  }</code></pre><p>Тут мы создали новый <code>record</code> под названием <code>style</code>, в котором описали базовый синтаксис нашего языка, пока что крайне простого - си-подобные комментарии, базовые операции (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) и зарезервированные слова <code>if</code> и <code>else</code>. Получившийся лексер мы теперь можем передать <a href="https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec-Token.html#t:GenTokenParser" rel="noopener noreferrer nofollow">конструкторам парсеров</a> из <code>Tok</code>, чтобы получить конкретный функции-парсеры для нашего языка:</p><pre><code class="haskell">integer    = Tok.integer lexer
float      = Tok.float lexer
-- и так далее, полный код - https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-01/app/Main.hs</code></pre><p>Попробуем написать парсер, который понимает простую операцию сложения целых чисел и возвращает результат.</p><p>Для парсеров определены монадные операторы, и если посмотреть определение типа, то видно что мы можем использовать их совместно с собственными монадами, state-ами и т.д. Когда я только начинал работать с Parsec, я этого не знал, и просто использовал do-нотацию, потому что так было написано в туториалах. Выше я вставлял ссылки на документацию, там можно увидеть что <code>ParserT</code> это на самом деле монадный трансформер, для которого определена куча инстансов монадных тайп классов, большинство из которых я до сих пор не понимаю. Для наших целей достаточно знать, что сами парсеры возвращают значения, а парсер-комбинаторы принимают одни парсеры и возвращают новые.</p><p>Зная это, определеить парсер для сложения можно так:</p><pre><code class="haskell">sumParse :: Parser Integer
sumParse = do
  first &lt;- integer
  reservedOp "+"
  second &lt;- integer
  return (first + second)

runSumParse = parse sumParse "&lt;stdin>"</code></pre><p>Вернуть из парсера можно по-большому счету что угодно, тип просто поменяется на <code>Parser ЧтоУгодно</code>. Функция <code>sumParse</code> принимает строку, и разбирает ее как бы по инструкции, соответствущей последовательности операции в do-блоке:</p><ul><li><p>Берет первое число <code>first &lt;- integer</code></p></li><li><p>Считывает зарезервированный оператор "+"</p></li><li><p>Берет второе число <code>second &lt;- integer</code></p></li><li><p>Возвращает результат сложения <code>return (first + second)</code></p></li></ul><p>У функции <code>runSumParse</code> один входной параметр - строка, которую она передает на разбор <code>sumParse</code>. <code>"&lt;stdin>"</code> -  указание на "источник" входных данных, используется это для сообщений об ошибках, например.</p><p>Если войти в ghci (команда <code>stack ghci</code>), и запустить <code>runSumParse "1 + 2"</code> -  вернется <code>Right 3</code>. Это значит что наш парсер отработал без ошибок, и вернул результат <code>3</code> - у функции <code>parse</code> тип возвращаемого значения <code>Either ParseError a</code> - где <code>a</code> - тип, возвращаемый <code>sumParse</code>, то есть <code>Integer</code>.</p><p>В качестве подведения черты под этим этапом, перепишем функцию <code>main</code> так, чтобы она читала строку из консоли, парсила сложение, и выводила результат или ошибку:</p><pre><code class="haskell">main = do
  line &lt;- getLine
  case runSumParse line of
  	Right result -> putStrLn ("Result: " ++ show result)
  	Left error -> print error</code></pre><details class="spoiler"><summary>Упражнение - парсер инкремента '1++'. Решение под спойлером</summary><div class="spoiler__content"><p> Во-первых, нам надо добавить операцию "++" в список зарезервированных операций: <code>ops = [ "++", "+", "*", "-", "/"]</code>. Затем пишем аналогичный парсер:</p><pre><code class="haskell">incrParse = do
	first &lt;- integer
  reservedOp "++"
  return (first + 1)</code></pre></div></details><h3>Описание AST</h3><p><code>ШАГ 2</code></p><p>Один из самых интересных этапов в проектировании языка, по-моему опыту - это описание формата <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE" rel="noopener noreferrer nofollow">синтаксического дерева</a>. Именно тут закладывается фундамент для всех конструкций языка.</p><p>В случае с хаскелем, описать "обычное" дерево легко - это рекурсивный алгебраический тип данных:</p><pre><code class="haskell">data Tree a
	= Leaf  -- тупик
	| Node a (Tree a) (Tree a)  -- узел дерева - значение и две "ячейки" под ветки
	deriving Show</code></pre><p>Тут <code>Leaf</code> и <code>Node</code> - конструкторы данных типа <code>Tree a</code>, где <code>a</code> - тип данных, которые содержат узлы дерева. Аналогичным образом мы можем описать и структуру выражения в нашем языке (еще раз напомню, что хоть синтаксис и похож на Си, мы пишем не сишный компилятор, а реализацию "учебного" си-подобного языка):</p><pre><code class="haskell">data Expr
  = Int Integer  -- значение типа Integer
  | Var Name  -- обращение к переменной
  | Def ExprType Name  -- объявление переменной
  | Block (CodeBlock Expr)  -- блок кода
  | Call String [Expr]  -- вызов функции с указанными аргументами
  | Function ExprType Name [Expr] (Maybe Name) (CodeBlock Expr)  -- объявление функции (разберем подробно далее)
  | BinaryOp String Expr Expr  -- бинарная операция над двумя выражениями
  | If Expr (CodeBlock Expr) (CodeBlock Expr)  -- if - условие и две ветки исполнения
  deriving (Eq, Ord, Show)</code></pre><p>Таким образом, мы объявили самые базовые конструкции (см. комментарии в коде). Можно заметить, что здесь есть ссылки на дополительные типы данных - <code>ExprType</code>, <code>CodeBlock</code>. Первый - это просто "enum" с типами, поддерживаемыми нашей программой. Сейчас это только инты и функции, но оставим задел на будущее и объявим несколько дополнительных:</p><pre><code class="haskell">data ExprType
  = VoidType
  | IntType
  | FloatType
  | BytesType
  | BooleanType
  | CallableType [ExprType] ExprType  -- [типы аргументов] тип возвращаемого значения
  | AutoType  -- тип должен быть выведен автоматически
  deriving (Eq, Ord)</code></pre><p><code>CodeBlock</code> - это массив выражений, определен просто как:</p><pre><code class="haskell">type CodeBlock term = [term]
-- [expr1, expr2] это CodeBlock Expr</code></pre><p>Разница между типами <code>[Expr]</code> и <code>CodeBlock Expr</code> чисто формальная - <code>CodeBlock</code> я использую там, где список выражения является "телом" чего-либо (функции, цикла и пр.), а <code>[Expr]</code> - например, как список аргументов функции. Для такого же "семантического" удобства определим тип <code>AST</code>, который будем использовать только в высокоуровневых функциях:</p><pre><code class="haskell">type AST = [Expr]</code></pre><p>В отличии от <code>CodeBlock</code>, <code>AST</code> определен строго для <code>Expr</code> . Мне это показалось логичным в контексте того, что каждый из них "представляет" в программе. Однако если читателю это кажется излишним нагромождением типов, от всего этого можно избавиться и просто везде использовать <code>[Expr]</code>.</p><details class="spoiler"><summary>Как можно сделать круче</summary><div class="spoiler__content"><p>В синтаксическое дерево в реальном компиляторе конечно хочется засунуть гораздо больше информации - начиная от типов всех выражений (как это сделал я будет показано далее), и до, например, номеров строк на которых находились выражения - для отладки и формирования сообщений об ошибках.</p><p>Я осознал это довольно поздно, и решил не переделывать, благо для моих задач мне это не понадобилось, но в хаскеле для подобных "многослойных" структур часто используется подход "Recursion Schemes". Вот <a href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html" rel="noopener noreferrer nofollow">неплохая статья про него</a> - как можно видеть, от структуры того, что я делаю в этой статье, отличается не сильно, однако для применения этого подхода требуется существенно более высокий уровень знания языка.</p><p>Так что если вдруг после прочтения статьи вы вдохновитесь на написание "серьезного" компилятора, можете спокойно использовать все, про что я рассказываю в этом разделе, но перед переходом к написанию кодогенератора попробовать внедрить рекурсивные схемы.</p></div></details><p>После описания структуры языка можно перейти к написанию функций-парсеров. Пока у нас нет кодогенерации, смотреть что выдает парсер можно будет только распечатывая дерево <code>Expr</code>. Если положиться на <code>derive Show</code>, то в консоль будет вываливаться просто стена текста, так что попробуем определить для наших типов инстанс Show такой, чтоб можно было легко понимать структуру полученной программы.</p><p>Кода в этой секции много, весь его я здесь приводить не буду, только основные моменты. Остальное, как всегда, можно посмотреть <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-02/app/Syntax.hs" rel="noopener noreferrer nofollow">в репозитории туториала</a>.</p><p>Определить <code>Show</code> для типов довольно просто:</p><pre><code class="haskell">instance Show ExprType where
	show VoidType = "void"
	show IntType = "int"
	-- и т.д.</code></pre><p>Гораздо интереснее его определять для Expr. Довольно быстро я понял, что определять именно Show не слишком правильно - например, красиво распечатанный <code>If</code> может занимать несколько строк, что не подходит для <code>Show</code>, поэтому я создал аналогичный тайп класс:</p><pre><code class="haskell">{- 
тайп класс Pretty определяет функцию prettify, возвращающую массив строк -
для выражений, "красивая" распечатка которых может не помещаться в одну
-}
class Show e => Pretty e where
	prettify :: e -> [String]</code></pre><p>Я хотел иметь функцию <code>prettifyAST</code>, которой я мог бы передать <code>AST</code> (массив выражений) и получить список отформатированных строк - дальше их можно печатать отдельно или соединить в большое текстовое представление структуры программы (<code>intercalate "\n"</code> - каждый <code>String</code> на отдельной строке). Определил я эти функции так:</p><pre><code class="haskell">joinN = intercalate "\n"

prettifyAST :: Pretty e => [e] -> [String]
prettifyAST = map (joinN . prettify)

joinedPrettyAST :: Pretty e => [e] -> String
joinedPrettyAST = joinN . prettifyAST</code></pre><p>Теперь дело осталось только за определением инстанса <code>Pretty Expr</code>. Как это сделал я, можете посмотреть <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-02/app/Syntax.hs#L77" rel="noopener noreferrer nofollow">тут</a> (некоторые используемые функции определены в модуле <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-02/app/StringUtils.hs" rel="noopener noreferrer nofollow">StringUtils</a>), общая структура такая:</p><pre><code class="haskell">instance Pretty Expr where
  prettify expr = case expr of
    (Int i) -> [joinS ["Int", show i]]
    -- и так для каждого Expr</code></pre><h3>Парсинг</h3><p>Все еще <code>ШАГ 2</code></p><p>Теперь рассмотрим написание парсера. Для этого мы будем использовать лексер, объявленный в шаге 1. Для парсера я создал отдельный модуль <code>Parser</code> (<code>parser.hs</code>) и вынес все связанное с лексером из первого шага в модуль <code>Lexer</code> (<code>lexer.hs</code>). Тут не будет ничего принципиально нового, просто продолжение принципов парсер-комбинаторов, которые я уже показывал.</p><p>Вот что мы будем использовать (есть еще импорты из стандартной библиотеки, их я опускаю):</p><pre><code class="haskell">import qualified Text.Parsec.Expr as Ex
import qualified Text.Parsec.Token as Tok

import Lexer
import Syntax</code></pre><p>Первая и самая запутанная часть - объявить парсеры операций. Её я вынес под спойлер, кому интересно - можете посмотреть, а остальным предлагаю сразу переходить к парсерам выражений, я до сих пор под впечатлением, насколько элегантно это можно сделать.</p><p>Как всегда, полный код этого модуля (для данного этапа) <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-02/app/Parser.hs" rel="noopener noreferrer nofollow">в репозитории</a>.</p><details class="spoiler"><summary>Парсеры операций</summary><div class="spoiler__content"><p>Для начала объявим парсер для операторов вида " <code>+</code> ", " <code>*</code> " и так далее:</p><pre><code class="haskell">op :: Parser String
op = do
  whitespace
  o &lt;- operator
  whitespace
  return o</code></pre><p>Результат работы <code>op</code> это <code>String</code> для стуктуры</p><pre><code class="haskell">data Expr
=
  -- ...
  BinaryOp String Expr Expr  -- операция с двумя операндами</code></pre><p>Затем нам надо объявить валидные операторы, ассоциативность операций и их приоритет:</p><pre><code class="haskell">{-
binary - конструктор бинарных операций, вернет частично созданный BinaryOp
(без операндов типа Expr и Expr)
Принимает сам оператор (s) и ассоциативность (у нас - Ex.AssocLeft)
-}
binary s assoc = Ex.Infix (reservedOp s >> return (BinaryOp s)) assoc

-- Функция, возвращающая функцию-генератор парсеров с указанной ассоциативностью для списока операторов
opList arity = opList'
	where 
    opList' [op] = [arity op Ex.AssocLeft]
    opList' (op:ops) = arity op Ex.AssocLeft : opList' ops

binList = opList binary

-- Доступные бинарные операторы (точнее уже парсеры для них - применяется binList), в порядке убывания приоритета
binops = [
  binList ["*", "/", "//", "%"]
  , binList ["+", "-"]
  , binList ["&lt;", "=", "&lt;=", ">=", "==", "!="]
	]</code></pre></div></details><p>Объявим сначала верхнеуровневую функцию-парсер для любого выражения - она нам понадобится для использования внутри других:</p><pre><code class="haskell">{-
Сгенерированния парсеком функция-парсер, возвращаящая Expr.
factor - функция которую мы объявим далее, она парсит "обычные" Expr
binops - таблица операторов (+, *, &lt;, != и пр.), которая позволяет нам правильно парсить и операции над Expr (в нашем случае только бинарные - BinaryOp)
-}
expr :: Parser Expr
expr =  Ex.buildExpressionParser binops factor</code></pre><p>Функция <code>factor</code> - это комбинация парсеров для всех существующих <code>Expr</code>. Она должна попытаться их применить с помощью <a href="https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec-Prim.html#v:try" rel="noopener noreferrer nofollow">try</a>, и вернуть первый получившийся результат:</p><pre><code class="haskell">factor :: Parser Expr
factor = try cast
      &lt;|> try block
      &lt;|> try function
      -- и т.д.</code></pre><p>Уже известным нам способом объявим утилитарные функции для прогона парсера, и можно переходить к написанию парсеров самих выражений.</p><details class="spoiler"><summary>Функции для запуска парсинга</summary><div class="spoiler__content"><pre><code class="haskell">-- парсит все до eof с помощью переданной функции
contents :: Parser a -> Parser a
contents p = do
  Tok.whiteSpace lexer
  r &lt;- p
  eof
  return r

-- парсит верхнеуровневые объявления файла (в нашем случае - только функции)
toplevel :: Parser [Expr]
toplevel = many $ do
  def &lt;- function
  reservedOp ";"
  return def

-- парсит одно выражение
parseExpr :: String -> Either ParseError Expr
parseExpr s = parse (contents expr) "&lt;stdin>" s

-- парсит много выражений (файл с кодом)
parseCode :: String -> Either ParseError AST
parseCode s = parse (contents toplevel) "&lt;stdin>" s</code></pre></div></details><p>Здесь я не буду приводить все функции, только несколько примеров - остальные можно посмотреть в репозитории.</p><p>Самый простой пример - парсер интов. Библиотечной функцией <code>integer</code> мы достаем из входного потока число и создаем <code>Expr</code>с помощью конструктора <code>Int</code>:</p><pre><code class="haskell">int :: Parser Expr
int = Int &lt;$> integer</code></pre><p>Так же мы можем использовать парсеры внутри парсеров, совмещая их с библиотечными комбинаторами:</p><pre><code class="haskell">codeBlock :: Parser [Expr]
codeBlock = braces $ many $
  do e &lt;- expr
  reserved ";"
  return e</code></pre><p>Объединив все вместе, разберем чуть более сложный парсер:</p><pre><code class="haskell">ifelse :: Parser Expr
ifelse = do
  reserved "if"  -- ищем в потоке ключевое слово if
  cond &lt;- parens expr  -- затем любое заключенное в круглые скобки выражение
  tr &lt;- codeBlock  -- парсим codeBlock, это true-ветка ифа
  fl &lt;- optionMaybe $ do  -- ветка else необязательная, поэтом maybe мы сможем найти "else" и еще один codeBlock
    reserved "else"
    code &lt;- codeBlock
    return code
  return $ If cond tr (fromMaybe [] fl)  -- конструируем и возвращаем Expr</code></pre><p>Осталось попробовать что-нибудь распарсить. Переопределим <code>main</code> так, чтоб он принимал на вход имя файла, и печатал результат парсинга кода в нем. Импорты я опускаю, а сам <code>main</code> выглядит теперь так:</p><pre><code class="haskell">main = do
  args &lt;- getArgs  -- аргументы командной строки
  case args of
    []   -> putStrLn "Provide file name!"
    [filename] -> do  -- если получили один аргумент
      code &lt;- readFile filename  -- читаем файл
      case parseCode code of  -- и парсим его содержимое
        Left err -> print err
        -- если успех - используем нашу joinedPrettyAST чтоб сделать результат читаемым
        Right ast -> putStrLn (joinedPrettyAST ast)  
    _ -> putStrLn "Provide one file name!"</code></pre><p>Вот как выглядит <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-02/app/Main.hs" rel="noopener noreferrer nofollow">main.hs</a> и <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-02/main.grt" rel="noopener noreferrer nofollow">main.grt</a> (файл с кодом) у меня (и у вас, если вы идете по шагам). Запустим это с помощью </p><pre><code class="bash">stack run -- main.grt</code></pre><p>и полюбуемся на результаты нашей работы - красиво распечатанное AST.</p><details class="spoiler"><summary>Текстовое представление AST</summary><div class="spoiler__content"><pre><code>Function "main" int ; args [] ; returns Nothing {
  BinaryOp = (Def int "i") (Int 0)
  If (BinaryOp &lt; (Var "i") (Int 1)) {
    Int 0
  }
  else {
    Int 1
  }
}</code></pre></div></details><p>Теперь можно двигаться дальше - к типизации.</p><h3>Типизация</h3><p><code>ШАГ 3</code></p><p>После создания базового синтаксического дерева, настало время заняться типизацией. После добавления типов, мы хотели бы в каждом узле дерева иметь дополнительное поле типа <code>ExprType</code>, который мы заранее завели выше:</p><pre><code class="haskell">{- Конструктор типизированного выражения, принимающий тип и 
собственно выражение - одно из тех, что мы объявляли ранее -}
data TypedExpr = TypedExpr ExprType Expr</code></pre><p>Но такой код, естественно, не делает то что нужно - "внутри" <code>TypedExpr</code> все еще лежит обычный <code>Expr</code>. Решение, которое придумал я - не оптимальное, но делает все, что надо. Это добавление "промежуточного контейнера" <code>TExpr</code> и собственно определение <code>TypedExpr</code>. Исходники - <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-03/app/Syntax.hs#L54" rel="noopener noreferrer nofollow">тут</a>. Прелесть такого способа в том, что он также позволяет добавлять любые аннотации (в том же месте где и <code>ExprType</code>), однако многословен и не совсем идиоматичен. Описание моего тернистого пути под спойлером, а мы идем дальше.</p><details class="spoiler"><summary>Мои ошибки с добавлением типов</summary><div class="spoiler__content"><p>Тут-то и оказываются нужен тот самый подход рекурсивных схем.</p><p>Как я уже говорил, информации по написанию компиляторов на хаскеле, доступной для понимания новичку, почти нет, поэтому я просто пытался получить что-нибудь работающее, а компилятор - наверное, из возможных пет-проджектов самый требовательный к предварительному планированию. Когда я, посоветовавшись с корифеями, понял, что для добавления дополнительной информации в дерево надо использовать <a href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html" rel="noopener noreferrer nofollow">рекурсивные схемы</a> или что-то <a href="http://comonad.com/reader/2009/incremental-folds/" rel="noopener noreferrer nofollow">такое</a> (близкое по смыслу),  - я уже имел парсер и кодогенератор, работающие с <code>Expr</code>.</p><p>Пробовал делать что-то типо:</p><pre><code class="haskell">data Expr' e
= Int Integer
| Call String [e]</code></pre><p>И определять:</p><ul><li><p><code>type Expr = Expr' Expr</code> - ругается на цикл в определении</p></li><li><p><code>type Expr = Expr' Expr'</code> -  ругается, вполне очевидно, что для последнего <code>Expr'</code> не хватает аргумента</p></li><li><p><code>newtype Expr = Expr (Expr' Expr)</code> - а это уже близко к тем самым рекурсивным схемам, не хватает только правильно заиспользовать <code>Fix</code>, но на этом моменте я сломался</p></li></ul><p>В общем, не повторяйте моих ошибок и сразу используйте параметризованные типы, <code>Data.Fix</code> и прочие прелести. Я же решил - сделаем <code>TypedExpr</code> аналогом <code>Expr</code>, но с типами и соответствущими поправками. Идея такая - сначала получив дерево из <code>Expr</code>, применим алгоритм, который трансформирует его в дерево типа <code>TypedExpr</code> - в котором все выражения будут аннотированы.</p><p>Есть несколько способов это сделать:</p><ul><li><p>Можно перенести все конструкторы (с заменой <code>Expr</code> на <code>TypedExpr</code>) в определение <code>TypedExpr</code>, и добавить во все типы - <code>data TypedExpr = ... | TBlock ExprType (CodeBlock TypedExpr)</code>, но в таком случае "тип" это не аннотация, а "часть" объявления синтаксиса - мне это не понравилось</p></li><li><p>Можно сделать аналогично, но добавить тип не во все конструкторы, а в один, "главный" - <code>data TypedExpr = ... |  TypedExpr ExprType TypedExpr</code> - но тогда функции принимающие TypedExpr смогут принимать как "главное" объявление, так и инстансы без типов</p></li><li><p><strong>Вариант, на котором я остановился</strong> - промежуточный тип <code>TExpr</code>, с конструкторами аналогичными <code>Expr</code>, но ссылающимися на <code>TypedExpr</code> (т.е. определение дерева, с "узлами" из <code>TypedExpr</code>), и тип <code>data TypedExpr = TypedExpr ExprType TExpr</code>. Вместе с view-паттернами это в коде выглядит не так многословно, как может показаться, это будет видно далее.</p></li></ul></div></details><h4>Механизм аннотирования типами</h4><blockquote><p>Ради историчности, и чтоб сразу показать, где код можно улучшить, я оставил все свои первоначальные <code>TODO</code>-пометки в исходниках.</p></blockquote><p>На этом шаге мы добавляем модуль <code>AST</code>, в котором находятся все функции для обработки синтаксического дерева. "Верхнеуровневая" функция - <code>processAST</code> - объявлена <span>тут</span> и либо превращает <code>AST</code> в типизированные дерево (<code>TAST</code>), либо возвращает список ошибок. Все, что она делает сама - это применяет по очереди функции-обработчики обычного <code>AST</code> (сейчас это только <code>desugarFunc</code> - удаление из определения функций "сахара" в виде объявления имени возвращаемой переменной и явного ее указания в конце тела), а затем передает получившееся в <code>annotateTypes</code> (которая просто делает <code>deduceType</code> рекурсивно для каждого <code>expr</code>), и возвращает ее результат.</p><p>Логика <code>deduceType</code> довольно простая - она принимает аннотируемый <code>expr</code>, который, если все пройдет успешно, "заменится" своим typed-аналогом, и "карту типов" - ассоциативный массив известных "языковых единиц" (переменных, функций) с их типами - изначально пустой, и заполняющйся по мере углубления в дерево. Большая часть типов просто подсматиривается в определении, либо выводится из операций (int + int = int, int / int = float и т.д.). <code>auto</code> разрешается максимально просто - если известно значение присваемого выражения (арифметическая операция или вызов функции), то назначается этот тип, иначе возвращается ошибка.</p><p>Полные исходники - <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-03/app/AST/Typing.hs" rel="noopener noreferrer nofollow">тут</a>, либо в файле step-03/AST/Typing.hs.</p><p>Добавим <code>processAST</code> в <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-03/app/Main.hs#L31" rel="noopener noreferrer nofollow">main</a> и посмотрим что нам выведет наша программа теперь для простейшей функции.</p><p>Исходник:</p><pre><code class="cpp">int main() = {
    int i = 0;
    if (i &lt; 1) {
        0;
    }
    else {
         1;
    };
};</code></pre><p>Типизированное представление:</p><pre><code class="diff">Function (() -> int) main [] {
  BinaryOp i= (Def int "i") (int 0)
  If int (BinaryOp b&lt; (Var int "i") (int 1)) {
    int 0
  }
  else {
    int 1
  }
}</code></pre><p>Тут <code>i=</code> - интовое присвоение, а <code>b&lt;</code> - операция сравнения, которая (очевидно) возвращает bool.</p><a class="anchor" name="part-3" id="part-3"></a><h2>Кодогенерация с LLVM</h2><p><code>ШАГ 4</code></p><p>В этом разделе мы воспользуемся инфраструктурой LLVM для создания машинного когда из нашего синтаксического дерева. Для этого нам нужна библиотека llvm-hs (<a href="https://github.com/llvm-hs/llvm-hs" rel="noopener noreferrer nofollow">github</a>, <a href="https://hackage.haskell.org/package/llvm-hs" rel="noopener noreferrer nofollow">hackage</a>), которую, вместе с некоторыми другими, надо добавить в зависимости нашего проекта. В моем stack.yaml это выглядит так:</p><pre><code>extra-deps:
- llvm-hs-9.0.1
- llvm-hs-pure-9.0.0
- llvm-hs-pretty-0.9.0.0</code></pre><p>Если же вы идете по туториалу по шагам из <a href="https://github.com/VoidDruid/habr-hs-llvm" rel="noopener noreferrer nofollow">репозитория</a>, то переходите в <strong>step-04</strong>.</p><p>Необходимо установить и саму LLVM - как это сделать, описано в документации llvm-hs. <a href="https://github.com/llvm-hs/llvm-hs/tree/3d08076125057e64702c5f4f189852ecae326cdd#installing-llvm" rel="noopener noreferrer nofollow">Инструкция</a>. Соответствущие изменения в конфигурационных файлах проекта - <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/stack.yaml" rel="noopener noreferrer nofollow">stack.yaml</a> и <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/habrhs.cabal" rel="noopener noreferrer nofollow">habrhs.cabal</a></p><h3>Из TAST в IR</h3><p>Это - финишная прямая. Тут мы добавим модуль <code>Codegen</code>, главная его функция - <code>buildIR</code>, выдающая промежуточное представление LLVM IR. Сразу добавим этот этап в <code>main</code> <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/app/Main.hs#L41" rel="noopener noreferrer nofollow">следующим образом</a>, чтобы сосредоточиться только на кодогенерации (обратите внимание - появилось много импортов и флаг --emit).</p><p><code>Codegen</code> состоит из трех файлов, главный - <code>Builder.hs</code>, где и происходит генерация IR, остальные содержат утилиты, по которым я предлагаю быстро пройтись (обратите внимание, что тут везде импортированы модули <code>LLVM.*</code>, функции с разными "компиляторными" названиями типо allocate или reference - это оттуда).</p><p><strong>1) </strong><a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/app/Codegen/ASTBridge.hs" rel="noopener noreferrer nofollow"><strong>ASTBridge</strong></a> - разные утилиты для перевода типов и операции нашего TAST в соответствущие для LLVM</p><ul><li><p><code>typeMap</code> - словарь из пар "наш идентификатор типа" - "тип в LLVM"</p></li><li><p>функции вида <code>allocateX</code> - генераторы вызовов LLVM для аллокации памяти под сам тип или указатель на него.</p></li><li><p>функции вида <code>referenceX</code> - генерации LLVM-ных "обращений" к ячейке памяти под какой-либо тип напрямую или по указателю</p></li><li><p><code>convert</code> - по нашим <code>IntType</code> и <code>FloatType</code> генерирует операции приведения типов для LLVM</p></li><li><p><code>opTable</code> и <code>findOperation</code> - соответственно словарь и функция для поиска в нем соответствующих операций. Словарь содержит для <code>IntType</code> и <code>FloatType</code> еще по вложенному словарю, с парами "строка операции" (+, -, ....) - "LLVM операция соответствующего типа" (интовое умножение, дробное умножение и т.д.)</p></li></ul><p>Каждая из этих функций (за исключением последней) возвращает <code>Operand</code> - это LLVM-примитив, обозначающий, как ни странно, операнд - не самостоятельное выражение, а некий объект, который должен быть или "записан в переменную" (store в llvm), или использован в составе другого операнда. <code>findOperation</code> же возвращает (а <code>opTable</code> - содержит) функции, принимающие два операнда и возвращающие третий - то есть бинарные операции.</p><p>Кроме уже упомянутых <code>reference</code> и <code>allocate</code>, тут используется еще несколько часто встречаемых конструкций из LLVM. Это <code>named</code>, генерирующий именованные выражения и <code>AST.PointerType</code>, оборачивающий любой другой LLVM-тип и объявляющий указатель. Особенно стоит отметить, что такое qualified имя обозначает что это не из "нашего" AST, а из модуля <code>LLVM.AST</code>.</p><p><strong>2) </strong><a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/app/Codegen/Primitives.hs" rel="noopener noreferrer nofollow"><strong>Primitives</strong></a> - содержит сокращенные объявления функций LLVM. Например, объявлние <em>типа</em> указателя на int требует определить адресное пространство и вид инта (i16, i32, i64). Мы для простоты используем выравнивание по 4, i32 и дефолтное адресное пространство - поэтому удобно создать утилитарные функции, которые подобные параметры проставляют сразу. Такие сокращения и содержит этот модуль.</p><p>И, наконец, то, ради чего мы тут собрались - <strong>генерация IR из AST</strong>, модуль <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/app/Codegen/Builder.hs" rel="noopener noreferrer nofollow">Builder</a>. </p><p>Благодаря рекурсивному объявлению синтаксического дерева, по сути нам надо лишь описать функцию, обрабатывающую единственный тип <code>TypedExpr</code> со специализациями под конкретные конструкторы (выражения) - <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/app/Codegen/Builder.hs#L28" rel="noopener noreferrer nofollow"><strong>emit</strong></a> (по ссылке - ее исходный код). Мы также гарантировали, что все верхнеуровневые выражения - это функции, так что сделаем их особым кейсом, и тогда вся схема кодогенерации выглядит так:</p><pre><code>TAST (то есть [TypedExpr]) -> buildIR -> LLVM Module, где

1) buildIR: применяет к каждому TypedExpr (который гарантированно функция) buildFunction 
2) buildFunction: генерирует IR функции, то есть создает ее объявление, аллоцирует аргументы,
   и затем генерирует тело с помощью funcBodyBuilder -> buildCodeBlock
3) buildCodeBlock: применяет emit к каждому выражению и его частям рекурсивно, и делает возвращаемым значением последнее выражение
   (мы сделали возвращаемые переменные "последним выражением" в блоке на этапе обработки AST, помните?)</code></pre><p>Тип функции <code>emit</code> следующий - <code>emit :: (MonadFix m, MonadIRBuilder m) => TypedExpr -> m Operand</code>. То есть это функция, которая работает с монадой <code>IRBuilder</code> из LLVM - это крайне удобно, т.к. с помощью do-блока и специальных фунций LLVM мы, по сути, просто объявляем (с помощью паттерн-матчинга) для каждого нашего выражения какой ему соответствует IR-код почти один-в-один для человеческого глаза. Т.к. большинство из того что "возвращают" функции LLVM можно передать далее по монаде, написание <code>emit</code> - довольно тривиально.</p><p>Разберем пример (тут используется функция <code>view</code> в паттерне для удобства - она сразу достает тип и составные части выражения) - генерация для <code>If</code>:</p><pre><code class="haskell">-- type_ - тип результата блока
emit (view -> (type_, TIf cond blockTrue blockFalse)) = mdo
  -- генерируем IR для условия If (рекурсивно используем emit), например для выражения вида "x &lt; y"
  condition &lt;- emit cond
  -- создаем указатель на будущий результат, он будет результатом блока
  -- и в него запишется результат выполненной ветки
  resultPointer &lt;- allocateT type_
  -- проверка условия и выбор ветки
  condBr condition trueBranch falseBranch
  -- генерация IR для ветки if (...) { }
  trueBranch &lt;- buildBranch "true" blockTrue resultPointer $ Just mainBr
  -- генерация IR для ветки else { }
  falseBranch &lt;- buildBranch "false" blockFalse resultPointer $ Just mainBr
  -- возвращаемся в "главную ветку" исполнения и возвращаем результат
  (mainBr, result) &lt;- emitExit resultPointer
  return result</code></pre><p>Тут есть несколько утилитарных функций. Самая простая - <code>emitExit</code>, она просто генерирует код выхода из блока с сохранением результата:</p><pre><code class="haskell">emitExit resultPointer = do
  mainBr &lt;- block `named` bodyLabel
  result &lt;- load resultPointer
  return (mainBr, result)</code></pre><p>Вторая - <code>buildBranch</code>. Аналоги веток есть не только у <code>If</code>, но в некотором смысле и у циклов, просто там в конце происходит прыжок в начало.</p><pre><code class="haskell">-- тут мы получаем имя, список expr для генерации (codeBlock), и уже известный resultPointer - куда сохранить результат
buildBranch name codeBlock resultPointer mNext =
  do
    -- начинаем ветку - метка для LLVM
    branch &lt;- block `named` name
    -- опять рекурсивно применяем emit, скрывающийся под buildCodeBlock
    blockR &lt;- buildCodeBlock codeBlock
    -- сохраняем результат по указателю
    store resultPointer blockR
    -- если надо выйти из ветки - генерируем прыжок, иначе пропускаем
    case mNext of
      Nothing -> pure ()
      Just label -> br label
    -- возвращаем получившийся блок
    return branch</code></pre><p>Расписав таким образом <code>emit</code> для каждого вида выражений (некоторые реализации занимают <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/app/Codegen/Builder.hs#L34" rel="noopener noreferrer nofollow">одну строку</a>), мы получаем генератор IR кода. Посмотрим, что у нас получилось в итоге для <a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-04/main.grt" rel="noopener noreferrer nofollow">все той же</a> простейшей функции (те кто следуют по туториалу - это <code>main.grt</code>).  Запустим <code>stack run -- -e main.grt</code> еще раз и полюбуемся на результат (флаг -e нужен для печати IR - ведь на этом этапе мы уже расчитываем скоро иметь компилятор, а они обычно не выводят на экран IR):</p><pre><code>; ModuleID = 'program'

define external ccc  i32 @main()    {
Body_0:
  %i_0 = alloca i32, align 4 
  store  i32 0, i32* %i_0, align 4 
  %0 = load  i32, i32* %i_0, align 4 
  %1 = icmp slt i32 %0, 1 
  %2 = alloca i32, align 4 
  br i1 %1, label %true_0, label %false_0 
true_0:
  store  i32 0, i32* %2, align 4 
  br label %Body_1 
false_0:
  store  i32 1, i32* %2, align 4 
  br label %Body_1 
Body_1:
  %3 = load  i32, i32* %2, align 4 
  ret i32 %3 
}</code></pre><p>Этот код сгенерирован без каких-либо оптимизаций, поэтому он многословнее чем "должен быть", но для нас это только лучше - нагляднее. Ура, мы наконец имеем LLVM IR из исходников нашей программы. Запустить его уже можно, например перенаправив вывод в файл, который затем дать на вход <code>lli</code> - интерпретатору IR.</p><p>Если хочется создать исполняемый файл, то дело за малым - обратиться к встроенному в LLVM функционалу компиляции модулей.</p><details class="spoiler"><summary>Бонус: создаем бинарник</summary><div class="spoiler__content"><p>Это уже <code>ШАГ 5</code>, директория <code>step-05</code>.</p><p>Чтобы максимально быстро получить результат, будем использовать все параметры по умолчанию - благо, для этого в llvm-hs есть готовые обертки. По большому счету, все что нам надо сделать - это склеить <a href="https://hackage.haskell.org/package/llvm-hs-9.0.1/docs/LLVM-Internal-Context.html#v:withContext" rel="noopener noreferrer nofollow">пустой контекст</a>, <a href="https://hackage.haskell.org/package/llvm-hs-9.0.1/docs/LLVM-Internal-Target.html#v:withHostTargetMachineDefault" rel="noopener noreferrer nofollow">настройки хостовой машины по умолчанию</a>, создать llvm-модуль из нашего <code>LLVM.AST.Module</code> с помощью <a href="https://hackage.haskell.org/package/llvm-hs-9.0.1/docs/LLVM-Module.html#v:withModuleFromAST" rel="noopener noreferrer nofollow">соответствующей функции</a>, и скормить финальный результат <a href="https://hackage.haskell.org/package/llvm-hs-9.0.1/docs/LLVM-Module.html#v:writeObjectToFile" rel="noopener noreferrer nofollow">билдеру объектников</a>, после чего этот файл слинковать.</p><p>Код для дешёвого и сердитого создания объектных файлов выглядит так (<a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-05/app/Compiler.hs" rel="noopener noreferrer nofollow">полный файл</a>):</p><pre><code class="haskell">writeWithDefaultTarget :: File -> Module -> IO ()
writeWithDefaultTarget file mod = withHostTargetMachineDefault (\t -> writeObjectToFile t file mod)

writeWithModuleFromAST :: File -> Context -> LLVM.AST.Module -> IO ()
writeWithModuleFromAST f c m = withModuleFromAST c m (writeWithDefaultTarget f)

writeObject :: File -> LLVM.AST.Module -> IO ()
writeObject file mod = withContext (\c -> writeWithModuleFromAST file c mod)</code></pre><p>И так добавляется в main (<a href="https://github.com/VoidDruid/habr-hs-llvm/blob/master/step-05/app/Main.hs" rel="noopener noreferrer nofollow">полный файл</a>):</p><pre><code class="haskell">writeObject (File ("output.o" :: FilePath)) ir</code></pre><p>С добавлением этого, наша программа после запуска сгенерирует файл <code>output.o</code>, который только останется слинковать вашим любимым линкером - у меня на маке это выглядит как <code>ld -lSystem output.o -o output</code>.</p><p>Так как ввод/вывод мы не реализовали, наша программа просто возвращает числа, которые будут выходными кодами. Соответствено, посмотреть результат исполнения можно распечатав exit code последней команды. Я написал утилитарный скрипт (проверял только на macOS) для упрощения этого процесса, который запускает наш комплиятор, линкует объектный файл, запускает получившуюся программу и печатает результат:</p><pre><code class="bash">#!/usr/bin/env bash
stack run -- main.grt

ld -lSystem output.o -o output
chmod +x output
./output

echo $?</code></pre></div></details><a class="anchor" name="part-4" id="part-4"></a><h2>Заключение</h2><p>Итак, мы прошли все основные этапы написания компилятора - парсер, обработка AST, генерация IR, даже затронули генерацию финального машинного кода. Иначе говоря, мы разработали фронтенд компилятора и научились взаимодействовать с бэкендом (LLVM). Конечно, как я уже указывал, многое можно сделать лучше - надеюсь я дал достаточно ссылок на другие материалы, чтобы вы смогли избежать моих ошибок, а мой туториал стал хорошей стартовой точкой.</p><p>Буду рад комментариям (постараюсь ответить на них), а также PR-ам в <a href="https://github.com/VoidDruid/habr-hs-llvm" rel="noopener noreferrer nofollow">репозиторий</a> туториала - версия кода, используемая в этой стате, зафиксирована в README и самой ссылке в начале, так что перепройти туториал можно в любой момент.</p><p>Любите и используйте функциональные языки, и спасибо за внимание!</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bhaskell%5D" class="tm-tags-list__link">haskell</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bllvm%5D" class="tm-tags-list__link">llvm</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bllvm%20ir%5D" class="tm-tags-list__link">llvm ir</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B%5D" class="tm-tags-list__link">компиляторы</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F%5D" class="tm-tags-list__link">компиляция</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%5D" class="tm-tags-list__link">ассемблер</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">функциональное программирование</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D0%B9%20%D1%81%D0%B0%D0%BC%5D" class="tm-tags-list__link">сделай сам</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bcompiler%5D" class="tm-tags-list__link">compiler</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%B0%D1%80%D1%81%D0%B8%D0%BD%D0%B3%5D" class="tm-tags-list__link">парсинг</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/haskell/" class="tm-hubs-list__link">
    Haskell
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/compilers/" class="tm-hubs-list__link">
    Компиляторы
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/funcprog/" class="tm-hubs-list__link">
    Функциональное программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/DIY/" class="tm-hubs-list__link">
    DIY или Сделай сам
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 35: ↑35 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 35: ↑35 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+35</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">4.7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    54
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/VoidDruid/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/ede/702/5ad/ede7025adfbe23f77b0cbd09e7feb966.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 16 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    16
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">35</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Игорь Бесчастнов</span> <a href="/ru/users/VoidDruid/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @VoidDruid
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Разработчик</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/581234/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 2 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/581234/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/581234/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"581234":{"id":"581234","timePublished":"2021-10-06T20:13:47+00:00","isCorporative":false,"lang":"ru","titleHtml":"Написание компилятора на Haskell + LLVM","leadData":{"textHtml":"\u003Cp\u003EНа работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C\u002FC++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание \u003Cstrong\u003Eкомпилятора на основе LLVM\u003C\u002Fstrong\u003E - зачем и что получилось я уже рассказывал в \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F508828\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eпредыдущей статье\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЭту статью я пишу для тех, кто, как и я, заинтересован в изучении Haskell, создании собственных языков программирования, или хочет поиграться с LLVM - но не знает с какого конца подойти к задаче.\u003C\u002Fp\u003E\u003Cp\u003EЯ кратко расскажу про необходимый \u003Cstrong\u003Eминимум знаний Haskell\u003C\u002Fstrong\u003E, про свои \u003Cstrong\u003Eошибки и к каким решениям я пришел\u003C\u002Fstrong\u003E - а так же про решения, к которым я не пришел, и про которые узнал позже - и как их можно интегрировать в ваш pet-компилятор. На все это я по возможности дам \u003Cstrong\u003Eссылки на изучение\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8bf\u002F9da\u002F8ab\u002F8bf9da8ab2389bff724179f9ad0073bf.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8bf\u002F9da\u002F8ab\u002F8bf9da8ab2389bff724179f9ad0073bf.png","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":16,"votesCount":16},"rating":35,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2358379","alias":"VoidDruid","fullname":"Игорь Бесчастнов","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fede\u002F702\u002F5ad\u002Fede7025adfbe23f77b0cbd09e7feb966.png","speciality":"Разработчик"},"statistics":{"commentsCount":2,"favoritesCount":54,"readingCount":4698,"score":35,"votesCount":35},"hubs":[{"relatedData":null,"id":"8424","alias":"haskell","type":"collective","title":"Haskell","titleHtml":"Haskell","isProfiled":true},{"relatedData":null,"id":"17188","alias":"compilers","type":"collective","title":"Компиляторы","titleHtml":"Компиляторы","isProfiled":true},{"relatedData":null,"id":"17853","alias":"funcprog","type":"collective","title":"Функциональное программирование","titleHtml":"Функциональное программирование","isProfiled":true},{"relatedData":null,"id":"21976","alias":"DIY","type":"collective","title":"DIY или Сделай сам","titleHtml":"DIY или Сделай сам","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EНа работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C\u002FC++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание \u003Cstrong\u003Eкомпилятора на основе LLVM\u003C\u002Fstrong\u003E - зачем и что получилось я уже рассказывал в \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F508828\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eпредыдущей статье\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЭту статью я пишу для тех, кто так же, как и я, заинтересован в изучении Haskell, создании собственных языков программирования, или хочет поиграться с LLVM, но не знает с какого конца подойти к задаче.\u003C\u002Fp\u003E\u003Cp\u003EЯ кратко расскажу про необходимый \u003Cstrong\u003Eминимум знаний Haskell\u003C\u002Fstrong\u003E, про свои \u003Cstrong\u003Eошибки и к каким решениям я пришел\u003C\u002Fstrong\u003E - а так же про решения, о которых я узнал позже - и как их можно интегрировать в ваш pet-компилятор. На всё это я по возможности дам \u003Cstrong\u003Eссылки на изучение\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"850\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1c1\u002Fe91\u002F60f\u002F1c1e9160f3dec79f1fbc97f0765bf229.png\" data-width=\"1890\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Chr\u002F\u003E\u003Ch3\u003EОглавление\u003C\u002Fh3\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"#part-1\" rel=\"noopener noreferrer nofollow\"\u003EHaskell - настраиваем проект и необходимые знания языка\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"#part-2\" rel=\"noopener noreferrer nofollow\"\u003EОсновы языка - синтаксис, парсер, AST\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"#part-3\" rel=\"noopener noreferrer nofollow\"\u003EКодогенерация с LLVM\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"#part-4\" rel=\"noopener noreferrer nofollow\"\u003EЗаключение\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cblockquote\u003E\u003Cp\u003EКод из этой статьи, разложенный по шагам: \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\" rel=\"noopener noreferrer nofollow\"\u003Ehttps:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EРепозиторий по этой ссылке можно использовать как \"интерактивный учебник\" в паре со статьей.\u003C\u002Fp\u003E\u003Ca class=\"anchor\" name=\"part-1\" id=\"part-1\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003EHaskell -  необходимые знания языка и настройка проекта\u003C\u002Fh2\u003E\u003Cp\u003EКак можно понять из вступления к статье - я в haskell совершенно не специалист. Эта статья - не мастер-класс по разработке компиляторов и не учебник по этому языку, а скорее практическое пособие на тему того, как подойти к жутко звучащей задаче - написанию компилятора на хаскеле, и не пойти на дно из-за \"наслоения сложности\". Далее я пошагово разберу этот процесс на примере \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fgrit\" rel=\"noopener noreferrer nofollow\"\u003Eсвоей дипломной работы\u003C\u002Fa\u003E, выкинув некоторые фичи, не нужные в рамках этой статьи (декораторы, например).\u003C\u002Fp\u003E\u003Cp\u003EБлагодаря этому проекту и нескольким после него я сильно продвинулся в haskell, но к началу работы над компилятором я успел написать на этом языке только \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Ftelemonitor\" rel=\"noopener noreferrer nofollow\"\u003Etelegram-бота\u003C\u002Fa\u003E, который помогает мне мониторить личный сервер. Для программистов примерно с такими же базовыми познаниями в хаскеле написана эта статья. В дальнейшем я рассчитываю, что вы знаете (хотя можно разобраться и по ходу):\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EБазовый синтаксис языка\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EМодули и импорты\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКак \u003Cem\u003Eработать\u003C\u002Fem\u003E с монадами (не обязательно уметь писать свои), хотя бы поверхностно\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Edo-нотация\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EIO монада\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EРекурсия, частичное применение функций, объявление типов\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cem\u003EЖелательно\u003C\u002Fem\u003E: typeclasses, алгебраические типы данных, records\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EЯ попытаюсь объяснить, зачем и как используется каждая фича языка, указанная в пункте \"\u003Cem\u003Eжелательно\u003C\u002Fem\u003E\", но будет проще, если вы с ними знакомы.\u003C\u002Fp\u003E\u003Cp\u003EСобирать проект мы будем с помощью stack - установить его довольно просто (\u003Ca href=\"https:\u002F\u002Fdocs.haskellstack.org\u002Fen\u002Fstable\u002FREADME\u002F#how-to-install\" rel=\"noopener noreferrer nofollow\"\u003Eинструкция\u003C\u002Fa\u003E), пользоваться тоже. Создавать проект с нуля не придется - можно клонировать \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\" rel=\"noopener noreferrer nofollow\"\u003Eэтот репозиторий\u003C\u002Fa\u003E, и идти в нем по шагам параллельно со статьей (readme есть в каждой папке плюс глобальный - ознакомьтесь с ними, чтоб упростить сборку и запуск кода). Или можно делать все самостоятельно, все же создав новый проект - с помощью самого stack (\u003Ca href=\"https:\u002F\u002Fdocs.haskellstack.org\u002Fen\u002Fstable\u002FREADME\u002F#start-your-new-project\" rel=\"noopener noreferrer nofollow\"\u003Eинструкция\u003C\u002Fa\u003E) или используя этот \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FProjectTemplates\u002Fhaskell-simple\" rel=\"noopener noreferrer nofollow\"\u003Eшаблон для cookiecutter\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Feax.me\u002Fhaskell-stack\u002F\" rel=\"noopener noreferrer nofollow\"\u003EНеплохая статья\u003C\u002Fa\u003E для начинающих про stack на русском\u003C\u002Fp\u003E\u003Cp\u003EКнига про haskell на английском, которую можно использовать как \u003Ca href=\"http:\u002F\u002Flearnyouahaskell.com\u002Fchapters\" rel=\"noopener noreferrer nofollow\"\u003Eонлайн-справочник\u003C\u002Fa\u003E  \u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EЕсли вы решили работать со статьей совместно с кодом из репозитория с пошаговым разбором, то перед тем как мы пойдем дальше, зайдите в папку \u003Ccode\u003Estep-00\u003C\u002Fcode\u003E, и запустите \u003Ccode\u003Estack run\u003C\u002Fcode\u003E. Если программа с вами поздоровалась, то мы готовы идти дальше. Сейчас мы находимся в директории \u003Ccode\u003Estep-00\u003C\u002Fcode\u003E, соответствующей \u003Ccode\u003EШАГ 0\u003C\u002Fcode\u003E. В дальнейшем, переходы к следующему шагу (и, соответственно, к другой папке с кодом) будут отмечены именно так - \u003Ccode\u003EШАГ Х\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Ca class=\"anchor\" name=\"part-2\" id=\"part-2\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003EОсновы языка - синтаксис, парсер, AST\u003C\u002Fh2\u003E\u003Ch3\u003EБазовый парсинг\u003C\u002Fh3\u003E\u003Cp\u003E\u003Ccode\u003EШАГ 1\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003EПервое, что мы попробуем сделать - это написать простой парсер. В стандартной библиотеке хаскеля есть отличный модуль \u003Cem\u003EParsec\u003C\u002Fem\u003E (Parser Combinators - \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fparsec\" rel=\"noopener noreferrer nofollow\"\u003Eописание и документация\u003C\u002Fa\u003E; \u003Ca href=\"https:\u002F\u002Fwww.stephendiehl.com\u002Fllvm\u002F#chapter-2-parser-and-ast\" rel=\"noopener noreferrer nofollow\"\u003Eтуториал, по которому учился я\u003C\u002Fa\u003E), позволяющий в декларативном стиле описывать парсеры. Для сборки необходимо добавить его в \u003Ccode\u003E.cabal\u003C\u002Fcode\u003E файл в секцию \u003Ccode\u003Ebuild-depends\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F50337\u002F\" rel=\"noopener noreferrer nofollow\"\u003EТуториал\u003C\u002Fa\u003E по Parsec на русском\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EНа данном этапе, весь код все еще будет помещаться в модуле \u003Ccode\u003EMain\u003C\u002Fcode\u003E. Добавим несколько импортов:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Eimport Text.Parsec (parse)\nimport Text.Parsec.String (Parser)\nimport Text.Parsec.Language (emptyDef)\nimport qualified Text.Parsec.Token as Tok\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЧто мы импортировали:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Eparse\u003C\u002Fcode\u003E - функция, прогоняющая парсер на входном потоке данных\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EParser\u003C\u002Fcode\u003E - определение типа простого парсера, принимающего на вход строки\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EemptyDef\u003C\u002Fcode\u003E - \"пустое\" определение синтаксиса языка, на основе которого мы сделаем свое\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EText.Parsec.Token\u003C\u002Fcode\u003E - основной модуль с функциями-парсерами\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EСоздадим новое определение лексера, с помощью функции \u003Ccode\u003EmakeTokenParser\u003C\u002Fcode\u003E, передав ей на вход определение синтаксиса нашего языка:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Elexer :: Tok.TokenParser ()\nlexer = Tok.makeTokenParser style\n  where\n  ops = [ \"+\", \"*\", \"-\", \"\u002F\"]\n  names = [\"if\", \"else\"]\n  style = emptyDef {\n  Tok.commentLine = \"\u002F\u002F\"\n  , Tok.commentStart = \"\u002F*\"\n  , Tok.commentEnd = \"*\u002F\"\n  , Tok.caseSensitive = True\n  , Tok.reservedOpNames = ops\n  , Tok.reservedNames = names\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут мы создали новый \u003Ccode\u003Erecord\u003C\u002Fcode\u003E под названием \u003Ccode\u003Estyle\u003C\u002Fcode\u003E, в котором описали базовый синтаксис нашего языка, пока что крайне простого - си-подобные комментарии, базовые операции (\u003Ccode\u003E+\u003C\u002Fcode\u003E, \u003Ccode\u003E-\u003C\u002Fcode\u003E, \u003Ccode\u003E*\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002F\u003C\u002Fcode\u003E) и зарезервированные слова \u003Ccode\u003Eif\u003C\u002Fcode\u003E и \u003Ccode\u003Eelse\u003C\u002Fcode\u003E. Получившийся лексер мы теперь можем передать \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fparsec-3.1.14.0\u002Fdocs\u002FText-Parsec-Token.html#t:GenTokenParser\" rel=\"noopener noreferrer nofollow\"\u003Eконструкторам парсеров\u003C\u002Fa\u003E из \u003Ccode\u003ETok\u003C\u002Fcode\u003E, чтобы получить конкретный функции-парсеры для нашего языка:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Einteger    = Tok.integer lexer\nfloat      = Tok.float lexer\n-- и так далее, полный код - https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-01\u002Fapp\u002FMain.hs\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПопробуем написать парсер, который понимает простую операцию сложения целых чисел и возвращает результат.\u003C\u002Fp\u003E\u003Cp\u003EДля парсеров определены монадные операторы, и если посмотреть определение типа, то видно что мы можем использовать их совместно с собственными монадами, state-ами и т.д. Когда я только начинал работать с Parsec, я этого не знал, и просто использовал do-нотацию, потому что так было написано в туториалах. Выше я вставлял ссылки на документацию, там можно увидеть что \u003Ccode\u003EParserT\u003C\u002Fcode\u003E это на самом деле монадный трансформер, для которого определена куча инстансов монадных тайп классов, большинство из которых я до сих пор не понимаю. Для наших целей достаточно знать, что сами парсеры возвращают значения, а парсер-комбинаторы принимают одни парсеры и возвращают новые.\u003C\u002Fp\u003E\u003Cp\u003EЗная это, определеить парсер для сложения можно так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003EsumParse :: Parser Integer\nsumParse = do\n  first &lt;- integer\n  reservedOp \"+\"\n  second &lt;- integer\n  return (first + second)\n\nrunSumParse = parse sumParse \"&lt;stdin\u003E\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВернуть из парсера можно по-большому счету что угодно, тип просто поменяется на \u003Ccode\u003EParser ЧтоУгодно\u003C\u002Fcode\u003E. Функция \u003Ccode\u003EsumParse\u003C\u002Fcode\u003E принимает строку, и разбирает ее как бы по инструкции, соответствущей последовательности операции в do-блоке:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EБерет первое число \u003Ccode\u003Efirst &lt;- integer\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСчитывает зарезервированный оператор \"+\"\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EБерет второе число \u003Ccode\u003Esecond &lt;- integer\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВозвращает результат сложения \u003Ccode\u003Ereturn (first + second)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EУ функции \u003Ccode\u003ErunSumParse\u003C\u002Fcode\u003E один входной параметр - строка, которую она передает на разбор \u003Ccode\u003EsumParse\u003C\u002Fcode\u003E. \u003Ccode\u003E\"&lt;stdin\u003E\"\u003C\u002Fcode\u003E -  указание на \"источник\" входных данных, используется это для сообщений об ошибках, например.\u003C\u002Fp\u003E\u003Cp\u003EЕсли войти в ghci (команда \u003Ccode\u003Estack ghci\u003C\u002Fcode\u003E), и запустить \u003Ccode\u003ErunSumParse \"1 + 2\"\u003C\u002Fcode\u003E -  вернется \u003Ccode\u003ERight 3\u003C\u002Fcode\u003E. Это значит что наш парсер отработал без ошибок, и вернул результат \u003Ccode\u003E3\u003C\u002Fcode\u003E - у функции \u003Ccode\u003Eparse\u003C\u002Fcode\u003E тип возвращаемого значения \u003Ccode\u003EEither ParseError a\u003C\u002Fcode\u003E - где \u003Ccode\u003Ea\u003C\u002Fcode\u003E - тип, возвращаемый \u003Ccode\u003EsumParse\u003C\u002Fcode\u003E, то есть \u003Ccode\u003EInteger\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВ качестве подведения черты под этим этапом, перепишем функцию \u003Ccode\u003Emain\u003C\u002Fcode\u003E так, чтобы она читала строку из консоли, парсила сложение, и выводила результат или ошибку:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Emain = do\n  line &lt;- getLine\n  case runSumParse line of\n  \tRight result -\u003E putStrLn (\"Result: \" ++ show result)\n  \tLeft error -\u003E print error\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EУпражнение - парсер инкремента '1++'. Решение под спойлером\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003E Во-первых, нам надо добавить операцию \"++\" в список зарезервированных операций: \u003Ccode\u003Eops = [ \"++\", \"+\", \"*\", \"-\", \"\u002F\"]\u003C\u002Fcode\u003E. Затем пишем аналогичный парсер:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003EincrParse = do\n\tfirst &lt;- integer\n  reservedOp \"++\"\n  return (first + 1)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ch3\u003EОписание AST\u003C\u002Fh3\u003E\u003Cp\u003E\u003Ccode\u003EШАГ 2\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003EОдин из самых интересных этапов в проектировании языка, по-моему опыту - это описание формата \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE\" rel=\"noopener noreferrer nofollow\"\u003Eсинтаксического дерева\u003C\u002Fa\u003E. Именно тут закладывается фундамент для всех конструкций языка.\u003C\u002Fp\u003E\u003Cp\u003EВ случае с хаскелем, описать \"обычное\" дерево легко - это рекурсивный алгебраический тип данных:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Edata Tree a\n\t= Leaf  -- тупик\n\t| Node a (Tree a) (Tree a)  -- узел дерева - значение и две \"ячейки\" под ветки\n\tderiving Show\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут \u003Ccode\u003ELeaf\u003C\u002Fcode\u003E и \u003Ccode\u003ENode\u003C\u002Fcode\u003E - конструкторы данных типа \u003Ccode\u003ETree a\u003C\u002Fcode\u003E, где \u003Ccode\u003Ea\u003C\u002Fcode\u003E - тип данных, которые содержат узлы дерева. Аналогичным образом мы можем описать и структуру выражения в нашем языке (еще раз напомню, что хоть синтаксис и похож на Си, мы пишем не сишный компилятор, а реализацию \"учебного\" си-подобного языка):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Edata Expr\n  = Int Integer  -- значение типа Integer\n  | Var Name  -- обращение к переменной\n  | Def ExprType Name  -- объявление переменной\n  | Block (CodeBlock Expr)  -- блок кода\n  | Call String [Expr]  -- вызов функции с указанными аргументами\n  | Function ExprType Name [Expr] (Maybe Name) (CodeBlock Expr)  -- объявление функции (разберем подробно далее)\n  | BinaryOp String Expr Expr  -- бинарная операция над двумя выражениями\n  | If Expr (CodeBlock Expr) (CodeBlock Expr)  -- if - условие и две ветки исполнения\n  deriving (Eq, Ord, Show)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТаким образом, мы объявили самые базовые конструкции (см. комментарии в коде). Можно заметить, что здесь есть ссылки на дополительные типы данных - \u003Ccode\u003EExprType\u003C\u002Fcode\u003E, \u003Ccode\u003ECodeBlock\u003C\u002Fcode\u003E. Первый - это просто \"enum\" с типами, поддерживаемыми нашей программой. Сейчас это только инты и функции, но оставим задел на будущее и объявим несколько дополнительных:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Edata ExprType\n  = VoidType\n  | IntType\n  | FloatType\n  | BytesType\n  | BooleanType\n  | CallableType [ExprType] ExprType  -- [типы аргументов] тип возвращаемого значения\n  | AutoType  -- тип должен быть выведен автоматически\n  deriving (Eq, Ord)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ccode\u003ECodeBlock\u003C\u002Fcode\u003E - это массив выражений, определен просто как:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Etype CodeBlock term = [term]\n-- [expr1, expr2] это CodeBlock Expr\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EРазница между типами \u003Ccode\u003E[Expr]\u003C\u002Fcode\u003E и \u003Ccode\u003ECodeBlock Expr\u003C\u002Fcode\u003E чисто формальная - \u003Ccode\u003ECodeBlock\u003C\u002Fcode\u003E я использую там, где список выражения является \"телом\" чего-либо (функции, цикла и пр.), а \u003Ccode\u003E[Expr]\u003C\u002Fcode\u003E - например, как список аргументов функции. Для такого же \"семантического\" удобства определим тип \u003Ccode\u003EAST\u003C\u002Fcode\u003E, который будем использовать только в высокоуровневых функциях:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Etype AST = [Expr]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ отличии от \u003Ccode\u003ECodeBlock\u003C\u002Fcode\u003E, \u003Ccode\u003EAST\u003C\u002Fcode\u003E определен строго для \u003Ccode\u003EExpr\u003C\u002Fcode\u003E . Мне это показалось логичным в контексте того, что каждый из них \"представляет\" в программе. Однако если читателю это кажется излишним нагромождением типов, от всего этого можно избавиться и просто везде использовать \u003Ccode\u003E[Expr]\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EКак можно сделать круче\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003EВ синтаксическое дерево в реальном компиляторе конечно хочется засунуть гораздо больше информации - начиная от типов всех выражений (как это сделал я будет показано далее), и до, например, номеров строк на которых находились выражения - для отладки и формирования сообщений об ошибках.\u003C\u002Fp\u003E\u003Cp\u003EЯ осознал это довольно поздно, и решил не переделывать, благо для моих задач мне это не понадобилось, но в хаскеле для подобных \"многослойных\" структур часто используется подход \"Recursion Schemes\". Вот \u003Ca href=\"https:\u002F\u002Fblog.sumtypeofway.com\u002Fposts\u002Fintroduction-to-recursion-schemes.html\" rel=\"noopener noreferrer nofollow\"\u003Eнеплохая статья про него\u003C\u002Fa\u003E - как можно видеть, от структуры того, что я делаю в этой статье, отличается не сильно, однако для применения этого подхода требуется существенно более высокий уровень знания языка.\u003C\u002Fp\u003E\u003Cp\u003EТак что если вдруг после прочтения статьи вы вдохновитесь на написание \"серьезного\" компилятора, можете спокойно использовать все, про что я рассказываю в этом разделе, но перед переходом к написанию кодогенератора попробовать внедрить рекурсивные схемы.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EПосле описания структуры языка можно перейти к написанию функций-парсеров. Пока у нас нет кодогенерации, смотреть что выдает парсер можно будет только распечатывая дерево \u003Ccode\u003EExpr\u003C\u002Fcode\u003E. Если положиться на \u003Ccode\u003Ederive Show\u003C\u002Fcode\u003E, то в консоль будет вываливаться просто стена текста, так что попробуем определить для наших типов инстанс Show такой, чтоб можно было легко понимать структуру полученной программы.\u003C\u002Fp\u003E\u003Cp\u003EКода в этой секции много, весь его я здесь приводить не буду, только основные моменты. Остальное, как всегда, можно посмотреть \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-02\u002Fapp\u002FSyntax.hs\" rel=\"noopener noreferrer nofollow\"\u003Eв репозитории туториала\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EОпределить \u003Ccode\u003EShow\u003C\u002Fcode\u003E для типов довольно просто:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Einstance Show ExprType where\n\tshow VoidType = \"void\"\n\tshow IntType = \"int\"\n\t-- и т.д.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EГораздо интереснее его определять для Expr. Довольно быстро я понял, что определять именно Show не слишком правильно - например, красиво распечатанный \u003Ccode\u003EIf\u003C\u002Fcode\u003E может занимать несколько строк, что не подходит для \u003Ccode\u003EShow\u003C\u002Fcode\u003E, поэтому я создал аналогичный тайп класс:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003E{- \nтайп класс Pretty определяет функцию prettify, возвращающую массив строк -\nдля выражений, \"красивая\" распечатка которых может не помещаться в одну\n-}\nclass Show e =\u003E Pretty e where\n\tprettify :: e -\u003E [String]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЯ хотел иметь функцию \u003Ccode\u003EprettifyAST\u003C\u002Fcode\u003E, которой я мог бы передать \u003Ccode\u003EAST\u003C\u002Fcode\u003E (массив выражений) и получить список отформатированных строк - дальше их можно печатать отдельно или соединить в большое текстовое представление структуры программы (\u003Ccode\u003Eintercalate \"\\n\"\u003C\u002Fcode\u003E - каждый \u003Ccode\u003EString\u003C\u002Fcode\u003E на отдельной строке). Определил я эти функции так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003EjoinN = intercalate \"\\n\"\n\nprettifyAST :: Pretty e =\u003E [e] -\u003E [String]\nprettifyAST = map (joinN . prettify)\n\njoinedPrettyAST :: Pretty e =\u003E [e] -\u003E String\njoinedPrettyAST = joinN . prettifyAST\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТеперь дело осталось только за определением инстанса \u003Ccode\u003EPretty Expr\u003C\u002Fcode\u003E. Как это сделал я, можете посмотреть \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-02\u002Fapp\u002FSyntax.hs#L77\" rel=\"noopener noreferrer nofollow\"\u003Eтут\u003C\u002Fa\u003E (некоторые используемые функции определены в модуле \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-02\u002Fapp\u002FStringUtils.hs\" rel=\"noopener noreferrer nofollow\"\u003EStringUtils\u003C\u002Fa\u003E), общая структура такая:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Einstance Pretty Expr where\n  prettify expr = case expr of\n    (Int i) -\u003E [joinS [\"Int\", show i]]\n    -- и так для каждого Expr\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EПарсинг\u003C\u002Fh3\u003E\u003Cp\u003EВсе еще \u003Ccode\u003EШАГ 2\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003EТеперь рассмотрим написание парсера. Для этого мы будем использовать лексер, объявленный в шаге 1. Для парсера я создал отдельный модуль \u003Ccode\u003EParser\u003C\u002Fcode\u003E (\u003Ccode\u003Eparser.hs\u003C\u002Fcode\u003E) и вынес все связанное с лексером из первого шага в модуль \u003Ccode\u003ELexer\u003C\u002Fcode\u003E (\u003Ccode\u003Elexer.hs\u003C\u002Fcode\u003E). Тут не будет ничего принципиально нового, просто продолжение принципов парсер-комбинаторов, которые я уже показывал.\u003C\u002Fp\u003E\u003Cp\u003EВот что мы будем использовать (есть еще импорты из стандартной библиотеки, их я опускаю):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Eimport qualified Text.Parsec.Expr as Ex\nimport qualified Text.Parsec.Token as Tok\n\nimport Lexer\nimport Syntax\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПервая и самая запутанная часть - объявить парсеры операций. Её я вынес под спойлер, кому интересно - можете посмотреть, а остальным предлагаю сразу переходить к парсерам выражений, я до сих пор под впечатлением, насколько элегантно это можно сделать.\u003C\u002Fp\u003E\u003Cp\u003EКак всегда, полный код этого модуля (для данного этапа) \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-02\u002Fapp\u002FParser.hs\" rel=\"noopener noreferrer nofollow\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EПарсеры операций\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003EДля начала объявим парсер для операторов вида \" \u003Ccode\u003E+\u003C\u002Fcode\u003E \", \" \u003Ccode\u003E*\u003C\u002Fcode\u003E \" и так далее:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Eop :: Parser String\nop = do\n  whitespace\n  o &lt;- operator\n  whitespace\n  return o\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EРезультат работы \u003Ccode\u003Eop\u003C\u002Fcode\u003E это \u003Ccode\u003EString\u003C\u002Fcode\u003E для стуктуры\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Edata Expr\n=\n  -- ...\n  BinaryOp String Expr Expr  -- операция с двумя операндами\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗатем нам надо объявить валидные операторы, ассоциативность операций и их приоритет:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003E{-\nbinary - конструктор бинарных операций, вернет частично созданный BinaryOp\n(без операндов типа Expr и Expr)\nПринимает сам оператор (s) и ассоциативность (у нас - Ex.AssocLeft)\n-}\nbinary s assoc = Ex.Infix (reservedOp s \u003E\u003E return (BinaryOp s)) assoc\n\n-- Функция, возвращающая функцию-генератор парсеров с указанной ассоциативностью для списока операторов\nopList arity = opList'\n\twhere \n    opList' [op] = [arity op Ex.AssocLeft]\n    opList' (op:ops) = arity op Ex.AssocLeft : opList' ops\n\nbinList = opList binary\n\n-- Доступные бинарные операторы (точнее уже парсеры для них - применяется binList), в порядке убывания приоритета\nbinops = [\n  binList [\"*\", \"\u002F\", \"\u002F\u002F\", \"%\"]\n  , binList [\"+\", \"-\"]\n  , binList [\"&lt;\", \"=\", \"&lt;=\", \"\u003E=\", \"==\", \"!=\"]\n\t]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EОбъявим сначала верхнеуровневую функцию-парсер для любого выражения - она нам понадобится для использования внутри других:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003E{-\nСгенерированния парсеком функция-парсер, возвращаящая Expr.\nfactor - функция которую мы объявим далее, она парсит \"обычные\" Expr\nbinops - таблица операторов (+, *, &lt;, != и пр.), которая позволяет нам правильно парсить и операции над Expr (в нашем случае только бинарные - BinaryOp)\n-}\nexpr :: Parser Expr\nexpr =  Ex.buildExpressionParser binops factor\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EФункция \u003Ccode\u003Efactor\u003C\u002Fcode\u003E - это комбинация парсеров для всех существующих \u003Ccode\u003EExpr\u003C\u002Fcode\u003E. Она должна попытаться их применить с помощью \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fparsec-3.1.14.0\u002Fdocs\u002FText-Parsec-Prim.html#v:try\" rel=\"noopener noreferrer nofollow\"\u003Etry\u003C\u002Fa\u003E, и вернуть первый получившийся результат:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Efactor :: Parser Expr\nfactor = try cast\n      &lt;|\u003E try block\n      &lt;|\u003E try function\n      -- и т.д.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EУже известным нам способом объявим утилитарные функции для прогона парсера, и можно переходить к написанию парсеров самих выражений.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EФункции для запуска парсинга\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003E-- парсит все до eof с помощью переданной функции\ncontents :: Parser a -\u003E Parser a\ncontents p = do\n  Tok.whiteSpace lexer\n  r &lt;- p\n  eof\n  return r\n\n-- парсит верхнеуровневые объявления файла (в нашем случае - только функции)\ntoplevel :: Parser [Expr]\ntoplevel = many $ do\n  def &lt;- function\n  reservedOp \";\"\n  return def\n\n-- парсит одно выражение\nparseExpr :: String -\u003E Either ParseError Expr\nparseExpr s = parse (contents expr) \"&lt;stdin\u003E\" s\n\n-- парсит много выражений (файл с кодом)\nparseCode :: String -\u003E Either ParseError AST\nparseCode s = parse (contents toplevel) \"&lt;stdin\u003E\" s\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EЗдесь я не буду приводить все функции, только несколько примеров - остальные можно посмотреть в репозитории.\u003C\u002Fp\u003E\u003Cp\u003EСамый простой пример - парсер интов. Библиотечной функцией \u003Ccode\u003Einteger\u003C\u002Fcode\u003E мы достаем из входного потока число и создаем \u003Ccode\u003EExpr\u003C\u002Fcode\u003Eс помощью конструктора \u003Ccode\u003EInt\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Eint :: Parser Expr\nint = Int &lt;$\u003E integer\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТак же мы можем использовать парсеры внутри парсеров, совмещая их с библиотечными комбинаторами:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003EcodeBlock :: Parser [Expr]\ncodeBlock = braces $ many $\n  do e &lt;- expr\n  reserved \";\"\n  return e\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОбъединив все вместе, разберем чуть более сложный парсер:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Eifelse :: Parser Expr\nifelse = do\n  reserved \"if\"  -- ищем в потоке ключевое слово if\n  cond &lt;- parens expr  -- затем любое заключенное в круглые скобки выражение\n  tr &lt;- codeBlock  -- парсим codeBlock, это true-ветка ифа\n  fl &lt;- optionMaybe $ do  -- ветка else необязательная, поэтом maybe мы сможем найти \"else\" и еще один codeBlock\n    reserved \"else\"\n    code &lt;- codeBlock\n    return code\n  return $ If cond tr (fromMaybe [] fl)  -- конструируем и возвращаем Expr\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОсталось попробовать что-нибудь распарсить. Переопределим \u003Ccode\u003Emain\u003C\u002Fcode\u003E так, чтоб он принимал на вход имя файла, и печатал результат парсинга кода в нем. Импорты я опускаю, а сам \u003Ccode\u003Emain\u003C\u002Fcode\u003E выглядит теперь так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Emain = do\n  args &lt;- getArgs  -- аргументы командной строки\n  case args of\n    []   -\u003E putStrLn \"Provide file name!\"\n    [filename] -\u003E do  -- если получили один аргумент\n      code &lt;- readFile filename  -- читаем файл\n      case parseCode code of  -- и парсим его содержимое\n        Left err -\u003E print err\n        -- если успех - используем нашу joinedPrettyAST чтоб сделать результат читаемым\n        Right ast -\u003E putStrLn (joinedPrettyAST ast)  \n    _ -\u003E putStrLn \"Provide one file name!\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВот как выглядит \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-02\u002Fapp\u002FMain.hs\" rel=\"noopener noreferrer nofollow\"\u003Emain.hs\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-02\u002Fmain.grt\" rel=\"noopener noreferrer nofollow\"\u003Emain.grt\u003C\u002Fa\u003E (файл с кодом) у меня (и у вас, если вы идете по шагам). Запустим это с помощью \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Estack run -- main.grt\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eи полюбуемся на результаты нашей работы - красиво распечатанное AST.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EТекстовое представление AST\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode\u003EFunction \"main\" int ; args [] ; returns Nothing {\n  BinaryOp = (Def int \"i\") (Int 0)\n  If (BinaryOp &lt; (Var \"i\") (Int 1)) {\n    Int 0\n  }\n  else {\n    Int 1\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EТеперь можно двигаться дальше - к типизации.\u003C\u002Fp\u003E\u003Ch3\u003EТипизация\u003C\u002Fh3\u003E\u003Cp\u003E\u003Ccode\u003EШАГ 3\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003EПосле создания базового синтаксического дерева, настало время заняться типизацией. После добавления типов, мы хотели бы в каждом узле дерева иметь дополнительное поле типа \u003Ccode\u003EExprType\u003C\u002Fcode\u003E, который мы заранее завели выше:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003E{- Конструктор типизированного выражения, принимающий тип и \nсобственно выражение - одно из тех, что мы объявляли ранее -}\ndata TypedExpr = TypedExpr ExprType Expr\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНо такой код, естественно, не делает то что нужно - \"внутри\" \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E все еще лежит обычный \u003Ccode\u003EExpr\u003C\u002Fcode\u003E. Решение, которое придумал я - не оптимальное, но делает все, что надо. Это добавление \"промежуточного контейнера\" \u003Ccode\u003ETExpr\u003C\u002Fcode\u003E и собственно определение \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E. Исходники - \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-03\u002Fapp\u002FSyntax.hs#L54\" rel=\"noopener noreferrer nofollow\"\u003Eтут\u003C\u002Fa\u003E. Прелесть такого способа в том, что он также позволяет добавлять любые аннотации (в том же месте где и \u003Ccode\u003EExprType\u003C\u002Fcode\u003E), однако многословен и не совсем идиоматичен. Описание моего тернистого пути под спойлером, а мы идем дальше.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EМои ошибки с добавлением типов\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003EТут-то и оказываются нужен тот самый подход рекурсивных схем.\u003C\u002Fp\u003E\u003Cp\u003EКак я уже говорил, информации по написанию компиляторов на хаскеле, доступной для понимания новичку, почти нет, поэтому я просто пытался получить что-нибудь работающее, а компилятор - наверное, из возможных пет-проджектов самый требовательный к предварительному планированию. Когда я, посоветовавшись с корифеями, понял, что для добавления дополнительной информации в дерево надо использовать \u003Ca href=\"https:\u002F\u002Fblog.sumtypeofway.com\u002Fposts\u002Fintroduction-to-recursion-schemes.html\" rel=\"noopener noreferrer nofollow\"\u003Eрекурсивные схемы\u003C\u002Fa\u003E или что-то \u003Ca href=\"http:\u002F\u002Fcomonad.com\u002Freader\u002F2009\u002Fincremental-folds\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eтакое\u003C\u002Fa\u003E (близкое по смыслу),  - я уже имел парсер и кодогенератор, работающие с \u003Ccode\u003EExpr\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EПробовал делать что-то типо:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003Edata Expr' e\n= Int Integer\n| Call String [e]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ определять:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Etype Expr = Expr' Expr\u003C\u002Fcode\u003E - ругается на цикл в определении\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Etype Expr = Expr' Expr'\u003C\u002Fcode\u003E -  ругается, вполне очевидно, что для последнего \u003Ccode\u003EExpr'\u003C\u002Fcode\u003E не хватает аргумента\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Enewtype Expr = Expr (Expr' Expr)\u003C\u002Fcode\u003E - а это уже близко к тем самым рекурсивным схемам, не хватает только правильно заиспользовать \u003Ccode\u003EFix\u003C\u002Fcode\u003E, но на этом моменте я сломался\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВ общем, не повторяйте моих ошибок и сразу используйте параметризованные типы, \u003Ccode\u003EData.Fix\u003C\u002Fcode\u003E и прочие прелести. Я же решил - сделаем \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E аналогом \u003Ccode\u003EExpr\u003C\u002Fcode\u003E, но с типами и соответствущими поправками. Идея такая - сначала получив дерево из \u003Ccode\u003EExpr\u003C\u002Fcode\u003E, применим алгоритм, который трансформирует его в дерево типа \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E - в котором все выражения будут аннотированы.\u003C\u002Fp\u003E\u003Cp\u003EЕсть несколько способов это сделать:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EМожно перенести все конструкторы (с заменой \u003Ccode\u003EExpr\u003C\u002Fcode\u003E на \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E) в определение \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E, и добавить во все типы - \u003Ccode\u003Edata TypedExpr = ... | TBlock ExprType (CodeBlock TypedExpr)\u003C\u002Fcode\u003E, но в таком случае \"тип\" это не аннотация, а \"часть\" объявления синтаксиса - мне это не понравилось\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EМожно сделать аналогично, но добавить тип не во все конструкторы, а в один, \"главный\" - \u003Ccode\u003Edata TypedExpr = ... |  TypedExpr ExprType TypedExpr\u003C\u002Fcode\u003E - но тогда функции принимающие TypedExpr смогут принимать как \"главное\" объявление, так и инстансы без типов\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EВариант, на котором я остановился\u003C\u002Fstrong\u003E - промежуточный тип \u003Ccode\u003ETExpr\u003C\u002Fcode\u003E, с конструкторами аналогичными \u003Ccode\u003EExpr\u003C\u002Fcode\u003E, но ссылающимися на \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E (т.е. определение дерева, с \"узлами\" из \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E), и тип \u003Ccode\u003Edata TypedExpr = TypedExpr ExprType TExpr\u003C\u002Fcode\u003E. Вместе с view-паттернами это в коде выглядит не так многословно, как может показаться, это будет видно далее.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ch4\u003EМеханизм аннотирования типами\u003C\u002Fh4\u003E\u003Cblockquote\u003E\u003Cp\u003EРади историчности, и чтоб сразу показать, где код можно улучшить, я оставил все свои первоначальные \u003Ccode\u003ETODO\u003C\u002Fcode\u003E-пометки в исходниках.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EНа этом шаге мы добавляем модуль \u003Ccode\u003EAST\u003C\u002Fcode\u003E, в котором находятся все функции для обработки синтаксического дерева. \"Верхнеуровневая\" функция - \u003Ccode\u003EprocessAST\u003C\u002Fcode\u003E - объявлена \u003Cspan\u003Eтут\u003C\u002Fspan\u003E и либо превращает \u003Ccode\u003EAST\u003C\u002Fcode\u003E в типизированные дерево (\u003Ccode\u003ETAST\u003C\u002Fcode\u003E), либо возвращает список ошибок. Все, что она делает сама - это применяет по очереди функции-обработчики обычного \u003Ccode\u003EAST\u003C\u002Fcode\u003E (сейчас это только \u003Ccode\u003EdesugarFunc\u003C\u002Fcode\u003E - удаление из определения функций \"сахара\" в виде объявления имени возвращаемой переменной и явного ее указания в конце тела), а затем передает получившееся в \u003Ccode\u003EannotateTypes\u003C\u002Fcode\u003E (которая просто делает \u003Ccode\u003EdeduceType\u003C\u002Fcode\u003E рекурсивно для каждого \u003Ccode\u003Eexpr\u003C\u002Fcode\u003E), и возвращает ее результат.\u003C\u002Fp\u003E\u003Cp\u003EЛогика \u003Ccode\u003EdeduceType\u003C\u002Fcode\u003E довольно простая - она принимает аннотируемый \u003Ccode\u003Eexpr\u003C\u002Fcode\u003E, который, если все пройдет успешно, \"заменится\" своим typed-аналогом, и \"карту типов\" - ассоциативный массив известных \"языковых единиц\" (переменных, функций) с их типами - изначально пустой, и заполняющйся по мере углубления в дерево. Большая часть типов просто подсматиривается в определении, либо выводится из операций (int + int = int, int \u002F int = float и т.д.). \u003Ccode\u003Eauto\u003C\u002Fcode\u003E разрешается максимально просто - если известно значение присваемого выражения (арифметическая операция или вызов функции), то назначается этот тип, иначе возвращается ошибка.\u003C\u002Fp\u003E\u003Cp\u003EПолные исходники - \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-03\u002Fapp\u002FAST\u002FTyping.hs\" rel=\"noopener noreferrer nofollow\"\u003Eтут\u003C\u002Fa\u003E, либо в файле step-03\u002FAST\u002FTyping.hs.\u003C\u002Fp\u003E\u003Cp\u003EДобавим \u003Ccode\u003EprocessAST\u003C\u002Fcode\u003E в \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-03\u002Fapp\u002FMain.hs#L31\" rel=\"noopener noreferrer nofollow\"\u003Emain\u003C\u002Fa\u003E и посмотрим что нам выведет наша программа теперь для простейшей функции.\u003C\u002Fp\u003E\u003Cp\u003EИсходник:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eint main() = {\n    int i = 0;\n    if (i &lt; 1) {\n        0;\n    }\n    else {\n         1;\n    };\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТипизированное представление:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003EFunction (() -\u003E int) main [] {\n  BinaryOp i= (Def int \"i\") (int 0)\n  If int (BinaryOp b&lt; (Var int \"i\") (int 1)) {\n    int 0\n  }\n  else {\n    int 1\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут \u003Ccode\u003Ei=\u003C\u002Fcode\u003E - интовое присвоение, а \u003Ccode\u003Eb&lt;\u003C\u002Fcode\u003E - операция сравнения, которая (очевидно) возвращает bool.\u003C\u002Fp\u003E\u003Ca class=\"anchor\" name=\"part-3\" id=\"part-3\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003EКодогенерация с LLVM\u003C\u002Fh2\u003E\u003Cp\u003E\u003Ccode\u003EШАГ 4\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cp\u003EВ этом разделе мы воспользуемся инфраструктурой LLVM для создания машинного когда из нашего синтаксического дерева. Для этого нам нужна библиотека llvm-hs (\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fllvm-hs\u002Fllvm-hs\" rel=\"noopener noreferrer nofollow\"\u003Egithub\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fllvm-hs\" rel=\"noopener noreferrer nofollow\"\u003Ehackage\u003C\u002Fa\u003E), которую, вместе с некоторыми другими, надо добавить в зависимости нашего проекта. В моем stack.yaml это выглядит так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003Eextra-deps:\n- llvm-hs-9.0.1\n- llvm-hs-pure-9.0.0\n- llvm-hs-pretty-0.9.0.0\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕсли же вы идете по туториалу по шагам из \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\" rel=\"noopener noreferrer nofollow\"\u003Eрепозитория\u003C\u002Fa\u003E, то переходите в \u003Cstrong\u003Estep-04\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cp\u003EНеобходимо установить и саму LLVM - как это сделать, описано в документации llvm-hs. \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fllvm-hs\u002Fllvm-hs\u002Ftree\u002F3d08076125057e64702c5f4f189852ecae326cdd#installing-llvm\" rel=\"noopener noreferrer nofollow\"\u003EИнструкция\u003C\u002Fa\u003E. Соответствущие изменения в конфигурационных файлах проекта - \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fstack.yaml\" rel=\"noopener noreferrer nofollow\"\u003Estack.yaml\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fhabrhs.cabal\" rel=\"noopener noreferrer nofollow\"\u003Ehabrhs.cabal\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Ch3\u003EИз TAST в IR\u003C\u002Fh3\u003E\u003Cp\u003EЭто - финишная прямая. Тут мы добавим модуль \u003Ccode\u003ECodegen\u003C\u002Fcode\u003E, главная его функция - \u003Ccode\u003EbuildIR\u003C\u002Fcode\u003E, выдающая промежуточное представление LLVM IR. Сразу добавим этот этап в \u003Ccode\u003Emain\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fapp\u002FMain.hs#L41\" rel=\"noopener noreferrer nofollow\"\u003Eследующим образом\u003C\u002Fa\u003E, чтобы сосредоточиться только на кодогенерации (обратите внимание - появилось много импортов и флаг --emit).\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003ECodegen\u003C\u002Fcode\u003E состоит из трех файлов, главный - \u003Ccode\u003EBuilder.hs\u003C\u002Fcode\u003E, где и происходит генерация IR, остальные содержат утилиты, по которым я предлагаю быстро пройтись (обратите внимание, что тут везде импортированы модули \u003Ccode\u003ELLVM.*\u003C\u002Fcode\u003E, функции с разными \"компиляторными\" названиями типо allocate или reference - это оттуда).\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003E1) \u003C\u002Fstrong\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fapp\u002FCodegen\u002FASTBridge.hs\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003EASTBridge\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E - разные утилиты для перевода типов и операции нашего TAST в соответствущие для LLVM\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EtypeMap\u003C\u002Fcode\u003E - словарь из пар \"наш идентификатор типа\" - \"тип в LLVM\"\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eфункции вида \u003Ccode\u003EallocateX\u003C\u002Fcode\u003E - генераторы вызовов LLVM для аллокации памяти под сам тип или указатель на него.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eфункции вида \u003Ccode\u003EreferenceX\u003C\u002Fcode\u003E - генерации LLVM-ных \"обращений\" к ячейке памяти под какой-либо тип напрямую или по указателю\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Econvert\u003C\u002Fcode\u003E - по нашим \u003Ccode\u003EIntType\u003C\u002Fcode\u003E и \u003Ccode\u003EFloatType\u003C\u002Fcode\u003E генерирует операции приведения типов для LLVM\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EopTable\u003C\u002Fcode\u003E и \u003Ccode\u003EfindOperation\u003C\u002Fcode\u003E - соответственно словарь и функция для поиска в нем соответствующих операций. Словарь содержит для \u003Ccode\u003EIntType\u003C\u002Fcode\u003E и \u003Ccode\u003EFloatType\u003C\u002Fcode\u003E еще по вложенному словарю, с парами \"строка операции\" (+, -, ....) - \"LLVM операция соответствующего типа\" (интовое умножение, дробное умножение и т.д.)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EКаждая из этих функций (за исключением последней) возвращает \u003Ccode\u003EOperand\u003C\u002Fcode\u003E - это LLVM-примитив, обозначающий, как ни странно, операнд - не самостоятельное выражение, а некий объект, который должен быть или \"записан в переменную\" (store в llvm), или использован в составе другого операнда. \u003Ccode\u003EfindOperation\u003C\u002Fcode\u003E же возвращает (а \u003Ccode\u003EopTable\u003C\u002Fcode\u003E - содержит) функции, принимающие два операнда и возвращающие третий - то есть бинарные операции.\u003C\u002Fp\u003E\u003Cp\u003EКроме уже упомянутых \u003Ccode\u003Ereference\u003C\u002Fcode\u003E и \u003Ccode\u003Eallocate\u003C\u002Fcode\u003E, тут используется еще несколько часто встречаемых конструкций из LLVM. Это \u003Ccode\u003Enamed\u003C\u002Fcode\u003E, генерирующий именованные выражения и \u003Ccode\u003EAST.PointerType\u003C\u002Fcode\u003E, оборачивающий любой другой LLVM-тип и объявляющий указатель. Особенно стоит отметить, что такое qualified имя обозначает что это не из \"нашего\" AST, а из модуля \u003Ccode\u003ELLVM.AST\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003E2) \u003C\u002Fstrong\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fapp\u002FCodegen\u002FPrimitives.hs\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003EPrimitives\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E - содержит сокращенные объявления функций LLVM. Например, объявлние \u003Cem\u003Eтипа\u003C\u002Fem\u003E указателя на int требует определить адресное пространство и вид инта (i16, i32, i64). Мы для простоты используем выравнивание по 4, i32 и дефолтное адресное пространство - поэтому удобно создать утилитарные функции, которые подобные параметры проставляют сразу. Такие сокращения и содержит этот модуль.\u003C\u002Fp\u003E\u003Cp\u003EИ, наконец, то, ради чего мы тут собрались - \u003Cstrong\u003Eгенерация IR из AST\u003C\u002Fstrong\u003E, модуль \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fapp\u002FCodegen\u002FBuilder.hs\" rel=\"noopener noreferrer nofollow\"\u003EBuilder\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cp\u003EБлагодаря рекурсивному объявлению синтаксического дерева, по сути нам надо лишь описать функцию, обрабатывающую единственный тип \u003Ccode\u003ETypedExpr\u003C\u002Fcode\u003E со специализациями под конкретные конструкторы (выражения) - \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fapp\u002FCodegen\u002FBuilder.hs#L28\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003Eemit\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E (по ссылке - ее исходный код). Мы также гарантировали, что все верхнеуровневые выражения - это функции, так что сделаем их особым кейсом, и тогда вся схема кодогенерации выглядит так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003ETAST (то есть [TypedExpr]) -\u003E buildIR -\u003E LLVM Module, где\n\n1) buildIR: применяет к каждому TypedExpr (который гарантированно функция) buildFunction \n2) buildFunction: генерирует IR функции, то есть создает ее объявление, аллоцирует аргументы,\n   и затем генерирует тело с помощью funcBodyBuilder -\u003E buildCodeBlock\n3) buildCodeBlock: применяет emit к каждому выражению и его частям рекурсивно, и делает возвращаемым значением последнее выражение\n   (мы сделали возвращаемые переменные \"последним выражением\" в блоке на этапе обработки AST, помните?)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТип функции \u003Ccode\u003Eemit\u003C\u002Fcode\u003E следующий - \u003Ccode\u003Eemit :: (MonadFix m, MonadIRBuilder m) =\u003E TypedExpr -\u003E m Operand\u003C\u002Fcode\u003E. То есть это функция, которая работает с монадой \u003Ccode\u003EIRBuilder\u003C\u002Fcode\u003E из LLVM - это крайне удобно, т.к. с помощью do-блока и специальных фунций LLVM мы, по сути, просто объявляем (с помощью паттерн-матчинга) для каждого нашего выражения какой ему соответствует IR-код почти один-в-один для человеческого глаза. Т.к. большинство из того что \"возвращают\" функции LLVM можно передать далее по монаде, написание \u003Ccode\u003Eemit\u003C\u002Fcode\u003E - довольно тривиально.\u003C\u002Fp\u003E\u003Cp\u003EРазберем пример (тут используется функция \u003Ccode\u003Eview\u003C\u002Fcode\u003E в паттерне для удобства - она сразу достает тип и составные части выражения) - генерация для \u003Ccode\u003EIf\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003E-- type_ - тип результата блока\nemit (view -\u003E (type_, TIf cond blockTrue blockFalse)) = mdo\n  -- генерируем IR для условия If (рекурсивно используем emit), например для выражения вида \"x &lt; y\"\n  condition &lt;- emit cond\n  -- создаем указатель на будущий результат, он будет результатом блока\n  -- и в него запишется результат выполненной ветки\n  resultPointer &lt;- allocateT type_\n  -- проверка условия и выбор ветки\n  condBr condition trueBranch falseBranch\n  -- генерация IR для ветки if (...) { }\n  trueBranch &lt;- buildBranch \"true\" blockTrue resultPointer $ Just mainBr\n  -- генерация IR для ветки else { }\n  falseBranch &lt;- buildBranch \"false\" blockFalse resultPointer $ Just mainBr\n  -- возвращаемся в \"главную ветку\" исполнения и возвращаем результат\n  (mainBr, result) &lt;- emitExit resultPointer\n  return result\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут есть несколько утилитарных функций. Самая простая - \u003Ccode\u003EemitExit\u003C\u002Fcode\u003E, она просто генерирует код выхода из блока с сохранением результата:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003EemitExit resultPointer = do\n  mainBr &lt;- block `named` bodyLabel\n  result &lt;- load resultPointer\n  return (mainBr, result)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВторая - \u003Ccode\u003EbuildBranch\u003C\u002Fcode\u003E. Аналоги веток есть не только у \u003Ccode\u003EIf\u003C\u002Fcode\u003E, но в некотором смысле и у циклов, просто там в конце происходит прыжок в начало.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003E-- тут мы получаем имя, список expr для генерации (codeBlock), и уже известный resultPointer - куда сохранить результат\nbuildBranch name codeBlock resultPointer mNext =\n  do\n    -- начинаем ветку - метка для LLVM\n    branch &lt;- block `named` name\n    -- опять рекурсивно применяем emit, скрывающийся под buildCodeBlock\n    blockR &lt;- buildCodeBlock codeBlock\n    -- сохраняем результат по указателю\n    store resultPointer blockR\n    -- если надо выйти из ветки - генерируем прыжок, иначе пропускаем\n    case mNext of\n      Nothing -\u003E pure ()\n      Just label -\u003E br label\n    -- возвращаем получившийся блок\n    return branch\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EРасписав таким образом \u003Ccode\u003Eemit\u003C\u002Fcode\u003E для каждого вида выражений (некоторые реализации занимают \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fapp\u002FCodegen\u002FBuilder.hs#L34\" rel=\"noopener noreferrer nofollow\"\u003Eодну строку\u003C\u002Fa\u003E), мы получаем генератор IR кода. Посмотрим, что у нас получилось в итоге для \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-04\u002Fmain.grt\" rel=\"noopener noreferrer nofollow\"\u003Eвсе той же\u003C\u002Fa\u003E простейшей функции (те кто следуют по туториалу - это \u003Ccode\u003Emain.grt\u003C\u002Fcode\u003E).  Запустим \u003Ccode\u003Estack run -- -e main.grt\u003C\u002Fcode\u003E еще раз и полюбуемся на результат (флаг -e нужен для печати IR - ведь на этом этапе мы уже расчитываем скоро иметь компилятор, а они обычно не выводят на экран IR):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E; ModuleID = 'program'\n\ndefine external ccc  i32 @main()    {\nBody_0:\n  %i_0 = alloca i32, align 4 \n  store  i32 0, i32* %i_0, align 4 \n  %0 = load  i32, i32* %i_0, align 4 \n  %1 = icmp slt i32 %0, 1 \n  %2 = alloca i32, align 4 \n  br i1 %1, label %true_0, label %false_0 \ntrue_0:\n  store  i32 0, i32* %2, align 4 \n  br label %Body_1 \nfalse_0:\n  store  i32 1, i32* %2, align 4 \n  br label %Body_1 \nBody_1:\n  %3 = load  i32, i32* %2, align 4 \n  ret i32 %3 \n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭтот код сгенерирован без каких-либо оптимизаций, поэтому он многословнее чем \"должен быть\", но для нас это только лучше - нагляднее. Ура, мы наконец имеем LLVM IR из исходников нашей программы. Запустить его уже можно, например перенаправив вывод в файл, который затем дать на вход \u003Ccode\u003Elli\u003C\u002Fcode\u003E - интерпретатору IR.\u003C\u002Fp\u003E\u003Cp\u003EЕсли хочется создать исполняемый файл, то дело за малым - обратиться к встроенному в LLVM функционалу компиляции модулей.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EБонус: создаем бинарник\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003EЭто уже \u003Ccode\u003EШАГ 5\u003C\u002Fcode\u003E, директория \u003Ccode\u003Estep-05\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EЧтобы максимально быстро получить результат, будем использовать все параметры по умолчанию - благо, для этого в llvm-hs есть готовые обертки. По большому счету, все что нам надо сделать - это склеить \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fllvm-hs-9.0.1\u002Fdocs\u002FLLVM-Internal-Context.html#v:withContext\" rel=\"noopener noreferrer nofollow\"\u003Eпустой контекст\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fllvm-hs-9.0.1\u002Fdocs\u002FLLVM-Internal-Target.html#v:withHostTargetMachineDefault\" rel=\"noopener noreferrer nofollow\"\u003Eнастройки хостовой машины по умолчанию\u003C\u002Fa\u003E, создать llvm-модуль из нашего \u003Ccode\u003ELLVM.AST.Module\u003C\u002Fcode\u003E с помощью \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fllvm-hs-9.0.1\u002Fdocs\u002FLLVM-Module.html#v:withModuleFromAST\" rel=\"noopener noreferrer nofollow\"\u003Eсоответствующей функции\u003C\u002Fa\u003E, и скормить финальный результат \u003Ca href=\"https:\u002F\u002Fhackage.haskell.org\u002Fpackage\u002Fllvm-hs-9.0.1\u002Fdocs\u002FLLVM-Module.html#v:writeObjectToFile\" rel=\"noopener noreferrer nofollow\"\u003Eбилдеру объектников\u003C\u002Fa\u003E, после чего этот файл слинковать.\u003C\u002Fp\u003E\u003Cp\u003EКод для дешёвого и сердитого создания объектных файлов выглядит так (\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-05\u002Fapp\u002FCompiler.hs\" rel=\"noopener noreferrer nofollow\"\u003Eполный файл\u003C\u002Fa\u003E):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003EwriteWithDefaultTarget :: File -\u003E Module -\u003E IO ()\nwriteWithDefaultTarget file mod = withHostTargetMachineDefault (\\t -\u003E writeObjectToFile t file mod)\n\nwriteWithModuleFromAST :: File -\u003E Context -\u003E LLVM.AST.Module -\u003E IO ()\nwriteWithModuleFromAST f c m = withModuleFromAST c m (writeWithDefaultTarget f)\n\nwriteObject :: File -\u003E LLVM.AST.Module -\u003E IO ()\nwriteObject file mod = withContext (\\c -\u003E writeWithModuleFromAST file c mod)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ так добавляется в main (\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\u002Fblob\u002Fmaster\u002Fstep-05\u002Fapp\u002FMain.hs\" rel=\"noopener noreferrer nofollow\"\u003Eполный файл\u003C\u002Fa\u003E):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"haskell\"\u003EwriteObject (File (\"output.o\" :: FilePath)) ir\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EС добавлением этого, наша программа после запуска сгенерирует файл \u003Ccode\u003Eoutput.o\u003C\u002Fcode\u003E, который только останется слинковать вашим любимым линкером - у меня на маке это выглядит как \u003Ccode\u003Eld -lSystem output.o -o output\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EТак как ввод\u002Fвывод мы не реализовали, наша программа просто возвращает числа, которые будут выходными кодами. Соответствено, посмотреть результат исполнения можно распечатав exit code последней команды. Я написал утилитарный скрипт (проверял только на macOS) для упрощения этого процесса, который запускает наш комплиятор, линкует объектный файл, запускает получившуюся программу и печатает результат:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E#!\u002Fusr\u002Fbin\u002Fenv bash\nstack run -- main.grt\n\nld -lSystem output.o -o output\nchmod +x output\n.\u002Foutput\n\necho $?\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ca class=\"anchor\" name=\"part-4\" id=\"part-4\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003EЗаключение\u003C\u002Fh2\u003E\u003Cp\u003EИтак, мы прошли все основные этапы написания компилятора - парсер, обработка AST, генерация IR, даже затронули генерацию финального машинного кода. Иначе говоря, мы разработали фронтенд компилятора и научились взаимодействовать с бэкендом (LLVM). Конечно, как я уже указывал, многое можно сделать лучше - надеюсь я дал достаточно ссылок на другие материалы, чтобы вы смогли избежать моих ошибок, а мой туториал стал хорошей стартовой точкой.\u003C\u002Fp\u003E\u003Cp\u003EБуду рад комментариям (постараюсь ответить на них), а также PR-ам в \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FVoidDruid\u002Fhabr-hs-llvm\" rel=\"noopener noreferrer nofollow\"\u003Eрепозиторий\u003C\u002Fa\u003E туториала - версия кода, используемая в этой стате, зафиксирована в README и самой ссылке в начале, так что перепройти туториал можно в любой момент.\u003C\u002Fp\u003E\u003Cp\u003EЛюбите и используйте функциональные языки, и спасибо за внимание!\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"haskell"},{"titleHtml":"llvm"},{"titleHtml":"llvm ir"},{"titleHtml":"компиляторы"},{"titleHtml":"компиляция"},{"titleHtml":"ассемблер"},{"titleHtml":"функциональное программирование"},{"titleHtml":"сделай сам"},{"titleHtml":"compiler"},{"titleHtml":"парсинг"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8bf\u002F9da\u002F8ab\u002F8bf9da8ab2389bff724179f9ad0073bf.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8bf\u002F9da\u002F8ab\u002F8bf9da8ab2389bff724179f9ad0073bf.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F581234\\\u002F\"},\"headline\":\"Написание компилятора на Haskell + LLVM\",\"datePublished\":\"2021-10-06T23:13:47+03:00\",\"dateModified\":\"2021-10-07T23:29:31+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Игорь Бесчастнов\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C\\\u002FC++, в одном pet-project использовал Haskell. С таким багажо...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F581234\\\u002F#post-content-body\",\"about\":[\"h_haskell\",\"h_compilers\",\"h_funcprog\",\"h_DIY\",\"f_develop\",\"f_popsci\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F581234\\\u002Fca3b6122a243d82baaa04127f3cc62b7\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F1c1\\\u002Fe91\\\u002F60f\\\u002F1c1e9160f3dec79f1fbc97f0765bf229.png\"]}","metaDescription":"На работе я пишу почти исключительно на Python, с университетской скамьи остались некоторые знания C\u002FC++, в одном pet-project использовал Haskell. С таким багажом знаний я взялся за написание...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"haskell,compilers,funcprog,DIY"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
