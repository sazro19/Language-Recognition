<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/wunderfund\/blog\/582004\/"},"headline":"Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз","datePublished":"2021-10-18T15:45:49+03:00","dateModified":"2021-10-18T19:02:58+03:00","author":{"@type":"Person","name":"mr-pickles"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось дости...","url":"https:\/\/habr.com\/ru\/company\/wunderfund\/blog\/582004\/#post-content-body","about":["c_wunderfund","h_programming","h_algorithms","h_vs","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/582004\/d169d40b6929b6405567408d49bfcf4f\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2d3\/88c\/ab8\/2d388cab8beec393b32a9e18596da2ca.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/45e\/187\/723\/45e1877237c70a7ea445eff078458f76.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2b5\/7a3\/f0d\/2b57a3f0d529607393eeecfc734a863a.gif","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/7b8\/228\/2b4\/7b82282b49dca54cb130d20d4e2dfdf9.gif","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/caf\/b71\/0ba\/cafb710ba7232a11bcdb299066cb62f4.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/e78\/32c\/84a\/e7832c84ad53d8d0967529864c97afbb.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/31f\/d7c\/8d7\/31fd7c8d7554a746843c66935fb8a257.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/0f6\/419\/204\/0f6419204c4a2adcf67df0e61cabf68d.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/248\/c3a\/6b3\/248c3a6b385feb591773359da9b0678f.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/fbb\/3c2\/379\/fbb3c23799bbdcfc718f1a4bf4d22c1a.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/0a3\/7b1\/444\/0a37b14445b054279b8dae0903bbe19e.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/89a\/ff3\/124\/89aff312484b7b0d997de5813d034a63.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/115\/d88\/8fd\/115d888fd04eee96f5203d6cd16f2ca4.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь значительного ускорения этого..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь значительного ускорения этого..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь значительного ускорения этого..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь значительного ускорения этого..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь значительного ускорения этого..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/927/f23/4a0/927f234a0f8e55af0bb86499a7dff515.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/927/f23/4a0/927f234a0f8e55af0bb86499a7dff515.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/927/f23/4a0/927f234a0f8e55af0bb86499a7dff515.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/927/f23/4a0/927f234a0f8e55af0bb86499a7dff515.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/927/f23/4a0/927f234a0f8e55af0bb86499a7dff515.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="582004" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-18T12:45:49.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/582004/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/wunderfund/blog/582004/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/927/f23/4a0/927f234a0f8e55af0bb86499a7dff515.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/582004/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="wunderfund" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/wunderfund/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/b1a/8c4/544/b1a8c4544d951f4ea9bad437589d958e.png" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">60.88</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/wunderfund/profile/" class="tm-company-card__name">
        Wunder Fund
      </a> <div class="tm-company-card__description">Мы занимаемся высокочастотной торговлей на бирже</div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/mr-pickles/" title="mr-pickles" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/a90/a35/fb7/a90a35fb73f6e7f05770af0978f90b11.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/mr-pickles/" class="tm-user-info__username">
      mr-pickles
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-18T12:45:49.000Z" title="2021-10-18, 15:45">18  октября   в 15:45</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/wunderfund/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании Wunder Fund</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/algorithms/" class="tm-article-snippet__hubs-item-link"><span>Алгоритмы</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/vs/" class="tm-article-snippet__hubs-item-link"><span>Visual Studio</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://code.visualstudio.com/blogs/2021/09/29/bracket-pair-colorization" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Henning Dieterichs
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><figure class="full-width "><img src="/img/image-loader.svg" height="440" data-src="https://habrastorage.org/getpro/habr/upload_files/2d3/88c/ab8/2d388cab8beec393b32a9e18596da2ca.png" data-width="780"/><figcaption></figcaption></figure><p><em>Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь </em>значительного<em> ускорения этого процесса. Нам самим очень нравится решать подобные задачи при работе над торговой системой, а если они вам тоже интересны, то пишите:)</em></p><p>Когда имеешь дело с глубоко вложенными скобками в Visual Studio Code — может быть непросто понять то, у каких скобок есть пары, а у каких — нет.</p><p>Для того чтобы упростить решение этой задачи, в 2016 году пользователь CoenraadS разработал восхитительное расширение для VS Code — <a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer">Bracket Pair Colorizer</a>, позволяющее раскрашивать парные скобки, и опубликовал его в VS Code Marketplace. Это расширение стало весьма популярным, теперь оно, с более чем 6 миллионами установок, входит в 10 самых скачиваемых расширений.</p><p>Для того чтобы решить проблемы, касающиеся производительности и точности работы расширения, в 2018 году CoenraadS выпустил расширение <a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2">Bracket Pair Colorizer 2</a>, которое тоже стало популярным и было установлено более 3 миллионов раз.<br/><br/>Bracket Pair Colorizer — это хороший пример возможностей расширяемости VS Code. Оно интенсивно использует для раскрашивания скобок <a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor.setDecorations">Decoration API</a>.</p><figure class="full-width "><img src="/img/image-loader.svg" height="536" data-src="https://habrastorage.org/getpro/habr/upload_files/45e/187/723/45e1877237c70a7ea445eff078458f76.png" data-width="1927"/><figcaption></figcaption></figure><p>Мы рады тому, что в VS Code Marketplace имеются и многие другие подобные расширения, написанные пользователями редактора. Каждое из них весьма креативно подходит к решению задачи идентификации парных скобок. Среди них — следующие: <a href="https://marketplace.visualstudio.com/items?itemName=2gua.rainbow-brackets">Rainbow Brackets</a>, <a href="https://marketplace.visualstudio.com/items?itemName=rafamel.subtle-brackets">Subtle Match Brackets</a>, <a href="https://marketplace.visualstudio.com/items?itemName=Durzn.brackethighlighter">Bracket Highlighter</a>, <a href="https://marketplace.visualstudio.com/items?itemName=leodevbro.blockman">Blockman</a> и <a href="https://marketplace.visualstudio.com/items?itemName=wraith13.bracket-lens">Bracket Lens</a>. Такое разнообразие расширений указывает на то, что у пользователей VS Code имеется реальное стремление к тому, чтобы редактор лучше поддерживал бы механизмы раскрашивания парных скобок.</p><h3>Проблема производительности</h3><p>К несчастью, то, что природа Decoration API неинкрементальна, и то, что мы не даём расширениям доступ к информации о токенах VS Code, приводит к тому, что расширение Bracket Pair Colorizer медленно обрабатывает большие файлы. При вставке одной скобки в начале файла <a href="https://github.com/microsoft/TypeScript/blob/8362a0f929d74ff46828016ec67c05744a8dbb3c/src/compiler/checker.ts">checker.ts</a>, содержащего более 42000 строк кода, входящего в состав TypeScript-проекта, на обновление цветов всех пар скобок уходит около 10 секунд. В течение этих 10 секунд хост-процесс расширения нагружает процессор на 100%, и все возможности редактора, обеспечиваемые расширениями, вроде автозавершения или диагностики, перестают функционировать. Хорошо, правда, то, что <a href="https://code.visualstudio.com/api/advanced-topics/extension-host#stability-and-performance">архитектура VS Code</a> обеспечивает работоспособность и отзывчивость интерфейса, и то, что документ при этом можно сохранить на диск.</p><p>CoenraadS знал об этой проблеме с производительностью и приложил значительные усилия к повышению скорости и точности работы второй версии расширения. Он переиспользовал токены и движок парсинга скобок из VS Code. Но API VS Code и архитектура расширений не рассчитаны на высокопроизводительную раскраску пар скобок в ситуации, когда речь идёт о сотнях тысяч пар скобок. В результате даже у расширения Bracket Pair Colorizer 2, уходит некоторое время на то, чтобы цвета скобок отразили бы новые уровни вложенности кода после вставки <code>{</code> в начало вышеупомянутого файла.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Обработка большого файла с помощью Bracket Pair Colorizer 2" title="Обработка большого файла с помощью Bracket Pair Colorizer 2" height="495" data-src="https://habrastorage.org/getpro/habr/upload_files/2b5/7a3/f0d/2b57a3f0d529607393eeecfc734a863a.gif" data-width="907"/><figcaption>Обработка большого файла с помощью Bracket Pair Colorizer 2</figcaption></figure><p>Хотя нас вполне устроило бы простое улучшение производительности расширения (что, конечно, потребовало бы создания более продвинутых API, оптимизированных для сценариев, создающих большую нагрузку на систему), асинхронная коммуникация между подсистемой рендеринга и хост-процессом расширения ограничивает то, как быстро может быть выполнена раскраска скобок в том случае, если соответствующий механизм реализован в виде расширения. Это ограничение обойти нельзя. В частности, цвета для пар скобок не должны запрашиваться в асинхронном режиме когда они появляются в области просмотра документа, так как это может привести к мерцанию при прокрутке больших файлов. Обсуждение этого вопроса можно найти <a href="https://github.com/microsoft/vscode/issues/128465#issuecomment-879089188">здесь</a>.</p><h3>Наше решение задачи</h3><p>Мы пошли другим путём. А именно, в обновлении <a href="https://code.visualstudio.com/updates/v1_60#_high-performance-bracket-pair-colorization">VS Code 1.60</a>, мы внедрили возможности рассматриваемого расширения в ядро VS Code и снизили время обработки вышеупомянутого документа до менее чем миллисекунды. В данном конкретном случае это означает ускорение раскрашивания скобок более чем в 10000 раз.</p><p>Соответствующую возможность можно включить, добавив в редактор следующую настройку:</p><pre><code class="bash">"editor.bracketPairColorization.enabled": true.</code></pre><p>Теперь перекрашивание скобок выполняется незаметно для пользователя — даже в файлах, содержащих сотни тысяч пар скобок. Обратите внимание на следующее анимированное изображение, где новый уровень вложенности отражается изменением цвета скобки в строке 42788 сразу же после вставки <code>{</code> в строку номер 2.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Быстрая обработка скобок в большом файле с использованием встроенных возможностей VS Code" title="Быстрая обработка скобок в большом файле с использованием встроенных возможностей VS Code" height="495" data-src="https://habrastorage.org/getpro/habr/upload_files/7b8/228/2b4/7b82282b49dca54cb130d20d4e2dfdf9.gif" data-width="907"/><figcaption>Быстрая обработка скобок в большом файле с использованием встроенных возможностей VS Code</figcaption></figure><p>После того, как мы решили перевести обработку скобок на уровень ядра, мы, кроме того, пользуясь случаем, решили максимально ускорить эту операцию. Кто не любит алгоритмических задачек?</p><p>Мы, не ограниченные особенностями общедоступного API, могли использовать (2,3)-деревья, нерекурсивный обход деревьев, двоичную арифметику, инкрементальный парсинг и другие подходы. Целью всего этого было уменьшение <a href="https://en.wikipedia.org/wiki/Time_complexity">временной сложности алгоритма</a> обновления данных о скобках, которую он показывает в худшем случае (то есть — время, необходимое на обработку пользовательского ввода, когда документ уже был открыт). Мы хотели перейти от временной сложности алгоритма O(N+E) к временной сложности O(log 3 N+E), при условии, что N — это размер документа, а E — это размер редактируемой области, исходя из предположения о том, что уровень вложенности пар скобок ограничен O(log N).</p><p>Мы, кроме того, использовав в своих целях существующие токены из подсистемы рендеринга и её механизм инкрементного обновления токенов, достигли дополнительного серьёзного (но неизменного) ускорения.</p><h3>Поддержка механизма раскрашивания скобок в Visual Studio Code for the Web</h3><p>Помимо того, что новая реализация механизма раскрашивания скобок оказалась производительнее старых решений, она ещё и поддерживается в VS Code for the Web. Узнать подробнее об этом редакторе — о VS Code, работающем в браузере — можно <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/web-based-editor">здесь</a>. Благодаря тому, что Bracket Pair Colorizer 2 использует в своих целях движок токенизации VS Code, невозможно было перевести это расширение в формат так называемого <a href="https://code.visualstudio.com/api/extension-guides/web-extensions">веб-расширения</a>.</p><p>Но наша новая система раскрашивания скобок не только работает в VS Code for the Web. Она функционирует ещё и в <a href="https://microsoft.github.io/monaco-editor/">Monaco Editor</a>!</p><h3>Сложная и интересная задача раскрашивания пар скобок</h3><p>В раскрашивании пар скобок самое главное — это быстрое нахождение всех скобок и их (абсолютного) уровня вложенности в области просмотра документа. Область просмотра документа можно описать как небольшую часть документа, представленную некоторым количеством строк и столбцов.</p><p>К сожалению, уровень вложенности скобки зависит от всех предшествующих ей символов: замена любого символа на открывающую скобку, <code>{</code>, обычно увеличивает уровень вложенности всех следующих за ней скобок.</p><p>В результате при первоначальном раскрашивании скобок в самом конце документа, необходимо обработать абсолютно каждый символ во всём документе.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Слева — уровень отступа 1, а справа — 2" title="Слева — уровень отступа 1, а справа — 2" height="147" data-src="https://habrastorage.org/getpro/habr/upload_files/caf/b71/0ba/cafb710ba7232a11bcdb299066cb62f4.png" data-width="723"/><figcaption>Слева — уровень отступа 1, а справа — 2</figcaption></figure><p>В расширении Bracket Pair Colorizer эта задача решается путём повторной обработки всего документа, выполняемой каждый раз, когда в документ добавляют новую скобку, или когда из него удаляют одну из существующих скобок (это весьма разумно при обработке маленьких документов). После этого нужно убрать старые цвета скобок и окрасить их в новые, используя <a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor.setDecorations">Decoration API</a> VS Code, который отправляет в подсистему рендеринга сведения о цветах символов.</p><p>Как уже было показано, этот подход, при обработке больших документов, включающих в себя сотни тысяч пар скобок, которые нужно раскрасить, оказывается медленным. Так как расширение не может менять сведения об оформлении скобок инкрементно и должно предоставить системе новые сведения за один раз, подобное расширение просто не может работать заметно лучше. Но, всё равно, подсистема рендеринга весьма разумно (с использованием так называемого <a href="https://github.com/microsoft/vscode/blob/534c529c292a96eb775c74dfcee2d733380ed629/src/vs/editor/common/model/intervalTree.ts">дерева интервалов</a>) организует полученные ей сведения об оформлении скобок. В результате рендеринг документа всегда выполняется быстро после того, как будут получены сведения об оформлении символов, возможно — сотен тысяч символов.</p><p>Наша цель заключается в том, чтобы избавиться от необходимости переобработки всего документа после каждого нажатия на клавишу клавиатуры. Вместо этого время, необходимое для обработки одного эпизода правки текста должно расти, по мере роста длины документа, лишь (<a href="https://en.wikipedia.org/wiki/Polylogarithmic_function">поли</a>) логарифмически.</p><p>Но при этом нам нужна и возможность выполнять запросы сведений обо всех скобках и об их уровнях вложенности в области просмотра документа за (поли) логарифмическое время, как это было бы при использовании Decoration API VS Code (этот API использует вышеупомянутое дерево интервалов).</p><h3>Алгоритмическая сложность</h3><p>Если вам это неинтересно — вы вполне можете пропустить этот раздел.</p><p>Ниже N — это длина документа. Если выразить нашу цель более формально, то окажется, что заключается она в том, чтобы выйти на временную сложность алгоритма, не превышающую O(log k N+R), используемого для запроса сведений обо всех скобках в заданном месте документа размера R и с достаточно маленьким k (наша цель — k=2). Сведения о скобках запрашиваются при рендеринге содержимого области просмотра документа, в результате запрос этих сведений должен быть по-настоящему быстрым.</p><p>Правда, мы допускаем, что временная сложность инициализации документа, открываемого впервые, может быть равна O(N). Это неизбежно, так как при первоначальном раскрашивании скобок нужно обработать все символы документа. Далее, нас устраивает временная сложность обновления цветов скобок, соответствующая O(log j N+E), где E — это количество модифицированных или добавленных в документ символов. Опять же, нам нужно достаточно маленькое значение j (наша цель — j=3). Мы, кроме того, исходим из предположения, что уровень вложенности пар скобок не слишком велик, что он ограничен O(log N), и что количество закрывающих скобок без соответствующих им открывающих пренебрежимо мало. Документ, не соответствующий этим предположениям — это документ нетипичный, и алгоритм, который нам нужен, не обязан быстро обрабатывать подобные документы.</p><h3>Семантика языка усложняет раскрашивание пар скобок</h3><p>Нашу задачу по-настоящему усложняет выявление настоящих скобок, являющихся скобками (а не, например, частями строк) в соответствии с правилами языка, используемого в документе. В частности, мы не хотели бы выявлять открывающие или закрывающие скобки в комментариях или в строках, как показано в следующем примере кода, написанного на C:</p><pre><code>{ /* } */ char str[] = "}"; }</code></pre><p>Тут открывающую скобку закрывает лишь третье вхождение символа <code>}</code>.</p><p>Всё становится ещё сложнее в языках, где токены языка не имеют регулярной структуры. Например — это TypeScript с JSX:</p><figure class="full-width "><img src="/img/image-loader.svg" alt="TypeScript-код, в котором имеется функция, содержащая шаблонный литерал со встроенными выражениями. Шаблонный литерал, кроме того, содержит закрывающую скобку в позиции 2. Тело функции начинается со скобки в позиции 1, а заканчивается скобкой на позиции 3" title="TypeScript-код, в котором имеется функция, содержащая шаблонный литерал со встроенными выражениями. Шаблонный литерал, кроме того, содержит закрывающую скобку в позиции 2. Тело функции начинается со скобки в позиции 1, а заканчивается скобкой на позиции 3" height="203" data-src="https://habrastorage.org/getpro/habr/upload_files/e78/32c/84a/e7832c84ad53d8d0967529864c97afbb.png" data-width="828"/><figcaption>TypeScript-код, в котором имеется функция, содержащая шаблонный литерал со встроенными выражениями. Шаблонный литерал, кроме того, содержит закрывающую скобку в позиции 2. Тело функции начинается со скобки в позиции 1, а заканчивается скобкой на позиции 3</figcaption></figure><p>Соответствует ли скобка [1] скобке [2] или скобке [3]? Это зависит от длины выражения шаблонного литерала, что может правильно определить лишь токенизатор с неограниченным состоянием (а это — нерегулярный токенизатор).</p><h3>Наше спасение — в токенах</h3><p>К счастью, при решении задачи подсветки синтаксических конструкций языка, приходится сталкиваться с теми же проблемами: нужно ли выводить скобку [2] в предыдущем примере как строку или как обычный текст программы?</p><p>Как оказалось, простое игнорирование скобок в комментариях и строках, идентифицированных системой подсветки синтаксиса, хорошо подходит при обработке большинства пар скобок. До сих пор мы обнаружили лишь одну проблемную пару скобок, появляющуюся в конструкции вида <code>&lt; ... ></code>. Дело в том, что обе такие скобки обычно используются в операциях сравнения и как часть определения обобщённых типов, но и в том и в другом случаях тип их токена оказывается одним и тем же.</p><p>В VS Code уже имеется эффективный и синхронный механизм для управления информацией о токенах, используемый для подсветки синтаксиса. Мы можем использовать этот механизм в своих целях для идентификации открывающих и закрывающих скобок.</p><p>Это — ещё одна сложная проблема, плохо влияющая на производительность, которая встала перед автором расширения Bracket Pair Colorization. У расширения нет доступа к этим токеном, оно должно находить их самостоятельно, выполняя работу, которая, в сущности, уже сделана. Мы <a href="https://github.com/microsoft/vscode/issues/128465#issuecomment-879089188">долго думали</a> о том, как можно эффективно и надёжно предоставить информацию о токенах расширениям, но пришли к выводу, что не можем этого сделать, не допустив значительной утечки информации о деталях реализации ядра VS Code через API, предназначенный для расширений. Так как расширению, вне зависимости от того, как оно получает сведения о токенах, всё ещё нужно отправлять системе сведения о цвете каждой скобки в документе, только лишь появление нового API даже не позволит решить проблем с производительностью.</p><p>Попутно можно отметить, что при внесении в самое начало документа изменения, влияющего на все следующие за ним токены (вроде — добавление в документ конструкции <code>/*</code> для C-подобных язкыков), VS Code не проводит одномоментную повторную токенизацию всего докумета. Вместо этого документ обрабатывается по частям в течение некоторого времени. Это обеспечивает работоспособность интерфейса, отсутствие «тормозов», несмотря даже на то, что токенизация производится в подсистеме рендеринга в синхронном режиме.</p><h3>Базовый алгоритм</h3><p>Нашей основной идеей было использование <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">рекурсивного нисходящего парсера</a> для создания абстрактного синтаксического дерева (<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree, AST</a>), которое описывает структуру всех пар скобок. Когда обнаруживается скобка — проверяется информация о токене. Если скобка входит в состав комментария или обычной строки — она пропускается. Токенизатор позволяет парсеру получать сведения о подобных скобках или о текстовых токенах.</p><p>Самое интересное тут в том, чтобы хранить сведения лишь о длине каждого узла (и, кроме того, чтобы имелись текстовые узлы для хранения всего того, что не является скобкой, чтобы перекрывать «пространства» между скобками), а не абсолютные данные о позиции начала и конца пары скобок. Если имеются лишь сведения о длине, узел, представляющий скобку, находящийся в определённой позиции, всё ещё можно эффективно найти в AST.</p><p>На следующей схеме показан пример AST с аннотациями, касающимися длины фрагментов.</p><figure class=""><img src="/img/image-loader.svg" alt="Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и относительную информацию о длине фрагментов" title="Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и относительную информацию о длине фрагментов" height="356" data-src="https://habrastorage.org/getpro/habr/upload_files/31f/d7c/8d7/31fd7c8d7554a746843c66935fb8a257.png" data-width="486"/><figcaption>Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и относительную информацию о длине фрагментов</figcaption></figure><p>Сравните это с классическим AST-представлением подобных данных, где используются абсолютные координаты начала и конца фрагментов.</p><figure class=""><img src="/img/image-loader.svg" alt="Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и абсолютные сведения о начале и конце фрагментов" title="Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и абсолютные сведения о начале и конце фрагментов" height="366" data-src="https://habrastorage.org/getpro/habr/upload_files/0f6/419/204/0f6419204c4a2adcf67df0e61cabf68d.png" data-width="483"/><figcaption>Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и абсолютные сведения о начале и конце фрагментов</figcaption></figure><p>Оба AST описывают один и тот же документ, но при обходе первого AST абсолютные позиции элементов нужно вычислять на ходу (для этого нужны весьма скромные вычислительные ресурсы), а во втором AST эти сведения хранятся в готовом виде.</p><p>Правда, при вставке единственного символа в первое дерево нужно пересчитать лишь длину самого узла и его родительского узла. А все остальные сведения о длинах фрагментов не меняются.</p><p>Когда в AST, как во втором случае, хранятся абсолютные позиции символов, получается, что в такой же ситуации нужно инкрементировать позицию каждого узла, находящегося в документе ниже добавленного символа.</p><p>Кроме того, отказавшись от хранения абсолютных смещений, можно наладить совместное использование листовых узлов, имеющих одинаковую длину, что позволит сэкономить память.</p><p>Вот как AST с аннотациями, касающимися длины фрагментов, можно описать средствами TypeScript:</p><pre><code class="javascript">type Length = ...;

type AST = BracketAST | BracketPairAST | ListAST | TextAST;
/** Описывает одну скобку, как, например, {, } или begin */
class BracketAST {
    constructor(public length: Length) {}
}
/** Описывает пару скобок, соответствующих друг другу, а так же узел, находящийся между ними. Например - {...} */
class BracketPairAST {
    constructor(
        public openingBracket: BracketAST;
        public child: BracketPairAST | ListAST | TextAST;
        public closingBracket: BracketAST;
    ) {}
    length = openingBracket.length + child.length + closingBracket.length;
}
/** Описывает список пар скобок или текстовых узлов. Например - ()...() */
class ListAST {
    constructor(
        public items: Array&lt;BracketPairAST | TextAST>
    ) {}
    length = items.sum(item => item.length);
}
/** Описывает текст, в котором нет скобок. */
class TextAST {
    constructor(public length: Length) {}
}</code></pre><p>Выполнение запросов к такому дереву для получения списка всех скобок и уровня их вложенности выглядит сравнительно просто: выполняется обход в глубину, на ходу вычисляется абсолютная позиция текущего узла (путём сложения длин предыдущих узлов), пропускаются дочерние элементы узлов, которые полностью находятся до или после области документа, сведения о которой запрошены.</p><p>Этот базовый алгоритм уже является рабочим, однако с ним связано несколько открытых вопросов:</p><ol><li><p>Как убедиться в том, что запрос сведений обо всех скобках в нужном фрагменте документа отличается нужной нам логарифмической временной сложностью и соответствующим уровнем производительности?</p></li><li><p>Как, при вводе текста, избежать создания нового AST с нуля?</p></li><li><p>Как обрабатывать поступление сведений о группах токенов? Когда открывается большой документ, в нашем распоряжении изначально нет сведений о токенах. Они поступают постепенно, в виде отдельных блоков данных.</p></li></ol><h3>Проверка того, что временная сложность алгоритма является логарифмической</h3><p>При запросе информации о скобках в заданном диапазоне документа, производительность может очень сильно пострадать в том случае, если речь идёт о по-настоящему длинных списках скобок. Мы не можем выполнить быстрый бинарный поиск на их дочерних элементах для того, чтобы опустить все ненужные непересекающиеся узлы, так как нам нужно сложить длины всех узлов для вычисления абсолютной позиции на ходу. В худшем случае нужно обойти все узлы.</p><p>В следующем примере нужно просмотреть 13 узлов (выделены синим) до тех пор, пока мы не найдём скобку в позиции 24.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Длинный список узлов в абстрактном синтаксическом дереве" title="Длинный список узлов в абстрактном синтаксическом дереве" height="420" data-src="https://habrastorage.org/getpro/habr/upload_files/248/c3a/6b3/248c3a6b385feb591773359da9b0678f.png" data-width="837"/><figcaption>Длинный список узлов в абстрактном синтаксическом дереве</figcaption></figure><p>Хотя можно вычислить и кешировать суммы длин, что позволит использовать бинарный поиск, тут появляется та же проблема, которая характерна для деревьев, хранящих абсолютные позиции узлов: нужно пересчитывать все данные о позициях каждый раз, когда размер хотя бы одного узла растёт или уменьшается, что означает серьёзную вычислительную нагрузку при обработке больших списков.</p><p>Вместо этого мы сделали так, чтобы списки, в виде дочерних элементов, могли бы иметь другие списки:</p><pre><code class="javascript">class ListAST {
  constructor(public items: Array&lt;ListAST | BracketPairAST | TextAST>) {}
  length = items.sum(item => item.length);
}</code></pre><p>Как это улучшает ситуацию?</p><p>Если мы можем гарантировать то, что у каждого узла имеется лишь ограниченное число дочерних узлов, и то, что получившаяся структура напоминает сбалансированное дерево, высота которого логарифмически зависит от числа его узлов, оказывается, что этого достаточно для того, чтобы обеспечить логарифмическую временную сложность запроса информации о скобках.</p><h3>Поддерживаем деревья списков в сбалансированном состоянии</h3><p>Для того чтобы обеспечить сбалансированность списков, мы используем <a href="https://en.wikipedia.org/wiki/2%E2%80%933_tree">(2,3)-деревья</a>: у каждого узла должно быть минимум 2 и максимум 3 дочерних элемента. Все дочерние элементы списка должны иметь одинаковую высоту в сбалансированном дереве списков. Обратите внимание на то, что пары скобок рассматриваются в сбалансированном дереве как листовые узлы высоты 0, но в AST у них могут быть дочерние элементы.</p><p>При конструировании AST с нуля при инициализации системы мы, в первую очередь, собираем все сведения о дочерних элементах, а затем преобразуем эти сведения в сбалансированное дерево. Это можно сделать за линейное время.</p><p>Возможный вариант (2,3)-дерева, соответствующего вышеприведённому примеру, выглядит так, как показано ниже. Обратите внимание на то, что теперь нам достаточно просмотреть лишь 8 узлов (выделены синим) для того чтобы обнаружить пару скобок в позиции 24, и на то, что при конструировании этого дерева можно пользоваться определённой свободой, так как у списка может быть 2 или 3 дочерних элемента.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Сбалансированное дерево, описывающее списки в AST" title="Сбалансированное дерево, описывающее списки в AST" height="502" data-src="https://habrastorage.org/getpro/habr/upload_files/fbb/3c2/379/fbb3c23799bbdcfc718f1a4bf4d22c1a.png" data-width="833"/><figcaption>Сбалансированное дерево, описывающее списки в AST</figcaption></figure><h3>Анализ временной сложности для наихудшего случая</h3><p>Если вам это неинтересно — вы вполне можете пропустить этот раздел.</p><p>Сейчас мы исходим из предположения о том, что каждый список похож на (2,3)-дерево, и в результате может иметь до 3 дочерних элементов.</p><p>Для того чтобы максимизировать время выполнения запроса, мы поработаем с документом, в котором имеется O(log N) вложенных пар скобок.</p><pre><code class="javascript">{
    {
        ... O(log N) вложенных пар скобок
            {
                {} [1]
            }
        ...
    }
}</code></pre><p>Тут пока нет списков, но нам надо обойти O(log N) узлов для того чтобы найти пару скобок в позиции [1]. К счастью, документы, отличающиеся ещё большим уровнем вложенности, встречаются очень редко, то есть — нам не нужно принимать их во внимание при анализе наихудшего случая.</p><p>Теперь, если говорить об анализе наихудшей временной сложности нашего алгоритма, мы заполним документ данными до тех пор, пока его размер не окажется равным N, вставляя в него дополнительные пары скобок, в количестве O(Nlog N ), в каждую вложенную пару скобок:</p><pre><code class="javascript">{}{}{}{}{}{}{}{}... O(N / log N)
{
    {}{}{}{}{}{}{}{}... O(N / log N)
    {
        ... O(log N) вложенных пар скобок
            {
                {}{}{}{}{}{}{}{}... O(N / log N)
                {} [1]
            }
        ...
    }
}
</code></pre><p>Каждый список скобок на одном и том же уровне вложенности приводит к появлению дерева высоты Olog Nlog N =Olog N — log log N  =O(log N ).</p><p>В результате — для того чтобы найти узел в позиции [1], нужно обойти O(log N) сбалансированных деревьев высоты O(log N). После того, как мы нашли узел и хотим собрать все скобки в диапазоне размера R, нам нужно прочитать сведения из, самое большее, O® смежных листовых узлов, соединённых, самое большее, O(N +R) внутренними узлами.</p><p>Получается, что наихудшая временная сложность операции запроса информации о скобках равна O(N +R).</p><p>Кроме того, это показывает, что максимальная высота AST равняется O(N).</p><h3>Инкрементные обновления сведений о скобках</h3><p>Но самый интересный вопрос, касающийся высокопроизводительной раскраски пар скобок, остаётся открытым: если имеется актуальное (сбалансированное) AST и выполнена правка текста, приводящая к замене некоего фрагмента документа, как эффективно обновить дерево для того, чтобы в нём отразились бы результаты этой правки текста?</p><p>Наша идея заключается в том, чтобы переиспользовать рекурсивный нисходящий парсер, применяемый при инициализации системы, и добавить в систему некий механизм кеширования. Это позволит повторно использовать информацию об узлах, на которые правка данных не подействовала, а значит — не обрабатывать их при обновлении фрагмента дерева.</p><p>Когда рекурсивный нисходящий парсер разбирает список пар скобок в позиции p, а правка затрагивает позицию e, он в первую очередь проверяет, есть ли в предыдущем AST узел с длиной, самое большее, e-p, находящийся там, где была позиция p до изменения текста. Если такой узел найти удаётся — то этот узел не надо подвергать повторному парсингу, а токенизатор, работающий на более глубоком уровне, может просто обработать фрагмент, соответствующий длине узла. После обработки узла парсинг продолжается. Обратите внимание на то, что этот узел может представлять собой и отдельную пару скобок, и целый список. Кроме того, если удаётся найти несколько подобных узлов, подходящих для повторного использования, нужно выбрать самый длинный из них.</p><p>Следующий пример демонстрирует то, какие узлы можно использовать повторно (выделены зелёным), когда в документ вставляют единственную открывающую скобку (минуя узлы, соответствующие отдельным скобкам).</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Узлы AST, подходящие для повторного использования" title="Узлы AST, подходящие для повторного использования" height="841" data-src="https://habrastorage.org/getpro/habr/upload_files/0a3/7b1/444/0a37b14445b054279b8dae0903bbe19e.png" data-width="860"/><figcaption>Узлы AST, подходящие для повторного использования</figcaption></figure><p>После обработки операции вставки текста, выполняемой путём повторного парсинга узлов, содержащих изменённый текст и переиспользования всех неизменённых узлов, обновлённое AST выглядит так, как показано ниже. Обратите внимание на то, что 11 узлов, подходящих для повторного использования, могут быть переиспользованы путём обработки 3 узлов — B, H и G, а лишь четыре узла (выделенные оранжевым) нужно создать заново.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="Обновлённое AST" title="Обновлённое AST" height="658" data-src="https://habrastorage.org/getpro/habr/upload_files/89a/ff3/124/89aff312484b7b0d997de5813d034a63.png" data-width="916"/><figcaption>Обновлённое AST</figcaption></figure><p>Этот пример демонстрирует тот факт, что применение сбалансированных списков не только позволяет быстро запрашивать информацию о скобках, но и помогает повторно использовать сразу множество узлов.</p><h3>Алгоритмическая сложность</h3><p>Если вам это неинтересно — вы вполне можете пропустить этот раздел.</p><p>Давайте представим себе, что в ходе редактирования текста заменяется фрагмент, размер которого не превышает E. При этом количество символов в новом тексте так же не превышает E. Мы, кроме того, пока игнорируем тут редкий случай, когда у закрывающих скобок нет парных открывающих скобок.</p><p>Нам нужно подвергнуть повторному парсингу лишь те узлы, которые пересекаются с зоной редактирования текста. В результате повторному парсингу надо подвергнуть, самое большее, O(N +E) узлов (тут применимы те же рассуждения, что и при разговоре о временной сложности выполнения запросов о скобках). А все остальные узлы могут быть переиспользованы.</p><p>Очевидно то, что если узел не пересекается с диапазоном редактирования текста, тогда с ним не пересекаются и дочерние элементы этого узла. В результате нам нужно ориентироваться на переиспользование узлов, которые не пересекаются с диапазоном редактирования, но при этом их родительские узлы могут пересекаться с этим диапазоном (при таком подходе автоматически будут переиспользованы все узлы, в случае, когда с диапазоном редактирования не пересекаются ни они сами, ни их родительские узлы). Далее, подобные родительские узлы не могут быть полностью перекрыты диапазоном редактирования, в противном случае с ним пересекутся все их дочерние узлы. Но на каждом уровне AST присутствует, самое большее, два узла, частично пересекающихся с диапазоном редактирования. Так как в AST может быть, самое большее, O(N) уровней (что ограничено высотой AST), а у каждого узла может быть, самое большее, 3 дочерних элемента, количество всех узлов, подходящих для повторного использования, будет, в лучшем случае, равняться O(2 ∙3∙N)=O(N) .</p><p>В результате, чтобы сконструировать обновлённое дерево, нам надо произвести повторный парсинг, самое большее, O(N+ E) узлов, а повторно использовать можно будет O(N) узлов.</p><p>Это, кроме того, определяет и временную сложность операции обновления дерева, но тут есть один нюанс.</p><h3>Как перебалансировать AST?</h3><p>К сожалению, дерево, показанное в последнем примере, больше не является сбалансированным.</p><p>При комбинировании списка узлов, подходящих для повторного использования, с узлом, только что полученным от парсера, нужно приложить некоторые усилия для того, чтобы наше дерево оставалось бы (2,3)-деревом. Мы знаем о том, что переиспользованные узлы и новый узел уже являются (2,3)-деревьями, но они могут иметь различную высоту. В результате мы не можем просто создавать родительские узлы, так как все дочерние элементы узла (2,3)-дерева должны иметь одну и ту же высоту.</p><p>Как эффективно объединить все эти узлы, имеющие разную высоту, в единое (2,3)-дерево?</p><p>Эту задачу несложно свести к задаче добавления маленького дерева в начало или конец большого дерева. Если два дерева имеют одинаковую высоту, достаточно создать список, содержащий оба дочерних элемента. В противном случае мы вставляем маленькое дерево высоты h1 в более крупное дерево размера h2 и вполне можем нарушить устройство узлов, что произойдёт в том случае, если у них, в итоге, будет более 3 дочерних элементов (это похоже на то, как происходит операция вставки данных в (2,3)-деревья).</p><p>Так как время выполнения такой операции соответствует O(h2- h1), мы берём 3 соседних узла (a, b и c), которые хотим вставить в дерево, и вставляем первым лишь один из них (это может привести к увеличению высоты дерева), что зависит от того, какая пара отличается наименьшей разницей высоты. Этот процесс повторяется до тех пор, пока все узлы не будут вставлены в дерево. Продолжая оптимизацию этого процесса, мы ищем последовательности узлов, которые имеют одну и ту же высоту, и создаём родительские списки для них за линейное время.</p><p>Для того чтобы сбалансировать списки и из предыдущего примера, мы выполняем операцию конкатенации над их дочерними элементами (списки, выделенные красным, нарушают правила построения (2,3)-деревьев, оранжевые узлы имеют высоту, отличающуюся от ожидаемой, а зелёные узлы пересоздаются в процессе перебалансировки дерева).</p><figure class="full-width "><img src="/img/image-loader.svg" alt="AST после балансировки списков" title="AST после балансировки списков" height="899" data-src="https://habrastorage.org/getpro/habr/upload_files/115/d88/8fd/115d888fd04eee96f5203d6cd16f2ca4.png" data-width="712"/><figcaption>AST после балансировки списков</figcaption></figure><p>Так как в несбалансированном дереве список B имеет высоту 2, а пара скобок — высоту 0, нам нужно присоединить к B, после чего обработка списка может считаться завершённой. Оставшееся (2,3)-дерево — это B, в результате оно становится новым корнем и заменяет список. Мы продолжаем работу с, его дочерний элемент и H имеют высоту, равную 0, а высота G равняется 1.</p><p>Мы, в первую очередь, объединяем и H и создаём новый родительский узел Y высоты 1 (так как и H имеют одинаковую высоту). Затем мы конкатенируем Y и G и создаём новый родительский список X (по той же причине). Затем X становится новым дочерним элементом родительской пары скобок, заменяя несбалансированный список.</p><p>В нашем примере операция балансировки помогла успешно уменьшить высоту самого верхнего списка с 3 до 2. Но общая высота AST выросла с 4 до 5, что плохо влияет на время выполнения запроса в наихудшем случае. Причиной этого является пара скобок, которая действует в роли листового узла в сбалансированном дереве списков, но, на самом деле, содержит ещё один список высоты 2.</p><p>Учёт высоты внутреннего AST узла при балансировке родительского списка может улучшить показатели, характерные для наихудшего случая, но это выходит за пределы теории (2,3)-деревьев.</p><h3>Алгоритмическая сложность</h3><p>Если вам это неинтересно — вы вполне можете пропустить этот раздел.</p><p>Нам надо произвести объединение, самое большее, O(N) узлов с максимальной высотой списка O(log N) (те, что мы переиспользуем), с дополнительными узлами в количестве O(N+ E), с высотой списков 0 (те, которые получены после повторного парсинга данных).</p><p>Так как конкатенация двух узлов разной высоты имеет временную сложность O(log N), и все узлы, полученные после повторного парсинга данных в списке, являются смежными и отличаются высотой списка 0, временная сложность всей операции по обновлению дерева составляет, самое большее, O(N+ E), учитывая то, что поиск узла, подходящего для повторного использования, может быть выполнен достаточно быстро.</p><h3>Как эффективно находить узлы, подходящие для повторного использования?</h3><p>Для решения этой задачи используются два механизма: средство сопоставления новых позиций элементов с позициями элементов до правки (класс <a href="https://github.com/microsoft/vscode/blob/f8e9f87b6554b527c61ba963d0c96c7687cbaae9/src/vs/editor/common/model/bracketPairColorizer/beforeEditPositionMapper.ts#L17">BeforeEditPositionMapper</a>) и средство считывания данных узлов (класс <a href="https://github.com/microsoft/vscode/blob/f8e9f87b6554b527c61ba963d0c96c7687cbaae9/src/vs/editor/common/model/bracketPairColorizer/nodeReader.ts#L13">NodeReader</a>).</p><p>Класс <code>BeforeEditPositionMapper</code> осуществляет, если это возможно, сопоставление позиции в новом документе (после выполнения правки) со старым документом (до выполнения правки). Он, кроме того, сообщает нам о расстоянии между текущей позицией и следующей правкой (или 0, если мы находимся в том месте, где выполняется правка). Делается это за время O(1).</p><p>При обработке операции правки текста и при парсинге узла этот компонент даёт нам позицию узла, который мы, возможно, сможем переиспользовать, а так же сообщает о максимальной длине, которую может иметь этот узел. Очевидно то, что узел, который мы хотим переиспользовать, должен быть меньше расстояния до следующей правки.</p><p>Класс <code>NodeReader</code> способен быстро находить самый длинный узел, удовлетворяющий заданному предикату и находящийся на заданной позиции в AST. Для того чтобы найти узел, который можно использовать повторно, мы используем <code>BeforeEditPositionMapper</code> для того, чтобы узнать его старую позицию и его максимальную разрешённую длину, а затем используем <code>NodeReader</code> для того, чтобы найти этот узел. Если мы такой узел нашли — мы знаем о том, что он не изменялся, и что мы можем его переиспользовать, не обращая внимания на его длину.</p><p>Так как запросы к <code>NodeReader</code> выполняются с передачей ему монотонно возрастающих сведений об интересующей нас позиции, ему не нужно каждый раз начинать поиск узлов с самого начала. Он может продолжить поиск с того места, где был найден последний переиспользованный узел. Самое главное тут — это алгоритм обхода дерева, в котором не используется рекурсия, который способен заходить в узлы, но может их пропускать или возвращаться к родительским узлам. Когда удаётся обнаружить узел, подходящий для повторного использования, обход дерева прекращается и продолжается лишь после следующего запроса к <code>NodeReader</code>.</p><p>Сложность однократного выполнения запроса к <code>NodeReader</code> выглядит как O(N), но мы более чем уверены, что амортизированная сложность, характеризующая все запросы, выполненные в ходе одной операции обновления дерева, тоже соответствует O(N). В конце концов, к классу <code>NodeReader</code> обращаются за сведениями о позициях, на которые не повлияли правки текста, и выполнение этих операций всегда производится с как можно меньшими затратами времени, когда система идёт от одного узла, подходящего для повторного использования, к другому такому узлу. В результате мы думаем, что класс <code>NodeReader</code> достаточно эффективен и не оказывает негативного влияния на вычислительную сложность алгоритма обновления дерева.</p><h3>Обновление токенов</h3><p>Когда в начало документов, содержащих код на C-подобном языке, вставляют конструкцию <code>/</code><em>, и при этом в тексте, идущем после неё, нет </em><code>/</code>, весь документ превращается в один большой комментарий, что приводит к изменению всех токенов.</p><p>Так как токенизация текста производится в том же процессе, что и рендеринг, в синхронном режиме, повторную токенизацию нельзя произвести за один проход, не «подвесив» при этом интерфейс редактора.</p><p>Поэтому сведения о токенах обновляются фрагментарно, в течение некоторого времени, в результате цикл событий JavaScript не блокируется на слишком длительные промежутки времени. Хотя этот подход и не позволяет уменьшить общее время блокировки главного потока, он улучшает отзывчивость интерфейса во время процесса обновления сведений о токенах. Тот же механизм используется и при первоначальной токенизации документа.</p><p>К счастью, благодаря инкрементальному механизму обновления сведений о парах скобок в AST, мы можем сразу же применить новые сведения о токенах, рассматривая новые группы токенов как операции правки текста. Эти токены заменяют данные о тех участках текста, которые подверглись повторной токенизации. После того как система получит все обновлённые токены, AST, содержащее сведения о парах скобок, гарантированно будет в том же состоянии, в котором оно пребывало бы в том случае, если было бы создано с нуля — даже если пользователь редактировал документ во время повторной токенизации текста.</p><p>При таком подходе не только токенизация оказывается достаточно производительной в том случае, если все токены в документы изменяются. Производительной оказывается и операция раскрашивания пар скобок.</p><p>Но, если документ содержит множество непарных скобок в комментариях, цвет скобок в конце документа может мерцать, так как парсер скобок постепенно узнаёт о том, что на определённые скобки внимания обращать не нужно.</p><p>Для того чтобы избежать мерцания пар скобок при открытии документа и при прокрутке его до самого конца, мы поддерживаем два AST, содержащих информацию о скобках, используя их до тех пор, пока процесс токенизации текста не будем завершён. Первое AST создаётся без учёта информации о токенах, оно не получает сведения об обновлениях токенов. Второе дерево изначально является клоном первого, но оно получает обновления токенов и всё сильнее и сильнее отличается от первого дерева по мере продвижения процесса токенизации и по мере применения сведений об обновлениях токенов. Изначально первое AST используется для выполнения запросов о скобках, а после полной токенизации документа его место занимает второе дерево.</p><p>Так как операция глубокого клонирования дерева почти так же ресурсозатратна, как и повторный парсинг документа, мы реализовали схему копирования при записи, что позволило нам выйти на временную сложность операции клонирования, соответствующую O(1).</p><h3>Кодирование длины</h3><p>Область просмотра документа в редакторе описывается в терминах номеров строк и столбцов. Ожидается, что и сведения о цветовом оформлении символов тоже будут выражены в виде диапазонов значений, основанных на номерах строк и столбцов.</p><p>Для того чтобы избежать преобразований между смещением и позициями, основанными на номерах строк и столбцов (что может быть сделано за время O(log N), мы и в AST используем сведения о позициях символов, основанные на номерах строк и столбцов.</p><p>Обратите внимание на то, что этот подход очень сильно отличается от подхода, предусматривающего применение структур данных, напрямую индексируемых номерами строк (как, например, в случае использования массива строк, описывающего содержимое документа). В частности, этот подход позволяет выполнять единообразные операции бинарного поиска и в применении к строкам целиком, и в применении к содержимому строк.</p><p>Сложить два значения длины несложно, но для выполнения этой операции нужно понять то, в каких именно условиях она выполняется. А именно, хотя сведения о номерах строк просто складывают, количество столбцов первого показателя длины включается в состав итогового показателя только в том случае, если второй показатель длины соответствует нулю строк.</p><p>Удивительно то, что большая часть кода не нуждается в знании о том, как именно представлены длины элементов. Это серьёзно усложняет лишь код <code>BeforeEditPositionMapper</code>, так как этому классу приходится учитывать тот факт, что в одну строку может быть внесено несколько правок.</p><p>Если говорить о деталях реализации, то мы кодируем подобные сведения о длине в виде единственного числа для того, чтобы ослабить нагрузку на память. JavaScript поддерживает целые числа вплоть до 253+1, поэтому мы можем использовать до 26 бит для хранения сведений о количестве строк и столбцов. Но v8, к сожалению, хранит числа, большие, чем 231, <a href="https://v8.dev/blog/react-cliff#smi-heapnumber-mutableheapnumber">в куче</a>, в результате этот трюк с кодированием данных оказался не таким эффективным, как мы того ожидали.</p><h3>Дальнейшие трудности: непарные скобки</h3><p>До сих пор мы исходили из предположения о том, что у каждой открывающей скобки имеется соответствующая ей закрывающая скобка. Но нам хотелось бы поддерживать и открывающие скобки без закрывающих, и закрывающие без открывающих. Красота рекурсивного нисходящего парсера заключается в том, что он позволяет использовать наборы привязок для улучшения работы системы при возникновении ошибок парсинга.</p><p>Рассмотрим следующий пример:</p><pre><code>( [1]
} [2]
) [3]</code></pre><p>Ясно, что <code>}</code> в позиции [2] не закрывает какую-либо пару скобок и представляется в виде закрывающей скобки для пока не открытой пары скобок. А вот скобки в позициях [1] и [3] формируют замечательную пару. Правда, если вставить в начале этого кода <code>{</code>, ситуация меняется:</p><pre><code>{ [0]
( [1]
} [2]
) [3]</code></pre><p>Теперь должны совпасть скобки [0] и [2], скобка [1] должна быть представлена как открывающая скобка без закрывающей, а скобка [3] — как закрывающая без открывающей.</p><p>В частности, в следующем примере скобка [1] должна быть представлена в виде незакрытой скобки, область действия этой скобки оканчивается на скобке [2]:</p><pre><code>{
    ( [1]
} [2]
{}</code></pre><p>В противном случае открытие круглой скобки будет способно повлиять на уровень вложенности следующих за ней пар скобок, никак с ней не связанных.</p><p>Для того чтобы поддерживать больше вариантов восстановления при возникновении ошибок, можно использовать наборы привязок для наблюдения за набором токенов, появление которых ожидается в некоей ситуации, с которым может продолжить работу сущность, пользующаяся услугами парсера.</p><p>В предыдущем примере, в позиции 1, набор привязок может выглядеть как { <code>}</code> }. В результате, при парсинге пары скобок в позиции [1], обнаруживается неожиданно появившаяся скобка в позиции [2]. Парсеру это не нравится, он возвращает то, что можно назвать «незакрытой парой скобок».</p><p>В первом примере набор привязок в позиции [2] выглядит как { <code>)</code> }, но тут появляется неожиданный символ <code>}</code>. Так как он не является частью набора привязок — он считается «неоткрытой парой скобок» </p><p>Это нужно учитывать при переиспользовании узлов: пару ( <code>}</code> ) нельзя использовать повторно в том случае, если перед ней окажется <code>{</code>. Мы используем наборы бит для кодирования наборов привязок и находим для каждого узла набор содержащихся в нём непарных закрывающих скобок. Если узлы пересекаются — мы не можем повторно использовать такой узел. Но, к счастью, существует совсем немного типов скобок, поэтому это не слишком воздействует на производительность.</p><h3>Что дальше?</h3><p>Создание эффективной системы раскраски пар скобок было увлекательной задачей. С применением новых структур данных мы смогли лучше решить некоторые задачи, имеющие отношение к работе со скобками. Например — общую <a href="https://code.visualstudio.com/docs/editor/editingevolved#_bracket-matching">задачу</a> сопоставления парных скобок или <a href="https://github.com/microsoft/vscode/issues/131001">задачу</a> цветового выделения области, соответствующей открывающей и закрывающей скобкам.</p><p>Даже несмотря на то, что JavaScript — это, возможно, не самый лучший язык для написания высокопроизводительного кода, различные задачи можно значительно ускорить, если снизить асимптотическую сложность алгоритмов, особенно — если речь идёт о работе с большими объёмами входных данных.</p><details class="spoiler"><summary>О, а приходите к нам работать? 😏</summary><div class="spoiler__content"><p>Мы в <a href="http://wunderfund.io/"><strong>wunderfund.io</strong></a> занимаемся <a href="https://en.wikipedia.org/wiki/High-frequency_trading">высокочастотной алготорговлей</a> с 2014 года. Высокочастотная торговля — это непрерывное соревнование лучших программистов и математиков всего мира. Присоединившись к нам, вы станете частью этой увлекательной схватки.</p><p>Мы предлагаем интересные и сложные задачи по анализу данных и low latency разработке для увлеченных исследователей и программистов. Гибкий график и никакой бюрократии, решения быстро принимаются и воплощаются в жизнь.</p><p>Сейчас мы ищем плюсовиков, питонистов, дата-инженеров и мл-рисерчеров.<br/><a href="http://wunderfund.io/#join_us">Присоединяйтесь к нашей команде.</a></p></div></details></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BVS%20Code%5D" class="tm-tags-list__link">VS Code</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%5D" class="tm-tags-list__link">разработка</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bvscode%5D" class="tm-tags-list__link">vscode</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%5D" class="tm-tags-list__link">алгоритмы</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bwunder%20fund%5D" class="tm-tags-list__link">wunder fund</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/wunderfund/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании Wunder Fund
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/algorithms/" class="tm-hubs-list__link">
    Алгоритмы
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/vs/" class="tm-hubs-list__link">
    Visual Studio
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 43: ↑43 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 43: ↑43 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+43</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">19K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    63
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/wunderfund/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/b1a/8c4/544/b1a8c4544d951f4ea9bad437589d958e.png" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/wunderfund/profile/" class="tm-company-snippet__title">Wunder Fund</a> <div class="tm-company-snippet__description">Мы занимаемся высокочастотной торговлей на бирже</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <div class="tm-article-author__company-contacts"><a href="http://wunderfund.io" rel="noopener" target="_blank" class="tm-article-author__contact">
      Сайт
    </a></div> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/mr-pickles/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/a90/a35/fb7/a90a35fb73f6e7f05770af0978f90b11.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 19 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    17
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">38.8</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/mr-pickles/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @mr-pickles
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/wunderfund/blog/582004/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 15 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2013-12-31T20:00:00.000Z" title="2014-01-01, 00:00">1  января  2014</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://wunderfund.io" target="_blank" class="tm-company-basic-info__link">
      wunderfund.io
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    11–30 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2015-11-22T01:25:19.000Z" title="2015-11-22, 04:25">22  ноября  2015</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Представитель</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="/ru/users/xopxe/" class="tm-company-basic-info__link">
      xopxe
    </a></dd></dl></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/wunderfund/blog/582004/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/wunderfund/blog/582004/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"582004":{"id":"582004","timePublished":"2021-10-18T12:45:49+00:00","isCorporative":true,"lang":"ru","titleHtml":"Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз","leadData":{"textHtml":"\u003Cp\u003E\u003Cem\u003EПрим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь&nbsp;\u003C\u002Fem\u003Eзначительного\u003Cem\u003Eускорения этого процесса. Нам самим очень нравится решать подобные задачи при работе над торговой системой, а если они вам тоже интересны, то пишите:)\u003Cbr\u003E\u003C\u002Fem\u003E\u003Cbr\u003EКогда имеешь дело с глубоко вложенными скобками в Visual Studio Code — может быть непросто понять то, у каких скобок есть пары, а у каких — нет.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы упростить решение этой задачи, в 2006 году пользователь CoenraadS разработал восхитительное расширение для VS Code —&nbsp;\u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=CoenraadS.bracket-pair-colorizer\"\u003EBracket Pair Colorizer\u003C\u002Fa\u003E, позволяющее раскрашивать парные скобки, и опубликовал его в VS Code Marketplace. Это расширение стало весьма популярным, теперь оно, с более чем 6 миллионами установок, входит в 10 самых скачиваемых расширений.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы решить проблемы, касающиеся производительности и точности работы расширения, в 2018 году CoenraadS выпустил расширение&nbsp;\u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=CoenraadS.bracket-pair-colorizer-2\"\u003EBracket Pair Colorizer 2\u003C\u002Fa\u003E, которое тоже стало популярным и было установлено более 3 миллионов раз.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F927\u002Ff23\u002F4a0\u002F927f234a0f8e55af0bb86499a7dff515.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F927\u002Ff23\u002F4a0\u002F927f234a0f8e55af0bb86499a7dff515.png","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Henning Dieterichs","originalUrl":"https:\u002F\u002Fcode.visualstudio.com\u002Fblogs\u002F2021\u002F09\u002F29\u002Fbracket-pair-colorization"}}],"author":{"scoreStats":{"score":17,"votesCount":19},"rating":38.8,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1521341","alias":"mr-pickles","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fa90\u002Fa35\u002Ffb7\u002Fa90a35fb73f6e7f05770af0978f90b11.png","speciality":null},"statistics":{"commentsCount":15,"favoritesCount":63,"readingCount":19314,"score":43,"votesCount":43},"hubs":[{"relatedData":null,"id":"19715","alias":"wunderfund","type":"corporative","title":"Блог компании Wunder Fund","titleHtml":"Блог компании Wunder Fund","isProfiled":false},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"8000","alias":"algorithms","type":"collective","title":"Алгоритмы","titleHtml":"Алгоритмы","isProfiled":true},{"relatedData":null,"id":"11606","alias":"vs","type":"collective","title":"Visual Studio","titleHtml":"Visual Studio","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"440\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2d3\u002F88c\u002Fab8\u002F2d388cab8beec393b32a9e18596da2ca.png\" data-width=\"780\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Cem\u003EПрим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь \u003C\u002Fem\u003Eзначительного\u003Cem\u003E ускорения этого процесса. Нам самим очень нравится решать подобные задачи при работе над торговой системой, а если они вам тоже интересны, то пишите:)\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cp\u003EКогда имеешь дело с глубоко вложенными скобками в Visual Studio Code — может быть непросто понять то, у каких скобок есть пары, а у каких — нет.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы упростить решение этой задачи, в 2016 году пользователь CoenraadS разработал восхитительное расширение для VS Code — \u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=CoenraadS.bracket-pair-colorizer\"\u003EBracket Pair Colorizer\u003C\u002Fa\u003E, позволяющее раскрашивать парные скобки, и опубликовал его в VS Code Marketplace. Это расширение стало весьма популярным, теперь оно, с более чем 6 миллионами установок, входит в 10 самых скачиваемых расширений.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы решить проблемы, касающиеся производительности и точности работы расширения, в 2018 году CoenraadS выпустил расширение \u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=CoenraadS.bracket-pair-colorizer-2\"\u003EBracket Pair Colorizer 2\u003C\u002Fa\u003E, которое тоже стало популярным и было установлено более 3 миллионов раз.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EBracket Pair Colorizer — это хороший пример возможностей расширяемости VS Code. Оно интенсивно использует для раскрашивания скобок \u003Ca href=\"https:\u002F\u002Fcode.visualstudio.com\u002Fapi\u002Freferences\u002Fvscode-api#TextEditor.setDecorations\"\u003EDecoration API\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"536\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F45e\u002F187\u002F723\u002F45e1877237c70a7ea445eff078458f76.png\" data-width=\"1927\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EМы рады тому, что в VS Code Marketplace имеются и многие другие подобные расширения, написанные пользователями редактора. Каждое из них весьма креативно подходит к решению задачи идентификации парных скобок. Среди них — следующие: \u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=2gua.rainbow-brackets\"\u003ERainbow Brackets\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=rafamel.subtle-brackets\"\u003ESubtle Match Brackets\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=Durzn.brackethighlighter\"\u003EBracket Highlighter\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=leodevbro.blockman\"\u003EBlockman\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=wraith13.bracket-lens\"\u003EBracket Lens\u003C\u002Fa\u003E. Такое разнообразие расширений указывает на то, что у пользователей VS Code имеется реальное стремление к тому, чтобы редактор лучше поддерживал бы механизмы раскрашивания парных скобок.\u003C\u002Fp\u003E\u003Ch3\u003EПроблема производительности\u003C\u002Fh3\u003E\u003Cp\u003EК несчастью, то, что природа Decoration API неинкрементальна, и то, что мы не даём расширениям доступ к информации о токенах VS Code, приводит к тому, что расширение Bracket Pair Colorizer медленно обрабатывает большие файлы. При вставке одной скобки в начале файла \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002FTypeScript\u002Fblob\u002F8362a0f929d74ff46828016ec67c05744a8dbb3c\u002Fsrc\u002Fcompiler\u002Fchecker.ts\"\u003Echecker.ts\u003C\u002Fa\u003E, содержащего более 42000 строк кода, входящего в состав TypeScript-проекта, на обновление цветов всех пар скобок уходит около 10 секунд. В течение этих 10 секунд хост-процесс расширения нагружает процессор на 100%, и все возможности редактора, обеспечиваемые расширениями, вроде автозавершения или диагностики, перестают функционировать. Хорошо, правда, то, что \u003Ca href=\"https:\u002F\u002Fcode.visualstudio.com\u002Fapi\u002Fadvanced-topics\u002Fextension-host#stability-and-performance\"\u003Eархитектура VS Code\u003C\u002Fa\u003E обеспечивает работоспособность и отзывчивость интерфейса, и то, что документ при этом можно сохранить на диск.\u003C\u002Fp\u003E\u003Cp\u003ECoenraadS знал об этой проблеме с производительностью и приложил значительные усилия к повышению скорости и точности работы второй версии расширения. Он переиспользовал токены и движок парсинга скобок из VS Code. Но API VS Code и архитектура расширений не рассчитаны на высокопроизводительную раскраску пар скобок в ситуации, когда речь идёт о сотнях тысяч пар скобок. В результате даже у расширения Bracket Pair Colorizer 2, уходит некоторое время на то, чтобы цвета скобок отразили бы новые уровни вложенности кода после вставки \u003Ccode\u003E{\u003C\u002Fcode\u003E в начало вышеупомянутого файла.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Обработка большого файла с помощью Bracket Pair Colorizer 2\" title=\"Обработка большого файла с помощью Bracket Pair Colorizer 2\" height=\"495\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2b5\u002F7a3\u002Ff0d\u002F2b57a3f0d529607393eeecfc734a863a.gif\" data-width=\"907\"\u002F\u003E\u003Cfigcaption\u003EОбработка большого файла с помощью Bracket Pair Colorizer 2\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EХотя нас вполне устроило бы простое улучшение производительности расширения (что, конечно, потребовало бы создания более продвинутых API, оптимизированных для сценариев, создающих большую нагрузку на систему), асинхронная коммуникация между подсистемой рендеринга и хост-процессом расширения ограничивает то, как быстро может быть выполнена раскраска скобок в том случае, если соответствующий механизм реализован в виде расширения. Это ограничение обойти нельзя. В частности, цвета для пар скобок не должны запрашиваться в асинхронном режиме когда они появляются в области просмотра документа, так как это может привести к мерцанию при прокрутке больших файлов. Обсуждение этого вопроса можно найти \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002Fvscode\u002Fissues\u002F128465#issuecomment-879089188\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Ch3\u003EНаше решение задачи\u003C\u002Fh3\u003E\u003Cp\u003EМы пошли другим путём. А именно, в обновлении \u003Ca href=\"https:\u002F\u002Fcode.visualstudio.com\u002Fupdates\u002Fv1_60#_high-performance-bracket-pair-colorization\"\u003EVS Code 1.60\u003C\u002Fa\u003E, мы внедрили возможности рассматриваемого расширения в ядро VS Code и снизили время обработки вышеупомянутого документа до менее чем миллисекунды. В данном конкретном случае это означает ускорение раскрашивания скобок более чем в 10000 раз.\u003C\u002Fp\u003E\u003Cp\u003EСоответствующую возможность можно включить, добавив в редактор следующую настройку:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E\"editor.bracketPairColorization.enabled\": true.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТеперь перекрашивание скобок выполняется незаметно для пользователя — даже в файлах, содержащих сотни тысяч пар скобок. Обратите внимание на следующее анимированное изображение, где новый уровень вложенности отражается изменением цвета скобки в строке 42788 сразу же после вставки \u003Ccode\u003E{\u003C\u002Fcode\u003E в строку номер 2.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Быстрая обработка скобок в большом файле с использованием встроенных возможностей VS Code\" title=\"Быстрая обработка скобок в большом файле с использованием встроенных возможностей VS Code\" height=\"495\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F7b8\u002F228\u002F2b4\u002F7b82282b49dca54cb130d20d4e2dfdf9.gif\" data-width=\"907\"\u002F\u003E\u003Cfigcaption\u003EБыстрая обработка скобок в большом файле с использованием встроенных возможностей VS Code\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПосле того, как мы решили перевести обработку скобок на уровень ядра, мы, кроме того, пользуясь случаем, решили максимально ускорить эту операцию. Кто не любит алгоритмических задачек?\u003C\u002Fp\u003E\u003Cp\u003EМы, не ограниченные особенностями общедоступного API, могли использовать (2,3)-деревья, нерекурсивный обход деревьев, двоичную арифметику, инкрементальный парсинг и другие подходы. Целью всего этого было уменьшение \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTime_complexity\"\u003Eвременной сложности алгоритма\u003C\u002Fa\u003E обновления данных о скобках, которую он показывает в худшем случае (то есть — время, необходимое на обработку пользовательского ввода, когда документ уже был открыт). Мы хотели перейти от временной сложности алгоритма O(N+E) к временной сложности O(log 3 N+E), при условии, что N — это размер документа, а E — это размер редактируемой области, исходя из предположения о том, что уровень вложенности пар скобок ограничен O(log N).\u003C\u002Fp\u003E\u003Cp\u003EМы, кроме того, использовав в своих целях существующие токены из подсистемы рендеринга и её механизм инкрементного обновления токенов, достигли дополнительного серьёзного (но неизменного) ускорения.\u003C\u002Fp\u003E\u003Ch3\u003EПоддержка механизма раскрашивания скобок в Visual Studio Code for the Web\u003C\u002Fh3\u003E\u003Cp\u003EПомимо того, что новая реализация механизма раскрашивания скобок оказалась производительнее старых решений, она ещё и поддерживается в VS Code for the Web. Узнать подробнее об этом редакторе — о VS Code, работающем в браузере — можно \u003Ca href=\"https:\u002F\u002Fdocs.github.com\u002Fen\u002Fcodespaces\u002Fdeveloping-in-codespaces\u002Fweb-based-editor\"\u003Eздесь\u003C\u002Fa\u003E. Благодаря тому, что Bracket Pair Colorizer 2 использует в своих целях движок токенизации VS Code, невозможно было перевести это расширение в формат так называемого \u003Ca href=\"https:\u002F\u002Fcode.visualstudio.com\u002Fapi\u002Fextension-guides\u002Fweb-extensions\"\u003Eвеб-расширения\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EНо наша новая система раскрашивания скобок не только работает в VS Code for the Web. Она функционирует ещё и в \u003Ca href=\"https:\u002F\u002Fmicrosoft.github.io\u002Fmonaco-editor\u002F\"\u003EMonaco Editor\u003C\u002Fa\u003E!\u003C\u002Fp\u003E\u003Ch3\u003EСложная и интересная задача раскрашивания пар скобок\u003C\u002Fh3\u003E\u003Cp\u003EВ раскрашивании пар скобок самое главное — это быстрое нахождение всех скобок и их (абсолютного) уровня вложенности в области просмотра документа. Область просмотра документа можно описать как небольшую часть документа, представленную некоторым количеством строк и столбцов.\u003C\u002Fp\u003E\u003Cp\u003EК сожалению, уровень вложенности скобки зависит от всех предшествующих ей символов: замена любого символа на открывающую скобку, \u003Ccode\u003E{\u003C\u002Fcode\u003E, обычно увеличивает уровень вложенности всех следующих за ней скобок.\u003C\u002Fp\u003E\u003Cp\u003EВ результате при первоначальном раскрашивании скобок в самом конце документа, необходимо обработать абсолютно каждый символ во всём документе.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Слева — уровень отступа 1, а справа — 2\" title=\"Слева — уровень отступа 1, а справа — 2\" height=\"147\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcaf\u002Fb71\u002F0ba\u002Fcafb710ba7232a11bcdb299066cb62f4.png\" data-width=\"723\"\u002F\u003E\u003Cfigcaption\u003EСлева — уровень отступа 1, а справа — 2\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВ расширении Bracket Pair Colorizer эта задача решается путём повторной обработки всего документа, выполняемой каждый раз, когда в документ добавляют новую скобку, или когда из него удаляют одну из существующих скобок (это весьма разумно при обработке маленьких документов). После этого нужно убрать старые цвета скобок и окрасить их в новые, используя \u003Ca href=\"https:\u002F\u002Fcode.visualstudio.com\u002Fapi\u002Freferences\u002Fvscode-api#TextEditor.setDecorations\"\u003EDecoration API\u003C\u002Fa\u003E VS Code, который отправляет в подсистему рендеринга сведения о цветах символов.\u003C\u002Fp\u003E\u003Cp\u003EКак уже было показано, этот подход, при обработке больших документов, включающих в себя сотни тысяч пар скобок, которые нужно раскрасить, оказывается медленным. Так как расширение не может менять сведения об оформлении скобок инкрементно и должно предоставить системе новые сведения за один раз, подобное расширение просто не может работать заметно лучше. Но, всё равно, подсистема рендеринга весьма разумно (с использованием так называемого \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002Fvscode\u002Fblob\u002F534c529c292a96eb775c74dfcee2d733380ed629\u002Fsrc\u002Fvs\u002Feditor\u002Fcommon\u002Fmodel\u002FintervalTree.ts\"\u003Eдерева интервалов\u003C\u002Fa\u003E) организует полученные ей сведения об оформлении скобок. В результате рендеринг документа всегда выполняется быстро после того, как будут получены сведения об оформлении символов, возможно — сотен тысяч символов.\u003C\u002Fp\u003E\u003Cp\u003EНаша цель заключается в том, чтобы избавиться от необходимости переобработки всего документа после каждого нажатия на клавишу клавиатуры. Вместо этого время, необходимое для обработки одного эпизода правки текста должно расти, по мере роста длины документа, лишь (\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FPolylogarithmic_function\"\u003Eполи\u003C\u002Fa\u003E) логарифмически.\u003C\u002Fp\u003E\u003Cp\u003EНо при этом нам нужна и возможность выполнять запросы сведений обо всех скобках и об их уровнях вложенности в области просмотра документа за (поли) логарифмическое время, как это было бы при использовании Decoration API VS Code (этот API использует вышеупомянутое дерево интервалов).\u003C\u002Fp\u003E\u003Ch3\u003EАлгоритмическая сложность\u003C\u002Fh3\u003E\u003Cp\u003EЕсли вам это неинтересно — вы вполне можете пропустить этот раздел.\u003C\u002Fp\u003E\u003Cp\u003EНиже N — это длина документа. Если выразить нашу цель более формально, то окажется, что заключается она в том, чтобы выйти на временную сложность алгоритма, не превышающую O(log k N+R), используемого для запроса сведений обо всех скобках в заданном месте документа размера R и с достаточно маленьким k (наша цель — k=2). Сведения о скобках запрашиваются при рендеринге содержимого области просмотра документа, в результате запрос этих сведений должен быть по-настоящему быстрым.\u003C\u002Fp\u003E\u003Cp\u003EПравда, мы допускаем, что временная сложность инициализации документа, открываемого впервые, может быть равна O(N). Это неизбежно, так как при первоначальном раскрашивании скобок нужно обработать все символы документа. Далее, нас устраивает временная сложность обновления цветов скобок, соответствующая O(log j N+E), где E — это количество модифицированных или добавленных в документ символов. Опять же, нам нужно достаточно маленькое значение j (наша цель — j=3). Мы, кроме того, исходим из предположения, что уровень вложенности пар скобок не слишком велик, что он ограничен O(log N), и что количество закрывающих скобок без соответствующих им открывающих пренебрежимо мало. Документ, не соответствующий этим предположениям — это документ нетипичный, и алгоритм, который нам нужен, не обязан быстро обрабатывать подобные документы.\u003C\u002Fp\u003E\u003Ch3\u003EСемантика языка усложняет раскрашивание пар скобок\u003C\u002Fh3\u003E\u003Cp\u003EНашу задачу по-настоящему усложняет выявление настоящих скобок, являющихся скобками (а не, например, частями строк) в соответствии с правилами языка, используемого в документе. В частности, мы не хотели бы выявлять открывающие или закрывающие скобки в комментариях или в строках, как показано в следующем примере кода, написанного на C:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E{ \u002F* } *\u002F char str[] = \"}\"; }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут открывающую скобку закрывает лишь третье вхождение символа \u003Ccode\u003E}\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВсё становится ещё сложнее в языках, где токены языка не имеют регулярной структуры. Например — это TypeScript с JSX:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"TypeScript-код, в котором имеется функция, содержащая шаблонный литерал со встроенными выражениями. Шаблонный литерал, кроме того, содержит закрывающую скобку в позиции 2. Тело функции начинается со скобки в позиции 1, а заканчивается скобкой на позиции 3\" title=\"TypeScript-код, в котором имеется функция, содержащая шаблонный литерал со встроенными выражениями. Шаблонный литерал, кроме того, содержит закрывающую скобку в позиции 2. Тело функции начинается со скобки в позиции 1, а заканчивается скобкой на позиции 3\" height=\"203\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe78\u002F32c\u002F84a\u002Fe7832c84ad53d8d0967529864c97afbb.png\" data-width=\"828\"\u002F\u003E\u003Cfigcaption\u003ETypeScript-код, в котором имеется функция, содержащая шаблонный литерал со встроенными выражениями. Шаблонный литерал, кроме того, содержит закрывающую скобку в позиции 2. Тело функции начинается со скобки в позиции 1, а заканчивается скобкой на позиции 3\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСоответствует ли скобка [1] скобке [2] или скобке [3]? Это зависит от длины выражения шаблонного литерала, что может правильно определить лишь токенизатор с неограниченным состоянием (а это — нерегулярный токенизатор).\u003C\u002Fp\u003E\u003Ch3\u003EНаше спасение — в токенах\u003C\u002Fh3\u003E\u003Cp\u003EК счастью, при решении задачи подсветки синтаксических конструкций языка, приходится сталкиваться с теми же проблемами: нужно ли выводить скобку [2] в предыдущем примере как строку или как обычный текст программы?\u003C\u002Fp\u003E\u003Cp\u003EКак оказалось, простое игнорирование скобок в комментариях и строках, идентифицированных системой подсветки синтаксиса, хорошо подходит при обработке большинства пар скобок. До сих пор мы обнаружили лишь одну проблемную пару скобок, появляющуюся в конструкции вида \u003Ccode\u003E&lt; ... \u003E\u003C\u002Fcode\u003E. Дело в том, что обе такие скобки обычно используются в операциях сравнения и как часть определения обобщённых типов, но и в том и в другом случаях тип их токена оказывается одним и тем же.\u003C\u002Fp\u003E\u003Cp\u003EВ VS Code уже имеется эффективный и синхронный механизм для управления информацией о токенах, используемый для подсветки синтаксиса. Мы можем использовать этот механизм в своих целях для идентификации открывающих и закрывающих скобок.\u003C\u002Fp\u003E\u003Cp\u003EЭто — ещё одна сложная проблема, плохо влияющая на производительность, которая встала перед автором расширения Bracket Pair Colorization. У расширения нет доступа к этим токеном, оно должно находить их самостоятельно, выполняя работу, которая, в сущности, уже сделана. Мы \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002Fvscode\u002Fissues\u002F128465#issuecomment-879089188\"\u003Eдолго думали\u003C\u002Fa\u003E о том, как можно эффективно и надёжно предоставить информацию о токенах расширениям, но пришли к выводу, что не можем этого сделать, не допустив значительной утечки информации о деталях реализации ядра VS Code через API, предназначенный для расширений. Так как расширению, вне зависимости от того, как оно получает сведения о токенах, всё ещё нужно отправлять системе сведения о цвете каждой скобки в документе, только лишь появление нового API даже не позволит решить проблем с производительностью.\u003C\u002Fp\u003E\u003Cp\u003EПопутно можно отметить, что при внесении в самое начало документа изменения, влияющего на все следующие за ним токены (вроде — добавление в документ конструкции \u003Ccode\u003E\u002F*\u003C\u002Fcode\u003E для C-подобных язкыков), VS Code не проводит одномоментную повторную токенизацию всего докумета. Вместо этого документ обрабатывается по частям в течение некоторого времени. Это обеспечивает работоспособность интерфейса, отсутствие «тормозов», несмотря даже на то, что токенизация производится в подсистеме рендеринга в синхронном режиме.\u003C\u002Fp\u003E\u003Ch3\u003EБазовый алгоритм\u003C\u002Fh3\u003E\u003Cp\u003EНашей основной идеей было использование \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRecursive_descent_parser\"\u003Eрекурсивного нисходящего парсера\u003C\u002Fa\u003E для создания абстрактного синтаксического дерева (\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAbstract_syntax_tree\"\u003Eabstract syntax tree, AST\u003C\u002Fa\u003E), которое описывает структуру всех пар скобок. Когда обнаруживается скобка — проверяется информация о токене. Если скобка входит в состав комментария или обычной строки — она пропускается. Токенизатор позволяет парсеру получать сведения о подобных скобках или о текстовых токенах.\u003C\u002Fp\u003E\u003Cp\u003EСамое интересное тут в том, чтобы хранить сведения лишь о длине каждого узла (и, кроме того, чтобы имелись текстовые узлы для хранения всего того, что не является скобкой, чтобы перекрывать «пространства» между скобками), а не абсолютные данные о позиции начала и конца пары скобок. Если имеются лишь сведения о длине, узел, представляющий скобку, находящийся в определённой позиции, всё ещё можно эффективно найти в AST.\u003C\u002Fp\u003E\u003Cp\u003EНа следующей схеме показан пример AST с аннотациями, касающимися длины фрагментов.\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и относительную информацию о длине фрагментов\" title=\"Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и относительную информацию о длине фрагментов\" height=\"356\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F31f\u002Fd7c\u002F8d7\u002F31fd7c8d7554a746843c66935fb8a257.png\" data-width=\"486\"\u002F\u003E\u003Cfigcaption\u003EАбстрактное синтаксическое дерево, хранящее сведения о парах скобок и относительную информацию о длине фрагментов\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСравните это с классическим AST-представлением подобных данных, где используются абсолютные координаты начала и конца фрагментов.\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и абсолютные сведения о начале и конце фрагментов\" title=\"Абстрактное синтаксическое дерево, хранящее сведения о парах скобок и абсолютные сведения о начале и конце фрагментов\" height=\"366\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0f6\u002F419\u002F204\u002F0f6419204c4a2adcf67df0e61cabf68d.png\" data-width=\"483\"\u002F\u003E\u003Cfigcaption\u003EАбстрактное синтаксическое дерево, хранящее сведения о парах скобок и абсолютные сведения о начале и конце фрагментов\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EОба AST описывают один и тот же документ, но при обходе первого AST абсолютные позиции элементов нужно вычислять на ходу (для этого нужны весьма скромные вычислительные ресурсы), а во втором AST эти сведения хранятся в готовом виде.\u003C\u002Fp\u003E\u003Cp\u003EПравда, при вставке единственного символа в первое дерево нужно пересчитать лишь длину самого узла и его родительского узла. А все остальные сведения о длинах фрагментов не меняются.\u003C\u002Fp\u003E\u003Cp\u003EКогда в AST, как во втором случае, хранятся абсолютные позиции символов, получается, что в такой же ситуации нужно инкрементировать позицию каждого узла, находящегося в документе ниже добавленного символа.\u003C\u002Fp\u003E\u003Cp\u003EКроме того, отказавшись от хранения абсолютных смещений, можно наладить совместное использование листовых узлов, имеющих одинаковую длину, что позволит сэкономить память.\u003C\u002Fp\u003E\u003Cp\u003EВот как AST с аннотациями, касающимися длины фрагментов, можно описать средствами TypeScript:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Etype Length = ...;\n\ntype AST = BracketAST | BracketPairAST | ListAST | TextAST;\n\u002F** Описывает одну скобку, как, например, {, } или begin *\u002F\nclass BracketAST {\n    constructor(public length: Length) {}\n}\n\u002F** Описывает пару скобок, соответствующих друг другу, а так же узел, находящийся между ними. Например - {...} *\u002F\nclass BracketPairAST {\n    constructor(\n        public openingBracket: BracketAST;\n        public child: BracketPairAST | ListAST | TextAST;\n        public closingBracket: BracketAST;\n    ) {}\n    length = openingBracket.length + child.length + closingBracket.length;\n}\n\u002F** Описывает список пар скобок или текстовых узлов. Например - ()...() *\u002F\nclass ListAST {\n    constructor(\n        public items: Array&lt;BracketPairAST | TextAST\u003E\n    ) {}\n    length = items.sum(item =\u003E item.length);\n}\n\u002F** Описывает текст, в котором нет скобок. *\u002F\nclass TextAST {\n    constructor(public length: Length) {}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВыполнение запросов к такому дереву для получения списка всех скобок и уровня их вложенности выглядит сравнительно просто: выполняется обход в глубину, на ходу вычисляется абсолютная позиция текущего узла (путём сложения длин предыдущих узлов), пропускаются дочерние элементы узлов, которые полностью находятся до или после области документа, сведения о которой запрошены.\u003C\u002Fp\u003E\u003Cp\u003EЭтот базовый алгоритм уже является рабочим, однако с ним связано несколько открытых вопросов:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EКак убедиться в том, что запрос сведений обо всех скобках в нужном фрагменте документа отличается нужной нам логарифмической временной сложностью и соответствующим уровнем производительности?\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКак, при вводе текста, избежать создания нового AST с нуля?\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКак обрабатывать поступление сведений о группах токенов? Когда открывается большой документ, в нашем распоряжении изначально нет сведений о токенах. Они поступают постепенно, в виде отдельных блоков данных.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Ch3\u003EПроверка того, что временная сложность алгоритма является логарифмической\u003C\u002Fh3\u003E\u003Cp\u003EПри запросе информации о скобках в заданном диапазоне документа, производительность может очень сильно пострадать в том случае, если речь идёт о по-настоящему длинных списках скобок. Мы не можем выполнить быстрый бинарный поиск на их дочерних элементах для того, чтобы опустить все ненужные непересекающиеся узлы, так как нам нужно сложить длины всех узлов для вычисления абсолютной позиции на ходу. В худшем случае нужно обойти все узлы.\u003C\u002Fp\u003E\u003Cp\u003EВ следующем примере нужно просмотреть 13 узлов (выделены синим) до тех пор, пока мы не найдём скобку в позиции 24.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Длинный список узлов в абстрактном синтаксическом дереве\" title=\"Длинный список узлов в абстрактном синтаксическом дереве\" height=\"420\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F248\u002Fc3a\u002F6b3\u002F248c3a6b385feb591773359da9b0678f.png\" data-width=\"837\"\u002F\u003E\u003Cfigcaption\u003EДлинный список узлов в абстрактном синтаксическом дереве\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EХотя можно вычислить и кешировать суммы длин, что позволит использовать бинарный поиск, тут появляется та же проблема, которая характерна для деревьев, хранящих абсолютные позиции узлов: нужно пересчитывать все данные о позициях каждый раз, когда размер хотя бы одного узла растёт или уменьшается, что означает серьёзную вычислительную нагрузку при обработке больших списков.\u003C\u002Fp\u003E\u003Cp\u003EВместо этого мы сделали так, чтобы списки, в виде дочерних элементов, могли бы иметь другие списки:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Eclass ListAST {\n  constructor(public items: Array&lt;ListAST | BracketPairAST | TextAST\u003E) {}\n  length = items.sum(item =\u003E item.length);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКак это улучшает ситуацию?\u003C\u002Fp\u003E\u003Cp\u003EЕсли мы можем гарантировать то, что у каждого узла имеется лишь ограниченное число дочерних узлов, и то, что получившаяся структура напоминает сбалансированное дерево, высота которого логарифмически зависит от числа его узлов, оказывается, что этого достаточно для того, чтобы обеспечить логарифмическую временную сложность запроса информации о скобках.\u003C\u002Fp\u003E\u003Ch3\u003EПоддерживаем деревья списков в сбалансированном состоянии\u003C\u002Fh3\u003E\u003Cp\u003EДля того чтобы обеспечить сбалансированность списков, мы используем \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002F2%E2%80%933_tree\"\u003E(2,3)-деревья\u003C\u002Fa\u003E: у каждого узла должно быть минимум 2 и максимум 3 дочерних элемента. Все дочерние элементы списка должны иметь одинаковую высоту в сбалансированном дереве списков. Обратите внимание на то, что пары скобок рассматриваются в сбалансированном дереве как листовые узлы высоты 0, но в AST у них могут быть дочерние элементы.\u003C\u002Fp\u003E\u003Cp\u003EПри конструировании AST с нуля при инициализации системы мы, в первую очередь, собираем все сведения о дочерних элементах, а затем преобразуем эти сведения в сбалансированное дерево. Это можно сделать за линейное время.\u003C\u002Fp\u003E\u003Cp\u003EВозможный вариант (2,3)-дерева, соответствующего вышеприведённому примеру, выглядит так, как показано ниже. Обратите внимание на то, что теперь нам достаточно просмотреть лишь 8 узлов (выделены синим) для того чтобы обнаружить пару скобок в позиции 24, и на то, что при конструировании этого дерева можно пользоваться определённой свободой, так как у списка может быть 2 или 3 дочерних элемента.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Сбалансированное дерево, описывающее списки в AST\" title=\"Сбалансированное дерево, описывающее списки в AST\" height=\"502\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ffbb\u002F3c2\u002F379\u002Ffbb3c23799bbdcfc718f1a4bf4d22c1a.png\" data-width=\"833\"\u002F\u003E\u003Cfigcaption\u003EСбалансированное дерево, описывающее списки в AST\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Ch3\u003EАнализ временной сложности для наихудшего случая\u003C\u002Fh3\u003E\u003Cp\u003EЕсли вам это неинтересно — вы вполне можете пропустить этот раздел.\u003C\u002Fp\u003E\u003Cp\u003EСейчас мы исходим из предположения о том, что каждый список похож на (2,3)-дерево, и в результате может иметь до 3 дочерних элементов.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы максимизировать время выполнения запроса, мы поработаем с документом, в котором имеется O(log N) вложенных пар скобок.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E{\n    {\n        ... O(log N) вложенных пар скобок\n            {\n                {} [1]\n            }\n        ...\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТут пока нет списков, но нам надо обойти O(log N) узлов для того чтобы найти пару скобок в позиции [1]. К счастью, документы, отличающиеся ещё большим уровнем вложенности, встречаются очень редко, то есть — нам не нужно принимать их во внимание при анализе наихудшего случая.\u003C\u002Fp\u003E\u003Cp\u003EТеперь, если говорить об анализе наихудшей временной сложности нашего алгоритма, мы заполним документ данными до тех пор, пока его размер не окажется равным N, вставляя в него дополнительные пары скобок, в количестве O(Nlog N ), в каждую вложенную пару скобок:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E{}{}{}{}{}{}{}{}... O(N \u002F log N)\n{\n    {}{}{}{}{}{}{}{}... O(N \u002F log N)\n    {\n        ... O(log N) вложенных пар скобок\n            {\n                {}{}{}{}{}{}{}{}... O(N \u002F log N)\n                {} [1]\n            }\n        ...\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКаждый список скобок на одном и том же уровне вложенности приводит к появлению дерева высоты Olog Nlog N =Olog N — log log N  =O(log N ).\u003C\u002Fp\u003E\u003Cp\u003EВ результате — для того чтобы найти узел в позиции [1], нужно обойти O(log N) сбалансированных деревьев высоты O(log N). После того, как мы нашли узел и хотим собрать все скобки в диапазоне размера R, нам нужно прочитать сведения из, самое большее, O® смежных листовых узлов, соединённых, самое большее, O(N +R) внутренними узлами.\u003C\u002Fp\u003E\u003Cp\u003EПолучается, что наихудшая временная сложность операции запроса информации о скобках равна O(N +R).\u003C\u002Fp\u003E\u003Cp\u003EКроме того, это показывает, что максимальная высота AST равняется O(N).\u003C\u002Fp\u003E\u003Ch3\u003EИнкрементные обновления сведений о скобках\u003C\u002Fh3\u003E\u003Cp\u003EНо самый интересный вопрос, касающийся высокопроизводительной раскраски пар скобок, остаётся открытым: если имеется актуальное (сбалансированное) AST и выполнена правка текста, приводящая к замене некоего фрагмента документа, как эффективно обновить дерево для того, чтобы в нём отразились бы результаты этой правки текста?\u003C\u002Fp\u003E\u003Cp\u003EНаша идея заключается в том, чтобы переиспользовать рекурсивный нисходящий парсер, применяемый при инициализации системы, и добавить в систему некий механизм кеширования. Это позволит повторно использовать информацию об узлах, на которые правка данных не подействовала, а значит — не обрабатывать их при обновлении фрагмента дерева.\u003C\u002Fp\u003E\u003Cp\u003EКогда рекурсивный нисходящий парсер разбирает список пар скобок в позиции p, а правка затрагивает позицию e, он в первую очередь проверяет, есть ли в предыдущем AST узел с длиной, самое большее, e-p, находящийся там, где была позиция p до изменения текста. Если такой узел найти удаётся — то этот узел не надо подвергать повторному парсингу, а токенизатор, работающий на более глубоком уровне, может просто обработать фрагмент, соответствующий длине узла. После обработки узла парсинг продолжается. Обратите внимание на то, что этот узел может представлять собой и отдельную пару скобок, и целый список. Кроме того, если удаётся найти несколько подобных узлов, подходящих для повторного использования, нужно выбрать самый длинный из них.\u003C\u002Fp\u003E\u003Cp\u003EСледующий пример демонстрирует то, какие узлы можно использовать повторно (выделены зелёным), когда в документ вставляют единственную открывающую скобку (минуя узлы, соответствующие отдельным скобкам).\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Узлы AST, подходящие для повторного использования\" title=\"Узлы AST, подходящие для повторного использования\" height=\"841\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0a3\u002F7b1\u002F444\u002F0a37b14445b054279b8dae0903bbe19e.png\" data-width=\"860\"\u002F\u003E\u003Cfigcaption\u003EУзлы AST, подходящие для повторного использования\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПосле обработки операции вставки текста, выполняемой путём повторного парсинга узлов, содержащих изменённый текст и переиспользования всех неизменённых узлов, обновлённое AST выглядит так, как показано ниже. Обратите внимание на то, что 11 узлов, подходящих для повторного использования, могут быть переиспользованы путём обработки 3 узлов — B, H и G, а лишь четыре узла (выделенные оранжевым) нужно создать заново.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"Обновлённое AST\" title=\"Обновлённое AST\" height=\"658\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F89a\u002Fff3\u002F124\u002F89aff312484b7b0d997de5813d034a63.png\" data-width=\"916\"\u002F\u003E\u003Cfigcaption\u003EОбновлённое AST\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЭтот пример демонстрирует тот факт, что применение сбалансированных списков не только позволяет быстро запрашивать информацию о скобках, но и помогает повторно использовать сразу множество узлов.\u003C\u002Fp\u003E\u003Ch3\u003EАлгоритмическая сложность\u003C\u002Fh3\u003E\u003Cp\u003EЕсли вам это неинтересно — вы вполне можете пропустить этот раздел.\u003C\u002Fp\u003E\u003Cp\u003EДавайте представим себе, что в ходе редактирования текста заменяется фрагмент, размер которого не превышает E. При этом количество символов в новом тексте так же не превышает E. Мы, кроме того, пока игнорируем тут редкий случай, когда у закрывающих скобок нет парных открывающих скобок.\u003C\u002Fp\u003E\u003Cp\u003EНам нужно подвергнуть повторному парсингу лишь те узлы, которые пересекаются с зоной редактирования текста. В результате повторному парсингу надо подвергнуть, самое большее, O(N +E) узлов (тут применимы те же рассуждения, что и при разговоре о временной сложности выполнения запросов о скобках). А все остальные узлы могут быть переиспользованы.\u003C\u002Fp\u003E\u003Cp\u003EОчевидно то, что если узел не пересекается с диапазоном редактирования текста, тогда с ним не пересекаются и дочерние элементы этого узла. В результате нам нужно ориентироваться на переиспользование узлов, которые не пересекаются с диапазоном редактирования, но при этом их родительские узлы могут пересекаться с этим диапазоном (при таком подходе автоматически будут переиспользованы все узлы, в случае, когда с диапазоном редактирования не пересекаются ни они сами, ни их родительские узлы). Далее, подобные родительские узлы не могут быть полностью перекрыты диапазоном редактирования, в противном случае с ним пересекутся все их дочерние узлы. Но на каждом уровне AST присутствует, самое большее, два узла, частично пересекающихся с диапазоном редактирования. Так как в AST может быть, самое большее, O(N) уровней (что ограничено высотой AST), а у каждого узла может быть, самое большее, 3 дочерних элемента, количество всех узлов, подходящих для повторного использования, будет, в лучшем случае, равняться O(2 ∙3∙N)=O(N) .\u003C\u002Fp\u003E\u003Cp\u003EВ результате, чтобы сконструировать обновлённое дерево, нам надо произвести повторный парсинг, самое большее, O(N+ E) узлов, а повторно использовать можно будет O(N) узлов.\u003C\u002Fp\u003E\u003Cp\u003EЭто, кроме того, определяет и временную сложность операции обновления дерева, но тут есть один нюанс.\u003C\u002Fp\u003E\u003Ch3\u003EКак перебалансировать AST?\u003C\u002Fh3\u003E\u003Cp\u003EК сожалению, дерево, показанное в последнем примере, больше не является сбалансированным.\u003C\u002Fp\u003E\u003Cp\u003EПри комбинировании списка узлов, подходящих для повторного использования, с узлом, только что полученным от парсера, нужно приложить некоторые усилия для того, чтобы наше дерево оставалось бы (2,3)-деревом. Мы знаем о том, что переиспользованные узлы и новый узел уже являются (2,3)-деревьями, но они могут иметь различную высоту. В результате мы не можем просто создавать родительские узлы, так как все дочерние элементы узла (2,3)-дерева должны иметь одну и ту же высоту.\u003C\u002Fp\u003E\u003Cp\u003EКак эффективно объединить все эти узлы, имеющие разную высоту, в единое (2,3)-дерево?\u003C\u002Fp\u003E\u003Cp\u003EЭту задачу несложно свести к задаче добавления маленького дерева в начало или конец большого дерева. Если два дерева имеют одинаковую высоту, достаточно создать список, содержащий оба дочерних элемента. В противном случае мы вставляем маленькое дерево высоты h1 в более крупное дерево размера h2 и вполне можем нарушить устройство узлов, что произойдёт в том случае, если у них, в итоге, будет более 3 дочерних элементов (это похоже на то, как происходит операция вставки данных в (2,3)-деревья).\u003C\u002Fp\u003E\u003Cp\u003EТак как время выполнения такой операции соответствует O(h2- h1), мы берём 3 соседних узла (a, b и c), которые хотим вставить в дерево, и вставляем первым лишь один из них (это может привести к увеличению высоты дерева), что зависит от того, какая пара отличается наименьшей разницей высоты. Этот процесс повторяется до тех пор, пока все узлы не будут вставлены в дерево. Продолжая оптимизацию этого процесса, мы ищем последовательности узлов, которые имеют одну и ту же высоту, и создаём родительские списки для них за линейное время.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы сбалансировать списки и из предыдущего примера, мы выполняем операцию конкатенации над их дочерними элементами (списки, выделенные красным, нарушают правила построения (2,3)-деревьев, оранжевые узлы имеют высоту, отличающуюся от ожидаемой, а зелёные узлы пересоздаются в процессе перебалансировки дерева).\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"AST после балансировки списков\" title=\"AST после балансировки списков\" height=\"899\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F115\u002Fd88\u002F8fd\u002F115d888fd04eee96f5203d6cd16f2ca4.png\" data-width=\"712\"\u002F\u003E\u003Cfigcaption\u003EAST после балансировки списков\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EТак как в несбалансированном дереве список B имеет высоту 2, а пара скобок — высоту 0, нам нужно присоединить к B, после чего обработка списка может считаться завершённой. Оставшееся (2,3)-дерево — это B, в результате оно становится новым корнем и заменяет список. Мы продолжаем работу с, его дочерний элемент и H имеют высоту, равную 0, а высота G равняется 1.\u003C\u002Fp\u003E\u003Cp\u003EМы, в первую очередь, объединяем и H и создаём новый родительский узел Y высоты 1 (так как и H имеют одинаковую высоту). Затем мы конкатенируем Y и G и создаём новый родительский список X (по той же причине). Затем X становится новым дочерним элементом родительской пары скобок, заменяя несбалансированный список.\u003C\u002Fp\u003E\u003Cp\u003EВ нашем примере операция балансировки помогла успешно уменьшить высоту самого верхнего списка с 3 до 2. Но общая высота AST выросла с 4 до 5, что плохо влияет на время выполнения запроса в наихудшем случае. Причиной этого является пара скобок, которая действует в роли листового узла в сбалансированном дереве списков, но, на самом деле, содержит ещё один список высоты 2.\u003C\u002Fp\u003E\u003Cp\u003EУчёт высоты внутреннего AST узла при балансировке родительского списка может улучшить показатели, характерные для наихудшего случая, но это выходит за пределы теории (2,3)-деревьев.\u003C\u002Fp\u003E\u003Ch3\u003EАлгоритмическая сложность\u003C\u002Fh3\u003E\u003Cp\u003EЕсли вам это неинтересно — вы вполне можете пропустить этот раздел.\u003C\u002Fp\u003E\u003Cp\u003EНам надо произвести объединение, самое большее, O(N) узлов с максимальной высотой списка O(log N) (те, что мы переиспользуем), с дополнительными узлами в количестве O(N+ E), с высотой списков 0 (те, которые получены после повторного парсинга данных).\u003C\u002Fp\u003E\u003Cp\u003EТак как конкатенация двух узлов разной высоты имеет временную сложность O(log N), и все узлы, полученные после повторного парсинга данных в списке, являются смежными и отличаются высотой списка 0, временная сложность всей операции по обновлению дерева составляет, самое большее, O(N+ E), учитывая то, что поиск узла, подходящего для повторного использования, может быть выполнен достаточно быстро.\u003C\u002Fp\u003E\u003Ch3\u003EКак эффективно находить узлы, подходящие для повторного использования?\u003C\u002Fh3\u003E\u003Cp\u003EДля решения этой задачи используются два механизма: средство сопоставления новых позиций элементов с позициями элементов до правки (класс \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002Fvscode\u002Fblob\u002Ff8e9f87b6554b527c61ba963d0c96c7687cbaae9\u002Fsrc\u002Fvs\u002Feditor\u002Fcommon\u002Fmodel\u002FbracketPairColorizer\u002FbeforeEditPositionMapper.ts#L17\"\u003EBeforeEditPositionMapper\u003C\u002Fa\u003E) и средство считывания данных узлов (класс \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002Fvscode\u002Fblob\u002Ff8e9f87b6554b527c61ba963d0c96c7687cbaae9\u002Fsrc\u002Fvs\u002Feditor\u002Fcommon\u002Fmodel\u002FbracketPairColorizer\u002FnodeReader.ts#L13\"\u003ENodeReader\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Cp\u003EКласс \u003Ccode\u003EBeforeEditPositionMapper\u003C\u002Fcode\u003E осуществляет, если это возможно, сопоставление позиции в новом документе (после выполнения правки) со старым документом (до выполнения правки). Он, кроме того, сообщает нам о расстоянии между текущей позицией и следующей правкой (или 0, если мы находимся в том месте, где выполняется правка). Делается это за время O(1).\u003C\u002Fp\u003E\u003Cp\u003EПри обработке операции правки текста и при парсинге узла этот компонент даёт нам позицию узла, который мы, возможно, сможем переиспользовать, а так же сообщает о максимальной длине, которую может иметь этот узел. Очевидно то, что узел, который мы хотим переиспользовать, должен быть меньше расстояния до следующей правки.\u003C\u002Fp\u003E\u003Cp\u003EКласс \u003Ccode\u003ENodeReader\u003C\u002Fcode\u003E способен быстро находить самый длинный узел, удовлетворяющий заданному предикату и находящийся на заданной позиции в AST. Для того чтобы найти узел, который можно использовать повторно, мы используем \u003Ccode\u003EBeforeEditPositionMapper\u003C\u002Fcode\u003E для того, чтобы узнать его старую позицию и его максимальную разрешённую длину, а затем используем \u003Ccode\u003ENodeReader\u003C\u002Fcode\u003E для того, чтобы найти этот узел. Если мы такой узел нашли — мы знаем о том, что он не изменялся, и что мы можем его переиспользовать, не обращая внимания на его длину.\u003C\u002Fp\u003E\u003Cp\u003EТак как запросы к \u003Ccode\u003ENodeReader\u003C\u002Fcode\u003E выполняются с передачей ему монотонно возрастающих сведений об интересующей нас позиции, ему не нужно каждый раз начинать поиск узлов с самого начала. Он может продолжить поиск с того места, где был найден последний переиспользованный узел. Самое главное тут — это алгоритм обхода дерева, в котором не используется рекурсия, который способен заходить в узлы, но может их пропускать или возвращаться к родительским узлам. Когда удаётся обнаружить узел, подходящий для повторного использования, обход дерева прекращается и продолжается лишь после следующего запроса к \u003Ccode\u003ENodeReader\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EСложность однократного выполнения запроса к \u003Ccode\u003ENodeReader\u003C\u002Fcode\u003E выглядит как O(N), но мы более чем уверены, что амортизированная сложность, характеризующая все запросы, выполненные в ходе одной операции обновления дерева, тоже соответствует O(N). В конце концов, к классу \u003Ccode\u003ENodeReader\u003C\u002Fcode\u003E обращаются за сведениями о позициях, на которые не повлияли правки текста, и выполнение этих операций всегда производится с как можно меньшими затратами времени, когда система идёт от одного узла, подходящего для повторного использования, к другому такому узлу. В результате мы думаем, что класс \u003Ccode\u003ENodeReader\u003C\u002Fcode\u003E достаточно эффективен и не оказывает негативного влияния на вычислительную сложность алгоритма обновления дерева.\u003C\u002Fp\u003E\u003Ch3\u003EОбновление токенов\u003C\u002Fh3\u003E\u003Cp\u003EКогда в начало документов, содержащих код на C-подобном языке, вставляют конструкцию \u003Ccode\u003E\u002F\u003C\u002Fcode\u003E\u003Cem\u003E, и при этом в тексте, идущем после неё, нет \u003C\u002Fem\u003E\u003Ccode\u003E\u002F\u003C\u002Fcode\u003E, весь документ превращается в один большой комментарий, что приводит к изменению всех токенов.\u003C\u002Fp\u003E\u003Cp\u003EТак как токенизация текста производится в том же процессе, что и рендеринг, в синхронном режиме, повторную токенизацию нельзя произвести за один проход, не «подвесив» при этом интерфейс редактора.\u003C\u002Fp\u003E\u003Cp\u003EПоэтому сведения о токенах обновляются фрагментарно, в течение некоторого времени, в результате цикл событий JavaScript не блокируется на слишком длительные промежутки времени. Хотя этот подход и не позволяет уменьшить общее время блокировки главного потока, он улучшает отзывчивость интерфейса во время процесса обновления сведений о токенах. Тот же механизм используется и при первоначальной токенизации документа.\u003C\u002Fp\u003E\u003Cp\u003EК счастью, благодаря инкрементальному механизму обновления сведений о парах скобок в AST, мы можем сразу же применить новые сведения о токенах, рассматривая новые группы токенов как операции правки текста. Эти токены заменяют данные о тех участках текста, которые подверглись повторной токенизации. После того как система получит все обновлённые токены, AST, содержащее сведения о парах скобок, гарантированно будет в том же состоянии, в котором оно пребывало бы в том случае, если было бы создано с нуля — даже если пользователь редактировал документ во время повторной токенизации текста.\u003C\u002Fp\u003E\u003Cp\u003EПри таком подходе не только токенизация оказывается достаточно производительной в том случае, если все токены в документы изменяются. Производительной оказывается и операция раскрашивания пар скобок.\u003C\u002Fp\u003E\u003Cp\u003EНо, если документ содержит множество непарных скобок в комментариях, цвет скобок в конце документа может мерцать, так как парсер скобок постепенно узнаёт о том, что на определённые скобки внимания обращать не нужно.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы избежать мерцания пар скобок при открытии документа и при прокрутке его до самого конца, мы поддерживаем два AST, содержащих информацию о скобках, используя их до тех пор, пока процесс токенизации текста не будем завершён. Первое AST создаётся без учёта информации о токенах, оно не получает сведения об обновлениях токенов. Второе дерево изначально является клоном первого, но оно получает обновления токенов и всё сильнее и сильнее отличается от первого дерева по мере продвижения процесса токенизации и по мере применения сведений об обновлениях токенов. Изначально первое AST используется для выполнения запросов о скобках, а после полной токенизации документа его место занимает второе дерево.\u003C\u002Fp\u003E\u003Cp\u003EТак как операция глубокого клонирования дерева почти так же ресурсозатратна, как и повторный парсинг документа, мы реализовали схему копирования при записи, что позволило нам выйти на временную сложность операции клонирования, соответствующую O(1).\u003C\u002Fp\u003E\u003Ch3\u003EКодирование длины\u003C\u002Fh3\u003E\u003Cp\u003EОбласть просмотра документа в редакторе описывается в терминах номеров строк и столбцов. Ожидается, что и сведения о цветовом оформлении символов тоже будут выражены в виде диапазонов значений, основанных на номерах строк и столбцов.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы избежать преобразований между смещением и позициями, основанными на номерах строк и столбцов (что может быть сделано за время O(log N), мы и в AST используем сведения о позициях символов, основанные на номерах строк и столбцов.\u003C\u002Fp\u003E\u003Cp\u003EОбратите внимание на то, что этот подход очень сильно отличается от подхода, предусматривающего применение структур данных, напрямую индексируемых номерами строк (как, например, в случае использования массива строк, описывающего содержимое документа). В частности, этот подход позволяет выполнять единообразные операции бинарного поиска и в применении к строкам целиком, и в применении к содержимому строк.\u003C\u002Fp\u003E\u003Cp\u003EСложить два значения длины несложно, но для выполнения этой операции нужно понять то, в каких именно условиях она выполняется. А именно, хотя сведения о номерах строк просто складывают, количество столбцов первого показателя длины включается в состав итогового показателя только в том случае, если второй показатель длины соответствует нулю строк.\u003C\u002Fp\u003E\u003Cp\u003EУдивительно то, что большая часть кода не нуждается в знании о том, как именно представлены длины элементов. Это серьёзно усложняет лишь код \u003Ccode\u003EBeforeEditPositionMapper\u003C\u002Fcode\u003E, так как этому классу приходится учитывать тот факт, что в одну строку может быть внесено несколько правок.\u003C\u002Fp\u003E\u003Cp\u003EЕсли говорить о деталях реализации, то мы кодируем подобные сведения о длине в виде единственного числа для того, чтобы ослабить нагрузку на память. JavaScript поддерживает целые числа вплоть до 253+1, поэтому мы можем использовать до 26 бит для хранения сведений о количестве строк и столбцов. Но v8, к сожалению, хранит числа, большие, чем 231, \u003Ca href=\"https:\u002F\u002Fv8.dev\u002Fblog\u002Freact-cliff#smi-heapnumber-mutableheapnumber\"\u003Eв куче\u003C\u002Fa\u003E, в результате этот трюк с кодированием данных оказался не таким эффективным, как мы того ожидали.\u003C\u002Fp\u003E\u003Ch3\u003EДальнейшие трудности: непарные скобки\u003C\u002Fh3\u003E\u003Cp\u003EДо сих пор мы исходили из предположения о том, что у каждой открывающей скобки имеется соответствующая ей закрывающая скобка. Но нам хотелось бы поддерживать и открывающие скобки без закрывающих, и закрывающие без открывающих. Красота рекурсивного нисходящего парсера заключается в том, что он позволяет использовать наборы привязок для улучшения работы системы при возникновении ошибок парсинга.\u003C\u002Fp\u003E\u003Cp\u003EРассмотрим следующий пример:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E( [1]\n} [2]\n) [3]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЯсно, что \u003Ccode\u003E}\u003C\u002Fcode\u003E в позиции [2] не закрывает какую-либо пару скобок и представляется в виде закрывающей скобки для пока не открытой пары скобок. А вот скобки в позициях [1] и [3] формируют замечательную пару. Правда, если вставить в начале этого кода \u003Ccode\u003E{\u003C\u002Fcode\u003E, ситуация меняется:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E{ [0]\n( [1]\n} [2]\n) [3]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТеперь должны совпасть скобки [0] и [2], скобка [1] должна быть представлена как открывающая скобка без закрывающей, а скобка [3] — как закрывающая без открывающей.\u003C\u002Fp\u003E\u003Cp\u003EВ частности, в следующем примере скобка [1] должна быть представлена в виде незакрытой скобки, область действия этой скобки оканчивается на скобке [2]:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode\u003E{\n    ( [1]\n} [2]\n{}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ противном случае открытие круглой скобки будет способно повлиять на уровень вложенности следующих за ней пар скобок, никак с ней не связанных.\u003C\u002Fp\u003E\u003Cp\u003EДля того чтобы поддерживать больше вариантов восстановления при возникновении ошибок, можно использовать наборы привязок для наблюдения за набором токенов, появление которых ожидается в некоей ситуации, с которым может продолжить работу сущность, пользующаяся услугами парсера.\u003C\u002Fp\u003E\u003Cp\u003EВ предыдущем примере, в позиции 1, набор привязок может выглядеть как { \u003Ccode\u003E}\u003C\u002Fcode\u003E }. В результате, при парсинге пары скобок в позиции [1], обнаруживается неожиданно появившаяся скобка в позиции [2]. Парсеру это не нравится, он возвращает то, что можно назвать «незакрытой парой скобок».\u003C\u002Fp\u003E\u003Cp\u003EВ первом примере набор привязок в позиции [2] выглядит как { \u003Ccode\u003E)\u003C\u002Fcode\u003E }, но тут появляется неожиданный символ \u003Ccode\u003E}\u003C\u002Fcode\u003E. Так как он не является частью набора привязок — он считается «неоткрытой парой скобок» \u003C\u002Fp\u003E\u003Cp\u003EЭто нужно учитывать при переиспользовании узлов: пару ( \u003Ccode\u003E}\u003C\u002Fcode\u003E ) нельзя использовать повторно в том случае, если перед ней окажется \u003Ccode\u003E{\u003C\u002Fcode\u003E. Мы используем наборы бит для кодирования наборов привязок и находим для каждого узла набор содержащихся в нём непарных закрывающих скобок. Если узлы пересекаются — мы не можем повторно использовать такой узел. Но, к счастью, существует совсем немного типов скобок, поэтому это не слишком воздействует на производительность.\u003C\u002Fp\u003E\u003Ch3\u003EЧто дальше?\u003C\u002Fh3\u003E\u003Cp\u003EСоздание эффективной системы раскраски пар скобок было увлекательной задачей. С применением новых структур данных мы смогли лучше решить некоторые задачи, имеющие отношение к работе со скобками. Например — общую \u003Ca href=\"https:\u002F\u002Fcode.visualstudio.com\u002Fdocs\u002Feditor\u002Feditingevolved#_bracket-matching\"\u003Eзадачу\u003C\u002Fa\u003E сопоставления парных скобок или \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002Fvscode\u002Fissues\u002F131001\"\u003Eзадачу\u003C\u002Fa\u003E цветового выделения области, соответствующей открывающей и закрывающей скобкам.\u003C\u002Fp\u003E\u003Cp\u003EДаже несмотря на то, что JavaScript — это, возможно, не самый лучший язык для написания высокопроизводительного кода, различные задачи можно значительно ускорить, если снизить асимптотическую сложность алгоритмов, особенно — если речь идёт о работе с большими объёмами входных данных.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EО, а приходите к нам работать? 😏\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cp\u003EМы в \u003Ca href=\"http:\u002F\u002Fwunderfund.io\u002F\"\u003E\u003Cstrong\u003Ewunderfund.io\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E занимаемся \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FHigh-frequency_trading\"\u003Eвысокочастотной алготорговлей\u003C\u002Fa\u003E с 2014 года. Высокочастотная торговля — это непрерывное соревнование лучших программистов и математиков всего мира. Присоединившись к нам, вы станете частью этой увлекательной схватки.\u003C\u002Fp\u003E\u003Cp\u003EМы предлагаем интересные и сложные задачи по анализу данных и low latency разработке для увлеченных исследователей и программистов. Гибкий график и никакой бюрократии, решения быстро принимаются и воплощаются в жизнь.\u003C\u002Fp\u003E\u003Cp\u003EСейчас мы ищем плюсовиков, питонистов, дата-инженеров и мл-рисерчеров.\u003Cbr\u002F\u003E\u003Ca href=\"http:\u002F\u002Fwunderfund.io\u002F#join_us\"\u003EПрисоединяйтесь к нашей команде.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"VS Code"},{"titleHtml":"разработка"},{"titleHtml":"vscode"},{"titleHtml":"алгоритмы"},{"titleHtml":"wunder fund"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F927\u002Ff23\u002F4a0\u002F927f234a0f8e55af0bb86499a7dff515.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F927\u002Ff23\u002F4a0\u002F927f234a0f8e55af0bb86499a7dff515.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fwunderfund\\\u002Fblog\\\u002F582004\\\u002F\"},\"headline\":\"Увлекательная история о раскрашивании парных скобок — как VSCode ускорил раскраску в 10,000 раз\",\"datePublished\":\"2021-10-18T15:45:49+03:00\",\"dateModified\":\"2021-10-18T19:02:58+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"mr-pickles\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось дости...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fwunderfund\\\u002Fblog\\\u002F582004\\\u002F#post-content-body\",\"about\":[\"c_wunderfund\",\"h_programming\",\"h_algorithms\",\"h_vs\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F582004\\\u002Fd169d40b6929b6405567408d49bfcf4f\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2d3\\\u002F88c\\\u002Fab8\\\u002F2d388cab8beec393b32a9e18596da2ca.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F45e\\\u002F187\\\u002F723\\\u002F45e1877237c70a7ea445eff078458f76.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2b5\\\u002F7a3\\\u002Ff0d\\\u002F2b57a3f0d529607393eeecfc734a863a.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F7b8\\\u002F228\\\u002F2b4\\\u002F7b82282b49dca54cb130d20d4e2dfdf9.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fcaf\\\u002Fb71\\\u002F0ba\\\u002Fcafb710ba7232a11bcdb299066cb62f4.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fe78\\\u002F32c\\\u002F84a\\\u002Fe7832c84ad53d8d0967529864c97afbb.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F31f\\\u002Fd7c\\\u002F8d7\\\u002F31fd7c8d7554a746843c66935fb8a257.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F0f6\\\u002F419\\\u002F204\\\u002F0f6419204c4a2adcf67df0e61cabf68d.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F248\\\u002Fc3a\\\u002F6b3\\\u002F248c3a6b385feb591773359da9b0678f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ffbb\\\u002F3c2\\\u002F379\\\u002Ffbb3c23799bbdcfc718f1a4bf4d22c1a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F0a3\\\u002F7b1\\\u002F444\\\u002F0a37b14445b054279b8dae0903bbe19e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F89a\\\u002Fff3\\\u002F124\\\u002F89aff312484b7b0d997de5813d034a63.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F115\\\u002Fd88\\\u002F8fd\\\u002F115d888fd04eee96f5203d6cd16f2ca4.png\"]}","metaDescription":"Прим. Wunder Fund: в этой статье из блога VSCode рассказана увлекательная алгоритмическая история о решении проблемы раскрашивания скобок. Господам удалось достичь значительного ускорения этого...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"wunderfund":{"alias":"wunderfund","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002Fb1a\u002F8c4\u002F544\u002Fb1a8c4544d951f4ea9bad437589d958e.png","titleHtml":"Wunder Fund","descriptionHtml":"Мы занимаемся высокочастотной торговлей на бирже","relatedData":null,"statistics":{"postsCount":29,"newsCount":0,"vacanciesCount":1,"employeesCount":3,"careerRating":null,"subscribersCount":436,"rating":60.88,"invest":null},"foundationDate":{"year":"2014","month":"01","day":"01"},"location":{"city":{"id":"447159","title":"Москва"},"region":{"id":"1885","title":"Москва и Московская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"http:\u002F\u002Fwunderfund.io","staffNumber":"11–30 человек","registrationDate":"2015-11-22T01:25:19+00:00","representativeUser":{"alias":"xopxe","fullname":null},"contacts":[{"title":"Сайт","url":"http:\u002F\u002Fwunderfund.io"}],"settings":{"analyticsSettings":[{"type":"ym","trackingId":"85710558"}],"branding":null,"status":"active"},"metadata":{"titleHtml":"Wunder Fund, Москва - Мы занимаемся высокочастотной торговлей на бирже с 1 января 2014 г.","title":"Wunder Fund, Москва - Мы занимаемся высокочастотной торговлей на бирже с 1 января 2014 г.","keywords":["Программирование","Алгоритмы","Математика","Natural Language Processing","Python"],"descriptionHtml":"29 статей от авторов компании Wunder Fund","description":"29 статей от авторов компании Wunder Fund"},"aDeskSettings":null,"careerAlias":"wunderfund","maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
