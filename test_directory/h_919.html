<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Запросы в PostgreSQL: 7. Сортировка и слияние / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/postgrespro\/blog\/582058\/"},"headline":"Запросы в PostgreSQL: 7. Сортировка и слияние","datePublished":"2021-10-07T01:41:30+03:00","dateModified":"2021-10-07T01:41:30+03:00","author":{"@type":"Person","name":"Егор Рогов"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным &mdash; последовательное сканирование и индексное ск...","url":"https:\/\/habr.com\/ru\/company\/postgrespro\/blog\/582058\/#post-content-body","about":["c_postgrespro","h_postgresql","h_sql","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/582058\/0b1829179219b61587448963e71f506f\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/0f8\/421\/7b4\/0f84217b4b0c7674a33db9888f328ba2.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/817\/9b1\/891\/8179b1891ad33781a7ea1442714b199a.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/eea\/82b\/6a3\/eea82b6a37059b337828a06886ea3fe1.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b6e\/763\/864\/b6e763864deb5a482cd526afb0263000.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/97c\/2d5\/fcc\/97c2d5fccf4889595986d16c2c830f52.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Запросы в PostgreSQL: 7. Сортировка и слияние" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Запросы в PostgreSQL: 7. Сортировка и слияние" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Запросы в PostgreSQL: 7. Сортировка и слияние" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным — последовательное сканирование и индексное сканирование, — и успел рассказать о двух..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным — последовательное сканирование и индексное сканирование, — и успел рассказать о двух..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным — последовательное сканирование и индексное сканирование, — и успел рассказать о двух..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным — последовательное сканирование и индексное сканирование, — и успел рассказать о двух..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным — последовательное сканирование и индексное сканирование, — и успел рассказать о двух..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/78b/71b/5d3/78b71b5d35a0c717ab2bd664367ae88a.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/78b/71b/5d3/78b71b5d35a0c717ab2bd664367ae88a.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/78b/71b/5d3/78b71b5d35a0c717ab2bd664367ae88a.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/78b/71b/5d3/78b71b5d35a0c717ab2bd664367ae88a.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/78b/71b/5d3/78b71b5d35a0c717ab2bd664367ae88a.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="582058" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-06T22:41:30.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/582058/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/postgrespro/blog/582058/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/78b/71b/5d3/78b71b5d35a0c717ab2bd664367ae88a.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/582058/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="postgrespro" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/postgrespro/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/4e0/339/621/4e0339621abc865fefb88f9e9f44748f.jpg" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">214.73</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/postgrespro/profile/" class="tm-company-card__name">
        Postgres Professional
      </a> <div class="tm-company-card__description">Разработчик СУБД Postgres Pro</div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/erogov/" title="erogov" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/d16/573/7e4/d165737e421383f77f007015ebd01fb1.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/erogov/" class="tm-user-info__username">
      erogov
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-06T22:41:30.000Z" title="2021-10-07, 01:41">7  октября   в 01:41</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Запросы в PostgreSQL: 7. Сортировка и слияние</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/postgrespro/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании Postgres Professional</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/postgresql/" class="tm-article-snippet__hubs-item-link"><span>PostgreSQL</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/sql/" class="tm-article-snippet__hubs-item-link"><span>SQL</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>В предыдущих статьях я писал про <a href="https://habr.com/ru/company/postgrespro/blog/574702/">этапы выполнения запросов</a>, про <a href="https://habr.com/ru/company/postgrespro/blog/576100/">статистику</a>, про два основных вида доступа к данным — <a href="https://habr.com/ru/company/postgrespro/blog/576980/">последовательное сканирование</a> и <a href="https://habr.com/ru/company/postgrespro/blog/578196/">индексное сканирование</a>, — и успел рассказать о двух способах соединения — <a href="https://habr.com/ru/company/postgrespro/blog/579024/">вложенном цикле</a> и <a href="https://habr.com/ru/company/postgrespro/blog/581174/">соединении хешированием</a>.</p><p>В заключительной статье этой серии я расскажу про <em>алгоритм слияния</em> и про <em>сортировку</em>, и сравню все три способа соединения между собой.</p><h2>Соединение слиянием</h2><p>Соединение слиянием работает для наборов данных, отсортированных по ключу соединения, и возвращает отсортированный же результат. Входной набор может получиться заранее отсортированным в результате индексного сканирования или он может быть отсортирован явно. </p><h3>Слияние отсортированных наборов</h3><p>Вот пример соединения слиянием; оно представлено в плане выполнения узлом Merge Join: </p><pre><code class="pgsql">EXPLAIN (costs off) SELECT * 
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no 
ORDER BY t.ticket_no;</code></pre><pre><code class="diff">                           QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Merge Join
   Merge Cond: (t.ticket_no = tf.ticket_no)
   −> Index Scan using tickets_pkey on tickets t
   −> Index Scan using ticket_flights_pkey on ticket_flights tf
(4 rows)</code></pre><p>Здесь оптимизатор предпочел именно этот способ соединения, поскольку он возвращает результат именно в том порядке, который указан в предложении <code>ORDER BY</code>. Работая с планами, оптимизатор учитывает порядок сортировки наборов данных и не выполняет явную сортировку, если в ней нет необходимости. В частности, полученный набор можно использовать для следующего соединения слиянием, если порядок сортировки сохраняется: </p><pre><code class="pgsql">EXPLAIN (costs off) SELECT * 
FROM tickets t
  JOIN ticket_flights tf ON t.ticket_no = tf.ticket_no 
  JOIN boarding_passes bp ON bp.ticket_no = tf.ticket_no 
                         AND bp.flight_id = tf.flight_id
ORDER BY t.ticket_no;</code></pre><pre><code class="diff">                             QUERY PLAN
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Merge Join
   Merge Cond: (tf.ticket_no = t.ticket_no) 
   −> Merge Join
       Merge Cond: ((tf.ticket_no = bp.ticket_no) AND (tf.flight_... 
       −> Index Scan using ticket_flights_pkey on ticket_flights tf 
       −> Index Scan using boarding_passes_pkey on boarding_passe...
  −> Index Scan using tickets_pkey on tickets t 
(7 rows)</code></pre><p>Сначала соединяются таблицы перелетов (<code>ticket_flights</code>) и посадочных талонов (<code>boarding_passes</code>); обе имеют составной первичный ключ (<code>ticket_no</code>, <code>flight_id</code>) и результат отсортирован по этим двум столбцам. Полученный набор строк соединяется с билетами (<code>tickets</code>), отсортированными по <code>ticket_no</code>. </p><p>Соединение выполняется за один проход по обоим наборам данных и не требует дополнительной памяти. Используются два указателя на текущие (изначально — первые) строки внутреннего и внешнего наборов. </p><p>Если ключи двух текущих строк не совпадают, один из указателей — тот, что ссылается на строку с меньшим ключом — продвигается на одну позицию вперед до тех пор, пока не будет найдено совпадение. Соответствующие друг другу строки возвращаются вышестоящему узлу, а указатель внутреннего набора данных продвигается на одну позицию вперед. Алгоритм продолжается до тех пор, пока один из наборов не закончится. </p><p>Такой алгоритм справляется с дубликатами ключей во внутреннем наборе данных, но, поскольку дубликаты могут быть и во внешнем наборе, алгоритм приходится немного усложнить: если после продвижения внешнего указателя ключ остается прежним, внутренний указатель возвращается назад на первую строку с тем же значением ключа. Таким образом, каждой строке из внешнего набора данных будут сопоставлены все строки с тем же ключом из внутреннего набора данных. </p><p>Для внешнего соединения алгоритм еще немного меняется, но общая идея остается той же самой. </p><p>Единственный оператор, на который рассчитано соединение слиянием — равенство, то есть поддерживаются только эквисоединения (хотя работа над поддержкой других условий тоже <a href="http://commitfest.postgresql.org/33/3160/">ведется</a>). </p><p><strong>Оценка стоимости. </strong>Рассмотрим приведенный выше пример: </p><pre><code class="pgsql">EXPLAIN SELECT * 
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no 
ORDER BY t.ticket_no;</code></pre><pre><code class="diff">                          QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Merge Join  (cost=0.99..822358.66 rows=8391852 width=136) 
   Merge Cond: (t.ticket_no = tf.ticket_no)
   −> Index Scan using tickets_pkey on tickets t
       (cost=0.43..139110.29 rows=2949857 width=104)
   −> Index Scan using ticket_flights_pkey on ticket_flights tf
       (cost=0.56..570975.58 rows=8391852 width=32) 
(6 rows)</code></pre><p>В начальную стоимость соединения входят как минимум начальные стоимости дочерних узлов. </p><p>В общем случае для нахождения первого соответствия может потребоваться прочитать некоторую долю внешнего или внутреннего наборов данных. Оценку этой доли можно дать, сравнив (с помощью гистограммы) минимальные значения ключа соединения в двух наборах. Но в данном случае диапазон номеров билетов в обоих таблицах совпадает. </p><p>Полная стоимость соединения складывается из стоимостей получения данных от дочерних узлов и стоимости вычислений. </p><p>Поскольку алгоритм соединения останавливается, когда заканчивается один из наборов данных (конечно, кроме случая внешнего соединения), другой набор может быть прочитан не полностью. Оценку этой доли можно получить, сравнив максимальные значения ключа в двух наборах. В нашем случае оба набора будут прочитаны до конца, так что в полную стоимость соединения войдет сумма полных стоимостей обоих дочерних узлов. </p><p>Кроме того, при наличии дубликатов часть строк внешнего набора может быть прочитана несколько раз. Количество повторных чтений оценивается разностью кардинальностей результата соединения и внутреннего набора. </p><p>В нашем запросе эти кардинальности совпадают, что говорит об отсутствии дубликатов. </p><p>Необходимые вычисления состоят из сравнений ключей соединения и выдачи результирующих строк. Количество сравнений можно оценить суммой кардинальностей обоих наборов и количества повторных чтений строк внешнего набора; одно сравнение оценивается значением параметра <em>cpu_operator_cost</em>. Стоимость обработки одной результирующей строки оценивается, как обычно, значением параметра <em>cpu_tuple_cost</em>. </p><p>Подытоживая, для нашего примера стоимость соединения вычисляется следующим образом: </p><pre><code class="pgsql">SELECT 0.43 + 0.56 AS startup, 
  round((
    139110.29 + 570975.58 +
    current_setting('cpu_tuple_cost')::real * 8391852 + 
    current_setting('cpu_operator_cost')::real * (2949857 + 8391852)
)::numeric, 2) AS total;</code></pre><pre><code class="diff"> startup |   total
−−−−−−−−−+−−−−−−−−−−− 
    0.99 | 822358.66
(1 row)</code></pre><h3>Параллельный режим</h3><p>Соединение слиянием может использоваться в параллельных планах. </p><p>Сканирование внешнего набора строк выполняется рабочими процессами параллельно, но внутренний набор строк каждый рабочий процесс всегда читает самостоятельно. </p><p>Вот пример параллельного плана запроса, использующего соединение слиянием: </p><pre><code class="pgsql">SET enable_hashjoin = off;
EXPLAIN (costs off)
SELECT count(*), sum(tf.amount) 
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no;</code></pre><pre><code class="diff">                             QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Finalize Aggregate 
   −> Gather
       Workers Planned: 2 
       −> Partial Aggregate
           −> Merge Join
               Merge Cond: (tf.ticket_no = t.ticket_no)
               −> Parallel Index Scan using ticket_flights_pkey o... 
               −> Index Only Scan using tickets_pkey on tickets t
(8 rows)</code></pre><p>Полные и правые внешние соединения слиянием в параллельных планах не поддерживаются. </p><h3>Модификации</h3><p>Соединение слиянием поддерживает любые типы соединений. Единственное ограничение для полного и правого внешних соединений — условие соединения должно содержать только выражения, подходящие для слияния (равенство столбцов из внешнего и внутреннего наборов или равенство столбца константе). В остальных случаях результат соединения просто фильтруется по таким дополнительным выражениям после соединения, но для полного и правого соединений это невозможно. </p><p>Вот пример полного соединения, использующего алгоритм слияния: </p><pre><code class="pgsql">EXPLAIN (costs off) SELECT * 
FROM tickets t
  FULL JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no 
ORDER BY t.ticket_no;</code></pre><pre><code>                             QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Sort
   Sort Key: t.ticket_no 
   −> Merge Full Join
       Merge Cond: (t.ticket_no = tf.ticket_no)
       −> Index Scan using tickets_pkey on tickets t
       −> Index Scan using ticket_flights_pkey on ticket_flights tf
(6 rows)</code></pre><p>Внутреннее и левое внешнее соединения слиянием сохраняют порядок сортировки. Но для полного и правого внешних соединений это не верно, поскольку между упорядоченными значениями внешнего набора данных могут быть вставлены неопределенные значения — а это нарушает сортировку. Поэтому здесь появляется узел Sort, восстанавливающий нужный порядок. Это, конечно, увеличивает стоимость плана и делает хеш-соединение более привлекательным, и, чтобы показать этот план, хеш-соединения пришлось отключить. </p><p>Но в следующем примере хеш-соединение используется все равно, поскольку это единственный способ выполнить полное соединение, содержащее условия в виде, который не поддерживается соединением слияния: </p><pre><code class="pgsql">EXPLAIN (costs off) SELECT * 
FROM tickets t
  FULL JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no 
                             AND tf.amount > 0
ORDER BY t.ticket_no;</code></pre><pre><code class="diff">                  QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Sort
   Sort Key: t.ticket_no 
   −> Hash Full Join
       Hash Cond: (tf.ticket_no = t.ticket_no) 
       Join Filter: (tf.amount > '0'::numeric) 
       −> Seq Scan on ticket_flights tf
       −> Hash
           −> Seq Scan on tickets t
(8 rows)</code></pre><pre><code class="pgsql">RESET enable_hashjoin;</code></pre><h2>Сортировка</h2><p>Если какой-то из наборов строк (а возможно, и оба) не отсортирован по ключу соединения, перед выполнением слияния он должен быть переупорядочен. Такая явная сортировка представляется в плане выполнения узлом Sort: </p><pre><code class="pgsql">EXPLAIN (costs off) 
SELECT *
FROM flights f
  JOIN airports_data dep ON f.departure_airport = dep.airport_code 
ORDER BY dep.airport_code;</code></pre><pre><code class="diff">                       QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Merge Join
   Merge Cond: (f.departure_airport = dep.airport_code) 
   −> Sort
       Sort Key: f.departure_airport
       −> Seq Scan on flights f 
   −> Sort
       Sort Key: dep.airport_code
       −> Seq Scan on airports_data dep 
(8 rows)</code></pre><p>Такая же сортировка может применяться и вне контекста соединений при использовании предложения <code>ORDER BY</code>, как самого по себе, так и в составе оконных функций: </p><pre><code class="pgsql">EXPLAIN (costs off) 
SELECT flight_id,
  row_number() OVER (PARTITION BY flight_no ORDER BY flight_id) 
FROM flights f;</code></pre><pre><code class="diff">              QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 WindowAgg 
   −> Sort
       Sort Key: flight_no, flight_id
       −> Seq Scan on flights f 
(4 rows)</code></pre><p>Здесь узел WindowAgg вычисляет оконную функцию по набору данных, предварительно отсортированному узлом Sort. </p><p>В арсенале планировщика имеется несколько способов сортировки данных. В примере, который я уже показывал, используется два из них (Sort Method). Как обычно, эти детали можно узнать, выполнив команду <code>EXPLAIN ANALYZE</code>: </p><pre><code class="pgsql">EXPLAIN (analyze,costs off,timing off,summary off) 
SELECT *
FROM flights f
  JOIN airports_data dep ON f.departure_airport = dep.airport_code 
ORDER BY dep.airport_code;</code></pre><pre><code class="diff">QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Merge Join (actual rows=214867 loops=1)
   Merge Cond: (f.departure_airport = dep.airport_code) 
   −> Sort (actual rows=214867 loops=1)
       Sort Key: f.departure_airport
       Sort Method: external merge Disk: 17136kB
       −> Seq Scan on flights f (actual rows=214867 loops=1)
   −> Sort (actual rows=104 loops=1)
       Sort Key: dep.airport_code
       Sort Method: quicksort Memory: 52kB
       −> Seq Scan on airports_data dep (actual rows=104 loops=1)
(10 rows)</code></pre><h3>Быстрая сортировка</h3><p>Если сортируемый набор данных помещается в память, ограниченную значением параметра <em>work_mem</em>, применяется традиционная <em>быстрая сортировка </em>(quick sort). Этот алгоритм описан во всех учебниках и я не буду его повторять. </p><p>С точки зрения реализации сортировка выполняется специальным компонентом, который выбирает наиболее подходящий алгоритм сортировки. </p><p><strong>Оценка стоимости. </strong>Возьмем пример сортировки небольшой таблицы: </p><pre><code class="pgsql">EXPLAIN SELECT * 
FROM airports_data 
ORDER BY airport_code;</code></pre><pre><code class="diff">                             QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Sort  (cost=7.52..7.78 rows=104 width=145)
   Sort Key: airport_code
   −> Seq Scan on airports_data  (cost=0.00..4.04 rows=104 width=...
(3 rows)</code></pre><p>Известно, что сортировка <em>n </em>значений имеет вычислительную сложность O(<em>n </em>log<sub>2</sub><em>n</em>). Одна операция сравнения оценивается удвоенным значением параметра <em>cpu_operator_cost</em>. Поскольку результат можно получить, только прочитав и отсортировав <em>весь </em>набор данных, стоимость операций сравнения вместе с полной стоимостью дочернего узла составляет начальную стоимость сортировки. </p><p>В полную стоимость сортировки добавляется обработка каждой строки результата, которая оценивается значением параметра <em>cpu_operator_cost </em>(а не <em>cpu_tuple_cost</em>, как обычно, поскольку для узла Sort накладные расходы невелики).</p><p>В нашем примере стоимость вычисляется так: </p><pre><code class="pgsql">WITH costs(startup) AS ( 
  SELECT 4.04 + round((
    current_setting('cpu_operator_cost')::real * 2 * 
      104 * log(2, 104)
  )::numeric, 2) 
)
SELECT startup, 
  startup + round((
    current_setting('cpu_operator_cost')::real * 104 
  )::numeric, 2) AS total
FROM costs;</code></pre><pre><code class="diff"> startup | total 
−−−−−−−−−+−−−−−−−
    7.52 | 7.78 
(1 row)</code></pre><h3>Частичная пирамидальная сортировка</h3><p>Если нужно отсортировать не весь набор данных, а только его часть (что определяется предложением <code>LIMIT</code>), может применяться <em>частичная пирамидальная сортировка </em>(top-N heapsort). Точнее, этот алгоритм используется, если количество строк после сортировки уменьшается как минимум вдвое, или если входной набор строк не помещается целиком в отведенную оперативную память (но выходной набор при этом помещается). </p><pre><code class="pgsql">EXPLAIN (analyze, timing off, summary off) SELECT * 
FROM seats
ORDER BY seat_no
LIMIT 100;</code></pre><pre><code class="diff">                            QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Limit  (cost=72.57..72.82 rows=100 width=15) 
   (actual rows=100 loops=1)
   −> Sort  (cost=72.57..75.91 rows=1339 width=15)
       (actual rows=100 loops=1)
       Sort Key: seat_no
       Sort Method: top−N heapsort Memory: 33kB
       −> Seq Scan on seats  (cost=0.00..21.39 rows=1339 width=15)
           (actual rows=1339 loops=1)
(8 rows)</code></pre><p>Чтобы найти <em>k </em>максимальных (минимальных) значений из <em>n</em>, в структуру данных, называемую кучей, добавляются <em>k </em>первых строк. Затем по одной добавляются и все остальные строки, но после добавления каждой следующей строки из кучи изымается одно наименьшее (наибольшее) значение. В результате в куче остаются <em>k </em>искомых значений. </p><p>Куча (heap), используемая в этот алгоритме, является структурой данных и не имеет ничего общего с таблицами базы данных, которые часто называют этим же термином. </p><p><strong>Оценка стоимости. </strong>Сложность алгоритма оценивается как <em>O</em>(<em>n </em>log<sub>2</sub><em>k</em>), однако каждая операция обходится дороже, чем в случае быстрой сортировки. Поэтому формула расчета стоимости использует <em>n </em>log<sub>2</sub>2<em>k</em>.</p><pre><code class="pgsql">WITH costs(startup) AS ( 
  SELECT 21.39 + round((
    current_setting('cpu_operator_cost')::real * 2 * 
      1339 * log(2, 2 * 100)
  )::numeric, 2) 
)
SELECT startup, 
  startup + round((
    current_setting('cpu_operator_cost')::real * 100 
  )::numeric, 2) AS total
FROM costs;</code></pre><pre><code class="diff"> startup | total 
−−−−−−−−−+−−−−−−−
   72.57 | 72.82 
(1 row)</code></pre><h3>Внешняя сортировка</h3><p>Если при чтении набора данных выясняется, что он слишком велик для сортировки в оперативной памяти, узел сортировки переключается на <em>внешнюю сортировку слиянием </em>(external merge). </p><p>Уже прочитанные строки сортируются в памяти алгоритмом быстрой сортировки и записываются во временный файл. </p><figure class="full-width "><img src="/img/image-loader.svg" height="469" data-src="https://habrastorage.org/getpro/habr/upload_files/0f8/421/7b4/0f84217b4b0c7674a33db9888f328ba2.png" data-width="1508"/><figcaption></figcaption></figure><p>В освобожденную память читаются следующие строки и процедура повторяется до тех пор, пока все данные не будут записаны в несколько файлов, каждый из которых по отдельности отсортирован. </p><figure class="full-width "><img src="/img/image-loader.svg" height="470" data-src="https://habrastorage.org/getpro/habr/upload_files/817/9b1/891/8179b1891ad33781a7ea1442714b199a.png" data-width="1522"/><figcaption></figcaption></figure><p>Далее несколько файлов объединяются в один примерно тем же алгоритмом, что используется и при соединении слиянием. Основное отличие состоит в том, что объединяться могут более двух файлов одновременно. </p><p>Для слияния не требуется много памяти. В принципе, достаточно располагать местом под одну строку для каждого файла. Из файлов читаются первые строки, среди них выбирается минимальная (или максимальная, в зависимости от направления сортировки) и возвращается как часть результата, а на ее место читается новая строка из соответствующего файла. </p><p>На практике строки читаются не по одной, а порциями по 32 страницы, чтобы уменьшить количество операций ввода-вывода. Количество файлов, которые объединяются за одну итерацию, определяется доступным местом в памяти, но меньше шести не используется никогда. Сверху это количество тоже ограничено (числом 500), поскольку при слишком большом числе файлов эффективность теряется.</p><p>Если объединить все отсортированные временные файлы за одну итерацию не получается, приходится выполнять слияние файлов по частям и записывать результат в новые временные файлы. Каждая такая итерация увеличивает объем записываемых и читаемых данных, поэтому чем больше оперативной памяти доступно, тем эффективнее будет выполняться внешняя сортировка.  </p><figure class="full-width "><img src="/img/image-loader.svg" height="972" data-src="https://habrastorage.org/getpro/habr/upload_files/eea/82b/6a3/eea82b6a37059b337828a06886ea3fe1.png" data-width="1508"/><figcaption></figcaption></figure><p>На следующей итерации слияние продолжается уже с новыми файлами. </p><figure class="full-width "><img src="/img/image-loader.svg" height="470" data-src="https://habrastorage.org/getpro/habr/upload_files/b6e/763/864/b6e763864deb5a482cd526afb0263000.png" data-width="1502"/><figcaption></figcaption></figure><p>Финальное слияние обычно откладывается и выполняется на лету, когда вышестоящий узел плана запрашивает данные. </p><p>Команда <code>EXPLAIN ANALYZE</code> показывает объем дисковой памяти, который потребовался внешней сортировке. Добавив ключевое слово <code>buffers</code>, можно получить и статистику использования буферов временных файлов (temp read и written). Количество записанных буферов будет (примерно) равно количеству прочитанных, и именно это значение, пересчитанное в килобайты, показано в плане в позиции Disk: </p><pre><code class="pgsql">EXPLAIN (analyze, buffers, costs off, timing off, summary off) 
SELECT *
FROM flights
ORDER BY scheduled_departure;</code></pre><pre><code class="diff">                            QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Sort (actual rows=214867 loops=1)
   Sort Key: scheduled_departure
   Sort Method: external merge Disk: 17136kB
   Buffers: shared hit=610 read=2017, temp read=2142 written=2150 
   −> Seq Scan on flights (actual rows=214867 loops=1)
       Buffers: shared hit=607 read=2017 
(6 rows)</code></pre><p>Более подробную статистику использование временных файлов можно получить в журнале сообщений, установив параметр <em>log_temp_buffers</em>. </p><p><strong>Оценка стоимости. </strong>В качестве примера возьмем тот же план с внешней сортировкой: </p><pre><code class="pgsql">EXPLAIN SELECT *
FROM flights
ORDER BY scheduled_departure;</code></pre><pre><code class="diff">                             QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Sort  (cost=31883.96..32421.12 rows=214867 width=63)
   Sort Key: scheduled_departure
   −> Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)
(3 rows)</code></pre><p>Здесь к обычной стоимости сравнений (количество которых остается таким же, как и в случае быстрой сортировки в памяти) добавляется стоимость ввода-вывода. Все входные данные придется сначала записать на диск во временные файлы, а затем прочитать с диска при слиянии (причем, возможно, несколько раз, если количество созданных файлов будет превышать количество одновременно объединяемых наборов). </p><p>Объем данных, попадающих на диск, определяется количеством и размером сортируемых строк. В данном случае запрос выводит все столбцы таблицы <code>flights</code>, поэтому объем почти равен размеру всей таблицы, за вычетом служебной информации в версиях строк и страницах (2309 страниц вместо 2624). В нашем примере на сортировку хватает одной итерации. </p><p>Обращение к диску (и запись, и чтение) оценивается как на три четверти последовательное и на одну четверть случайное. </p><p>Таким образом стоимость сортировки в нашем плане вычисляется так: </p><pre><code class="pgsql">WITH costs(startup) AS ( 
  SELECT 4772.67 + round((
    current_setting('cpu_operator_cost')::real * 2 * 
      214867 * log(2, 214867) +
    (current_setting('seq_page_cost')::real * 0.75 + 
      current_setting('random_page_cost')::real * 0.25) *
    2 * 2309 * 1 -- одна итерация 
  )::numeric, 2)
)
SELECT startup,
  startup + round(( current_setting('cpu_operator_cost')::real * 214867
  )::numeric, 2) AS total 
FROM costs;</code></pre><pre><code class="diff"> startup  |  total 
−−−−−−−−−−+−−−−−−−−−−
 31883.96 | 32421.13 
(1 row)</code></pre><h3>Инкрементальная сортировка</h3><p>Если набор данных требуется отсортировать по ключам <em>K</em><sub>1</sub> ... <em>K<sub>m</sub> </em>... <em>K<sub>n</sub></em>, и при этом известно, что набор уже отсортирован по первым нескольким из этих ключей <em>K</em><sub>1</sub> ... <em>K<sub>m</sub></em>, то не обязательно пересортировывать весь набор заново. Можно разбить набор данных на группы, имеющие одинаковые значения начальных ключей <em>K</em><sub>1</sub> ... <em>K<sub>m</sub> </em>(значения таких групп следуют друг за другом), и затем отсортировать отдельно каждую из групп по оставшимся ключам <em>K</em><sub>m+1</sub> ... <em>K<sub>n</sub></em>. Такой способ называется <em>инкрементальной сортировкой</em>. Он доступен начиная с версии PostgreSQL 13.</p><p>Инкрементальная сортировка уменьшает требования к памяти, разбивая весь набор на несколько меньших групп, а также позволяет начать выдавать результаты после обработки первой группы, не дожидаясь сортировки всего набора. </p><p>Реализация действует более тонко: отдельно обрабатываются только относительно крупные группы строк, а небольшие объединяются и сортируются полностью. Это уменьшает накладные расходы на запуск алгоритма сортировки. </p><p>В плане выполнения инкрементальная сортировка представлена узлом Incremental Sort: </p><pre><code class="pgsql">EXPLAIN (analyze, costs off, timing off, summary off) 
SELECT *
FROM bookings
ORDER BY total_amount, book_date;</code></pre><pre><code class="diff">                             QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Incremental Sort (actual rows=2111110 loops=1)
   Sort Key: total_amount, book_date
   Presorted Key: total_amount
   Full−sort Groups: 2823 Sort Method: quicksort Average 
   Memory: 30kB Peak Memory: 30kB
   Pre−sorted Groups: 2624 Sort Method: quicksort Average
   Memory: 3152kB Peak Memory: 3259kB
   −> Index Scan using bookings_total_amount_idx on bookings (ac...
(8 rows)</code></pre><p>Как видно из плана, набор строк уже отсортирован по <code>total_amount</code>, поскольку получен сканированием индекса, построенного по этому столбцу (Presorted Key). Команда <code>EXPLAIN ANALYZE</code> показывает также статистику времени выполнения. Строка Full-sort Groups относится к строкам из небольших групп, которые были объединены и отсортированы полностью, а строка Pre-sorted Groups — к крупным группам, которые досортировывались по столбцу <code>book_date</code>. В обоих случаях использовалась быстрая сортировка в памяти. Наличие групп разного размера вызвано неравномерным распределением стоимости бронирований. </p><p>Начиная с версии 14 инкрементальная сортировка может использоваться и для оконных функций: </p><pre><code class="pgsql">EXPLAIN (costs off)
SELECT row_number() OVER (ORDER BY total_amount, book_date) 
FROM bookings;</code></pre><pre><code class="diff">                           QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 WindowAgg
   −> Incremental Sort
       Sort Key: total_amount, book_date
       Presorted Key: total_amount
       −> Index Scan using bookings_total_amount_idx on bookings
(5 rows)</code></pre><p><strong>Оценка стоимости. </strong>Расчет стоимости инкрементальной сортировки опирается на оценку количества групп и оценку сортировки группы среднего размера (которую мы уже рассмотрели). </p><p>Начальная стоимость отражает оценки сортировки одной (первой) группы, после чего узел уже может выдавать отсортированные строки, а полная стоимость учитывает сортировку всех групп: </p><pre><code class="pgsql">EXPLAIN SELECT *
FROM bookings
ORDER BY total_amount, book_date;</code></pre><pre><code class="diff">                             QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Incremental Sort  (cost=45.10..282293.40 rows=2111110 width=21) 
   Sort Key: total_amount, book_date
   Presorted Key: total_amount
   −> Index Scan using bookings_total_amount_idx on bookings  (co...
(4 rows)</code></pre><p>Подробно останавливаться на вычислении оценок я не буду. </p><h3>Параллельный режим</h3><p>Сортировка может выполняться параллельно. Но, хотя рабочие процессы выдают свою часть данных в отсортированном виде, узел Gather ничего не знает про упорядоченность и может объединять данные только в порядке поступления. Чтобы сохранить сортировку, применяется другой узел — Gather Merge.</p><pre><code class="pgsql">EXPLAIN (analyze, costs off, timing off, summary off) 
SELECT *
FROM flights
ORDER BY scheduled_departure
LIMIT 10;</code></pre><pre><code class="diff">                             QUERY PLAN
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Limit (actual rows=10 loops=1)
   −> Gather Merge (actual rows=10 loops=1)
       Workers Planned: 1
       Workers Launched: 1
       −> Sort (actual rows=8 loops=2)
           Sort Key: scheduled_departure
           Sort Method: top−N heapsort Memory: 27kB
           Worker 0: Sort Method: top−N heapsort Memory: 27kB
           −> Parallel Seq Scan on flights (actual rows=107434 lo...
(9 rows)</code></pre><p>Узел Gather Merge использует двоичную кучу для упорядочения строк, поступающих от нескольких процессов. По сути, выполняется слияние нескольких отсортированных наборов строк, как при внешней сортировке, но алгоритм рассчитан на другие условия работы: на небольшое фиксированное число источников и получение строк по одной, без блочного доступа. </p><p><strong>Оценка стоимости. </strong>Начальная стоимость узла Gather Merge опирается на начальную стоимость дочернего узла. К ней (как и в случае узла Gather) добавляется стоимость запуска процессов, которая оценивается значением параметра <em>parallel_setup_cost</em>. </p><p>Сюда же добавляется оценка построения двоичной кучи, что требует сортировки <em>n</em> значений по числу параллельных процессов (то есть <em>n </em>log<sub>2</sub><em>n</em>). Одна операция сравнения оценивается удвоенным значением параметра <em>cpu_operator_cost</em>, и общая сумма обычно пренебрежимо мала, поскольку <em>n </em>невелико. </p><p>В полную стоимость входит получение всех данных дочерним узлом, который выполняется несколькими параллельными процессами, и стоимость пересылки строк от этих процессов. Пересылка одной строки оценивается значением параметра <em>parallel_tuple_cost</em>, увеличенным на 5 %, чтобы учесть возможные потери при ожидании получения очередных значений. </p><p>В полную стоимость входит также обновление двоичной кучи. Для каждой входящей строки данных это требует log<sub>2</sub><em>n </em>операций сравнения и определенных вспомогательных действий (которые оцениваются значением <em>cpu_operator_cost</em>). </p><p>Вот еще один пример плана с узлом Gather Merge: </p><pre><code class="pgsql">EXPLAIN SELECT amount, count(*) 
FROM ticket_flights
GROUP BY amount;</code></pre><pre><code class="diff">                             QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Finalize GroupAggregate  (cost=123399.62..123485.00 rows=337 wid... 
   Group Key: amount
   −> Gather Merge  (cost=123399.62..123478.26 rows=674 width=14)
       Workers Planned: 2
       −> Sort  (cost=122399.59..122400.44 rows=337 width=14)
           Sort Key: amount
           −> Partial HashAggregate  (cost=122382.07..122385.44 r...
               Group Key: amount
               −> Parallel Seq Scan on ticket_flights  (cost=0.00...
(9 rows)</code></pre><p>Этот план интересен тем, что рабочие процессы выполняют частичную агрегацию с помощью хеширования, затем полученные результаты сортируются узлом Sort (это дешево, поскольку после агрегации остается немного строк) и передаются ведущему процессу, который собирает полный результат в узле Gather Merge. Окончательная же агрегация выполняется не хешированием, а по отсортированному списку значений. </p><p>В данном случае количество параллельных процессов равно трем (включая основной) и стоимость узла Gather Merge вычисляется так: </p><pre><code class="pgsql">WITH costs(startup, run) AS ( 
  SELECT round((
    -- запуск процессов 
    current_setting('parallel_setup_cost')::real +
    -- построение кучи
    current_setting('cpu_operator_cost')::real * 2 * 3 * log(2, 3)
  )::numeric, 2), 
  round((
    -- передача строк
    current_setting('parallel_tuple_cost')::real * 1.05 * 674 +
    -- обновление кучи
    current_setting('cpu_operator_cost')::real * 2 * 674 * log(2, 3) + 
    current_setting('cpu_operator_cost')::real * 674
  )::numeric, 2) 
)
SELECT 122399.59 + startup AS startup, 
  122400.44 + startup + run AS total
FROM costs;</code></pre><pre><code class="diff">  startup  |   total 
−−−−−−−−−−−+−−−−−−−−−−−
 123399.61 | 123478.26 
(1 row)</code></pre><h2>Группировка и уникальные значения</h2><p>Как мы только что видели, группировка значений для агрегации (и устранения дубликатов) может выполняться не только хешированием, но и с помощью сортировки. В отсортированном списке группы повторяющихся значений элементарно выделяются за один проход. </p><p>Выбор уникальных значений из отсортированного списка представляется в плане очень простым узлом Unique:</p><pre><code class="pgsql">EXPLAIN (costs off) SELECT DISTINCT book_ref 
FROM bookings
ORDER BY book_ref;</code></pre><pre><code class="diff">                        QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 Result
   −> Unique
       −> Index Only Scan using bookings_pkey on bookings 
(3 rows)</code></pre><p>Для агрегации используется другой узел, GroupAggregate: </p><pre><code class="pgsql">EXPLAIN (costs off) SELECT book_ref, count(*) 
FROM bookings
GROUP BY book_ref
ORDER BY book_ref;</code></pre><pre><code class="diff">                      QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 GroupAggregate
   Group Key: book_ref
   −> Index Only Scan using bookings_pkey on bookings
(3 rows)</code></pre><p>В параллельных планах такой узел будет называться Partial GroupAggregate, а узел, завершающий агрегацию, — Finalize GroupAggregate. </p><p>Начиная с версии PostgreSQL 10 обе стратегии — хеширование и сортировка — могут совмещаться в одном узле при группировке по нескольким наборам (в предложениях <code>GROUPING SETS</code>, <code>CUBE</code> или <code>ROLLUP</code>). Я не буду углубляться в весьма непростые детали алгоритма. Приведу лишь один пример, в котором группировка должна вычисляться по трем разным столбцам в условиях недостаточной памяти: </p><pre><code class="pgsql">SET work_mem = '64kB';
EXPLAIN (costs off)
SELECT count(*)
FROM flights
GROUP BY GROUPING SETS (aircraft_code, flight_no, departure_airport);</code></pre><pre><code class="diff">          QUERY PLAN 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 MixedAggregate
   Hash Key: departure_airport 
   Group Key: aircraft_code 
   Sort Key: flight_no
     Group Key: flight_no 
   −> Sort
       Sort Key: aircraft_code
       −> Seq Scan on flights 
(8 rows)</code></pre><p>Вот что происходит при выполнении этого запроса. Узел агрегации, который обозначен в плане как MixedAggregate, получает набор данных, отсортированных по столбцу <code>aircraft_code</code>. </p><p>На первом этапе этот набор сканируется и значения группируются по <code>aircraft_code</code> (Group Key). По мере сканирования строки переупорядочиваются по столбцу <code>flight_no</code> (так, как это делает обычный узел Sort: либо быстрой сортировкой в памяти, если ее достаточно, либо внешней сортировкой на диске) и одновременно с этим записываются в хеш-таблицу с ключом <code>departure_airport</code> (так, как это делает агрегация хешированием: либо в памяти, либо с использованием временных файлов). </p><p>На втором этапе сканируется набор строк, отсортированный на предыдущем этапе по столбцу <code>flight_no</code>, и значения группируются по этому же столбцу (Sort Key и вложенный Group Key). Если бы требовалась группировка сортировкой по еще одному столбцу, на этом этапе строки бы пересортировались в том порядке, который был бы необходим дальше. </p><p>Наконец, сканируется хеш-таблица, подготовленная на первом этапе, и значения группируются по столбцу <code>departure_airport</code> (Hash Key). </p><h2>Сравнение способов соединения</h2><p>Итак, для соединения двух наборов данных могут использоваться три разных способа, каждый со своими достоинствами и недостатками. </p><p><em>Соединение вложенным циклом </em>не требует никакой подготовительной работы и начинает возвращать результирующие строки сразу же. Это единственный из способов соединения, которому не требуется просматривать внутренний набор полностью, если для него есть эффективный индексный доступ. Эти свойства делают алгоритм вложенного цикла (в сочетании с индексами) идеальным механизмом для коротких OLTP-запросов, которые строятся на небольшой выборке строк. </p><p>Недостаток вложенного цикла проявляется с ростом объема данных. Для декартова произведения этот алгоритм имеет квадратичную сложность — затраты пропорциональны произведению размеров соединяемых наборов данных. Декартово произведение нечасто встречается на практике; обычно для каждой строки внешнего набора данных с помощью индекса просматривается некоторое количество строк внутреннего набора, и это среднее количество не зависит от размера всего набора данных (например, среднее количество билетов в одном бронировании не меняется с ростом количества бронирований и купленных билетов). Поэтому часто рост сложности будет линейным, а не квадратичным, хотя и с большим коэффициентом. </p><p>Важная особенность вложенного цикла состоит в его универсальности: поддерживаются любые условия соединения, в то время как остальные способы работают только с эквисоединениями. Это дает возможность выполнять любые запросы с любыми условиями (кроме полного соединения, которое не реализуется вложенным циклом), но надо помнить о том, что не-эквисоединение больших объемов будет выполняться заведомо неэффективно. </p><p><em>Соединение хешированием </em>очень эффективно для больших наборов данных. При наличии достаточного объема памяти оно требует однократного просмотра двух наборов данных, то есть имеет линейную сложность. В сочетании с последовательным сканированием таблиц, соединение хешированием часто встречается в OLAP-запросах, вычисляющих результат на основании большого объема данных. </p><p>Для ситуаций, в которых время отклика важнее пропускной способности, хеш-соединение подходит хуже, поскольку результирующие строки не могут возвращаться, пока хеш-таблица не построена полностью. </p><p>Применение хеш-соединения ограничено эквисоединениями. Кроме того, тип данных должен допускать хеширование (это выполняется почти всегда). </p><p>Начиная с версии 14 вложенный цикл может иногда составить конкуренцию соединению хешированием за счет кеширования строк внутреннего набора в узле Memoize (также основанного на хеш-таблице). Выигрыш может достигаться за счет того, что соединение хешированием всегда просматривает внутренний набор строк полностью, а алгоритм вложенного цикла — нет. </p><p><em>Соединение слиянием </em>отлично подходит и для коротких OLTP-запросов, и для длинных запросов OLAP. Оно имеет линейную сложность (требуется однократный просмотр соединяемых наборов строк), не требовательно к памяти и выдает результаты без предварительной подготовки. Единственная сложность состоит в том, что наборы данных должны быть отсортированы в правильном порядке. Наиболее эффективный способ добиться этого — получать данные от индексного сканирования. Это естественный вариант для небольшого количества строк; при большом объеме данных индексный доступ тоже может быть эффективен, если это только индексное сканирование с минимальными обращениями к таблице или вовсе без них. </p><p>Если подходящих индексов нет, то наборы данных придется сортировать, а сортировка требует памяти и имеет сложность выше линейной: O(<em>n </em>log<sub>2</sub><em>n</em>). В таком случае соединение слиянием почти всегда проигрывает соединению хешированием — за исключением ситуации, когда результат нужен отсортированным. </p><p>К приятным свойствам соединения слиянием относится равноценность внешнего и внутреннего наборов строк. Эффективность и вложенного цикла, и хеш-соединения сильно зависит от того, правильно ли планировщик выберет, какой из наборов данных поставить внешним, а какой — внутренним. </p><p>Применение соединения слиянием ограничено эквисоединениями. Кроме того, тип данных должен иметь класс операторов для B-дерева. </p><p>На графике показана примерная зависимость стоимостей различных способов соединений двух таблиц от доли соединяемых строк. </p><figure class="full-width "><img src="/img/image-loader.svg" height="924" data-src="https://habrastorage.org/getpro/habr/upload_files/97c/2d5/fcc/97c2d5fccf4889595986d16c2c830f52.png" data-width="1512"/><figcaption></figcaption></figure><p>Соединение вложенным циклом при высокой селективности использует индексный доступ к обоим таблицам; затем планировщик переключается на полное сканирование внешней таблицы и график становится линейным. </p><p>Соединения хешированием использует в этом примере полное сканирование обоих таблиц. «Ступенька» на графике возникает в тот момент, когда хеш-таблица перестает помещаться в оперативной памяти и пакеты начинают сбрасываться на диск. </p><p>Соединение слиянием с использованием индекса показывает небольшой линейный рост стоимости. При достаточном объеме <em>work_mem </em>соединение хешированием обычно оказывается эффективнее, но, когда дело доходит до временных файлов, соединение слиянием выигрывает. </p><p>Верхний график соединения слиянием с сортировкой показывает рост стоимости в ситуации, когда индексы недоступны, и данные приходится сортировать. Как и в случае хеширования, «ступенька» на графике вызвана недостатком памяти и необходимостью использовать для сортировки временные файлы. </p><p>Это только пример; в каждом конкретном случае соотношения стоимостей, разумеется, будут отличаться. </p><blockquote><p>На этом я остановлюсь. Нельзя объять необъятное, но думаю, что основные моменты я охватил.</p><p>Материал этой и прошлых серий статей лег в основу книги, над которой я сейчас работаю, и которая, надеюсь, увидит свет уже в конце этого года. Спасибо всем, кто меня читает — ваши комментарии позволяют улучшить текст.</p><p>Оставайтесь с нами!</p></blockquote></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%5D" class="tm-tags-list__link">оптимизация</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">планирование</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%5D" class="tm-tags-list__link">соединения</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">слияние</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%5D" class="tm-tags-list__link">сортировка</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BD%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%BE%D1%80%20%D0%BD%D0%B8%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BD%D0%B5%20%D0%B3%D0%BE%D0%B4%D0%B8%D1%82%D1%81%D1%8F%5D" class="tm-tags-list__link">новый редактор никуда не годится</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/postgrespro/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании Postgres Professional
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/postgresql/" class="tm-hubs-list__link">
    PostgreSQL
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/sql/" class="tm-hubs-list__link">
    SQL
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 15: ↑15 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 15: ↑15 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+15</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">3.2K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    85
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/postgrespro/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/4e0/339/621/4e0339621abc865fefb88f9e9f44748f.jpg" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/postgrespro/profile/" class="tm-company-snippet__title">Postgres Professional</a> <div class="tm-company-snippet__description">Разработчик СУБД Postgres Pro</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <div class="tm-article-author__company-contacts"><a href="https://facebook.com/PostgresProfessional" rel="noopener" target="_blank" class="tm-article-author__contact">
      Facebook
    </a><a href="https://twitter.com/PostgresPro" rel="noopener" target="_blank" class="tm-article-author__contact">
      Twitter
    </a><a href="https://vk.com/public101507899" rel="noopener" target="_blank" class="tm-article-author__contact">
      ВКонтакте
    </a><a href="https://plus.google.com/+PostgresproRuCompany" rel="noopener" target="_blank" class="tm-article-author__contact">
      Google+
    </a><a href="https://postgrespro.livejournal.com/" rel="noopener" target="_blank" class="tm-article-author__contact">
      LiveJournal
    </a></div> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/erogov/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/d16/573/7e4/d165737e421383f77f007015ebd01fb1.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 170 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    163.5
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">47</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Егор Рогов</span> <a href="/ru/users/erogov/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @erogov
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <div class="tm-article-author__user-contacts"><a href="http://egorius.dreamwidth.org/" rel="noopener" target="_blank" class="tm-article-author__contact">
      Сайт
    </a></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/postgrespro/blog/582058/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 6 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2015-01-26T21:00:00.000Z" title="2015-01-27, 00:00">27  января  2015</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://www.postgrespro.ru/" target="_blank" class="tm-company-basic-info__link">
      www.postgrespro.ru
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    51–100 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2015-09-30T07:41:09.000Z" title="2015-09-30, 10:41">30  сентября  2015</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Представитель</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="/ru/users/x-wao/" class="tm-company-basic-info__link">
      Иван Панченко
    </a></dd></dl></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/postgrespro/blog/582058/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/postgrespro/blog/582058/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"582058":{"id":"582058","timePublished":"2021-10-06T22:41:30+00:00","isCorporative":true,"lang":"ru","titleHtml":"Запросы в PostgreSQL: 7. Сортировка и слияние","leadData":{"textHtml":"\u003Cp\u003EВ предыдущих статьях я писал про \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F574702\u002F\"\u003Eэтапы выполнения запросов\u003C\u002Fa\u003E, про \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F576100\u002F\"\u003Eстатистику\u003C\u002Fa\u003E, про два основных вида доступа к данным — \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F576980\u002F\"\u003Eпоследовательное сканирование\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F578196\u002F\"\u003Eиндексное сканирование\u003C\u002Fa\u003E, — и успел рассказать о двух способах соединения — \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F579024\u002F\"\u003Eвложенном цикле\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F581174\u002F\"\u003Eсоединении хешированием\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВ заключительной статье этой серии я расскажу про \u003Cem\u003Eалгоритм слияния\u003C\u002Fem\u003E и про \u003Cem\u003Eсортировку\u003C\u002Fem\u003E, и сравню все три алгоритма соединения между собой.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F78b\u002F71b\u002F5d3\u002F78b71b5d35a0c717ab2bd664367ae88a.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F78b\u002F71b\u002F5d3\u002F78b71b5d35a0c717ab2bd664367ae88a.png","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":163.5,"votesCount":170},"rating":47,"relatedData":null,"contacts":[{"title":"Сайт","url":"http:\u002F\u002Fegorius.dreamwidth.org\u002F","value":"http:\u002F\u002Fegorius.dreamwidth.org\u002F"}],"authorContacts":[{"title":"Сайт","url":"http:\u002F\u002Fegorius.dreamwidth.org\u002F","value":"http:\u002F\u002Fegorius.dreamwidth.org\u002F"}],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"594155","alias":"erogov","fullname":"Егор Рогов","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002Fd16\u002F573\u002F7e4\u002Fd165737e421383f77f007015ebd01fb1.jpg","speciality":"Пользователь"},"statistics":{"commentsCount":6,"favoritesCount":85,"readingCount":3167,"score":15,"votesCount":15},"hubs":[{"relatedData":null,"id":"19663","alias":"postgrespro","type":"corporative","title":"Блог компании Postgres Professional","titleHtml":"Блог компании Postgres Professional","isProfiled":false},{"relatedData":null,"id":"358","alias":"postgresql","type":"collective","title":"PostgreSQL","titleHtml":"PostgreSQL","isProfiled":true},{"relatedData":null,"id":"594","alias":"sql","type":"collective","title":"SQL","titleHtml":"SQL","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EВ предыдущих статьях я писал про \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F574702\u002F\"\u003Eэтапы выполнения запросов\u003C\u002Fa\u003E, про \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F576100\u002F\"\u003Eстатистику\u003C\u002Fa\u003E, про два основных вида доступа к данным — \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F576980\u002F\"\u003Eпоследовательное сканирование\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F578196\u002F\"\u003Eиндексное сканирование\u003C\u002Fa\u003E, — и успел рассказать о двух способах соединения — \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F579024\u002F\"\u003Eвложенном цикле\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fpostgrespro\u002Fblog\u002F581174\u002F\"\u003Eсоединении хешированием\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВ заключительной статье этой серии я расскажу про \u003Cem\u003Eалгоритм слияния\u003C\u002Fem\u003E и про \u003Cem\u003Eсортировку\u003C\u002Fem\u003E, и сравню все три способа соединения между собой.\u003C\u002Fp\u003E\u003Ch2\u003EСоединение слиянием\u003C\u002Fh2\u003E\u003Cp\u003EСоединение слиянием работает для наборов данных, отсортированных по ключу соединения, и возвращает отсортированный же результат. Входной набор может получиться заранее отсортированным в результате индексного сканирования или он может быть отсортирован явно. \u003C\u002Fp\u003E\u003Ch3\u003EСлияние отсортированных наборов\u003C\u002Fh3\u003E\u003Cp\u003EВот пример соединения слиянием; оно представлено в плане выполнения узлом Merge Join: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) SELECT * \nFROM tickets t\n  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no \nORDER BY t.ticket_no;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                           QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Merge Join\n   Merge Cond: (t.ticket_no = tf.ticket_no)\n   −\u003E Index Scan using tickets_pkey on tickets t\n   −\u003E Index Scan using ticket_flights_pkey on ticket_flights tf\n(4 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗдесь оптимизатор предпочел именно этот способ соединения, поскольку он возвращает результат именно в том порядке, который указан в предложении \u003Ccode\u003EORDER BY\u003C\u002Fcode\u003E. Работая с планами, оптимизатор учитывает порядок сортировки наборов данных и не выполняет явную сортировку, если в ней нет необходимости. В частности, полученный набор можно использовать для следующего соединения слиянием, если порядок сортировки сохраняется: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) SELECT * \nFROM tickets t\n  JOIN ticket_flights tf ON t.ticket_no = tf.ticket_no \n  JOIN boarding_passes bp ON bp.ticket_no = tf.ticket_no \n                         AND bp.flight_id = tf.flight_id\nORDER BY t.ticket_no;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Merge Join\n   Merge Cond: (tf.ticket_no = t.ticket_no) \n   −\u003E Merge Join\n       Merge Cond: ((tf.ticket_no = bp.ticket_no) AND (tf.flight_... \n       −\u003E Index Scan using ticket_flights_pkey on ticket_flights tf \n       −\u003E Index Scan using boarding_passes_pkey on boarding_passe...\n  −\u003E Index Scan using tickets_pkey on tickets t \n(7 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EСначала соединяются таблицы перелетов (\u003Ccode\u003Eticket_flights\u003C\u002Fcode\u003E) и посадочных талонов (\u003Ccode\u003Eboarding_passes\u003C\u002Fcode\u003E); обе имеют составной первичный ключ (\u003Ccode\u003Eticket_no\u003C\u002Fcode\u003E, \u003Ccode\u003Eflight_id\u003C\u002Fcode\u003E) и результат отсортирован по этим двум столбцам. Полученный набор строк соединяется с билетами (\u003Ccode\u003Etickets\u003C\u002Fcode\u003E), отсортированными по \u003Ccode\u003Eticket_no\u003C\u002Fcode\u003E. \u003C\u002Fp\u003E\u003Cp\u003EСоединение выполняется за один проход по обоим наборам данных и не требует дополнительной памяти. Используются два указателя на текущие (изначально — первые) строки внутреннего и внешнего наборов. \u003C\u002Fp\u003E\u003Cp\u003EЕсли ключи двух текущих строк не совпадают, один из указателей — тот, что ссылается на строку с меньшим ключом — продвигается на одну позицию вперед до тех пор, пока не будет найдено совпадение. Соответствующие друг другу строки возвращаются вышестоящему узлу, а указатель внутреннего набора данных продвигается на одну позицию вперед. Алгоритм продолжается до тех пор, пока один из наборов не закончится. \u003C\u002Fp\u003E\u003Cp\u003EТакой алгоритм справляется с дубликатами ключей во внутреннем наборе данных, но, поскольку дубликаты могут быть и во внешнем наборе, алгоритм приходится немного усложнить: если после продвижения внешнего указателя ключ остается прежним, внутренний указатель возвращается назад на первую строку с тем же значением ключа. Таким образом, каждой строке из внешнего набора данных будут сопоставлены все строки с тем же ключом из внутреннего набора данных. \u003C\u002Fp\u003E\u003Cp\u003EДля внешнего соединения алгоритм еще немного меняется, но общая идея остается той же самой. \u003C\u002Fp\u003E\u003Cp\u003EЕдинственный оператор, на который рассчитано соединение слиянием — равенство, то есть поддерживаются только эквисоединения (хотя работа над поддержкой других условий тоже \u003Ca href=\"http:\u002F\u002Fcommitfest.postgresql.org\u002F33\u002F3160\u002F\"\u003Eведется\u003C\u002Fa\u003E). \u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EОценка стоимости. \u003C\u002Fstrong\u003EРассмотрим приведенный выше пример: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN SELECT * \nFROM tickets t\n  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no \nORDER BY t.ticket_no;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                          QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Merge Join  (cost=0.99..822358.66 rows=8391852 width=136) \n   Merge Cond: (t.ticket_no = tf.ticket_no)\n   −\u003E Index Scan using tickets_pkey on tickets t\n       (cost=0.43..139110.29 rows=2949857 width=104)\n   −\u003E Index Scan using ticket_flights_pkey on ticket_flights tf\n       (cost=0.56..570975.58 rows=8391852 width=32) \n(6 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ начальную стоимость соединения входят как минимум начальные стоимости дочерних узлов. \u003C\u002Fp\u003E\u003Cp\u003EВ общем случае для нахождения первого соответствия может потребоваться прочитать некоторую долю внешнего или внутреннего наборов данных. Оценку этой доли можно дать, сравнив (с помощью гистограммы) минимальные значения ключа соединения в двух наборах. Но в данном случае диапазон номеров билетов в обоих таблицах совпадает. \u003C\u002Fp\u003E\u003Cp\u003EПолная стоимость соединения складывается из стоимостей получения данных от дочерних узлов и стоимости вычислений. \u003C\u002Fp\u003E\u003Cp\u003EПоскольку алгоритм соединения останавливается, когда заканчивается один из наборов данных (конечно, кроме случая внешнего соединения), другой набор может быть прочитан не полностью. Оценку этой доли можно получить, сравнив максимальные значения ключа в двух наборах. В нашем случае оба набора будут прочитаны до конца, так что в полную стоимость соединения войдет сумма полных стоимостей обоих дочерних узлов. \u003C\u002Fp\u003E\u003Cp\u003EКроме того, при наличии дубликатов часть строк внешнего набора может быть прочитана несколько раз. Количество повторных чтений оценивается разностью кардинальностей результата соединения и внутреннего набора. \u003C\u002Fp\u003E\u003Cp\u003EВ нашем запросе эти кардинальности совпадают, что говорит об отсутствии дубликатов. \u003C\u002Fp\u003E\u003Cp\u003EНеобходимые вычисления состоят из сравнений ключей соединения и выдачи результирующих строк. Количество сравнений можно оценить суммой кардинальностей обоих наборов и количества повторных чтений строк внешнего набора; одно сравнение оценивается значением параметра \u003Cem\u003Ecpu_operator_cost\u003C\u002Fem\u003E. Стоимость обработки одной результирующей строки оценивается, как обычно, значением параметра \u003Cem\u003Ecpu_tuple_cost\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\u003Cp\u003EПодытоживая, для нашего примера стоимость соединения вычисляется следующим образом: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ESELECT 0.43 + 0.56 AS startup, \n  round((\n    139110.29 + 570975.58 +\n    current_setting('cpu_tuple_cost')::real * 8391852 + \n    current_setting('cpu_operator_cost')::real * (2949857 + 8391852)\n)::numeric, 2) AS total;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E startup |   total\n−−−−−−−−−+−−−−−−−−−−− \n    0.99 | 822358.66\n(1 row)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EПараллельный режим\u003C\u002Fh3\u003E\u003Cp\u003EСоединение слиянием может использоваться в параллельных планах. \u003C\u002Fp\u003E\u003Cp\u003EСканирование внешнего набора строк выполняется рабочими процессами параллельно, но внутренний набор строк каждый рабочий процесс всегда читает самостоятельно. \u003C\u002Fp\u003E\u003Cp\u003EВот пример параллельного плана запроса, использующего соединение слиянием: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ESET enable_hashjoin = off;\nEXPLAIN (costs off)\nSELECT count(*), sum(tf.amount) \nFROM tickets t\n  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Finalize Aggregate \n   −\u003E Gather\n       Workers Planned: 2 \n       −\u003E Partial Aggregate\n           −\u003E Merge Join\n               Merge Cond: (tf.ticket_no = t.ticket_no)\n               −\u003E Parallel Index Scan using ticket_flights_pkey o... \n               −\u003E Index Only Scan using tickets_pkey on tickets t\n(8 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПолные и правые внешние соединения слиянием в параллельных планах не поддерживаются. \u003C\u002Fp\u003E\u003Ch3\u003EМодификации\u003C\u002Fh3\u003E\u003Cp\u003EСоединение слиянием поддерживает любые типы соединений. Единственное ограничение для полного и правого внешних соединений — условие соединения должно содержать только выражения, подходящие для слияния (равенство столбцов из внешнего и внутреннего наборов или равенство столбца константе). В остальных случаях результат соединения просто фильтруется по таким дополнительным выражениям после соединения, но для полного и правого соединений это невозможно. \u003C\u002Fp\u003E\u003Cp\u003EВот пример полного соединения, использующего алгоритм слияния: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) SELECT * \nFROM tickets t\n  FULL JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no \nORDER BY t.ticket_no;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode\u003E                             QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Sort\n   Sort Key: t.ticket_no \n   −\u003E Merge Full Join\n       Merge Cond: (t.ticket_no = tf.ticket_no)\n       −\u003E Index Scan using tickets_pkey on tickets t\n       −\u003E Index Scan using ticket_flights_pkey on ticket_flights tf\n(6 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВнутреннее и левое внешнее соединения слиянием сохраняют порядок сортировки. Но для полного и правого внешних соединений это не верно, поскольку между упорядоченными значениями внешнего набора данных могут быть вставлены неопределенные значения — а это нарушает сортировку. Поэтому здесь появляется узел Sort, восстанавливающий нужный порядок. Это, конечно, увеличивает стоимость плана и делает хеш-соединение более привлекательным, и, чтобы показать этот план, хеш-соединения пришлось отключить. \u003C\u002Fp\u003E\u003Cp\u003EНо в следующем примере хеш-соединение используется все равно, поскольку это единственный способ выполнить полное соединение, содержащее условия в виде, который не поддерживается соединением слияния: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) SELECT * \nFROM tickets t\n  FULL JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no \n                             AND tf.amount \u003E 0\nORDER BY t.ticket_no;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                  QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Sort\n   Sort Key: t.ticket_no \n   −\u003E Hash Full Join\n       Hash Cond: (tf.ticket_no = t.ticket_no) \n       Join Filter: (tf.amount \u003E '0'::numeric) \n       −\u003E Seq Scan on ticket_flights tf\n       −\u003E Hash\n           −\u003E Seq Scan on tickets t\n(8 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ERESET enable_hashjoin;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003EСортировка\u003C\u002Fh2\u003E\u003Cp\u003EЕсли какой-то из наборов строк (а возможно, и оба) не отсортирован по ключу соединения, перед выполнением слияния он должен быть переупорядочен. Такая явная сортировка представляется в плане выполнения узлом Sort: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) \nSELECT *\nFROM flights f\n  JOIN airports_data dep ON f.departure_airport = dep.airport_code \nORDER BY dep.airport_code;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                       QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Merge Join\n   Merge Cond: (f.departure_airport = dep.airport_code) \n   −\u003E Sort\n       Sort Key: f.departure_airport\n       −\u003E Seq Scan on flights f \n   −\u003E Sort\n       Sort Key: dep.airport_code\n       −\u003E Seq Scan on airports_data dep \n(8 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТакая же сортировка может применяться и вне контекста соединений при использовании предложения \u003Ccode\u003EORDER BY\u003C\u002Fcode\u003E, как самого по себе, так и в составе оконных функций: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) \nSELECT flight_id,\n  row_number() OVER (PARTITION BY flight_no ORDER BY flight_id) \nFROM flights f;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E              QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n WindowAgg \n   −\u003E Sort\n       Sort Key: flight_no, flight_id\n       −\u003E Seq Scan on flights f \n(4 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗдесь узел WindowAgg вычисляет оконную функцию по набору данных, предварительно отсортированному узлом Sort. \u003C\u002Fp\u003E\u003Cp\u003EВ арсенале планировщика имеется несколько способов сортировки данных. В примере, который я уже показывал, используется два из них (Sort Method). Как обычно, эти детали можно узнать, выполнив команду \u003Ccode\u003EEXPLAIN ANALYZE\u003C\u002Fcode\u003E: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (analyze,costs off,timing off,summary off) \nSELECT *\nFROM flights f\n  JOIN airports_data dep ON f.departure_airport = dep.airport_code \nORDER BY dep.airport_code;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003EQUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Merge Join (actual rows=214867 loops=1)\n   Merge Cond: (f.departure_airport = dep.airport_code) \n   −\u003E Sort (actual rows=214867 loops=1)\n       Sort Key: f.departure_airport\n       Sort Method: external merge Disk: 17136kB\n       −\u003E Seq Scan on flights f (actual rows=214867 loops=1)\n   −\u003E Sort (actual rows=104 loops=1)\n       Sort Key: dep.airport_code\n       Sort Method: quicksort Memory: 52kB\n       −\u003E Seq Scan on airports_data dep (actual rows=104 loops=1)\n(10 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EБыстрая сортировка\u003C\u002Fh3\u003E\u003Cp\u003EЕсли сортируемый набор данных помещается в память, ограниченную значением параметра \u003Cem\u003Ework_mem\u003C\u002Fem\u003E, применяется традиционная \u003Cem\u003Eбыстрая сортировка \u003C\u002Fem\u003E(quick sort). Этот алгоритм описан во всех учебниках и я не буду его повторять. \u003C\u002Fp\u003E\u003Cp\u003EС точки зрения реализации сортировка выполняется специальным компонентом, который выбирает наиболее подходящий алгоритм сортировки. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EОценка стоимости. \u003C\u002Fstrong\u003EВозьмем пример сортировки небольшой таблицы: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN SELECT * \nFROM airports_data \nORDER BY airport_code;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Sort  (cost=7.52..7.78 rows=104 width=145)\n   Sort Key: airport_code\n   −\u003E Seq Scan on airports_data  (cost=0.00..4.04 rows=104 width=...\n(3 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИзвестно, что сортировка \u003Cem\u003En \u003C\u002Fem\u003Eзначений имеет вычислительную сложность O(\u003Cem\u003En \u003C\u002Fem\u003Elog\u003Csub\u003E2\u003C\u002Fsub\u003E\u003Cem\u003En\u003C\u002Fem\u003E). Одна операция сравнения оценивается удвоенным значением параметра \u003Cem\u003Ecpu_operator_cost\u003C\u002Fem\u003E. Поскольку результат можно получить, только прочитав и отсортировав \u003Cem\u003Eвесь \u003C\u002Fem\u003Eнабор данных, стоимость операций сравнения вместе с полной стоимостью дочернего узла составляет начальную стоимость сортировки. \u003C\u002Fp\u003E\u003Cp\u003EВ полную стоимость сортировки добавляется обработка каждой строки результата, которая оценивается значением параметра \u003Cem\u003Ecpu_operator_cost \u003C\u002Fem\u003E(а не \u003Cem\u003Ecpu_tuple_cost\u003C\u002Fem\u003E, как обычно, поскольку для узла Sort накладные расходы невелики).\u003C\u002Fp\u003E\u003Cp\u003EВ нашем примере стоимость вычисляется так: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EWITH costs(startup) AS ( \n  SELECT 4.04 + round((\n    current_setting('cpu_operator_cost')::real * 2 * \n      104 * log(2, 104)\n  )::numeric, 2) \n)\nSELECT startup, \n  startup + round((\n    current_setting('cpu_operator_cost')::real * 104 \n  )::numeric, 2) AS total\nFROM costs;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E startup | total \n−−−−−−−−−+−−−−−−−\n    7.52 | 7.78 \n(1 row)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EЧастичная пирамидальная сортировка\u003C\u002Fh3\u003E\u003Cp\u003EЕсли нужно отсортировать не весь набор данных, а только его часть (что определяется предложением \u003Ccode\u003ELIMIT\u003C\u002Fcode\u003E), может применяться \u003Cem\u003Eчастичная пирамидальная сортировка \u003C\u002Fem\u003E(top-N heapsort). Точнее, этот алгоритм используется, если количество строк после сортировки уменьшается как минимум вдвое, или если входной набор строк не помещается целиком в отведенную оперативную память (но выходной набор при этом помещается). \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (analyze, timing off, summary off) SELECT * \nFROM seats\nORDER BY seat_no\nLIMIT 100;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                            QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Limit  (cost=72.57..72.82 rows=100 width=15) \n   (actual rows=100 loops=1)\n   −\u003E Sort  (cost=72.57..75.91 rows=1339 width=15)\n       (actual rows=100 loops=1)\n       Sort Key: seat_no\n       Sort Method: top−N heapsort Memory: 33kB\n       −\u003E Seq Scan on seats  (cost=0.00..21.39 rows=1339 width=15)\n           (actual rows=1339 loops=1)\n(8 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЧтобы найти \u003Cem\u003Ek \u003C\u002Fem\u003Eмаксимальных (минимальных) значений из \u003Cem\u003En\u003C\u002Fem\u003E, в структуру данных, называемую кучей, добавляются \u003Cem\u003Ek \u003C\u002Fem\u003Eпервых строк. Затем по одной добавляются и все остальные строки, но после добавления каждой следующей строки из кучи изымается одно наименьшее (наибольшее) значение. В результате в куче остаются \u003Cem\u003Ek \u003C\u002Fem\u003Eискомых значений. \u003C\u002Fp\u003E\u003Cp\u003EКуча (heap), используемая в этот алгоритме, является структурой данных и не имеет ничего общего с таблицами базы данных, которые часто называют этим же термином. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EОценка стоимости. \u003C\u002Fstrong\u003EСложность алгоритма оценивается как \u003Cem\u003EO\u003C\u002Fem\u003E(\u003Cem\u003En \u003C\u002Fem\u003Elog\u003Csub\u003E2\u003C\u002Fsub\u003E\u003Cem\u003Ek\u003C\u002Fem\u003E), однако каждая операция обходится дороже, чем в случае быстрой сортировки. Поэтому формула расчета стоимости использует \u003Cem\u003En \u003C\u002Fem\u003Elog\u003Csub\u003E2\u003C\u002Fsub\u003E2\u003Cem\u003Ek\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EWITH costs(startup) AS ( \n  SELECT 21.39 + round((\n    current_setting('cpu_operator_cost')::real * 2 * \n      1339 * log(2, 2 * 100)\n  )::numeric, 2) \n)\nSELECT startup, \n  startup + round((\n    current_setting('cpu_operator_cost')::real * 100 \n  )::numeric, 2) AS total\nFROM costs;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E startup | total \n−−−−−−−−−+−−−−−−−\n   72.57 | 72.82 \n(1 row)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EВнешняя сортировка\u003C\u002Fh3\u003E\u003Cp\u003EЕсли при чтении набора данных выясняется, что он слишком велик для сортировки в оперативной памяти, узел сортировки переключается на \u003Cem\u003Eвнешнюю сортировку слиянием \u003C\u002Fem\u003E(external merge). \u003C\u002Fp\u003E\u003Cp\u003EУже прочитанные строки сортируются в памяти алгоритмом быстрой сортировки и записываются во временный файл. \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"469\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0f8\u002F421\u002F7b4\u002F0f84217b4b0c7674a33db9888f328ba2.png\" data-width=\"1508\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВ освобожденную память читаются следующие строки и процедура повторяется до тех пор, пока все данные не будут записаны в несколько файлов, каждый из которых по отдельности отсортирован. \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"470\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F817\u002F9b1\u002F891\u002F8179b1891ad33781a7ea1442714b199a.png\" data-width=\"1522\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EДалее несколько файлов объединяются в один примерно тем же алгоритмом, что используется и при соединении слиянием. Основное отличие состоит в том, что объединяться могут более двух файлов одновременно. \u003C\u002Fp\u003E\u003Cp\u003EДля слияния не требуется много памяти. В принципе, достаточно располагать местом под одну строку для каждого файла. Из файлов читаются первые строки, среди них выбирается минимальная (или максимальная, в зависимости от направления сортировки) и возвращается как часть результата, а на ее место читается новая строка из соответствующего файла. \u003C\u002Fp\u003E\u003Cp\u003EНа практике строки читаются не по одной, а порциями по 32 страницы, чтобы уменьшить количество операций ввода-вывода. Количество файлов, которые объединяются за одну итерацию, определяется доступным местом в памяти, но меньше шести не используется никогда. Сверху это количество тоже ограничено (числом 500), поскольку при слишком большом числе файлов эффективность теряется.\u003C\u002Fp\u003E\u003Cp\u003EЕсли объединить все отсортированные временные файлы за одну итерацию не получается, приходится выполнять слияние файлов по частям и записывать результат в новые временные файлы. Каждая такая итерация увеличивает объем записываемых и читаемых данных, поэтому чем больше оперативной памяти доступно, тем эффективнее будет выполняться внешняя сортировка.  \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"972\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Feea\u002F82b\u002F6a3\u002Feea82b6a37059b337828a06886ea3fe1.png\" data-width=\"1508\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EНа следующей итерации слияние продолжается уже с новыми файлами. \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"470\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb6e\u002F763\u002F864\u002Fb6e763864deb5a482cd526afb0263000.png\" data-width=\"1502\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EФинальное слияние обычно откладывается и выполняется на лету, когда вышестоящий узел плана запрашивает данные. \u003C\u002Fp\u003E\u003Cp\u003EКоманда \u003Ccode\u003EEXPLAIN ANALYZE\u003C\u002Fcode\u003E показывает объем дисковой памяти, который потребовался внешней сортировке. Добавив ключевое слово \u003Ccode\u003Ebuffers\u003C\u002Fcode\u003E, можно получить и статистику использования буферов временных файлов (temp read и written). Количество записанных буферов будет (примерно) равно количеству прочитанных, и именно это значение, пересчитанное в килобайты, показано в плане в позиции Disk: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (analyze, buffers, costs off, timing off, summary off) \nSELECT *\nFROM flights\nORDER BY scheduled_departure;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                            QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Sort (actual rows=214867 loops=1)\n   Sort Key: scheduled_departure\n   Sort Method: external merge Disk: 17136kB\n   Buffers: shared hit=610 read=2017, temp read=2142 written=2150 \n   −\u003E Seq Scan on flights (actual rows=214867 loops=1)\n       Buffers: shared hit=607 read=2017 \n(6 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EБолее подробную статистику использование временных файлов можно получить в журнале сообщений, установив параметр \u003Cem\u003Elog_temp_buffers\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EОценка стоимости. \u003C\u002Fstrong\u003EВ качестве примера возьмем тот же план с внешней сортировкой: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN SELECT *\nFROM flights\nORDER BY scheduled_departure;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Sort  (cost=31883.96..32421.12 rows=214867 width=63)\n   Sort Key: scheduled_departure\n   −\u003E Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)\n(3 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗдесь к обычной стоимости сравнений (количество которых остается таким же, как и в случае быстрой сортировки в памяти) добавляется стоимость ввода-вывода. Все входные данные придется сначала записать на диск во временные файлы, а затем прочитать с диска при слиянии (причем, возможно, несколько раз, если количество созданных файлов будет превышать количество одновременно объединяемых наборов). \u003C\u002Fp\u003E\u003Cp\u003EОбъем данных, попадающих на диск, определяется количеством и размером сортируемых строк. В данном случае запрос выводит все столбцы таблицы \u003Ccode\u003Eflights\u003C\u002Fcode\u003E, поэтому объем почти равен размеру всей таблицы, за вычетом служебной информации в версиях строк и страницах (2309 страниц вместо 2624). В нашем примере на сортировку хватает одной итерации. \u003C\u002Fp\u003E\u003Cp\u003EОбращение к диску (и запись, и чтение) оценивается как на три четверти последовательное и на одну четверть случайное. \u003C\u002Fp\u003E\u003Cp\u003EТаким образом стоимость сортировки в нашем плане вычисляется так: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EWITH costs(startup) AS ( \n  SELECT 4772.67 + round((\n    current_setting('cpu_operator_cost')::real * 2 * \n      214867 * log(2, 214867) +\n    (current_setting('seq_page_cost')::real * 0.75 + \n      current_setting('random_page_cost')::real * 0.25) *\n    2 * 2309 * 1 -- одна итерация \n  )::numeric, 2)\n)\nSELECT startup,\n  startup + round(( current_setting('cpu_operator_cost')::real * 214867\n  )::numeric, 2) AS total \nFROM costs;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E startup  |  total \n−−−−−−−−−−+−−−−−−−−−−\n 31883.96 | 32421.13 \n(1 row)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003EИнкрементальная сортировка\u003C\u002Fh3\u003E\u003Cp\u003EЕсли набор данных требуется отсортировать по ключам \u003Cem\u003EK\u003C\u002Fem\u003E\u003Csub\u003E1\u003C\u002Fsub\u003E ... \u003Cem\u003EK\u003Csub\u003Em\u003C\u002Fsub\u003E \u003C\u002Fem\u003E... \u003Cem\u003EK\u003Csub\u003En\u003C\u002Fsub\u003E\u003C\u002Fem\u003E, и при этом известно, что набор уже отсортирован по первым нескольким из этих ключей \u003Cem\u003EK\u003C\u002Fem\u003E\u003Csub\u003E1\u003C\u002Fsub\u003E ... \u003Cem\u003EK\u003Csub\u003Em\u003C\u002Fsub\u003E\u003C\u002Fem\u003E, то не обязательно пересортировывать весь набор заново. Можно разбить набор данных на группы, имеющие одинаковые значения начальных ключей \u003Cem\u003EK\u003C\u002Fem\u003E\u003Csub\u003E1\u003C\u002Fsub\u003E ... \u003Cem\u003EK\u003Csub\u003Em\u003C\u002Fsub\u003E \u003C\u002Fem\u003E(значения таких групп следуют друг за другом), и затем отсортировать отдельно каждую из групп по оставшимся ключам \u003Cem\u003EK\u003C\u002Fem\u003E\u003Csub\u003Em+1\u003C\u002Fsub\u003E ... \u003Cem\u003EK\u003Csub\u003En\u003C\u002Fsub\u003E\u003C\u002Fem\u003E. Такой способ называется \u003Cem\u003Eинкрементальной сортировкой\u003C\u002Fem\u003E. Он доступен начиная с версии PostgreSQL 13.\u003C\u002Fp\u003E\u003Cp\u003EИнкрементальная сортировка уменьшает требования к памяти, разбивая весь набор на несколько меньших групп, а также позволяет начать выдавать результаты после обработки первой группы, не дожидаясь сортировки всего набора. \u003C\u002Fp\u003E\u003Cp\u003EРеализация действует более тонко: отдельно обрабатываются только относительно крупные группы строк, а небольшие объединяются и сортируются полностью. Это уменьшает накладные расходы на запуск алгоритма сортировки. \u003C\u002Fp\u003E\u003Cp\u003EВ плане выполнения инкрементальная сортировка представлена узлом Incremental Sort: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (analyze, costs off, timing off, summary off) \nSELECT *\nFROM bookings\nORDER BY total_amount, book_date;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Incremental Sort (actual rows=2111110 loops=1)\n   Sort Key: total_amount, book_date\n   Presorted Key: total_amount\n   Full−sort Groups: 2823 Sort Method: quicksort Average \n   Memory: 30kB Peak Memory: 30kB\n   Pre−sorted Groups: 2624 Sort Method: quicksort Average\n   Memory: 3152kB Peak Memory: 3259kB\n   −\u003E Index Scan using bookings_total_amount_idx on bookings (ac...\n(8 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКак видно из плана, набор строк уже отсортирован по \u003Ccode\u003Etotal_amount\u003C\u002Fcode\u003E, поскольку получен сканированием индекса, построенного по этому столбцу (Presorted Key). Команда \u003Ccode\u003EEXPLAIN ANALYZE\u003C\u002Fcode\u003E показывает также статистику времени выполнения. Строка Full-sort Groups относится к строкам из небольших групп, которые были объединены и отсортированы полностью, а строка Pre-sorted Groups — к крупным группам, которые досортировывались по столбцу \u003Ccode\u003Ebook_date\u003C\u002Fcode\u003E. В обоих случаях использовалась быстрая сортировка в памяти. Наличие групп разного размера вызвано неравномерным распределением стоимости бронирований. \u003C\u002Fp\u003E\u003Cp\u003EНачиная с версии 14 инкрементальная сортировка может использоваться и для оконных функций: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off)\nSELECT row_number() OVER (ORDER BY total_amount, book_date) \nFROM bookings;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                           QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n WindowAgg\n   −\u003E Incremental Sort\n       Sort Key: total_amount, book_date\n       Presorted Key: total_amount\n       −\u003E Index Scan using bookings_total_amount_idx on bookings\n(5 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cstrong\u003EОценка стоимости. \u003C\u002Fstrong\u003EРасчет стоимости инкрементальной сортировки опирается на оценку количества групп и оценку сортировки группы среднего размера (которую мы уже рассмотрели). \u003C\u002Fp\u003E\u003Cp\u003EНачальная стоимость отражает оценки сортировки одной (первой) группы, после чего узел уже может выдавать отсортированные строки, а полная стоимость учитывает сортировку всех групп: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN SELECT *\nFROM bookings\nORDER BY total_amount, book_date;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Incremental Sort  (cost=45.10..282293.40 rows=2111110 width=21) \n   Sort Key: total_amount, book_date\n   Presorted Key: total_amount\n   −\u003E Index Scan using bookings_total_amount_idx on bookings  (co...\n(4 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПодробно останавливаться на вычислении оценок я не буду. \u003C\u002Fp\u003E\u003Ch3\u003EПараллельный режим\u003C\u002Fh3\u003E\u003Cp\u003EСортировка может выполняться параллельно. Но, хотя рабочие процессы выдают свою часть данных в отсортированном виде, узел Gather ничего не знает про упорядоченность и может объединять данные только в порядке поступления. Чтобы сохранить сортировку, применяется другой узел — Gather Merge.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (analyze, costs off, timing off, summary off) \nSELECT *\nFROM flights\nORDER BY scheduled_departure\nLIMIT 10;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Limit (actual rows=10 loops=1)\n   −\u003E Gather Merge (actual rows=10 loops=1)\n       Workers Planned: 1\n       Workers Launched: 1\n       −\u003E Sort (actual rows=8 loops=2)\n           Sort Key: scheduled_departure\n           Sort Method: top−N heapsort Memory: 27kB\n           Worker 0: Sort Method: top−N heapsort Memory: 27kB\n           −\u003E Parallel Seq Scan on flights (actual rows=107434 lo...\n(9 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EУзел Gather Merge использует двоичную кучу для упорядочения строк, поступающих от нескольких процессов. По сути, выполняется слияние нескольких отсортированных наборов строк, как при внешней сортировке, но алгоритм рассчитан на другие условия работы: на небольшое фиксированное число источников и получение строк по одной, без блочного доступа. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EОценка стоимости. \u003C\u002Fstrong\u003EНачальная стоимость узла Gather Merge опирается на начальную стоимость дочернего узла. К ней (как и в случае узла Gather) добавляется стоимость запуска процессов, которая оценивается значением параметра \u003Cem\u003Eparallel_setup_cost\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\u003Cp\u003EСюда же добавляется оценка построения двоичной кучи, что требует сортировки \u003Cem\u003En\u003C\u002Fem\u003E значений по числу параллельных процессов (то есть \u003Cem\u003En \u003C\u002Fem\u003Elog\u003Csub\u003E2\u003C\u002Fsub\u003E\u003Cem\u003En\u003C\u002Fem\u003E). Одна операция сравнения оценивается удвоенным значением параметра \u003Cem\u003Ecpu_operator_cost\u003C\u002Fem\u003E, и общая сумма обычно пренебрежимо мала, поскольку \u003Cem\u003En \u003C\u002Fem\u003Eневелико. \u003C\u002Fp\u003E\u003Cp\u003EВ полную стоимость входит получение всех данных дочерним узлом, который выполняется несколькими параллельными процессами, и стоимость пересылки строк от этих процессов. Пересылка одной строки оценивается значением параметра \u003Cem\u003Eparallel_tuple_cost\u003C\u002Fem\u003E, увеличенным на 5 %, чтобы учесть возможные потери при ожидании получения очередных значений. \u003C\u002Fp\u003E\u003Cp\u003EВ полную стоимость входит также обновление двоичной кучи. Для каждой входящей строки данных это требует log\u003Csub\u003E2\u003C\u002Fsub\u003E\u003Cem\u003En \u003C\u002Fem\u003Eопераций сравнения и определенных вспомогательных действий (которые оцениваются значением \u003Cem\u003Ecpu_operator_cost\u003C\u002Fem\u003E). \u003C\u002Fp\u003E\u003Cp\u003EВот еще один пример плана с узлом Gather Merge: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN SELECT amount, count(*) \nFROM ticket_flights\nGROUP BY amount;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                             QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Finalize GroupAggregate  (cost=123399.62..123485.00 rows=337 wid... \n   Group Key: amount\n   −\u003E Gather Merge  (cost=123399.62..123478.26 rows=674 width=14)\n       Workers Planned: 2\n       −\u003E Sort  (cost=122399.59..122400.44 rows=337 width=14)\n           Sort Key: amount\n           −\u003E Partial HashAggregate  (cost=122382.07..122385.44 r...\n               Group Key: amount\n               −\u003E Parallel Seq Scan on ticket_flights  (cost=0.00...\n(9 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭтот план интересен тем, что рабочие процессы выполняют частичную агрегацию с помощью хеширования, затем полученные результаты сортируются узлом Sort (это дешево, поскольку после агрегации остается немного строк) и передаются ведущему процессу, который собирает полный результат в узле Gather Merge. Окончательная же агрегация выполняется не хешированием, а по отсортированному списку значений. \u003C\u002Fp\u003E\u003Cp\u003EВ данном случае количество параллельных процессов равно трем (включая основной) и стоимость узла Gather Merge вычисляется так: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EWITH costs(startup, run) AS ( \n  SELECT round((\n    -- запуск процессов \n    current_setting('parallel_setup_cost')::real +\n    -- построение кучи\n    current_setting('cpu_operator_cost')::real * 2 * 3 * log(2, 3)\n  )::numeric, 2), \n  round((\n    -- передача строк\n    current_setting('parallel_tuple_cost')::real * 1.05 * 674 +\n    -- обновление кучи\n    current_setting('cpu_operator_cost')::real * 2 * 674 * log(2, 3) + \n    current_setting('cpu_operator_cost')::real * 674\n  )::numeric, 2) \n)\nSELECT 122399.59 + startup AS startup, \n  122400.44 + startup + run AS total\nFROM costs;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E  startup  |   total \n−−−−−−−−−−−+−−−−−−−−−−−\n 123399.61 | 123478.26 \n(1 row)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003EГруппировка и уникальные значения\u003C\u002Fh2\u003E\u003Cp\u003EКак мы только что видели, группировка значений для агрегации (и устранения дубликатов) может выполняться не только хешированием, но и с помощью сортировки. В отсортированном списке группы повторяющихся значений элементарно выделяются за один проход. \u003C\u002Fp\u003E\u003Cp\u003EВыбор уникальных значений из отсортированного списка представляется в плане очень простым узлом Unique:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) SELECT DISTINCT book_ref \nFROM bookings\nORDER BY book_ref;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                        QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n Result\n   −\u003E Unique\n       −\u003E Index Only Scan using bookings_pkey on bookings \n(3 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EДля агрегации используется другой узел, GroupAggregate: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EEXPLAIN (costs off) SELECT book_ref, count(*) \nFROM bookings\nGROUP BY book_ref\nORDER BY book_ref;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E                      QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n GroupAggregate\n   Group Key: book_ref\n   −\u003E Index Only Scan using bookings_pkey on bookings\n(3 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВ параллельных планах такой узел будет называться Partial GroupAggregate, а узел, завершающий агрегацию, — Finalize GroupAggregate. \u003C\u002Fp\u003E\u003Cp\u003EНачиная с версии PostgreSQL 10 обе стратегии — хеширование и сортировка — могут совмещаться в одном узле при группировке по нескольким наборам (в предложениях \u003Ccode\u003EGROUPING SETS\u003C\u002Fcode\u003E, \u003Ccode\u003ECUBE\u003C\u002Fcode\u003E или \u003Ccode\u003EROLLUP\u003C\u002Fcode\u003E). Я не буду углубляться в весьма непростые детали алгоритма. Приведу лишь один пример, в котором группировка должна вычисляться по трем разным столбцам в условиях недостаточной памяти: \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ESET work_mem = '64kB';\nEXPLAIN (costs off)\nSELECT count(*)\nFROM flights\nGROUP BY GROUPING SETS (aircraft_code, flight_no, departure_airport);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cpre\u003E\u003Ccode class=\"diff\"\u003E          QUERY PLAN \n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n MixedAggregate\n   Hash Key: departure_airport \n   Group Key: aircraft_code \n   Sort Key: flight_no\n     Group Key: flight_no \n   −\u003E Sort\n       Sort Key: aircraft_code\n       −\u003E Seq Scan on flights \n(8 rows)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВот что происходит при выполнении этого запроса. Узел агрегации, который обозначен в плане как MixedAggregate, получает набор данных, отсортированных по столбцу \u003Ccode\u003Eaircraft_code\u003C\u002Fcode\u003E. \u003C\u002Fp\u003E\u003Cp\u003EНа первом этапе этот набор сканируется и значения группируются по \u003Ccode\u003Eaircraft_code\u003C\u002Fcode\u003E (Group Key). По мере сканирования строки переупорядочиваются по столбцу \u003Ccode\u003Eflight_no\u003C\u002Fcode\u003E (так, как это делает обычный узел Sort: либо быстрой сортировкой в памяти, если ее достаточно, либо внешней сортировкой на диске) и одновременно с этим записываются в хеш-таблицу с ключом \u003Ccode\u003Edeparture_airport\u003C\u002Fcode\u003E (так, как это делает агрегация хешированием: либо в памяти, либо с использованием временных файлов). \u003C\u002Fp\u003E\u003Cp\u003EНа втором этапе сканируется набор строк, отсортированный на предыдущем этапе по столбцу \u003Ccode\u003Eflight_no\u003C\u002Fcode\u003E, и значения группируются по этому же столбцу (Sort Key и вложенный Group Key). Если бы требовалась группировка сортировкой по еще одному столбцу, на этом этапе строки бы пересортировались в том порядке, который был бы необходим дальше. \u003C\u002Fp\u003E\u003Cp\u003EНаконец, сканируется хеш-таблица, подготовленная на первом этапе, и значения группируются по столбцу \u003Ccode\u003Edeparture_airport\u003C\u002Fcode\u003E (Hash Key). \u003C\u002Fp\u003E\u003Ch2\u003EСравнение способов соединения\u003C\u002Fh2\u003E\u003Cp\u003EИтак, для соединения двух наборов данных могут использоваться три разных способа, каждый со своими достоинствами и недостатками. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСоединение вложенным циклом \u003C\u002Fem\u003Eне требует никакой подготовительной работы и начинает возвращать результирующие строки сразу же. Это единственный из способов соединения, которому не требуется просматривать внутренний набор полностью, если для него есть эффективный индексный доступ. Эти свойства делают алгоритм вложенного цикла (в сочетании с индексами) идеальным механизмом для коротких OLTP-запросов, которые строятся на небольшой выборке строк. \u003C\u002Fp\u003E\u003Cp\u003EНедостаток вложенного цикла проявляется с ростом объема данных. Для декартова произведения этот алгоритм имеет квадратичную сложность — затраты пропорциональны произведению размеров соединяемых наборов данных. Декартово произведение нечасто встречается на практике; обычно для каждой строки внешнего набора данных с помощью индекса просматривается некоторое количество строк внутреннего набора, и это среднее количество не зависит от размера всего набора данных (например, среднее количество билетов в одном бронировании не меняется с ростом количества бронирований и купленных билетов). Поэтому часто рост сложности будет линейным, а не квадратичным, хотя и с большим коэффициентом. \u003C\u002Fp\u003E\u003Cp\u003EВажная особенность вложенного цикла состоит в его универсальности: поддерживаются любые условия соединения, в то время как остальные способы работают только с эквисоединениями. Это дает возможность выполнять любые запросы с любыми условиями (кроме полного соединения, которое не реализуется вложенным циклом), но надо помнить о том, что не-эквисоединение больших объемов будет выполняться заведомо неэффективно. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСоединение хешированием \u003C\u002Fem\u003Eочень эффективно для больших наборов данных. При наличии достаточного объема памяти оно требует однократного просмотра двух наборов данных, то есть имеет линейную сложность. В сочетании с последовательным сканированием таблиц, соединение хешированием часто встречается в OLAP-запросах, вычисляющих результат на основании большого объема данных. \u003C\u002Fp\u003E\u003Cp\u003EДля ситуаций, в которых время отклика важнее пропускной способности, хеш-соединение подходит хуже, поскольку результирующие строки не могут возвращаться, пока хеш-таблица не построена полностью. \u003C\u002Fp\u003E\u003Cp\u003EПрименение хеш-соединения ограничено эквисоединениями. Кроме того, тип данных должен допускать хеширование (это выполняется почти всегда). \u003C\u002Fp\u003E\u003Cp\u003EНачиная с версии 14 вложенный цикл может иногда составить конкуренцию соединению хешированием за счет кеширования строк внутреннего набора в узле Memoize (также основанного на хеш-таблице). Выигрыш может достигаться за счет того, что соединение хешированием всегда просматривает внутренний набор строк полностью, а алгоритм вложенного цикла — нет. \u003C\u002Fp\u003E\u003Cp\u003E\u003Cem\u003EСоединение слиянием \u003C\u002Fem\u003Eотлично подходит и для коротких OLTP-запросов, и для длинных запросов OLAP. Оно имеет линейную сложность (требуется однократный просмотр соединяемых наборов строк), не требовательно к памяти и выдает результаты без предварительной подготовки. Единственная сложность состоит в том, что наборы данных должны быть отсортированы в правильном порядке. Наиболее эффективный способ добиться этого — получать данные от индексного сканирования. Это естественный вариант для небольшого количества строк; при большом объеме данных индексный доступ тоже может быть эффективен, если это только индексное сканирование с минимальными обращениями к таблице или вовсе без них. \u003C\u002Fp\u003E\u003Cp\u003EЕсли подходящих индексов нет, то наборы данных придется сортировать, а сортировка требует памяти и имеет сложность выше линейной: O(\u003Cem\u003En \u003C\u002Fem\u003Elog\u003Csub\u003E2\u003C\u002Fsub\u003E\u003Cem\u003En\u003C\u002Fem\u003E). В таком случае соединение слиянием почти всегда проигрывает соединению хешированием — за исключением ситуации, когда результат нужен отсортированным. \u003C\u002Fp\u003E\u003Cp\u003EК приятным свойствам соединения слиянием относится равноценность внешнего и внутреннего наборов строк. Эффективность и вложенного цикла, и хеш-соединения сильно зависит от того, правильно ли планировщик выберет, какой из наборов данных поставить внешним, а какой — внутренним. \u003C\u002Fp\u003E\u003Cp\u003EПрименение соединения слиянием ограничено эквисоединениями. Кроме того, тип данных должен иметь класс операторов для B-дерева. \u003C\u002Fp\u003E\u003Cp\u003EНа графике показана примерная зависимость стоимостей различных способов соединений двух таблиц от доли соединяемых строк. \u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"924\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F97c\u002F2d5\u002Ffcc\u002F97c2d5fccf4889595986d16c2c830f52.png\" data-width=\"1512\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСоединение вложенным циклом при высокой селективности использует индексный доступ к обоим таблицам; затем планировщик переключается на полное сканирование внешней таблицы и график становится линейным. \u003C\u002Fp\u003E\u003Cp\u003EСоединения хешированием использует в этом примере полное сканирование обоих таблиц. «Ступенька» на графике возникает в тот момент, когда хеш-таблица перестает помещаться в оперативной памяти и пакеты начинают сбрасываться на диск. \u003C\u002Fp\u003E\u003Cp\u003EСоединение слиянием с использованием индекса показывает небольшой линейный рост стоимости. При достаточном объеме \u003Cem\u003Ework_mem \u003C\u002Fem\u003Eсоединение хешированием обычно оказывается эффективнее, но, когда дело доходит до временных файлов, соединение слиянием выигрывает. \u003C\u002Fp\u003E\u003Cp\u003EВерхний график соединения слиянием с сортировкой показывает рост стоимости в ситуации, когда индексы недоступны, и данные приходится сортировать. Как и в случае хеширования, «ступенька» на графике вызвана недостатком памяти и необходимостью использовать для сортировки временные файлы. \u003C\u002Fp\u003E\u003Cp\u003EЭто только пример; в каждом конкретном случае соотношения стоимостей, разумеется, будут отличаться. \u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EНа этом я остановлюсь. Нельзя объять необъятное, но думаю, что основные моменты я охватил.\u003C\u002Fp\u003E\u003Cp\u003EМатериал этой и прошлых серий статей лег в основу книги, над которой я сейчас работаю, и которая, надеюсь, увидит свет уже в конце этого года. Спасибо всем, кто меня читает — ваши комментарии позволяют улучшить текст.\u003C\u002Fp\u003E\u003Cp\u003EОставайтесь с нами!\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"оптимизация"},{"titleHtml":"планирование"},{"titleHtml":"соединения"},{"titleHtml":"слияние"},{"titleHtml":"сортировка"},{"titleHtml":"новый редактор никуда не годится"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F78b\u002F71b\u002F5d3\u002F78b71b5d35a0c717ab2bd664367ae88a.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F78b\u002F71b\u002F5d3\u002F78b71b5d35a0c717ab2bd664367ae88a.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpostgrespro\\\u002Fblog\\\u002F582058\\\u002F\"},\"headline\":\"Запросы в PostgreSQL: 7. Сортировка и слияние\",\"datePublished\":\"2021-10-07T01:41:30+03:00\",\"dateModified\":\"2021-10-07T01:41:30+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Егор Рогов\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным &mdash; последовательное сканирование и индексное ск...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpostgrespro\\\u002Fblog\\\u002F582058\\\u002F#post-content-body\",\"about\":[\"c_postgrespro\",\"h_postgresql\",\"h_sql\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F582058\\\u002F0b1829179219b61587448963e71f506f\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F0f8\\\u002F421\\\u002F7b4\\\u002F0f84217b4b0c7674a33db9888f328ba2.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F817\\\u002F9b1\\\u002F891\\\u002F8179b1891ad33781a7ea1442714b199a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Feea\\\u002F82b\\\u002F6a3\\\u002Feea82b6a37059b337828a06886ea3fe1.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb6e\\\u002F763\\\u002F864\\\u002Fb6e763864deb5a482cd526afb0263000.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F97c\\\u002F2d5\\\u002Ffcc\\\u002F97c2d5fccf4889595986d16c2c830f52.png\"]}","metaDescription":"В предыдущих статьях я писал про этапы выполнения запросов, про статистику, про два основных вида доступа к данным — последовательное сканирование и индексное сканирование, — и успел рассказать о двух...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"postgrespro":{"alias":"postgrespro","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F4e0\u002F339\u002F621\u002F4e0339621abc865fefb88f9e9f44748f.jpg","titleHtml":"Postgres Professional","descriptionHtml":"Разработчик СУБД Postgres Pro","relatedData":null,"statistics":{"postsCount":152,"newsCount":0,"vacanciesCount":0,"employeesCount":22,"careerRating":null,"subscribersCount":41954,"rating":214.73,"invest":null},"foundationDate":{"year":"2015","month":"01","day":"27"},"location":{"city":{"id":"447159","title":"Москва"},"region":{"id":"1885","title":"Москва и Московская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"http:\u002F\u002Fwww.postgrespro.ru\u002F","staffNumber":"51–100 человек","registrationDate":"2015-09-30T07:41:09+00:00","representativeUser":{"alias":"x-wao","fullname":"Иван Панченко"},"contacts":[{"title":"Facebook","url":"https:\u002F\u002Ffacebook.com\u002FPostgresProfessional"},{"title":"Twitter","url":"https:\u002F\u002Ftwitter.com\u002FPostgresPro"},{"title":"ВКонтакте","url":"https:\u002F\u002Fvk.com\u002Fpublic101507899"},{"title":"Google+","url":"https:\u002F\u002Fplus.google.com\u002F+PostgresproRuCompany"},{"title":"LiveJournal","url":"https:\u002F\u002Fpostgrespro.livejournal.com\u002F"}],"settings":{"analyticsSettings":[{"type":"ga","trackingId":"UA-55152600-4"}],"branding":null,"status":"active"},"metadata":{"titleHtml":"Postgres Professional, Москва - Разработчик СУБД Postgres Pro с 27 января 2015 г.","title":"Postgres Professional, Москва - Разработчик СУБД Postgres Pro с 27 января 2015 г.","keywords":["PostgreSQL","SQL","Занимательные задачки","Конференции","Администрирование баз данных"],"descriptionHtml":"152 статьи от авторов компании Postgres Professional","description":"152 статьи от авторов компании Postgres Professional"},"aDeskSettings":null,"careerAlias":"postgrespro","maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
