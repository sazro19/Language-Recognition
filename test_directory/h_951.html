<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Android, Kotlin Flow во ViewModel — все сложно / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/581914\/"},"headline":"Android, Kotlin Flow во ViewModel — все сложно","datePublished":"2021-10-06T15:14:22+03:00","dateModified":"2021-10-06T15:14:22+03:00","author":{"@type":"Person","name":"Firsov Maxim"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому...","url":"https:\/\/habr.com\/ru\/post\/581914\/#post-content-body","about":["h_mobile_dev","h_android_dev","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/581914\/a7be16de85e974c4a29b758b3d0789a1\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/628\/2e6\/bf0\/6282e6bf07eaa5791987a2ed62f152ad.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/b40\/3b5\/d7c\/b403b5d7c91b7a8b30234e850fc6dbac.jpeg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/f91\/872\/749\/f91872749e9d6e05345be8de76c729d4.jpeg","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/e76\/702\/3c0\/e767023c06977a4e9751b6c87ac0c042.jpeg"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Android, Kotlin Flow во ViewModel — все сложно" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Android, Kotlin Flow во ViewModel — все сложно" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Android, Kotlin Flow во ViewModel — все сложно" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому что все это приводит к уничтожению и..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому что все это приводит к уничтожению и..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому что все это приводит к уничтожению и..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому что все это приводит к уничтожению и..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому что все это приводит к уничтожению и..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/3de/a4d/720/3dea4d72029f51afff6cca023003f118.jpg" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/3de/a4d/720/3dea4d72029f51afff6cca023003f118.jpg" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/3de/a4d/720/3dea4d72029f51afff6cca023003f118.jpg" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/3de/a4d/720/3dea4d72029f51afff6cca023003f118.jpg" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/3de/a4d/720/3dea4d72029f51afff6cca023003f118.jpg" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="581914" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-06T12:14:22.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/581914/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/581914/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/3de/a4d/720/3dea4d72029f51afff6cca023003f118.jpg" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/581914/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/FirsofMaxim/" title="FirsofMaxim" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/120/859/bc8/120859bc81ec070471cb5db3a6fa4401.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/FirsofMaxim/" class="tm-user-info__username">
      FirsofMaxim
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-06T12:14:22.000Z" title="2021-10-06, 15:14">6  октября   в 15:14</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Android, Kotlin Flow во ViewModel — все сложно</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/mobile_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка мобильных приложений</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/android_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка под Android</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://bladecoder.medium.com/kotlins-flow-in-viewmodels-it-s-complicated-556b472e281a" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Christophe Beyls
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и <strong>изменения конфигурации</strong>, потому что все это приводит к уничтожению и восстановлению Activity.</p><p>Отдельные экраны приложения постоянно переключаются между активным и неактивным состоянием, когда пользователь ходит вперед назад по экранам, переключается с одного приложения на другое, блокирует и разблокирует экран. Каждый компонент должен выполнять активную работу в нужном состоянии экрана.</p><p><strong>Изменения конфигурации</strong> происходят в случаях:</p><ul><li><p>при изменении ориентации экрана;</p></li><li><p>когда приложение переключается в мульти-оконный режим;</p></li><li><p>при переключении визуальной темы смартфона;</p></li><li><p>при изменении системных настроек - языка, шрифтов и т.д.</p></li></ul><h2>Повышаем эффективность</h2><p>Для улучшения пользовательского опыта, эффективная загрузка данных во Fragment и Activity должна учитывать следующие правила:</p><ol><li><p><strong>Кеширование</strong>: актуальные загруженные данные, должны быть доставлены немедленно и не загружаться повторно. В частности, когда существующий Fragment или Activity становятся видимыми снова или Activity пересоздается после изменения конфигурации.</p></li><li><p><strong>Избегать фоновую работу</strong>: когда Activity или Fragment скрываются (состояние изменяется со <code>STARTED</code> на <code>STOPPED</code>), любая работа по загрузке внешних данных должна вставать на паузу или отменяться для экономии ресурсов. Это особенно важно для бесконeчных потоков данных, как например геолокация или периодическое обновление каких-либо данных.</p></li><li><p><strong>Работа не прерывается при изменении конфигурации</strong>: это исключение из правила #2, Во время смены конфигурации, текущая Activity заменяется новым экземпляром с сохранением состояния, поэтому отменять текущую работу в старом экземпляре Activity и перезапускать работу при создании нового экземпляра Activiti было бы контр продуктивно.</p></li></ol><h3>Современный подход: ViewModel и LiveData</h3><p>В 2017 Google зарелизила первый набор библиотек <a href="https://developer.android.com/topic/libraries/architecture" rel="noopener noreferrer nofollow"><strong>Architecture Components</strong></a>{:target="_blank"}, там появились <strong>ViewModel</strong> и <strong>LiveData</strong> компоненты, которые помогают разработчикам эффективно работать с данными, поддерживая все 3 правила выше. </p><p><a href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener noreferrer nofollow"><strong>ViewModel</strong></a>{:target="_blank"}, сохраняет данные при изменении конфигурации, используется для достижения правил #1 и #3: операции загрузки выполняются непрерывно во время изменения конфигурации, полученные данные могут кешироваться и совместно использоваться одним, или несколькими Fragment или Activity.</p><p><a href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener noreferrer nofollow"><strong>LiveData</strong></a>{:target="_blank"}, простой контейнер данных, поддерживающий подписку на изменения и учитывающий жизненный цикл компонентов Android. Новые данные отправляются наблюдателям только когда их жизненный цикл в состоянии не менее <code>STARTED</code> (видимый), наблюдатели отписываются автоматически, что избавляет от утечек памяти. <code>LiveData</code> используется для достижения правил #1 и #2: кеширует последнее значение данных и это значение автоматически отправляется новым наблюдателям. В дополнение, LiveData уведомляет, когда в состоянии <code>STARTED</code> больше нет наблюдателей и можно избежать ненужной фоновой работы.</p><figure class="full-width "><img src="/img/image-loader.svg" alt="ViewModel scope." title="ViewModel scope." height="543" data-src="https://habrastorage.org/getpro/habr/upload_files/628/2e6/bf0/6282e6bf07eaa5791987a2ed62f152ad.png" data-width="522"/><figcaption>ViewModel scope.</figcaption></figure><blockquote><p>Опытный разработчик, как правило уже знаком со всем этим. Но важно вспомнить все возможности, чтобы сравнить их с <strong>Flow</strong>.</p></blockquote><h3>LiveData + Coroutines</h3><p>LiveData довольна ограничена по сравнению с реактивными решениями (например RxJava):</p><ul><li><p>передает и берет данные только на главном потоке (main thread). Интересно, что оператор <code>map</code> выполняет трансформацию объектов на главном потоке и не может использоваться на I/O потоках или для тяжелых вычислений на CPU. Для этого используется оператор <code>switchMap</code> совместно с ручным запуском асинхронной операции в нужном потоке, даже если в основной поток надо отправить единственное значение.</p></li><li><p>есть только 3 оператора преобразования для LiveData: <code>map()</code>, <code>switchMap()</code> и <code>distinctUntilChanged()</code>. Если вам нужно больше, вы должны сами это сделать, используя <code>MediatorLiveData</code>.</p></li></ul><p>Чтобы преодолеть эти ограничения, библиотеки Jetpack дают специальные "мосты" из LiveData для других технологий, таких как RxJava или Kotlin корутины.</p><p>Самый простой и наиболее элегантный из них, по мнению автора, это <a href="https://developer.android.com/topic/libraries/architecture/coroutines#livedata" rel="noopener noreferrer nofollow"><strong>LiveData coroutine builder</strong></a>, подключается через <code>androidx.lifecycle:lifecycle-livedata-ktx</code> Gradle зависимость. Этот функционал похож на <code>flow {} builder function</code> из библиотеки Kotlin Coroutines и позволяет грамотно обернуть корутину в экземпляр LiveData:</p><pre><code class="kotlin">val result: LiveData&lt;Result> = liveData {
    val data = someSuspendingFunction()
    emit(data)
}</code></pre><ul><li><p>Вы можете использовать все силу корутин, их контекстов для написания асинхронного кода в синхронной манере без колбеков, автоматически переключаясь между нужными потоками;</p></li><li><p>Новые значения отправляются наблюдателям LiveData в главном потоке через <em>suspending</em> методы <code>emit()</code> или <code>emitSource()</code> из корутины;</p></li><li><p>Корутина использует специальную область видимости (scope) и жизненный цикл привязанный к экземпляру LiveData. Когда LiveData становится <em>неактивной</em> (это значит, что больше нет наблюдателей в состоянии <code>STARTED</code>), то корутина будет автоматически отменена, работает правило #2;</p></li><li><p>В реальности отмена корутины будет <strong>задержана на 5 секунд</strong> после того как LiveData станет неактивной для правильной обработки смены конфигурации: если новая Activity немедленно заменит старую и LiveData станет активной до срабатывания задержки, то отмена корутины не будет и цена перезапуска будет нулевой (правило #3);</p></li><li><p>если пользователь вернется назад на экран и LiveData станет активной, то корутина автоматически перезапустится, но только если она была отменена до завершения. Как только корутина завершится, она больше не будет перезапускаться, те же данные не будут загружаться дважды, если входные параметры не изменились (правило #1).</p></li></ul><p>Вывод: используйте LiveData coroutines builder, это дает простой код и лучшее поведение по умолчанию.</p><p>А что если, репозиторий возвращает <em>поток значений</em> в форме <code>Flow</code> (вместо <em>suspend</em> функций с единственным значением)? В этом случае также возможно сконвертировать поток в LiveData и использовать все преимущества перечисленные выше, используя <code>asLiveData()</code> функцию-расширение.</p><pre><code class="kotlin">val result: LiveData&lt;Result> = someFunctionReturningFlow().asLiveData()</code></pre><p>Внутри <code>asLiveData()</code> также использует LiveData coroutines builder для создания простой корутины обрабатывающий Flow пока LiveData активна:</p><pre><code class="kotlin">fun &lt;T> Flow&lt;T>.asLiveData(): LiveData&lt;T> = liveData {
    collect {
        emit(it)
    }
}</code></pre><p>Но давайте остановимся ненадолго – что такое <code>Flow</code> и можно ли им полностью заменить LiveData?</p><h3>Введение в Kotlin Flow</h3><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/b40/3b5/d7c/b403b5d7c91b7a8b30234e850fc6dbac.jpeg" width="700" height="482" data-src="https://habrastorage.org/getpro/habr/upload_files/b40/3b5/d7c/b403b5d7c91b7a8b30234e850fc6dbac.jpeg" data-blurred="true"/><figcaption></figcaption></figure><p><a href="https://kotlinlang.org/docs/flow.html" rel="noopener noreferrer nofollow"><strong>Flow</strong></a> это класс из библиотеки <a href="https://github.com/Kotlin/kotlinx.coroutines" rel="noopener noreferrer nofollow">Kotlin Coroutines</a> представленной в 2019 году, класс является потоком значений, вычисляемый асинхронно. Концептуально похож на RxJava Observable, но основан на корутинах и имеет более простой API.</p><p>Изначально были доступны только <strong>холодные потоки</strong> (cold flows): потоки без состояний, которые создаются по требованию каждый раз, когда наблюдатель начинает собирать значения в области видимости (scope) корутины. Каждый наблюдатель получает собственную последовательность значений, они не общие.</p><p>Позже были добавлены новые <strong>горячие потоки</strong> подтипы Flow: <code>SharedFlow</code> и <code>StateFlow</code>. Они были выпущены со стабильной реализацией API в версии библиотеки корутин #1.4.0.</p><p><code>SharedFlow</code> публикует данные, которые распространяются всем слушателям. Класс может управлять дополнительным кешем и/или буфером и фактически заменяет все варианты устаревшего <code>BroadcastChannel</code> API.</p><p><code>StateFlow</code> специально оптимизированный подкласс <code>SharedFlow</code>, который хранит и воспроизводит только последнее значение. Что-то знакомое, да? </p><h2>StateFlow и LiveData много общего:</h2><ul><li><p>Эти классы наблюдаемые (observable)</p></li><li><p>Они хранят и распространяют последнее значение любому количеству наблюдателей</p></li><li><p>Они заставляют перехватывать ошибки на ранней стадии: необработанное исключение (<code>Exception</code>) в колбеке LiveData останавливает приложение. Не пойманное исключение в горячем Flow потоке завершает поток без возможности перезапустить его, даже если использовать оператор <code>.catch()</code>.</p></li></ul><h2>Но есть и важные отличия:</h2><ul><li><p><code>MutableStateFlow</code> требует начального значения, в отличие от <code>MutableLiveData</code>. Замечание: <code>MutableSharedFlow(replay = 1)</code>  может эмулировать <code>MutableStateFlow</code> без начального значения, но данная реализация менее эффективна.</p></li><li><p><code>StateFlow</code> всегда фильтрует повторяющиеся значения с помощью сравнения <code>Any.equals()</code>, <code>LiveData</code> так не делает, для этого следует подключить оператор <code>distinctUntilChanged()</code> (замечание: <code>SharedFlow</code> не имеет такого поведения).</p></li><li><p><code>StateFlow</code> не учитывает жизненный цикл (<strong>not lifecycle-aware</strong>). Однако, <code>Flow</code> может быть использовано в корутине с учетом жизненного цикла, это требует некоторого кода для настройки без использования LiveData (детали ниже).</p></li><li><p><code>LiveData</code> использует "версионность", чтобы управлять отправкой значений наблюдателям. При помощи этого наблюдатель не получит дважды одного и того же значения при переходе обратно в состояние <code>STARTED</code>. <code>StateFlow</code> не использует "версионность". Каждый раз, когда корутина собирает данные <code>Flow</code>, она рассматривается как <strong>новый наблюдатель</strong> и всегда будет получать сначала последнее значение. Из-за этого может быть дублирование работы, как мы увидим на следующем примере.</p></li></ul><h3>Наблюдение за LiveData против сбора данных в Flow</h3><p>Организовать наблюдение за экземпляром LiveData довольно просто:</p><pre><code class="kotlin">viewModel.results.observe(viewLifecycleOwner) { data ->
    displayResult(data)
}</code></pre><p>Эта операция однократная и дальше LiveData берет на себя синхронизацию потока данных с жизненным циклом наблюдателей.</p><p>Аналогичная операция для Flow называется <em>сбором</em> (collecting) и сбор должен выполняться в корутине. Из-за того, что Flow не знает ничего о жизненном цикле, ответственность за жизненный цикл возлагают на корутину, работающую с Flow.</p><p>Чтобы создать корутину для работы с Flow, учитывающую жизненный цикл Activity/Fragment (запускать работу с данными при состоянии <code>STARTED</code> и автоматически отменять эту работу при уничтожении):</p><pre><code class="kotlin">viewLifecycleOwner.lifecycleScope.launchWhenStarted {
    viewModel.result.collect { data ->
        displayResult(data)
    }
}</code></pre><p>Но здесь есть серьезное ограничение: <strong>код будет работать правильно только с "холодными" потоками, без поддержки каналом или буфером</strong>. Такой Flow управляется только собирающей его корутиной: когда Activity/Fragment перейдет в состояние <code>STOPPPED</code>, корутина приостановится, производитель Flow также приостановится с ней, и больше ничего не произойдет пока корутина не возобновится.</p><p>Однако, есть и другие виды Flow:</p><ul><li><p><strong>горячие потоки</strong>, которые всегда активные и посылают результаты всем текущим наблюдателями (включая приостановленные);</p></li><li><p><strong>холодные потоки с колбэком или поддержкой канала</strong>, которые подписываются на активный источник данных, когда сбор данных запускается и останавливает подписку, когда сбор данных отменяется (не приостанавливается).</p></li></ul><p>В этих случаях, <strong>основной производитель Flow будет оставаться активным</strong> даже когда корутина будет приостановлена, сохраняя (в буфер) новые результаты в фоновом режиме. Ресурсы расходуются впустую, правило #2 нарушается.</p><figure class=""><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/f91/872/749/f91872749e9d6e05345be8de76c729d4.jpeg" width="500" height="735" data-src="https://habrastorage.org/getpro/habr/upload_files/f91/872/749/f91872749e9d6e05345be8de76c729d4.jpeg" data-blurred="true"/><figcaption></figcaption></figure><p>Нужно создать более безопасный способ сборки Flow любого типа. Корутина работающая с потоком данных, должна быть отменена когда Activity/Fragment становится невидимой и перезапущена снова, так же как это делает LiveData-Coroutine-Builder. Для этого был представлен новый API в <code>lifecycle:lifecycle-runtime-ktx:2.4.0</code> (остается в статусе alpha на момент написания статьи, на момент перевода - перешел в beta).</p><pre><code class="kotlin">viewLifecycleOwner.lifecycleScope.launch {
    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.result.collect { data ->
            displayResult(data)
        }
    }
}</code></pre><p>Или аналогично:</p><pre><code class="kotlin">viewLifecycleOwner.lifecycleScope.launch {
    viewModel.result
.flowWithLifecycle(viewLifecycleOwner.lifecycle, Lifecycle.State.STARTED)
        .collect { data ->
            displayResult(data)
        }
}</code></pre><p>Как видно, эффективно и безопасно работать с данными в Actvivity или Fragment проще с помощью LiveData.</p><blockquote><p>Можно посмотреть дополнительную информацию о новом API в статье "<a href="https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda" rel="noopener noreferrer nofollow"><strong><em>A safer way to collect flows from Android UIs</em></strong></a><strong><em>"</em></strong> от Manuel Vivo.</p></blockquote><h3>Заменяем LiveData на StateFlow во ViewModel</h3><p>Давайте-ка вернемся к ViewModel. Мы убедились, что это простой и эффективный способ работы с данными в асинхронном режиме:</p><pre><code class="kotlin">val result: LiveData&lt;Result> = liveData {
    val data = someSuspendingFunction()
    emit(data)
}</code></pre><p>Как мы можем добиться того же самого, используя <code>StateFlow</code> вместо <code>LiveData</code>? <em>Jose Alcérreca</em> написал <a href="https://medium.com/androiddevelopers/migrating-from-livedata-to-kotlins-flow-379292f419fb" rel="noopener noreferrer nofollow">внушительное руководство</a> для ответа на этот вопрос. Вкратце, для случая выше, код будет выглядеть так:</p><pre><code class="kotlin">val result: Flow&lt;Result> = flow {
    val data = someSuspendingFunction()
    emit(data)
}.stateIn(
    scope = viewModelScope,
    started = SharingStarted.WhileSubscribed(5000L),
    initialValue = Result.Loading
)</code></pre><p>Оператор <code>stateIn()</code> трансформирует наш холодный Flow в горячий, способный делиться одним и тем же результатом между разными наблюдателями. Благодаря <code>SharingStarted.WhileSubscribed(5000L)</code>, горячий поток запускается лениво при подписке первого наблюдателя и отменяется через 5 секунд, когда последний наблюдатель отпишется, что позволяет избегать лишней работы в фоновом режиме и при этом сохраняется работа при смене конфигурации. Кроме того, как только исходящий поток данных достигнет конца, он не будет перезапущен автоматически, этим мы избегаем двойной работы.</p><p><strong>Похоже, что мы сумели выполнить 3 наших правила и воспроизвести почти такое же поведение как у LiveData с использованием более сложного кода.</strong></p><p>Все же еще остается небольшая, но важная разница: каждый раз когда Activity/Fragment становится видимым снова, начинается новый сбор потока и <code>StateFlow</code>  всегда будет отправлять последний результат наблюдателю немедленно. <strong>Даже если этот же результат был уже доставлен в тот же самый Activity/Fragment во время последнего сбора данных.</strong> Потому что <code>StateFlow</code> не поддерживает версионность (в отличие от LiveData) и каждый новый сбор потока данных - это новый подписчик.</p><p>Это проблематично? Для простых случаев нет, Activity или Fragment могут сделать дополнительную проверку, чтобы не делать лишнее обновление UI, если данные не изменились.</p><pre><code class="kotlin">viewLifecycleOwner.lifecycleScope.launch {
    viewModel.result
        .flowWithLifecycle(viewLifecycleOwner.lifecycle, Lifecycle.State.STARTED)
        .distinctUntilChanged()
        .collect { data ->
            displayResult(data)
        }
}</code></pre><p>Проблемы возникают в более сложных, реальных случаях, как мы увидим в следующем разделе.</p><h2>Использование StateFlow как триггер во ViewModel</h2><p>Подход на основе триггера обычно используется во ViewModel: каждый раз когда значение триггера изменяется - данные обновляются.</p><p><code>MutableLiveData</code> для этого работает очень хорошо:</p><pre><code class="kotlin">class MyViewModel(repository: MyRepository) : ViewModel() {
    private val trigger = MutableLiveData&lt;String>()

    fun setQuery(query: String) {
        trigger.value = query
    }

    val results: LiveData&lt;SearchResult>
            = trigger.switchMap { query ->
        liveData {
            emit(repository.search(query))
        }
    }
}</code></pre><ul><li><p>При обновлении, оператор <code>switchMap()</code> подключает наблюдателей к новому источнику LiveData, заменяя старый. И так как в примере выше, используется LiveData coroutine builder, старая LiveData автоматически отменит связанную с ним корутину через 5 секунд после отключения от своих наблюдателей. Работа с устаревшими данными прекращается с небольшой задержкой.</p></li><li><p>Так как в LiveData есть версионность, <code>MutableLiveData</code> триггер отправит новое значение <strong>только один раз</strong> оператору <code>switchMap()</code>, как только появится хотя бы один активный наблюдатель. Позже, если наблюдатели становятся неактивными и активными снова, работа источника данных LiveData просто возобновится с последними данными, где она остановилась.</p></li></ul><p>Этот код достаточно прост и соблюдает все правила по эффективности выше.</p><p>Давайте посмотрим, можно ли реализовать ту же самую логику с классом <code>MutableStateFlow</code> вместо <code>MutableLiveData</code>.</p><h3>Наивный подход</h3><pre><code class="kotlin">class MyViewModel(repository: MyRepository) : ViewModel() {
    private val trigger = MutableStateFlow("")

    fun setQuery(query: String) {
        trigger.value = query
    }

    val results: Flow&lt;SearchResult> = trigger.mapLatest { query ->
        repository.search(query)
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000L),
        initialValue = SearchResult.EMPTY
    )
}</code></pre><p>API <code>MutableLiveData</code> и <code>MutableLiveData</code> выглядят очень похоже, код триггера выглядит почти одинаково. Самое большое различие это использование <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map-latest.html" rel="noopener noreferrer nofollow"><strong>mapLatest</strong></a>, это эквивалент функции <code>switchMap()</code> в LiveData для возвращения единственного значения (для возвращения нескольких значений, надо использовать <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html" rel="noopener noreferrer nofollow"><strong>flatMapLatest</strong></a>).</p><p><code>mapLatest()</code> работает как <code>map()</code>, но вместо полного преобразования по порядку всех входных значений, входные значения используются немедленно, а преобразование происходит в <strong>отдельной корутине</strong> асинхронно. При появлении нового значения во входящем потоке данных, трансформация предыдущего значения будет <strong>немедленно отменена</strong>, если она все еще работала и вместо нее будет запущена новая трансформация. Таким образом можно избежать работы с устаревшими данными.</p><p>Вроде выглядит неплохо. Однако здесь всплывает основная проблема: так как <code>StateFlow</code> не поддерживает версионность, триггер отправит <strong>повторно последнее значение</strong>, когда Flow перезапустится. Это случается <strong>каждый раз, когда Activity/Frgament становится видимым опять</strong>, после того, как был невидимым более 5 секунд.</p><figure class="full-width "><img src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/e76/702/3c0/e767023c06977a4e9751b6c87ac0c042.jpeg" width="700" height="393" data-src="https://habrastorage.org/getpro/habr/upload_files/e76/702/3c0/e767023c06977a4e9751b6c87ac0c042.jpeg" data-blurred="true"/><figcaption></figcaption></figure><p>Триггер выдает значение повторно, <code>mapLatest()</code> снова запускается, еще раз дергается метод в репозитории с теми же аргументами, хотя результат уже был получен и обработан. Правило #1 не работает: актуальные данные не должны загружаться повторно.</p><h3>Чиним повторную отправку последнего сообщения</h3><p>Вопросы приходящие на ум: должны ли мы предотвращать повторную отправку и как это сделать? <code>StateFlow</code> уже позаботился об этом <em>внутри коллекции flow</em> и оператор <code>distinctUntilChanged()</code> делает то же самое для других типов flow. При этом нет стандартного оператора для отмены повторной отправки среди множества коллекций одного и того же flow, потому что flow коллекции должны быть <strong>самодостаточные</strong>. Это главная разница с LiveData.</p><p>В конкретном случае flow разделяемого между несколькими наблюдателями с использованием оператора <code>stateIn()</code>, исходящие значения будут кешироваться и в любой момент времени будет только одна корутина обрабатывающая эти значения. Можно попробовать взломать какой-нибудь оператор, который будет запоминать последнее значение предыдущей коллекции, чтобы пропустить его, когда запускается новая коллекция (не делайте так на работе, да и дома тоже):</p><pre><code class="kotlin">// Don't do this at home (or at work)
fun &lt;T> Flow&lt;T>.rememberLatest(): Flow&lt;T> {
    var latest: Any? = NULL
    return flow {
        collectIndexed { index, value ->
            if (index != 0 || value !== latest) {
                emit(value)
                latest = value
            }
        }
    }
}</code></pre><blockquote><p>Примечание: внимательный читатель может заметить, что такое же поведение достигается за счет замены <code>MutableStateFlow</code> с <code>Channel(capacity = CONFLATED)</code> и затем превратиь его в Flow с использованием <code>receiveAsFlow()</code>. Сhannel никогда не передают значение повторно.</p></blockquote><p>К сожалению, <strong>логика в коде выше несовершенна</strong> и перестанет работать, как задумано, когда трансформация flow будет <strong>отменена до завершения</strong>.</p><p>Код предполагает, что после возврата <code>emit(value)</code>, значение было обработано и не должно быть выдано снова, если сбор flow перезапустится, но <strong>это так, только при использовании не буферизированных Flow операторов</strong>. Операторы, подобные <code>mapLatest()</code>, буферизированные и в этом случае <code>emit(value)</code> вернется немедленно, при этом преобразование выполняется асинхронно. Это значит, что нет способа узнать, когда значение было обработано flow. Если сбор flow отменяется в середине асинхронного преобразования, нам все равно придется повторно сделать <code>emit</code> последнего значения, когда сбор flow возобновится, чтобы возобновить преобразование, иначе значение будет потеряно.</p><blockquote><p><strong>TL;DR</strong> Использование <code>StateFlow</code> в качестве триггера в ViewModel приводит к дублирующейся работе каждый раз когда Activity/Fragment становится видимой повторно и здесь нет простого пути избежать такого поведения.</p></blockquote><p>Вот почему <code>LiveData</code> предпочтительнее <code>StateFlow</code> при использовании как триггер во ViewModel. Эти различия не упоминаются в Codelab от Google - <a href="https://developer.android.com/codelabs/advanced-kotlin-coroutines#11" rel="noopener noreferrer nofollow">Advanced coroutines with Kotlin Flow</a>, там подразумевается, что реализация на Flow ведет себя так же как на LiveData. Но это не так.</p><h2>Выводы</h2><p>Мои рекомендации на основании примеров выше:</p><ul><li><p>Продолжайте использовать LiveData в вашем Android-UI слое и ViewModels, особенно в качестве триггера. Используйте это везде, для передачи данных в Activity/Fragment: код будет простым и эффективным;</p></li><li><p><strong>LiveData coroutine builder</strong> ваш друг и может заменить Flows во ViewModels в большинстве случаев;</p></li><li><p>Вы можете использовать мощь Flow операторов при необходимости, конвертируя Flows в LiveData;</p></li><li><p>Flow лучше подходит, чем LiveData, для других слоев приложения, таких как - репозитории, источники данных и т.д., они не завязаны на платформенные особенности Android и их будет легче тестировать.</p></li></ul><p>Теперь вы знаете все компромиcсы при переходе от LiveData к подходу "полностью на Flow" в вашем Android-UI слое.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bandroid%5D" class="tm-tags-list__link">android</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bkotlin%5D" class="tm-tags-list__link">kotlin</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bflow%5D" class="tm-tags-list__link">flow</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bviewmodel%5D" class="tm-tags-list__link">viewmodel</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/mobile_dev/" class="tm-hubs-list__link">
    Разработка мобильных приложений
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/android_dev/" class="tm-hubs-list__link">
    Разработка под Android
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 3: ↑3 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 3: ↑3 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+3</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">3.8K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    30
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/FirsofMaxim/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/120/859/bc8/120859bc81ec070471cb5db3a6fa4401.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 25 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    15
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">1.5</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Firsov Maxim</span> <a href="/ru/users/FirsofMaxim/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @FirsofMaxim
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Mobile developer</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/581914/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 6 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/581914/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/581914/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"581914":{"id":"581914","timePublished":"2021-10-06T12:14:22+00:00","isCorporative":false,"lang":"ru","titleHtml":"Android, Kotlin Flow во ViewModel — все сложно","leadData":{"textHtml":"\u003Cp\u003EСравним Kotlin-Flow и ViewModel в Android приложении, посмотрим в чем отличия и узнаем сильные стороны каждого подхода.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3de\u002Fa4d\u002F720\u002F3dea4d72029f51afff6cca023003f118.jpg","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3de\u002Fa4d\u002F720\u002F3dea4d72029f51afff6cca023003f118.jpg","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Christophe Beyls","originalUrl":"https:\u002F\u002Fbladecoder.medium.com\u002Fkotlins-flow-in-viewmodels-it-s-complicated-556b472e281a"}}],"author":{"scoreStats":{"score":15,"votesCount":25},"rating":1.5,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"21323","alias":"FirsofMaxim","fullname":"Firsov Maxim","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F120\u002F859\u002Fbc8\u002F120859bc81ec070471cb5db3a6fa4401.png","speciality":"Mobile developer"},"statistics":{"commentsCount":6,"favoritesCount":30,"readingCount":3769,"score":3,"votesCount":3},"hubs":[{"relatedData":null,"id":"6345","alias":"mobile_dev","type":"collective","title":"Разработка мобильных приложений","titleHtml":"Разработка мобильных приложений","isProfiled":true},{"relatedData":null,"id":"17107","alias":"android_dev","type":"collective","title":"Разработка под Android","titleHtml":"Разработка под Android","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EЗагрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и \u003Cstrong\u003Eизменения конфигурации\u003C\u002Fstrong\u003E, потому что все это приводит к уничтожению и восстановлению Activity.\u003C\u002Fp\u003E\u003Cp\u003EОтдельные экраны приложения постоянно переключаются между активным и неактивным состоянием, когда пользователь ходит вперед назад по экранам, переключается с одного приложения на другое, блокирует и разблокирует экран. Каждый компонент должен выполнять активную работу в нужном состоянии экрана.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EИзменения конфигурации\u003C\u002Fstrong\u003E происходят в случаях:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003Eпри изменении ориентации экрана;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eкогда приложение переключается в мульти-оконный режим;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eпри переключении визуальной темы смартфона;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eпри изменении системных настроек - языка, шрифтов и т.д.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EПовышаем эффективность\u003C\u002Fh2\u003E\u003Cp\u003EДля улучшения пользовательского опыта, эффективная загрузка данных во Fragment и Activity должна учитывать следующие правила:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EКеширование\u003C\u002Fstrong\u003E: актуальные загруженные данные, должны быть доставлены немедленно и не загружаться повторно. В частности, когда существующий Fragment или Activity становятся видимыми снова или Activity пересоздается после изменения конфигурации.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EИзбегать фоновую работу\u003C\u002Fstrong\u003E: когда Activity или Fragment скрываются (состояние изменяется со \u003Ccode\u003ESTARTED\u003C\u002Fcode\u003E на \u003Ccode\u003ESTOPPED\u003C\u002Fcode\u003E), любая работа по загрузке внешних данных должна вставать на паузу или отменяться для экономии ресурсов. Это особенно важно для бесконeчных потоков данных, как например геолокация или периодическое обновление каких-либо данных.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EРабота не прерывается при изменении конфигурации\u003C\u002Fstrong\u003E: это исключение из правила #2, Во время смены конфигурации, текущая Activity заменяется новым экземпляром с сохранением состояния, поэтому отменять текущую работу в старом экземпляре Activity и перезапускать работу при создании нового экземпляра Activiti было бы контр продуктивно.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Ch3\u003EСовременный подход: ViewModel и LiveData\u003C\u002Fh3\u003E\u003Cp\u003EВ 2017 Google зарелизила первый набор библиотек \u003Ca href=\"https:\u002F\u002Fdeveloper.android.com\u002Ftopic\u002Flibraries\u002Farchitecture\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003EArchitecture Components\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E{:target=\"_blank\"}, там появились \u003Cstrong\u003EViewModel\u003C\u002Fstrong\u003E и \u003Cstrong\u003ELiveData\u003C\u002Fstrong\u003E компоненты, которые помогают разработчикам эффективно работать с данными, поддерживая все 3 правила выше. \u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.android.com\u002Ftopic\u002Flibraries\u002Farchitecture\u002Fviewmodel\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003EViewModel\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E{:target=\"_blank\"}, сохраняет данные при изменении конфигурации, используется для достижения правил #1 и #3: операции загрузки выполняются непрерывно во время изменения конфигурации, полученные данные могут кешироваться и совместно использоваться одним, или несколькими Fragment или Activity.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.android.com\u002Ftopic\u002Flibraries\u002Farchitecture\u002Flivedata\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003ELiveData\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E{:target=\"_blank\"}, простой контейнер данных, поддерживающий подписку на изменения и учитывающий жизненный цикл компонентов Android. Новые данные отправляются наблюдателям только когда их жизненный цикл в состоянии не менее \u003Ccode\u003ESTARTED\u003C\u002Fcode\u003E (видимый), наблюдатели отписываются автоматически, что избавляет от утечек памяти. \u003Ccode\u003ELiveData\u003C\u002Fcode\u003E используется для достижения правил #1 и #2: кеширует последнее значение данных и это значение автоматически отправляется новым наблюдателям. В дополнение, LiveData уведомляет, когда в состоянии \u003Ccode\u003ESTARTED\u003C\u002Fcode\u003E больше нет наблюдателей и можно избежать ненужной фоновой работы.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"ViewModel scope.\" title=\"ViewModel scope.\" height=\"543\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F628\u002F2e6\u002Fbf0\u002F6282e6bf07eaa5791987a2ed62f152ad.png\" data-width=\"522\"\u002F\u003E\u003Cfigcaption\u003EViewModel scope.\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cblockquote\u003E\u003Cp\u003EОпытный разработчик, как правило уже знаком со всем этим. Но важно вспомнить все возможности, чтобы сравнить их с \u003Cstrong\u003EFlow\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003ELiveData + Coroutines\u003C\u002Fh3\u003E\u003Cp\u003ELiveData довольна ограничена по сравнению с реактивными решениями (например RxJava):\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003Eпередает и берет данные только на главном потоке (main thread). Интересно, что оператор \u003Ccode\u003Emap\u003C\u002Fcode\u003E выполняет трансформацию объектов на главном потоке и не может использоваться на I\u002FO потоках или для тяжелых вычислений на CPU. Для этого используется оператор \u003Ccode\u003EswitchMap\u003C\u002Fcode\u003E совместно с ручным запуском асинхронной операции в нужном потоке, даже если в основной поток надо отправить единственное значение.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eесть только 3 оператора преобразования для LiveData: \u003Ccode\u003Emap()\u003C\u002Fcode\u003E, \u003Ccode\u003EswitchMap()\u003C\u002Fcode\u003E и \u003Ccode\u003EdistinctUntilChanged()\u003C\u002Fcode\u003E. Если вам нужно больше, вы должны сами это сделать, используя \u003Ccode\u003EMediatorLiveData\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EЧтобы преодолеть эти ограничения, библиотеки Jetpack дают специальные \"мосты\" из LiveData для других технологий, таких как RxJava или Kotlin корутины.\u003C\u002Fp\u003E\u003Cp\u003EСамый простой и наиболее элегантный из них, по мнению автора, это \u003Ca href=\"https:\u002F\u002Fdeveloper.android.com\u002Ftopic\u002Flibraries\u002Farchitecture\u002Fcoroutines#livedata\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003ELiveData coroutine builder\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E, подключается через \u003Ccode\u003Eandroidx.lifecycle:lifecycle-livedata-ktx\u003C\u002Fcode\u003E Gradle зависимость. Этот функционал похож на \u003Ccode\u003Eflow {} builder function\u003C\u002Fcode\u003E из библиотеки Kotlin Coroutines и позволяет грамотно обернуть корутину в экземпляр LiveData:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval result: LiveData&lt;Result\u003E = liveData {\n    val data = someSuspendingFunction()\n    emit(data)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EВы можете использовать все силу корутин, их контекстов для написания асинхронного кода в синхронной манере без колбеков, автоматически переключаясь между нужными потоками;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EНовые значения отправляются наблюдателям LiveData в главном потоке через \u003Cem\u003Esuspending\u003C\u002Fem\u003E методы \u003Ccode\u003Eemit()\u003C\u002Fcode\u003E или \u003Ccode\u003EemitSource()\u003C\u002Fcode\u003E из корутины;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКорутина использует специальную область видимости (scope) и жизненный цикл привязанный к экземпляру LiveData. Когда LiveData становится \u003Cem\u003Eнеактивной\u003C\u002Fem\u003E (это значит, что больше нет наблюдателей в состоянии \u003Ccode\u003ESTARTED\u003C\u002Fcode\u003E), то корутина будет автоматически отменена, работает правило #2;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ реальности отмена корутины будет \u003Cstrong\u003Eзадержана на 5 секунд\u003C\u002Fstrong\u003E после того как LiveData станет неактивной для правильной обработки смены конфигурации: если новая Activity немедленно заменит старую и LiveData станет активной до срабатывания задержки, то отмена корутины не будет и цена перезапуска будет нулевой (правило #3);\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003Eесли пользователь вернется назад на экран и LiveData станет активной, то корутина автоматически перезапустится, но только если она была отменена до завершения. Как только корутина завершится, она больше не будет перезапускаться, те же данные не будут загружаться дважды, если входные параметры не изменились (правило #1).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВывод: используйте LiveData coroutines builder, это дает простой код и лучшее поведение по умолчанию.\u003C\u002Fp\u003E\u003Cp\u003EА что если, репозиторий возвращает \u003Cem\u003Eпоток значений\u003C\u002Fem\u003E в форме \u003Ccode\u003EFlow\u003C\u002Fcode\u003E (вместо \u003Cem\u003Esuspend\u003C\u002Fem\u003E функций с единственным значением)? В этом случае также возможно сконвертировать поток в LiveData и использовать все преимущества перечисленные выше, используя \u003Ccode\u003EasLiveData()\u003C\u002Fcode\u003E функцию-расширение.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval result: LiveData&lt;Result\u003E = someFunctionReturningFlow().asLiveData()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВнутри \u003Ccode\u003EasLiveData()\u003C\u002Fcode\u003E также использует LiveData coroutines builder для создания простой корутины обрабатывающий Flow пока LiveData активна:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Efun &lt;T\u003E Flow&lt;T\u003E.asLiveData(): LiveData&lt;T\u003E = liveData {\n    collect {\n        emit(it)\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНо давайте остановимся ненадолго – что такое \u003Ccode\u003EFlow\u003C\u002Fcode\u003E и можно ли им полностью заменить LiveData?\u003C\u002Fp\u003E\u003Ch3\u003EВведение в Kotlin Flow\u003C\u002Fh3\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb40\u002F3b5\u002Fd7c\u002Fb403b5d7c91b7a8b30234e850fc6dbac.jpeg\" width=\"700\" height=\"482\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb40\u002F3b5\u002Fd7c\u002Fb403b5d7c91b7a8b30234e850fc6dbac.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fkotlinlang.org\u002Fdocs\u002Fflow.html\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003EFlow\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E это класс из библиотеки \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FKotlin\u002Fkotlinx.coroutines\" rel=\"noopener noreferrer nofollow\"\u003EKotlin Coroutines\u003C\u002Fa\u003E представленной в 2019 году, класс является потоком значений, вычисляемый асинхронно. Концептуально похож на RxJava Observable, но основан на корутинах и имеет более простой API.\u003C\u002Fp\u003E\u003Cp\u003EИзначально были доступны только \u003Cstrong\u003Eхолодные потоки\u003C\u002Fstrong\u003E (cold flows): потоки без состояний, которые создаются по требованию каждый раз, когда наблюдатель начинает собирать значения в области видимости (scope) корутины. Каждый наблюдатель получает собственную последовательность значений, они не общие.\u003C\u002Fp\u003E\u003Cp\u003EПозже были добавлены новые \u003Cstrong\u003Eгорячие потоки\u003C\u002Fstrong\u003E подтипы Flow: \u003Ccode\u003ESharedFlow\u003C\u002Fcode\u003E и \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E. Они были выпущены со стабильной реализацией API в версии библиотеки корутин #1.4.0.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003ESharedFlow\u003C\u002Fcode\u003E публикует данные, которые распространяются всем слушателям. Класс может управлять дополнительным кешем и\u002Fили буфером и фактически заменяет все варианты устаревшего \u003Ccode\u003EBroadcastChannel\u003C\u002Fcode\u003E API.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E специально оптимизированный подкласс \u003Ccode\u003ESharedFlow\u003C\u002Fcode\u003E, который хранит и воспроизводит только последнее значение. Что-то знакомое, да? \u003C\u002Fp\u003E\u003Ch2\u003EStateFlow и LiveData много общего:\u003C\u002Fh2\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EЭти классы наблюдаемые (observable)\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EОни хранят и распространяют последнее значение любому количеству наблюдателей\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EОни заставляют перехватывать ошибки на ранней стадии: необработанное исключение (\u003Ccode\u003EException\u003C\u002Fcode\u003E) в колбеке LiveData останавливает приложение. Не пойманное исключение в горячем Flow потоке завершает поток без возможности перезапустить его, даже если использовать оператор \u003Ccode\u003E.catch()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch2\u003EНо есть и важные отличия:\u003C\u002Fh2\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EMutableStateFlow\u003C\u002Fcode\u003E требует начального значения, в отличие от \u003Ccode\u003EMutableLiveData\u003C\u002Fcode\u003E. Замечание: \u003Ccode\u003EMutableSharedFlow(replay = 1)\u003C\u002Fcode\u003E  может эмулировать \u003Ccode\u003EMutableStateFlow\u003C\u002Fcode\u003E без начального значения, но данная реализация менее эффективна.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E всегда фильтрует повторяющиеся значения с помощью сравнения \u003Ccode\u003EAny.equals()\u003C\u002Fcode\u003E, \u003Ccode\u003ELiveData\u003C\u002Fcode\u003E так не делает, для этого следует подключить оператор \u003Ccode\u003EdistinctUntilChanged()\u003C\u002Fcode\u003E (замечание: \u003Ccode\u003ESharedFlow\u003C\u002Fcode\u003E не имеет такого поведения).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E не учитывает жизненный цикл (\u003Cstrong\u003Enot lifecycle-aware\u003C\u002Fstrong\u003E). Однако, \u003Ccode\u003EFlow\u003C\u002Fcode\u003E может быть использовано в корутине с учетом жизненного цикла, это требует некоторого кода для настройки без использования LiveData (детали ниже).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003ELiveData\u003C\u002Fcode\u003E использует \"версионность\", чтобы управлять отправкой значений наблюдателям. При помощи этого наблюдатель не получит дважды одного и того же значения при переходе обратно в состояние \u003Ccode\u003ESTARTED\u003C\u002Fcode\u003E. \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E не использует \"версионность\". Каждый раз, когда корутина собирает данные \u003Ccode\u003EFlow\u003C\u002Fcode\u003E, она рассматривается как \u003Cstrong\u003Eновый наблюдатель\u003C\u002Fstrong\u003E и всегда будет получать сначала последнее значение. Из-за этого может быть дублирование работы, как мы увидим на следующем примере.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Ch3\u003EНаблюдение за LiveData против сбора данных в Flow\u003C\u002Fh3\u003E\u003Cp\u003EОрганизовать наблюдение за экземпляром LiveData довольно просто:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EviewModel.results.observe(viewLifecycleOwner) { data -\u003E\n    displayResult(data)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭта операция однократная и дальше LiveData берет на себя синхронизацию потока данных с жизненным циклом наблюдателей.\u003C\u002Fp\u003E\u003Cp\u003EАналогичная операция для Flow называется \u003Cem\u003Eсбором\u003C\u002Fem\u003E (collecting) и сбор должен выполняться в корутине. Из-за того, что Flow не знает ничего о жизненном цикле, ответственность за жизненный цикл возлагают на корутину, работающую с Flow.\u003C\u002Fp\u003E\u003Cp\u003EЧтобы создать корутину для работы с Flow, учитывающую жизненный цикл Activity\u002FFragment (запускать работу с данными при состоянии \u003Ccode\u003ESTARTED\u003C\u002Fcode\u003E и автоматически отменять эту работу при уничтожении):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EviewLifecycleOwner.lifecycleScope.launchWhenStarted {\n    viewModel.result.collect { data -\u003E\n        displayResult(data)\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНо здесь есть серьезное ограничение: \u003Cstrong\u003Eкод будет работать правильно только с \"холодными\" потоками, без поддержки каналом или буфером\u003C\u002Fstrong\u003E. Такой Flow управляется только собирающей его корутиной: когда Activity\u002FFragment перейдет в состояние \u003Ccode\u003ESTOPPPED\u003C\u002Fcode\u003E, корутина приостановится, производитель Flow также приостановится с ней, и больше ничего не произойдет пока корутина не возобновится.\u003C\u002Fp\u003E\u003Cp\u003EОднако, есть и другие виды Flow:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eгорячие потоки\u003C\u002Fstrong\u003E, которые всегда активные и посылают результаты всем текущим наблюдателями (включая приостановленные);\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eхолодные потоки с колбэком или поддержкой канала\u003C\u002Fstrong\u003E, которые подписываются на активный источник данных, когда сбор данных запускается и останавливает подписку, когда сбор данных отменяется (не приостанавливается).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВ этих случаях, \u003Cstrong\u003Eосновной производитель Flow будет оставаться активным\u003C\u002Fstrong\u003E даже когда корутина будет приостановлена, сохраняя (в буфер) новые результаты в фоновом режиме. Ресурсы расходуются впустую, правило #2 нарушается.\u003C\u002Fp\u003E\u003Cfigure class=\"\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff91\u002F872\u002F749\u002Ff91872749e9d6e05345be8de76c729d4.jpeg\" width=\"500\" height=\"735\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff91\u002F872\u002F749\u002Ff91872749e9d6e05345be8de76c729d4.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EНужно создать более безопасный способ сборки Flow любого типа. Корутина работающая с потоком данных, должна быть отменена когда Activity\u002FFragment становится невидимой и перезапущена снова, так же как это делает LiveData-Coroutine-Builder. Для этого был представлен новый API в \u003Ccode\u003Elifecycle:lifecycle-runtime-ktx:2.4.0\u003C\u002Fcode\u003E (остается в статусе alpha на момент написания статьи, на момент перевода - перешел в beta).\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EviewLifecycleOwner.lifecycleScope.launch {\n    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n        viewModel.result.collect { data -\u003E\n            displayResult(data)\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИли аналогично:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EviewLifecycleOwner.lifecycleScope.launch {\n    viewModel.result\n.flowWithLifecycle(viewLifecycleOwner.lifecycle, Lifecycle.State.STARTED)\n        .collect { data -\u003E\n            displayResult(data)\n        }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКак видно, эффективно и безопасно работать с данными в Actvivity или Fragment проще с помощью LiveData.\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003EМожно посмотреть дополнительную информацию о новом API в статье \"\u003Ca href=\"https:\u002F\u002Fmedium.com\u002Fandroiddevelopers\u002Fa-safer-way-to-collect-flows-from-android-uis-23080b1f8bda\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003E\u003Cem\u003EA safer way to collect flows from Android UIs\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\u003Cstrong\u003E\u003Cem\u003E\"\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E от Manuel Vivo.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Ch3\u003EЗаменяем LiveData на StateFlow во ViewModel\u003C\u002Fh3\u003E\u003Cp\u003EДавайте-ка вернемся к ViewModel. Мы убедились, что это простой и эффективный способ работы с данными в асинхронном режиме:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval result: LiveData&lt;Result\u003E = liveData {\n    val data = someSuspendingFunction()\n    emit(data)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EКак мы можем добиться того же самого, используя \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E вместо \u003Ccode\u003ELiveData\u003C\u002Fcode\u003E? \u003Cem\u003EJose Alcérreca\u003C\u002Fem\u003E написал \u003Ca href=\"https:\u002F\u002Fmedium.com\u002Fandroiddevelopers\u002Fmigrating-from-livedata-to-kotlins-flow-379292f419fb\" rel=\"noopener noreferrer nofollow\"\u003Eвнушительное руководство\u003C\u002Fa\u003E для ответа на этот вопрос. Вкратце, для случая выше, код будет выглядеть так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval result: Flow&lt;Result\u003E = flow {\n    val data = someSuspendingFunction()\n    emit(data)\n}.stateIn(\n    scope = viewModelScope,\n    started = SharingStarted.WhileSubscribed(5000L),\n    initialValue = Result.Loading\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОператор \u003Ccode\u003EstateIn()\u003C\u002Fcode\u003E трансформирует наш холодный Flow в горячий, способный делиться одним и тем же результатом между разными наблюдателями. Благодаря \u003Ccode\u003ESharingStarted.WhileSubscribed(5000L)\u003C\u002Fcode\u003E, горячий поток запускается лениво при подписке первого наблюдателя и отменяется через 5 секунд, когда последний наблюдатель отпишется, что позволяет избегать лишней работы в фоновом режиме и при этом сохраняется работа при смене конфигурации. Кроме того, как только исходящий поток данных достигнет конца, он не будет перезапущен автоматически, этим мы избегаем двойной работы.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EПохоже, что мы сумели выполнить 3 наших правила и воспроизвести почти такое же поведение как у LiveData с использованием более сложного кода.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cp\u003EВсе же еще остается небольшая, но важная разница: каждый раз когда Activity\u002FFragment становится видимым снова, начинается новый сбор потока и \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E  всегда будет отправлять последний результат наблюдателю немедленно. \u003Cstrong\u003EДаже если этот же результат был уже доставлен в тот же самый Activity\u002FFragment во время последнего сбора данных.\u003C\u002Fstrong\u003E Потому что \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E не поддерживает версионность (в отличие от LiveData) и каждый новый сбор потока данных - это новый подписчик.\u003C\u002Fp\u003E\u003Cp\u003EЭто проблематично? Для простых случаев нет, Activity или Fragment могут сделать дополнительную проверку, чтобы не делать лишнее обновление UI, если данные не изменились.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EviewLifecycleOwner.lifecycleScope.launch {\n    viewModel.result\n        .flowWithLifecycle(viewLifecycleOwner.lifecycle, Lifecycle.State.STARTED)\n        .distinctUntilChanged()\n        .collect { data -\u003E\n            displayResult(data)\n        }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПроблемы возникают в более сложных, реальных случаях, как мы увидим в следующем разделе.\u003C\u002Fp\u003E\u003Ch2\u003EИспользование StateFlow как триггер во ViewModel\u003C\u002Fh2\u003E\u003Cp\u003EПодход на основе триггера обычно используется во ViewModel: каждый раз когда значение триггера изменяется - данные обновляются.\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003EMutableLiveData\u003C\u002Fcode\u003E для этого работает очень хорошо:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eclass MyViewModel(repository: MyRepository) : ViewModel() {\n    private val trigger = MutableLiveData&lt;String\u003E()\n\n    fun setQuery(query: String) {\n        trigger.value = query\n    }\n\n    val results: LiveData&lt;SearchResult\u003E\n            = trigger.switchMap { query -\u003E\n        liveData {\n            emit(repository.search(query))\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EПри обновлении, оператор \u003Ccode\u003EswitchMap()\u003C\u002Fcode\u003E подключает наблюдателей к новому источнику LiveData, заменяя старый. И так как в примере выше, используется LiveData coroutine builder, старая LiveData автоматически отменит связанную с ним корутину через 5 секунд после отключения от своих наблюдателей. Работа с устаревшими данными прекращается с небольшой задержкой.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EТак как в LiveData есть версионность, \u003Ccode\u003EMutableLiveData\u003C\u002Fcode\u003E триггер отправит новое значение \u003Cstrong\u003Eтолько один раз\u003C\u002Fstrong\u003E оператору \u003Ccode\u003EswitchMap()\u003C\u002Fcode\u003E, как только появится хотя бы один активный наблюдатель. Позже, если наблюдатели становятся неактивными и активными снова, работа источника данных LiveData просто возобновится с последними данными, где она остановилась.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EЭтот код достаточно прост и соблюдает все правила по эффективности выше.\u003C\u002Fp\u003E\u003Cp\u003EДавайте посмотрим, можно ли реализовать ту же самую логику с классом \u003Ccode\u003EMutableStateFlow\u003C\u002Fcode\u003E вместо \u003Ccode\u003EMutableLiveData\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Ch3\u003EНаивный подход\u003C\u002Fh3\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eclass MyViewModel(repository: MyRepository) : ViewModel() {\n    private val trigger = MutableStateFlow(\"\")\n\n    fun setQuery(query: String) {\n        trigger.value = query\n    }\n\n    val results: Flow&lt;SearchResult\u003E = trigger.mapLatest { query -\u003E\n        repository.search(query)\n    }.stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5000L),\n        initialValue = SearchResult.EMPTY\n    )\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EAPI \u003Ccode\u003EMutableLiveData\u003C\u002Fcode\u003E и \u003Ccode\u003EMutableLiveData\u003C\u002Fcode\u003E выглядят очень похоже, код триггера выглядит почти одинаково. Самое большое различие это использование \u003Ca href=\"https:\u002F\u002Fkotlin.github.io\u002Fkotlinx.coroutines\u002Fkotlinx-coroutines-core\u002Fkotlinx.coroutines.flow\u002Fmap-latest.html\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003EmapLatest\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E, это эквивалент функции \u003Ccode\u003EswitchMap()\u003C\u002Fcode\u003E в LiveData для возвращения единственного значения (для возвращения нескольких значений, надо использовать \u003Ca href=\"https:\u002F\u002Fkotlin.github.io\u002Fkotlinx.coroutines\u002Fkotlinx-coroutines-core\u002Fkotlinx.coroutines.flow\u002Fflat-map-latest.html\" rel=\"noopener noreferrer nofollow\"\u003E\u003Cstrong\u003EflatMapLatest\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Cp\u003E\u003Ccode\u003EmapLatest()\u003C\u002Fcode\u003E работает как \u003Ccode\u003Emap()\u003C\u002Fcode\u003E, но вместо полного преобразования по порядку всех входных значений, входные значения используются немедленно, а преобразование происходит в \u003Cstrong\u003Eотдельной корутине\u003C\u002Fstrong\u003E асинхронно. При появлении нового значения во входящем потоке данных, трансформация предыдущего значения будет \u003Cstrong\u003Eнемедленно отменена\u003C\u002Fstrong\u003E, если она все еще работала и вместо нее будет запущена новая трансформация. Таким образом можно избежать работы с устаревшими данными.\u003C\u002Fp\u003E\u003Cp\u003EВроде выглядит неплохо. Однако здесь всплывает основная проблема: так как \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E не поддерживает версионность, триггер отправит \u003Cstrong\u003Eповторно последнее значение\u003C\u002Fstrong\u003E, когда Flow перезапустится. Это случается \u003Cstrong\u003Eкаждый раз, когда Activity\u002FFrgament становится видимым опять\u003C\u002Fstrong\u003E, после того, как был невидимым более 5 секунд.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe76\u002F702\u002F3c0\u002Fe767023c06977a4e9751b6c87ac0c042.jpeg\" width=\"700\" height=\"393\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe76\u002F702\u002F3c0\u002Fe767023c06977a4e9751b6c87ac0c042.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EТриггер выдает значение повторно, \u003Ccode\u003EmapLatest()\u003C\u002Fcode\u003E снова запускается, еще раз дергается метод в репозитории с теми же аргументами, хотя результат уже был получен и обработан. Правило #1 не работает: актуальные данные не должны загружаться повторно.\u003C\u002Fp\u003E\u003Ch3\u003EЧиним повторную отправку последнего сообщения\u003C\u002Fh3\u003E\u003Cp\u003EВопросы приходящие на ум: должны ли мы предотвращать повторную отправку и как это сделать? \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E уже позаботился об этом \u003Cem\u003Eвнутри коллекции flow\u003C\u002Fem\u003E и оператор \u003Ccode\u003EdistinctUntilChanged()\u003C\u002Fcode\u003E делает то же самое для других типов flow. При этом нет стандартного оператора для отмены повторной отправки среди множества коллекций одного и того же flow, потому что flow коллекции должны быть \u003Cstrong\u003Eсамодостаточные\u003C\u002Fstrong\u003E. Это главная разница с LiveData.\u003C\u002Fp\u003E\u003Cp\u003EВ конкретном случае flow разделяемого между несколькими наблюдателями с использованием оператора \u003Ccode\u003EstateIn()\u003C\u002Fcode\u003E, исходящие значения будут кешироваться и в любой момент времени будет только одна корутина обрабатывающая эти значения. Можно попробовать взломать какой-нибудь оператор, который будет запоминать последнее значение предыдущей коллекции, чтобы пропустить его, когда запускается новая коллекция (не делайте так на работе, да и дома тоже):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E\u002F\u002F Don't do this at home (or at work)\nfun &lt;T\u003E Flow&lt;T\u003E.rememberLatest(): Flow&lt;T\u003E {\n    var latest: Any? = NULL\n    return flow {\n        collectIndexed { index, value -\u003E\n            if (index != 0 || value !== latest) {\n                emit(value)\n                latest = value\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cblockquote\u003E\u003Cp\u003EПримечание: внимательный читатель может заметить, что такое же поведение достигается за счет замены \u003Ccode\u003EMutableStateFlow\u003C\u002Fcode\u003E с \u003Ccode\u003EChannel(capacity = CONFLATED)\u003C\u002Fcode\u003E и затем превратиь его в Flow с использованием \u003Ccode\u003EreceiveAsFlow()\u003C\u002Fcode\u003E. Сhannel никогда не передают значение повторно.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EК сожалению, \u003Cstrong\u003Eлогика в коде выше несовершенна\u003C\u002Fstrong\u003E и перестанет работать, как задумано, когда трансформация flow будет \u003Cstrong\u003Eотменена до завершения\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cp\u003EКод предполагает, что после возврата \u003Ccode\u003Eemit(value)\u003C\u002Fcode\u003E, значение было обработано и не должно быть выдано снова, если сбор flow перезапустится, но \u003Cstrong\u003Eэто так, только при использовании не буферизированных Flow операторов\u003C\u002Fstrong\u003E. Операторы, подобные \u003Ccode\u003EmapLatest()\u003C\u002Fcode\u003E, буферизированные и в этом случае \u003Ccode\u003Eemit(value)\u003C\u002Fcode\u003E вернется немедленно, при этом преобразование выполняется асинхронно. Это значит, что нет способа узнать, когда значение было обработано flow. Если сбор flow отменяется в середине асинхронного преобразования, нам все равно придется повторно сделать \u003Ccode\u003Eemit\u003C\u002Fcode\u003E последнего значения, когда сбор flow возобновится, чтобы возобновить преобразование, иначе значение будет потеряно.\u003C\u002Fp\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003Cstrong\u003ETL;DR\u003C\u002Fstrong\u003E Использование \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E в качестве триггера в ViewModel приводит к дублирующейся работе каждый раз когда Activity\u002FFragment становится видимой повторно и здесь нет простого пути избежать такого поведения.\u003C\u002Fp\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EВот почему \u003Ccode\u003ELiveData\u003C\u002Fcode\u003E предпочтительнее \u003Ccode\u003EStateFlow\u003C\u002Fcode\u003E при использовании как триггер во ViewModel. Эти различия не упоминаются в Codelab от Google - \u003Ca href=\"https:\u002F\u002Fdeveloper.android.com\u002Fcodelabs\u002Fadvanced-kotlin-coroutines#11\" rel=\"noopener noreferrer nofollow\"\u003EAdvanced coroutines with Kotlin Flow\u003C\u002Fa\u003E, там подразумевается, что реализация на Flow ведет себя так же как на LiveData. Но это не так.\u003C\u002Fp\u003E\u003Ch2\u003EВыводы\u003C\u002Fh2\u003E\u003Cp\u003EМои рекомендации на основании примеров выше:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EПродолжайте использовать LiveData в вашем Android-UI слое и ViewModels, особенно в качестве триггера. Используйте это везде, для передачи данных в Activity\u002FFragment: код будет простым и эффективным;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ELiveData coroutine builder\u003C\u002Fstrong\u003E ваш друг и может заменить Flows во ViewModels в большинстве случаев;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВы можете использовать мощь Flow операторов при необходимости, конвертируя Flows в LiveData;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EFlow лучше подходит, чем LiveData, для других слоев приложения, таких как - репозитории, источники данных и т.д., они не завязаны на платформенные особенности Android и их будет легче тестировать.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EТеперь вы знаете все компромиcсы при переходе от LiveData к подходу \"полностью на Flow\" в вашем Android-UI слое.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"android"},{"titleHtml":"kotlin"},{"titleHtml":"flow"},{"titleHtml":"viewmodel"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3de\u002Fa4d\u002F720\u002F3dea4d72029f51afff6cca023003f118.jpg","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3de\u002Fa4d\u002F720\u002F3dea4d72029f51afff6cca023003f118.jpg","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F581914\\\u002F\"},\"headline\":\"Android, Kotlin Flow во ViewModel — все сложно\",\"datePublished\":\"2021-10-06T15:14:22+03:00\",\"dateModified\":\"2021-10-06T15:14:22+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Firsov Maxim\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F581914\\\u002F#post-content-body\",\"about\":[\"h_mobile_dev\",\"h_android_dev\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F581914\\\u002Fa7be16de85e974c4a29b758b3d0789a1\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F628\\\u002F2e6\\\u002Fbf0\\\u002F6282e6bf07eaa5791987a2ed62f152ad.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fb40\\\u002F3b5\\\u002Fd7c\\\u002Fb403b5d7c91b7a8b30234e850fc6dbac.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ff91\\\u002F872\\\u002F749\\\u002Ff91872749e9d6e05345be8de76c729d4.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fe76\\\u002F702\\\u002F3c0\\\u002Fe767023c06977a4e9751b6c87ac0c042.jpeg\"]}","metaDescription":"Загрузка данных для UI в приложении Android может быть непростой задачей. Нам надо учитывать жизненный цикл компонентов Android и изменения конфигурации, потому что все это приводит к уничтожению и...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"mobile_dev,android_dev"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
