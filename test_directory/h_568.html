<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>iOS. UI. Приёмы. Часть 2 / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/583368\/"},"headline":"iOS. UI. Приёмы. Часть 2","datePublished":"2021-10-14T00:15:34+03:00","dateModified":"2021-10-14T02:03:03+03:00","author":{"@type":"Person","name":"kostyanoy"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными l...","url":"https:\/\/habr.com\/ru\/post\/583368\/#post-content-body","about":["h_ios_dev","h_mobile_dev","h_swift","h_apps_design","f_develop","f_design"],"image":["https:\/\/habr.com\/share\/publication\/583368\/50b18302ec03744723a49b9164e43340\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/703\/52c\/e03\/70352ce03294ec837efd2c5caabb299a.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/fd6\/61b\/9f5\/fd661b9f5487355a25140b28ba52cf36.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/cf5\/58f\/006\/cf558f0065cf4eac4422b1f70b03ee08.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/aca\/268\/6bd\/aca2686bdd1536e11cdf97edbd6b6992.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/41f\/202\/3da\/41f2023da20f55351cc704cbc4053685.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/5a9\/ca3\/d35\/5a9ca3d3568da0421a0d9e648b55eaec.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/dde\/9f5\/c9a\/dde9f5c9afc19df68bed0afc128a88b7.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d4e\/5ba\/9f6\/d4e5ba9f65210135180f2d671ceeb9c1.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="iOS. UI. Приёмы. Часть 2" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="iOS. UI. Приёмы. Часть 2" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="iOS. UI. Приёмы. Часть 2" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/8ee/77d/287/8ee77d287a1e0e62a7cecbc9fa11687a.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/8ee/77d/287/8ee77d287a1e0e62a7cecbc9fa11687a.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/8ee/77d/287/8ee77d287a1e0e62a7cecbc9fa11687a.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/8ee/77d/287/8ee77d287a1e0e62a7cecbc9fa11687a.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/8ee/77d/287/8ee77d287a1e0e62a7cecbc9fa11687a.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="583368" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-13T21:15:34.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/583368/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/583368/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/8ee/77d/287/8ee77d287a1e0e62a7cecbc9fa11687a.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/583368/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/kostyanoy/" title="kostyanoy" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_pink"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="/ru/users/kostyanoy/" class="tm-user-info__username">
      kostyanoy
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-13T21:15:34.000Z" title="2021-10-14, 00:15">14  октября   в 00:15</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>iOS. UI. Приёмы. Часть 2</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/ios_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка под iOS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/mobile_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка мобильных приложений</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/swift/" class="tm-article-snippet__hubs-item-link"><span>Swift</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/apps_design/" class="tm-article-snippet__hubs-item-link"><span>Дизайн мобильных приложений</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>Привет читателям хабра! В прошлой <a href="https://habr.com/ru/post/549300/" rel="noopener noreferrer nofollow">статье</a> рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на довольно интересных, на мой взгляд, примерах.</p><h3>Введение</h3><p>Предполагаю, что читатель достаточно хорошо знаком с UICollectionView, т.е. понимает, куда и как прокидывать данные, как задавать layout, что вообще такое UICollectionViewLayout и т.п. На момент написания были некоторые сомнения об актуальности материала, но SwiftUI вроде бы ещё не занял доминирующую позицию, да и слышал от разработчиков, что на нём сильно кастомные компоненты проблематично создавать.<br/><br/>Все примеры взяты из жизни с незначительными модификациями. Во вставках с кодом умышленно допущены неточности для более удобной читаемости. Крайние случаи вроде всяких пограничных переходов позволил себе не рассматривать, чтобы не загромождать код в примерах. Если у вас будет что-то падать при попытке запуска примеров кода, попробуйте выставить <strong>estimatedItemSize </strong>в ноль<strong>.</strong></p><h3>Селектор в виде горизонтального списка</h3><figure class="full-width "><img src="/img/image-loader.svg" alt="При скролле ближайший элемент автоматически выравнивается по центру" title="При скролле ближайший элемент автоматически выравнивается по центру" height="403" data-src="https://habrastorage.org/getpro/habr/upload_files/703/52c/e03/70352ce03294ec837efd2c5caabb299a.png" data-width="800"/><figcaption>При скролле ближайший элемент автоматически выравнивается по центру</figcaption></figure><p>С точки зрения пользователя имеем горизонтально скроллящийся список карточек, в котором после каждого свайпа и прекращения движения по инерции ближайшая к центру экрана карточка автоматически оказывается ровно посередине. В банковских приложениях такое частенько можно увидеть.</p><p>Прежде чем пускаться в детали, напомню вкратце про самые, пожалуй, важные методы, которые нужно переопределять при создании кастомного layout-а: в функции <strong>prepare</strong> мы создаём layout attributes (UICollectionViewLayoutAttributes), которые затем "скармливаем" функции <strong>layoutAttributesForElements(in:)</strong>. И ещё важно переопределить <strong>collectionViewContentSize</strong>, чтобы всем ячейкам хватило места.<br/><br/>В случаях таких layout-ов, мне кажется, удобно задавать ширину ячейки как "ширина коллекции минус константное расстояние по бокам", а высоту уже брать как захочется, потому что она на scroll, можно сказать, не влияет. Т.е. в начале функции prepare можно написать что-то вроде:</p><pre><code class="swift">itemSize = CGSize(
	width: collection.bounds.width - 2 * Constants.itemInset,
	height: Constants.itemHeight
)</code></pre><p>Также расстояние между элементами коллекции можно взять за константу и подгонять её так, чтобы покрасивее смотрелось. Расположение ячеек - дело нехитрое, в коде будет выглядеть примерно так:</p><pre><code class="swift">attr.frame = CGRect(
	x: Constants.itemInset + i * (itemSize.width + Constants.distance),
  y: collection.bounds.height / 2 - Constants.itemHeight / 2,
  width: itemSize.width,
  height: itemSize.height
)</code></pre><p>Внутри collectionContentSize будет что-то очень похожее. Самое интересное в этом примере - выравнивание item-ов по центру. В этом нам поможет функция <strong>targetContentOffset(forProposedContentOffset:withScrollingVelocity)</strong>, которая переопределяется внутри layout. Её смысл примерно в следующем: после того как юзер проводит чем-нибудь по экрану и потом отпускает экран, коллекция продолжает проматывать содержимое по инерции, зная заранее, в какой точке она остановится. TargetContentOffset позволяет вмешаться в этот процесс и сказать collection, где ей остановиться. А это как раз то, что нам нужно. Т.е. эта функция работает так, что на вход подаётся contentOffset, в котором коллекция собирается "остановиться", а её возвращаемое значение - скорректированный contetOffset.<br/><br/>Итак, мы знаем, при каком contentOffset коллекция собирается перестать скроллить контент. В этот момент положение центра экрана относительно всего контента равно</p><pre><code class="swift">let contentCenterX = contentOffset + collection.width / 2</code></pre><p>Логично, что нужно найти item, центр которого ближе всего к этой величине. Для этого, как мне показалось, проще мысленно провести разделительные линии посередине между элементами коллекции и представить, что мы имеем дело с "мнимыми" элементами большего размера, располагающимися вплотную друг к другу:</p><figure class="full-width "><img src="/img/image-loader.svg" height="386" data-src="https://habrastorage.org/getpro/habr/upload_files/fd6/61b/9f5/fd661b9f5487355a25140b28ba52cf36.png" data-width="645"/><figcaption></figcaption></figure><p>При таком раскладе точка в центре экрана обязательно попадет в какой-то мнимый item, индекс которого легко вычисляется:</p><pre><code class="swift">let imaginaryItemWidth = itemWidth + Constants.distance
let index = Int(contentCenterX / imaginaryItemWidth)</code></pre><p>Однако это даёт не совсем точный результат из-за несоответствия расстояния между ячейками и ширины самих ячеек по отношению к ширине коллекции - мнимые элементы в нашем случае в сумме дают большую ширину, чем contentSize.width. Выражаться это будет в том, что в каких-то пограничных случаях (например, центр видимой области экрана попадает ровно посередине между item-ами) подскролливаться к центру будет не тот элемент, который мы ожидаем.</p><p>Исправить проблему просто - добавить (или отнять) недостающее расстояние в contentCenterX:</p><pre><code class="swift">let diff = (Constants.distance / 2 - Constants.itemInset)
contentCenterX = proposedContentOffset.x + collection.width / 2 + diff</code></pre><p>и после этого уже вычислять индекс элемента. В итоге в функции targetContentOffset нужно вернуть новый contentOffset в виде:</p><pre><code class="swift">CGPoint(
	x: index * imaginaryItemWidth,
	y: proposedContentOffset.y
)</code></pre><details class="spoiler"><summary>Полный код для layout-а из примера 1</summary><div class="spoiler__content"><pre><code class="swift">import UIKit

final class SelectorSimpleLayout: UICollectionViewFlowLayout {
  
  private var attrs: [UICollectionViewLayoutAttributes] = []
  
  // MARK: Override
  
  override var collectionViewContentSize: CGSize {
    guard let collection = collectionView,
          collection.numberOfSections > 0 else { return .zero }
    let number = collection.numberOfItems(inSection: 0)
    let itemWidth = collection.bounds.width - 2 * Constants.itemInset
    let resultWidth = Constants.itemInset + CGFloat(number) * (Constants.distance + itemWidth)
      - Constants.distance
      + Constants.itemInset
    return CGSize(
      width: resultWidth,
      height: collection.bounds.height
    )
  }
  
  override func prepare() {
    super.prepare()
    
    attrs = []
    
    guard let collection = collectionView,
          collection.numberOfSections > 0 else { return }
    
    itemSize = CGSize(
      width: collection.bounds.width - 2 * Constants.itemInset,
      height: Constants.itemHeight
    )
    
    for i in 0..&lt;collection.numberOfItems(inSection: 0) {
      let attr = UICollectionViewLayoutAttributes(forCellWith: IndexPath(row: i, section: 0))
      attr.frame = CGRect(
        x: Constants.itemInset + CGFloat(i) * (itemSize.width + Constants.distance),
        y: collection.bounds.height / 2 - Constants.itemHeight / 2,
        width: itemSize.width,
        height: itemSize.height
      )
      attrs.append(attr)
    }
  }
  
  override func layoutAttributesForElements(
    in rect: CGRect
  ) -> [UICollectionViewLayoutAttributes]? {
    attrs.filter { $0.frame.intersects(rect) }
  }
  
  override func layoutAttributesForItem(
    at indexPath: IndexPath
  ) -> UICollectionViewLayoutAttributes? {
    attrs[indexPath.row]
  }
  
  override func targetContentOffset(
    forProposedContentOffset proposedContentOffset: CGPoint,
    withScrollingVelocity velocity: CGPoint
  ) -> CGPoint {
    guard let collection = collectionView else { return proposedContentOffset }
    
    let diff = (Constants.distance / 2 - Constants.itemInset)
    let contentCenterX = proposedContentOffset.x + collection.bounds.width / 2 + diff
    let imaginaryItemWidth = itemSize.width + Constants.distance
    
    let index = Int(contentCenterX / imaginaryItemWidth)
    
    return CGPoint(
      x: CGFloat(index) * imaginaryItemWidth,
      y: proposedContentOffset.y
    )
  }
  
  // MARK: Constants
  
  // Every cell has length = collection's bounds minus itemInsets
  private enum Constants {
    static let itemHeight: CGFloat = 200
    static let itemInset: CGFloat = 36
    static let distance: CGFloat = 100
  }
}</code></pre></div></details><h3>Селектор в виде стопки карточек со свайпом влево</h3><figure class="full-width "><img src="/img/image-loader.svg" alt="При смахивании влево очередной карточки следующая занимает её место, а остальные пропорционально увеличиваются" title="При смахивании влево очередной карточки следующая занимает её место, а остальные пропорционально увеличиваются" height="404" data-src="https://habrastorage.org/getpro/habr/upload_files/cf5/58f/006/cf558f0065cf4eac4422b1f70b03ee08.png" data-width="802"/><figcaption>При смахивании влево очередной карточки следующая занимает её место, а остальные пропорционально увеличиваются</figcaption></figure><p>В этом примере пользователь выбирает из стопки карточек нужную путем перебора, смахивая в сторону неподходящие. При смахивании следующая карточка увеличивается и занимает место той, что ушла вбок. Остальные карточки при этом тоже немного увеличиваются. Коллекция не останавливается в промежуточных состояниях, а автоматически размещает текущую или следующую карточку посередине экрана над всеми остальными.<br/><br/>На первый взгляд может показаться, что мы имеем дело с совершенно другим layout-ом, но на самом деле он получается из предыдущего всего лишь добавлением нескольких строк кода! Если присмотреться, то здесь концептуально только пара дополнительных эффектов - центрирование всех элементов и зум.<br/><br/>Сразу оговорюсь насчёт одной вещи. В этом (и следующем) примере по сути на каждое изменение bounds у collection нужно пересчитывать все атрибуты элементов. Для этого у layout-а есть функция <strong>shouldInvalidateLayout(forBoundsChange:)</strong>, которую нужно переопределить и, в самом простом случае, вернуть true. Конечно, можно это делать более эффективно, но я не гнался за эффективностью в данной статье. Цель была - скорее показать, что можно делать в UI с помощью UICollectionView.<br/><br/>Сначала будет удобнее разобраться с зумом. Мне показалась простой и лаконичной следующая идея. Возьмём число, меньшее единицы (например, 0.4), и будем считать, что это - минимальный scale для всех элементов в коллекции. Достигается этот минимум у последнего элемента, когда коллекция проскроллена к началу, т.е. когда contentOffset = 0. Соответственно, все айтемы, находящиеся правее центра экрана относительно контента (далее буду это называть просто центр экрана, что соответствует именно contentCenterX, обсуждавшемуся выше), будем равномерно увеличивать по мере приближения к этому центру. Другими словами, мы вводим некоторую величину вида:</p><pre><code class="swift">let scale = 0.4 + something * (1 - 0.4)</code></pre><p>где something - другая величина, изменяющаяся в пределах от 0 до 1 и зависящая от расположения элемента относительно центра.  Т.е. что-то вроде (1 - distance) / maxDistance, где maxDistance - наибольшее расстояние, на которое элемент коллекции может удалиться от центра экрана. Очевидно, достигается это расстояние при contentOffset = 0. Размер и расстояние между элементами по сути константны, поэтому мы можем без труда посчитать maxDistance:</p><pre><code class="swift">let maxDistance = (number - 1) * (itemWidth + Constants.distance)</code></pre><p>Все остальные величины для расчёта scale известны.</p><p>С расположением элементов по центру друг под другом всё попроще - мы уже знаем, что такое contentCenterX. Соответственно, если мы в конце цикла создания layout attributes добавим пару строк вида:</p><pre><code class="swift">if attr.center.x > contentCenterX {
	attr.center.x = contentCenterX
}</code></pre><p>то при скролле все элементы, которые должны были находиться правее центра экрана, соберутся друг под другом, и мы получим нужный эффект. При этом contentSize не меняется, и до всех карточек удаётся добраться несмотря на то, что визуально может казаться, что весь content занимает фиксированную ширину, равную ширине экрана девайса.<br/><br/>Наконец, смещение по вертикальной оси. Эмпирическим путём выяснил, что удобно поступать следующим образом: если ячейка уменьшена в scale раз, то относительно изначального размера сверху и снизу образуeтся зазор, на который уменьшенный item должен "торчать" из под item-а оригинального размера:</p><figure class="full-width "><img src="/img/image-loader.svg" height="220" data-src="https://habrastorage.org/getpro/habr/upload_files/aca/268/6bd/aca2686bdd1536e11cdf97edbd6b6992.png" data-width="602"/><figcaption></figcaption></figure><p>У такого подхода есть интересный эффект: расстояние, на которое соседние ячейки "вылезают" друг из-под друга постоянно и не зависит от порядковых номеров ячеек, кроме разве что между первой и второй (между первой и второй - сами понимаете). Т.е. item с номером 12 будет вылезать из-под item-а с номером 11 ровно на столько же, на сколько item с номером 17 будет вылезать из-под item-а с номером 16. Этот эффект можно прямо математически доказать, это несложно, но, думаю, здесь это не суть. Да и математики хватит в следующем примере.<br/><br/>В итоге, имея layot из предыдущего примера, дописываем в конец итерации цикла создания layout attribures внутри функции prepare примерно следующие строки:</p><pre><code class="swift">if attr.center.x > screenCenterX {
	let distance = attr.center.x  - screenCenterX
  let maxDistance = (number - 1) * (itemSize.width + Constants.distance)
  let scale = Constants.minScale 
  	+ abs(1 - distance / maxDistance) * (1 - Constants.minScale)
 
	attr.transform = CGAffineTransform(scaleX: scale, y: scale)
	attr.center.x = screenCenterX
	attr.center.y += itemSize.height * (1 - scale)
}</code></pre><p>Единственное, про что не упомянул - zIndex, но, думаю, что в этом смысле всё довольно очевидно, и уделять этому особого внимания не стоит.</p><details class="spoiler"><summary>Полный код для layout-а из примера 2</summary><div class="spoiler__content"><pre><code class="swift">import UIKit

final class CardsSwipeLayout: UICollectionViewFlowLayout {
  
  private var attrs: [UICollectionViewLayoutAttributes] = []
  
  // MARK: Override
  
  override func prepare() {
    super.prepare()
    
    attrs = []
    
    guard let collection = collectionView,
          collection.numberOfSections > 0 else {
      return
    }
    
    let itemSize = CGSize(
      width: collection.bounds.width - 2 * Constants.itemInset,
      height: Constants.itemHeight
    )
    
    let screenCenterX = collection.contentOffset.x + collection.bounds.width / 2
    let number = collection.numberOfItems(inSection: 0)
    
    for i in 0..&lt;number {
      let attr = UICollectionViewLayoutAttributes(forCellWith: IndexPath(row: i, section: 0))
      attr.frame = CGRect(
        x: Constants.itemInset + CGFloat(i) * (itemSize.width + Constants.distance),
        y: collection.bounds.height / 2 - Constants.itemHeight / 2,
        width: itemSize.width,
        height: itemSize.height
      )
      
      attr.zIndex = -i

      if attr.center.x > screenCenterX {
        let distance = attr.center.x  - screenCenterX
        let maxDistance = CGFloat(number - 1) * (itemSize.width + Constants.distance)
        let scale = Constants.minScale + abs(1 - distance / maxDistance) * (1 - Constants.minScale)

        attr.transform = CGAffineTransform(scaleX: scale, y: scale)
        attr.center.x = screenCenterX
        attr.center.y += itemSize.height * (1 - scale)
      }
      
      attrs.append(attr)
    }
  }
  
  override var collectionViewContentSize: CGSize {
    guard let collection = collectionView,
          collection.numberOfSections > 0 else { return .zero }
    let number = collection.numberOfItems(inSection: 0)
    let itemWidth = collection.bounds.width - 2 * Constants.itemInset
    let resultWidth = Constants.itemInset + CGFloat(number) * (Constants.distance + itemWidth)
      - Constants.distance
      + Constants.itemInset
    return CGSize(
      width: resultWidth,
      height: collection.bounds.height
    )
  }
  
  override func layoutAttributesForElements(
    in rect: CGRect
  ) -> [UICollectionViewLayoutAttributes]? {
    return attrs.filter { $0.frame.intersects(rect) }
  }
  
  override func layoutAttributesForItem(
    at indexPath: IndexPath
  ) -> UICollectionViewLayoutAttributes? {
    return attrs[indexPath.row]
  }
  
  override func targetContentOffset(
    forProposedContentOffset proposedContentOffset: CGPoint,
    withScrollingVelocity velocity: CGPoint
  ) -> CGPoint {
    guard let collection = collectionView else { return proposedContentOffset }
    
    let itemSize = CGSize(
      width: collection.bounds.width - 2 * Constants.itemInset,
      height: Constants.itemHeight
    )

    let diff = (Constants.distance / 2 - Constants.itemInset)
    let screenCenterX = proposedContentOffset.x + collection.bounds.width / 2 + diff
    let imaginaryItemWidth = itemSize.width + Constants.distance

    let index = Int(screenCenterX / imaginaryItemWidth)

    return CGPoint(
      x: CGFloat(index) * imaginaryItemWidth,
      y: proposedContentOffset.y
    )
  }
  
  override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool { true }
  
  // MARK: Constants
  
  // Every cell has length = collection's bounds minus itemInsets
  private enum Constants {
    static let itemHeight: CGFloat = 200
    static let itemInset: CGFloat = 36
    static let distance: CGFloat = 50
    
    static let minScale: CGFloat = 0.4
    static let itemYOffset: CGFloat = 20
  }
}</code></pre></div></details><h3>Селектор-барабан с зумом выбираемого элемента</h3><figure class="full-width "><img src="/img/image-loader.svg" alt="При скролле ближайший к центру элемент автоматически выравнивается и увеличивается" title="При скролле ближайший к центру элемент автоматически выравнивается и увеличивается" height="409" data-src="https://habrastorage.org/getpro/habr/upload_files/41f/202/3da/41f2023da20f55351cc704cbc4053685.png" data-width="800"/><figcaption>При скролле ближайший к центру элемент автоматически выравнивается и увеличивается</figcaption></figure><p>Здесь пользователь буквально вращает барабан, и элемент по центру является выбираемым. Так же, как и в предыдущих примерах, в промежуточных состояниях коллекция не "останавливается" - в итоге всё время какой-то из элементов находится ровно посередине.<br/><br/>Пожалуй, это самый интересный пример с точки зрения разработки. Дальнейшее объяснение условно разобью на три этапа: сначала про радиус барабана и размеры item-ов; затем про contentSize, расположение элементов и их форму; под конец про зум выбираемого элемента.<br/><br/>Итак, первое - внешняя окружность и размеры item-ов. На картинке выше расположена ровно половина круга, потому что высота коллекции это позволяет. Вообще говоря, могло бы быть иначе (как некогда и произошло в моём случае), т.е. высота коллекции ниже, и половина круга не вписывается в рамки collection:</p><figure class="float "><img src="/img/image-loader.svg" height="265" data-src="https://habrastorage.org/getpro/habr/upload_files/5a9/ca3/d35/5a9ca3d3568da0421a0d9e648b55eaec.png" data-width="449"/><figcaption></figcaption></figure><p>В целом это не влияет на механику барабана, только внешний вид немного меняется. Как, имея рамки коллекции, посчитать внешнюю окружность барабана? Обозначим высоту коллекции как <strong>h</strong>, половину ширины как <strong>w</strong>, радиус внешней окружности как <strong>R</strong> и нарисуем картинку, попутно вспоминая пару фактов из школьной геометрии:</p><figure class="full-width "><img src="/img/image-loader.svg" height="491" data-src="https://habrastorage.org/getpro/habr/upload_files/dde/9f5/c9a/dde9f5c9afc19df68bed0afc128a88b7.png" data-width="1228"/><figcaption></figcaption></figure><p>Пожалуй, сложнее всего вспомнить то, что центральный угол в два раза больше вписанного угла, если они опираются на одну и ту же дугу. А тригонометрические формулы можно подсмотреть в википедии. <br/><br/>Из формул получаем радиус внешней окружности:</p><pre><code class="swift">let radius = h > w ? w : (w * w + h * h) / (2 * h)</code></pre><p>Заодно мы можем получить угол, в котором заключены видимые элементы коллекции:</p><pre><code class="swift">let angle = h > w ? .pi : 4 * atan(h / w)</code></pre><p>Также, взяв количество видимых на экране элементов за константу numberOfVisibleItems, получаем угол, соответствующий каждому item-у:</p><pre><code class="swift">let anglePerItem = ange / numberOfVisibleItems</code></pre><p>Для расчёта размера item-а проделаем примерно то же самое, что и для расчёта радиуса внешней окружности, но в каком-то смысле в обратную сторону:</p><figure class="full-width "><img src="/img/image-loader.svg" height="729" data-src="https://habrastorage.org/getpro/habr/upload_files/d4e/5ba/9f6/d4e5ba9f65210135180f2d671ceeb9c1.png" data-width="1621"/><figcaption></figcaption></figure><p>Здесь мы взяли высоту каждой ячейки как константу, и из уравнений на картинке в результате получаем ширину item-а и радиус внутренней окружности:</p><pre><code class="swift">let width = 2 * radius * sin(anglePerItem / 2)
let innerRadius = (radius - itemHeight) / cos(anglePerItem / 2)</code></pre><p>Также, поскольку все элементы имеют одинаковый размер, и их верхние границы имеют одну и ту же форму в виде дуги окружности, можно легко получить длину этой дуги:</p><pre><code class="swift">let lengthPerItem = radius * anglePerItem</code></pre><p>Это пригодится для дальнейших расчётов.<br/><br/>Теперь перейдем к contentSize и расположению ячеек. Школьная задачка: на какой угол повернётся колесо радиусом R вокруг своей оси, если проедет расстояние L по ровной поверхности без проскальзывания? Ответ простой на самом деле - L / R. Понимание этого, возможно, требует некоторой интуиции и воображения. Если x1 - точка поверхности колеса, касающаяся пола до начала движения, x2 - точка касания пола в конце движения, то расстояние вдоль поверхности колеса между x1 и x2 будет равно в точности L, потому что колесо катится без проскальзывания и в каждый момент времени касается поверхности. Длина дуги окружности равна радиусу, умноженному на величину центрального угла, высекающего эту дугу - снова школа.<br/><br/>К чему это всё? А к тому, что в нашем случае есть практически то же самое колесо, только касается оно не пола, а "потолка" - воображаемой горизонтальной линии, касающейся внешней окружности барабана в верхней точке. Чтобы промотать всё содержимое коллекции до конца, нужно сдвинуть bounds примерно на сумму длин всех дуг, являющихся верхними гранями элементов коллекции. И, поскольку изначально первый и последний item-ы располагаются посередине экрана, получаем, что ширина всего содержимого collection равна:</p><pre><code class="swift">let width = collection.width + (number - 1) * lengthPerItem</code></pre><p>Здесь number - число элементов в коллекции. По краям добавляем по половине ширины collection, чтобы была возможность доскроллить контент до крайних item-ов.<br/><br/>Из рассуждений про колесо также следует, что расстояние вдоль поверхности барабана от его верхней точки в изначальном положении (contentOffset = 0) до середины верхней грани каждой ячейки равно:</p><pre><code class="swift">let absX = lengthPerItem * index</code></pre><p>Однако для вычисления угла поворота нам нужно расстояние до центра экрана, который, как мы уже выяснили, перемещается с изменением collection.bounds. В итоге отрезок, соединяющий центр барабана и центр item-а с индексом index, равен:</p><pre><code class="swift">var angle = (absX - collection.width / 2) / radius</code></pre><p>А теперь, впоминая формулы перехода от полярных координат к декартовым, мы можем вычислить положение центра item-а:</p><pre><code class="swift">let itemCenterRadius = radius - itemHeight / 2
attr.center = CGPoint(
  x: contentCenter.x + itemCenterRadius * sin(angle),
  y: contentCenter.y - itemCenterRadius * cos(angle)
)</code></pre><p>И тут сразу возникает пара нюансов. Во-первых, если все расчёты так и оставить, то при достаточно большом количестве элементов в коллекции они начнут наслаиваться друг на друга по кругу, потому что углы, скажем, в 30 градусов и 360 + 30 градусов ничем не будут отличаться с точки зрения вычислений. Эту проблему можно убрать следующим образом:</p><pre><code class="swift">if abs(angle) > CGFloat.pi / 2 + anglePerItem {
	angle = CGFloat.pi
}</code></pre><p>Т.е. мы по сути все ячейки, которые не должны быть видны в конкретный момент времени, складываем в одно и то же место где-то за пределами видимой части коллекции.<br/><br/>Во-вторых, когда мы проматываем collection в самое начало, мы хотим также видеть и последние элементы левее самого первого, чтобы в барабане не было "дырок". Оказалось довольно удобно решать это на уровне индексов элементов, в каком-то смысле обманывая вычисления: последнему элементу будем приписывать индекс, равный минус единице, предпоследнему - минус двойке и т.д. При таком подходе для последних item-ов будут получены правильные углы, и они встанут туда, куда нужно. Функцию можно будет посмотреть в полном коде для всего layout-а.<br/><br/>До сих пор мы рассматривали общие вещи, связанные с положением элементов, contentSize и прочее. А как же насчёт самой формы ячеек? Тут какие-то полуокружности... В этом нам помогут кастомные layout attributes! <br/><br/>Опять же напомню, что если мы хотим использовать класс, производный от UICollectionViewLayoutAttributes, в layout-е нужно переопределить свойство <strong>layoutAttributesClass</strong>, возвращая в нём соответствующий тип, а также создавать экземпляры этого класса внутри функции prepare для каждого элемента. Для придания нужной формы достаточно знать внешний радиус, внутренний радиус и угол:</p><pre><code class="swift">final class CarouselLayoutAttributes: UICollectionViewLayoutAttributes {
  var angle: CGFloat = 0
  var outerRadius: CGFloat = 0
  var innerRadius: CGFloat = 0
}</code></pre><p>Не забудьте переопределить <strong>copy(with:) </strong>и<strong> isEqual(_:)</strong>! Коллекция что-то там делает с атрибутами у себя внутри - копирует их, сравнивает. Без этих методов что-то может не работать. <br/><br/>Наверное, вы уже встречали на stackoverflow, что у класса UICollectionReusableView есть метод <strong>apply(_ layoutAttributes:)</strong>. В принципе его название говорит само за себя - метод даёт возможность применить  какие-то параметры, насчитанные в функции prepare, уже внутри UICollectionViewCell. Я бы даже сказал, это удобный способ передачи меняющихся параметров в каждую ячейку. Внутри ячейки, зная радиусы и угол, мы просто создаём слой-маску и задаём у него path вдоль дуг окружностей, образуемых поворотом имеющихся радиусов на имеющийся угол. Если кто не помнит, как задавать маски у слоёв, прошу <a href="http://habr.com/ru/post/549300/" rel="noopener noreferrer nofollow">сюда</a>.</p><details class="spoiler"><summary>Полный код ячейки из примера 3</summary><div class="spoiler__content"><pre><code class="swift">import UIKit

final class Cell: UICollectionViewCell {
  
  var title: String? {
    get { titleLabel.text }
    set { titleLabel.text = newValue }
  }
  
  var color: UIColor = .white {
    didSet { contentView.backgroundColor = color }
  }
  
  private var titleLabel: UILabel = {
    let label = UILabel()
    label.font = .systemFont(ofSize: 30, weight: .bold)
    return label
  }()
  
  private var angle: CGFloat = 0
  private var outerRadius: CGFloat = 0
  private var innerRadius: CGFloat = 0
  
  // MARK: Override
  
  override init(frame: CGRect) {
    super.init(frame: frame)
    setup()
  }
  
  required init?(coder: NSCoder) {
    super.init(coder: coder)
    setup()
  }
  
  override func layoutSubviews() {
    super.layoutSubviews()
    
    let path = UIBezierPath()
    path.addArc(withCenter: CGPoint(x: bounds.width / 2, y: outerRadius),
                radius: outerRadius,
                startAngle: -CGFloat.pi / 2 - angle / 2,
                endAngle: -CGFloat.pi / 2 + angle / 2,
                clockwise: true)
    path.addArc(withCenter: CGPoint(x: bounds.width / 2, y: outerRadius),
                radius: innerRadius,
                startAngle: -CGFloat.pi / 2 + angle / 2,
                endAngle: -CGFloat.pi / 2 - angle / 2,
                clockwise: false)
    path.close()

    (layer.mask as? CAShapeLayer)?.path = path.cgPath
  }
  
  override func apply(_ layoutAttributes: UICollectionViewLayoutAttributes) {
    guard let attr = layoutAttributes as? CarouselLayoutAttributes else { return }
    angle = attr.angle
    outerRadius = attr.outerRadius
    innerRadius = attr.innerRadius
  }
  
  // MARK: Setup
  
  private func setup() {
    contentView.backgroundColor = color
    layer.mask = CAShapeLayer()
    
    contentView.addSubview(titleLabel)
    titleLabel.translatesAutoresizingMaskIntoConstraints = false
    NSLayoutConstraint.activate([
      titleLabel.centerXAnchor.constraint(equalTo: contentView.centerXAnchor),
      titleLabel.centerYAnchor.constraint(equalTo: contentView.centerYAnchor)
    ])
  }
}</code></pre></div></details><p>Наконец, остался зум центрального элемента. С величиной зума всё довольно просто: максимальное значение достигается тогда, когда элемент находится ровно по центру (т.е. angle = 0), и по мере удаления от центра по окружности item уменьшается до первоначальных размеров. Причём уменьшается очень быстро - после того, как angle превысит anglePerItem, величина зума становится равной единице. Учитывая, что всё это изменяется линейно, получаем что-то вроде:</p><pre><code class="swift">let scale = max(Constants.maxScale - abs(angle) / anglePerItem, 1)</code></pre><p>Осталось только скорректировать форму ячейки во время зума. Дамы и господа, должен признать, что примерно в этом месте у меня уже поехала крыша, и радиусы подбирались мной чисто эмпирическим путём. В результате нескольких попыток получилось такое:</p><pre><code class="swift">let heightDiff = itemSizeHeight * (scale - 1)
attr.outerRadius = (radius + heightDiff / 2) / scale
attr.innerRadius = innerRadius / scale</code></pre><p>Объяснение этому примерно следующее. Зум физически осуществляется с помощью transform, при котором все расстояния в собственной плоскости item-а пропорционально увеличиваются относительно координат коллекции; мне хотелось сделать так, чтобы после зума центр окружности в "растянутой" плоскости ячейки, из которого рисуются дуги, совпал с центром окружности барабана в системе координат коллекции. Такой подход позволяет линиям, образующим боковые стороны секторов окружности, в которых по сути и находятся ячейки, как бы накладываться друг на друга, хоть они и находятся в разных системах координат. Визуально это выражается в том, что при зуме элементы "урезаются" по краям так, что не наезжают друг на друга, сохраняя изначальную ширину.<br/><br/>Посчитать, какими должны быть радиусы в старой системе координат после зума, несложно: внешний равен текущему + величина, на которую увеличенный item "вылезает" над оригинальным (itemHeight * scale - itemHeight) / 2; внутренний же радиус должен остаться без изменений, чтобы нижние грани ячеек образовывали сплошную гладкую линию без изломов. Но, поскольку мы находимся в другой системе координат, где всё растянуто, нужно итоговые величины разделить на scale.  </p><details class="spoiler"><summary>Полный код для layout-а из примера 3</summary><div class="spoiler__content"><pre><code class="swift">import UIKit

final class CarouselLayout: UICollectionViewFlowLayout {
  
  private var attrs: [UICollectionViewLayoutAttributes] = []
  
  // MARK: Override
  
  override static var layoutAttributesClass: AnyClass { CarouselLayoutAttributes.self }
  
  override var collectionViewContentSize: CGSize {
    guard let collection = collectionView,
          collection.numberOfSections > 0 else { return .zero }
    
    let radius = getRadius()
    let angle = getAngle()
    let anglePerItem = angle / CGFloat(Constants.numberOfVisibleItems)
    let lengthPerItem = anglePerItem * radius
    
    let width = collection.bounds.width + CGFloat(collection.numberOfItems(inSection: 0) - 1) * lengthPerItem 
    
    return CGSize(width: width, height: collection.bounds.height)
  }
  
  override func prepare() {
    super.prepare()
    
    attrs = []
    
    guard let collection = collectionView else { return }
    
    let radius = getRadius()
    let angle = getAngle()
    let anglePerItem = angle / CGFloat(Constants.numberOfVisibleItems)
    let lengthPerItem = anglePerItem * radius
    
    let itemSize = getItemSize(radius: radius, anglePerItem: anglePerItem)
    let contentCenter = getContentCenter(radius: radius)
    let itemCenterRadius = radius - itemSize.height / 2
    let innerRadius = (radius - itemSize.height) / cos(anglePerItem / 2)
    
    let numberOfItems = collection.numberOfItems(inSection: 0)
    let centerItemIndex = Int(collection.contentOffset.x / lengthPerItem)
    
    for i in 0..&lt;numberOfItems {
      let attr = CarouselLayoutAttributes(forCellWith: IndexPath(row: i, section: 0))
      attr.angle = anglePerItem
      
      let index = fakeItemIndexFor(itemIndex: i, centerItemIndex: centerItemIndex, numberOfItems: numberOfItems)
      
      let absX = lengthPerItem * CGFloat(index)
      let relativeX = absX - collection.contentOffset.x
      var angle = relativeX / radius
      
      if abs(angle) > CGFloat.pi / 2 + anglePerItem {
        angle = CGFloat.pi
      }
      
      let scale = max(Constants.maxScale - abs(angle) / anglePerItem, 1)
      
      attr.size = itemSize
      attr.center = CGPoint(x: contentCenter.x + itemCenterRadius * sin(angle),
                            y: contentCenter.y - itemCenterRadius * cos(angle))
      attr.transform = CGAffineTransform(rotationAngle: angle).scaledBy(x: scale, y: scale)
      attr.zIndex = Int(scale * 10) // just in caseй
      
      let heightDiff = itemSize.height * (scale - 1)
      attr.outerRadius = (radius + heightDiff / 2) / scale
      attr.innerRadius = innerRadius / scale
            
      attrs.append(attr)
    }
  }
  
  override func layoutAttributesForElements(
    in rect: CGRect
  ) -> [UICollectionViewLayoutAttributes]? {
    attrs
  }
  
  override func layoutAttributesForItem(
    at indexPath: IndexPath
  ) -> UICollectionViewLayoutAttributes? {
    attrs[indexPath.row]
  }
  
  override func targetContentOffset(
    forProposedContentOffset proposedContentOffset: CGPoint,
    withScrollingVelocity velocity: CGPoint
  ) -> CGPoint {
    let radius = getRadius()
    let angle = getAngle()
    let anglePerItem = angle / CGFloat(Constants.numberOfVisibleItems)
    let lengthPerItem = anglePerItem * radius
    
    let floatIndex = floor((proposedContentOffset.x + lengthPerItem / 2) / lengthPerItem)

    let x = floatIndex * lengthPerItem

    return CGPoint(x: x, y: proposedContentOffset.y)
  }
  
  override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool { true }
  
  // MARK: Helpers
  
  private func getRadius() -> CGFloat {
    guard let bounds = collectionView?.bounds else { return 0 }
    
    let w = bounds.width / 2
    let h = bounds.height
    
    return h > w ? w : (w * w + h * h) / (2 * h)
  }
  
  private func getAngle() -> CGFloat {
    guard let bounds = collectionView?.bounds else { return 0 }
    
    let w = bounds.width / 2
    let h = bounds.height
    
    return h > w ? .pi : 4 * atan(h / w)
  }
  
  func getContentCenter(radius: CGFloat) -> CGPoint {
    guard let collection = collectionView else { return .zero }
    
    let w = collection.bounds.width / 2
    let h = collection.bounds.height
    let offset = collection.contentOffset.x
    
    return h > w ? .init(x: w + offset, y: h) : .init(x: w + offset, y: radius)
  }
  
  private func getItemSize(radius: CGFloat, anglePerItem: CGFloat) -> CGSize {
    let width = 2 * radius * sin(anglePerItem / 2)
    return CGSize(width: width, height: Constants.itemHeight)
  }
  
  private func fakeItemIndexFor(itemIndex: Int, centerItemIndex: Int, numberOfItems: Int) -> Int {
    if centerItemIndex &lt; Constants.numberOfVisibleItems {
      return itemIndex >= numberOfItems - Constants.numberOfVisibleItems ? itemIndex - numberOfItems : itemIndex
    } else if centerItemIndex >= numberOfItems - Constants.numberOfVisibleItems {
      return itemIndex &lt; Constants.numberOfVisibleItems ? numberOfItems + itemIndex : itemIndex
    } else {
      return itemIndex
    }
  }
  
  // MARK: Constants
  
  private enum Constants {
    static let numberOfVisibleItems = 5
    static let itemHeight: CGFloat = 70
    static let maxScale: CGFloat = 1.7
  }
}</code></pre></div></details><h3>Заключение</h3><p>На этих трёх примерах пытался показать, что можно делать с помощью коллекций, layout-ов и капли воображения. Копируйте код, играйтесь с параметрами, используйте у себя в проектах! Надеюсь, было интересно.<br/><br/><strong>Things to remember:</strong></p><ul><li><p><strong>contentSize</strong> - пожалуй первое, с чего надо начать, если хотите "поиздеваться" над ячейками коллекции;</p></li><li><p><strong>targetContentOffset </strong>- можно повлиять на момент остановки скролла<strong>;</strong></p></li><li><p><strong>shouldInvalidateLayout </strong>- можно переопределять, если необходимы частые обновления атрибутов ячеек при скролле;</p></li><li><p><strong>layoutAttributesClass + apply(_ layoutAttributes:) </strong>- возможность передать дополнительные атрибуты в каждую из ячеек;</p></li><li><p><strong>школьная математика</strong> не так уж и бесполезна.</p></li></ul><p>Всем добра, пишите классные приложения и делайте красоту в интерфейсах!</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bswitch%5D" class="tm-tags-list__link">switch</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%5D" class="tm-tags-list__link">ios</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bios%20development%5D" class="tm-tags-list__link">ios development</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bui%5D" class="tm-tags-list__link">ui</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/ios_dev/" class="tm-hubs-list__link">
    Разработка под iOS
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/mobile_dev/" class="tm-hubs-list__link">
    Разработка мобильных приложений
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/swift/" class="tm-hubs-list__link">
    Swift
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/apps_design/" class="tm-hubs-list__link">
    Дизайн мобильных приложений
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 7: ↑7 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 7: ↑7 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+7</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">2.7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    42
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/kostyanoy/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_pink"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 11 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    11
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">7</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/kostyanoy/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @kostyanoy
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">iOS developer</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/583368/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 5 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/583368/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/583368/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"583368":{"id":"583368","timePublished":"2021-10-13T21:15:34+00:00","isCorporative":false,"lang":"ru","titleHtml":"iOS. UI. Приёмы. Часть 2","leadData":{"textHtml":"\u003Cp\u003EПривет читателям хабра! В прошлой \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F549300\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eстатье\u003C\u002Fa\u003E рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на довольно интересных, на мой взгляд, примерах.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8ee\u002F77d\u002F287\u002F8ee77d287a1e0e62a7cecbc9fa11687a.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8ee\u002F77d\u002F287\u002F8ee77d287a1e0e62a7cecbc9fa11687a.png","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":11,"votesCount":11},"rating":7,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"239177","alias":"kostyanoy","fullname":null,"avatarUrl":null,"speciality":"iOS developer"},"statistics":{"commentsCount":5,"favoritesCount":42,"readingCount":2708,"score":7,"votesCount":7},"hubs":[{"relatedData":null,"id":"548","alias":"ios_dev","type":"collective","title":"Разработка под iOS","titleHtml":"Разработка под iOS","isProfiled":true},{"relatedData":null,"id":"6345","alias":"mobile_dev","type":"collective","title":"Разработка мобильных приложений","titleHtml":"Разработка мобильных приложений","isProfiled":true},{"relatedData":null,"id":"19039","alias":"swift","type":"collective","title":"Swift","titleHtml":"Swift","isProfiled":true},{"relatedData":null,"id":"19465","alias":"apps_design","type":"collective","title":"Дизайн мобильных приложений","titleHtml":"Дизайн мобильных приложений","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"2","alias":"design","title":"Дизайн"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EПривет читателям хабра! В прошлой \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F549300\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eстатье\u003C\u002Fa\u003E рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на довольно интересных, на мой взгляд, примерах.\u003C\u002Fp\u003E\u003Ch3\u003EВведение\u003C\u002Fh3\u003E\u003Cp\u003EПредполагаю, что читатель достаточно хорошо знаком с UICollectionView, т.е. понимает, куда и как прокидывать данные, как задавать layout, что вообще такое UICollectionViewLayout и т.п. На момент написания были некоторые сомнения об актуальности материала, но SwiftUI вроде бы ещё не занял доминирующую позицию, да и слышал от разработчиков, что на нём сильно кастомные компоненты проблематично создавать.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EВсе примеры взяты из жизни с незначительными модификациями. Во вставках с кодом умышленно допущены неточности для более удобной читаемости. Крайние случаи вроде всяких пограничных переходов позволил себе не рассматривать, чтобы не загромождать код в примерах. Если у вас будет что-то падать при попытке запуска примеров кода, попробуйте выставить \u003Cstrong\u003EestimatedItemSize \u003C\u002Fstrong\u003Eв ноль\u003Cstrong\u003E.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Ch3\u003EСелектор в виде горизонтального списка\u003C\u002Fh3\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"При скролле ближайший элемент автоматически выравнивается по центру\" title=\"При скролле ближайший элемент автоматически выравнивается по центру\" height=\"403\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F703\u002F52c\u002Fe03\u002F70352ce03294ec837efd2c5caabb299a.png\" data-width=\"800\"\u002F\u003E\u003Cfigcaption\u003EПри скролле ближайший элемент автоматически выравнивается по центру\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EС точки зрения пользователя имеем горизонтально скроллящийся список карточек, в котором после каждого свайпа и прекращения движения по инерции ближайшая к центру экрана карточка автоматически оказывается ровно посередине. В банковских приложениях такое частенько можно увидеть.\u003C\u002Fp\u003E\u003Cp\u003EПрежде чем пускаться в детали, напомню вкратце про самые, пожалуй, важные методы, которые нужно переопределять при создании кастомного layout-а: в функции \u003Cstrong\u003Eprepare\u003C\u002Fstrong\u003E мы создаём layout attributes (UICollectionViewLayoutAttributes), которые затем \"скармливаем\" функции \u003Cstrong\u003ElayoutAttributesForElements(in:)\u003C\u002Fstrong\u003E. И ещё важно переопределить \u003Cstrong\u003EcollectionViewContentSize\u003C\u002Fstrong\u003E, чтобы всем ячейкам хватило места.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EВ случаях таких layout-ов, мне кажется, удобно задавать ширину ячейки как \"ширина коллекции минус константное расстояние по бокам\", а высоту уже брать как захочется, потому что она на scroll, можно сказать, не влияет. Т.е. в начале функции prepare можно написать что-то вроде:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003EitemSize = CGSize(\n\twidth: collection.bounds.width - 2 * Constants.itemInset,\n\theight: Constants.itemHeight\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТакже расстояние между элементами коллекции можно взять за константу и подгонять её так, чтобы покрасивее смотрелось. Расположение ячеек - дело нехитрое, в коде будет выглядеть примерно так:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eattr.frame = CGRect(\n\tx: Constants.itemInset + i * (itemSize.width + Constants.distance),\n  y: collection.bounds.height \u002F 2 - Constants.itemHeight \u002F 2,\n  width: itemSize.width,\n  height: itemSize.height\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВнутри collectionContentSize будет что-то очень похожее. Самое интересное в этом примере - выравнивание item-ов по центру. В этом нам поможет функция \u003Cstrong\u003EtargetContentOffset(forProposedContentOffset:withScrollingVelocity)\u003C\u002Fstrong\u003E, которая переопределяется внутри layout. Её смысл примерно в следующем: после того как юзер проводит чем-нибудь по экрану и потом отпускает экран, коллекция продолжает проматывать содержимое по инерции, зная заранее, в какой точке она остановится. TargetContentOffset позволяет вмешаться в этот процесс и сказать collection, где ей остановиться. А это как раз то, что нам нужно. Т.е. эта функция работает так, что на вход подаётся contentOffset, в котором коллекция собирается \"остановиться\", а её возвращаемое значение - скорректированный contetOffset.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EИтак, мы знаем, при каком contentOffset коллекция собирается перестать скроллить контент. В этот момент положение центра экрана относительно всего контента равно\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet contentCenterX = contentOffset + collection.width \u002F 2\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЛогично, что нужно найти item, центр которого ближе всего к этой величине. Для этого, как мне показалось, проще мысленно провести разделительные линии посередине между элементами коллекции и представить, что мы имеем дело с \"мнимыми\" элементами большего размера, располагающимися вплотную друг к другу:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"386\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ffd6\u002F61b\u002F9f5\u002Ffd661b9f5487355a25140b28ba52cf36.png\" data-width=\"645\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПри таком раскладе точка в центре экрана обязательно попадет в какой-то мнимый item, индекс которого легко вычисляется:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet imaginaryItemWidth = itemWidth + Constants.distance\nlet index = Int(contentCenterX \u002F imaginaryItemWidth)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОднако это даёт не совсем точный результат из-за несоответствия расстояния между ячейками и ширины самих ячеек по отношению к ширине коллекции - мнимые элементы в нашем случае в сумме дают большую ширину, чем contentSize.width. Выражаться это будет в том, что в каких-то пограничных случаях (например, центр видимой области экрана попадает ровно посередине между item-ами) подскролливаться к центру будет не тот элемент, который мы ожидаем.\u003C\u002Fp\u003E\u003Cp\u003EИсправить проблему просто - добавить (или отнять) недостающее расстояние в contentCenterX:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet diff = (Constants.distance \u002F 2 - Constants.itemInset)\ncontentCenterX = proposedContentOffset.x + collection.width \u002F 2 + diff\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eи после этого уже вычислять индекс элемента. В итоге в функции targetContentOffset нужно вернуть новый contentOffset в виде:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003ECGPoint(\n\tx: index * imaginaryItemWidth,\n\ty: proposedContentOffset.y\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EПолный код для layout-а из примера 1\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eimport UIKit\n\nfinal class SelectorSimpleLayout: UICollectionViewFlowLayout {\n  \n  private var attrs: [UICollectionViewLayoutAttributes] = []\n  \n  \u002F\u002F MARK: Override\n  \n  override var collectionViewContentSize: CGSize {\n    guard let collection = collectionView,\n          collection.numberOfSections \u003E 0 else { return .zero }\n    let number = collection.numberOfItems(inSection: 0)\n    let itemWidth = collection.bounds.width - 2 * Constants.itemInset\n    let resultWidth = Constants.itemInset + CGFloat(number) * (Constants.distance + itemWidth)\n      - Constants.distance\n      + Constants.itemInset\n    return CGSize(\n      width: resultWidth,\n      height: collection.bounds.height\n    )\n  }\n  \n  override func prepare() {\n    super.prepare()\n    \n    attrs = []\n    \n    guard let collection = collectionView,\n          collection.numberOfSections \u003E 0 else { return }\n    \n    itemSize = CGSize(\n      width: collection.bounds.width - 2 * Constants.itemInset,\n      height: Constants.itemHeight\n    )\n    \n    for i in 0..&lt;collection.numberOfItems(inSection: 0) {\n      let attr = UICollectionViewLayoutAttributes(forCellWith: IndexPath(row: i, section: 0))\n      attr.frame = CGRect(\n        x: Constants.itemInset + CGFloat(i) * (itemSize.width + Constants.distance),\n        y: collection.bounds.height \u002F 2 - Constants.itemHeight \u002F 2,\n        width: itemSize.width,\n        height: itemSize.height\n      )\n      attrs.append(attr)\n    }\n  }\n  \n  override func layoutAttributesForElements(\n    in rect: CGRect\n  ) -\u003E [UICollectionViewLayoutAttributes]? {\n    attrs.filter { $0.frame.intersects(rect) }\n  }\n  \n  override func layoutAttributesForItem(\n    at indexPath: IndexPath\n  ) -\u003E UICollectionViewLayoutAttributes? {\n    attrs[indexPath.row]\n  }\n  \n  override func targetContentOffset(\n    forProposedContentOffset proposedContentOffset: CGPoint,\n    withScrollingVelocity velocity: CGPoint\n  ) -\u003E CGPoint {\n    guard let collection = collectionView else { return proposedContentOffset }\n    \n    let diff = (Constants.distance \u002F 2 - Constants.itemInset)\n    let contentCenterX = proposedContentOffset.x + collection.bounds.width \u002F 2 + diff\n    let imaginaryItemWidth = itemSize.width + Constants.distance\n    \n    let index = Int(contentCenterX \u002F imaginaryItemWidth)\n    \n    return CGPoint(\n      x: CGFloat(index) * imaginaryItemWidth,\n      y: proposedContentOffset.y\n    )\n  }\n  \n  \u002F\u002F MARK: Constants\n  \n  \u002F\u002F Every cell has length = collection's bounds minus itemInsets\n  private enum Constants {\n    static let itemHeight: CGFloat = 200\n    static let itemInset: CGFloat = 36\n    static let distance: CGFloat = 100\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ch3\u003EСелектор в виде стопки карточек со свайпом влево\u003C\u002Fh3\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"При смахивании влево очередной карточки следующая занимает её место, а остальные пропорционально увеличиваются\" title=\"При смахивании влево очередной карточки следующая занимает её место, а остальные пропорционально увеличиваются\" height=\"404\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcf5\u002F58f\u002F006\u002Fcf558f0065cf4eac4422b1f70b03ee08.png\" data-width=\"802\"\u002F\u003E\u003Cfigcaption\u003EПри смахивании влево очередной карточки следующая занимает её место, а остальные пропорционально увеличиваются\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВ этом примере пользователь выбирает из стопки карточек нужную путем перебора, смахивая в сторону неподходящие. При смахивании следующая карточка увеличивается и занимает место той, что ушла вбок. Остальные карточки при этом тоже немного увеличиваются. Коллекция не останавливается в промежуточных состояниях, а автоматически размещает текущую или следующую карточку посередине экрана над всеми остальными.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EНа первый взгляд может показаться, что мы имеем дело с совершенно другим layout-ом, но на самом деле он получается из предыдущего всего лишь добавлением нескольких строк кода! Если присмотреться, то здесь концептуально только пара дополнительных эффектов - центрирование всех элементов и зум.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EСразу оговорюсь насчёт одной вещи. В этом (и следующем) примере по сути на каждое изменение bounds у collection нужно пересчитывать все атрибуты элементов. Для этого у layout-а есть функция \u003Cstrong\u003EshouldInvalidateLayout(forBoundsChange:)\u003C\u002Fstrong\u003E, которую нужно переопределить и, в самом простом случае, вернуть true. Конечно, можно это делать более эффективно, но я не гнался за эффективностью в данной статье. Цель была - скорее показать, что можно делать в UI с помощью UICollectionView.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EСначала будет удобнее разобраться с зумом. Мне показалась простой и лаконичной следующая идея. Возьмём число, меньшее единицы (например, 0.4), и будем считать, что это - минимальный scale для всех элементов в коллекции. Достигается этот минимум у последнего элемента, когда коллекция проскроллена к началу, т.е. когда contentOffset = 0. Соответственно, все айтемы, находящиеся правее центра экрана относительно контента (далее буду это называть просто центр экрана, что соответствует именно contentCenterX, обсуждавшемуся выше), будем равномерно увеличивать по мере приближения к этому центру. Другими словами, мы вводим некоторую величину вида:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet scale = 0.4 + something * (1 - 0.4)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eгде something - другая величина, изменяющаяся в пределах от 0 до 1 и зависящая от расположения элемента относительно центра.  Т.е. что-то вроде (1 - distance) \u002F maxDistance, где maxDistance - наибольшее расстояние, на которое элемент коллекции может удалиться от центра экрана. Очевидно, достигается это расстояние при contentOffset = 0. Размер и расстояние между элементами по сути константны, поэтому мы можем без труда посчитать maxDistance:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet maxDistance = (number - 1) * (itemWidth + Constants.distance)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВсе остальные величины для расчёта scale известны.\u003C\u002Fp\u003E\u003Cp\u003EС расположением элементов по центру друг под другом всё попроще - мы уже знаем, что такое contentCenterX. Соответственно, если мы в конце цикла создания layout attributes добавим пару строк вида:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eif attr.center.x \u003E contentCenterX {\n\tattr.center.x = contentCenterX\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eто при скролле все элементы, которые должны были находиться правее центра экрана, соберутся друг под другом, и мы получим нужный эффект. При этом contentSize не меняется, и до всех карточек удаётся добраться несмотря на то, что визуально может казаться, что весь content занимает фиксированную ширину, равную ширине экрана девайса.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EНаконец, смещение по вертикальной оси. Эмпирическим путём выяснил, что удобно поступать следующим образом: если ячейка уменьшена в scale раз, то относительно изначального размера сверху и снизу образуeтся зазор, на который уменьшенный item должен \"торчать\" из под item-а оригинального размера:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"220\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Faca\u002F268\u002F6bd\u002Faca2686bdd1536e11cdf97edbd6b6992.png\" data-width=\"602\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EУ такого подхода есть интересный эффект: расстояние, на которое соседние ячейки \"вылезают\" друг из-под друга постоянно и не зависит от порядковых номеров ячеек, кроме разве что между первой и второй (между первой и второй - сами понимаете). Т.е. item с номером 12 будет вылезать из-под item-а с номером 11 ровно на столько же, на сколько item с номером 17 будет вылезать из-под item-а с номером 16. Этот эффект можно прямо математически доказать, это несложно, но, думаю, здесь это не суть. Да и математики хватит в следующем примере.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EВ итоге, имея layot из предыдущего примера, дописываем в конец итерации цикла создания layout attribures внутри функции prepare примерно следующие строки:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eif attr.center.x \u003E screenCenterX {\n\tlet distance = attr.center.x  - screenCenterX\n  let maxDistance = (number - 1) * (itemSize.width + Constants.distance)\n  let scale = Constants.minScale \n  \t+ abs(1 - distance \u002F maxDistance) * (1 - Constants.minScale)\n \n\tattr.transform = CGAffineTransform(scaleX: scale, y: scale)\n\tattr.center.x = screenCenterX\n\tattr.center.y += itemSize.height * (1 - scale)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЕдинственное, про что не упомянул - zIndex, но, думаю, что в этом смысле всё довольно очевидно, и уделять этому особого внимания не стоит.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EПолный код для layout-а из примера 2\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eimport UIKit\n\nfinal class CardsSwipeLayout: UICollectionViewFlowLayout {\n  \n  private var attrs: [UICollectionViewLayoutAttributes] = []\n  \n  \u002F\u002F MARK: Override\n  \n  override func prepare() {\n    super.prepare()\n    \n    attrs = []\n    \n    guard let collection = collectionView,\n          collection.numberOfSections \u003E 0 else {\n      return\n    }\n    \n    let itemSize = CGSize(\n      width: collection.bounds.width - 2 * Constants.itemInset,\n      height: Constants.itemHeight\n    )\n    \n    let screenCenterX = collection.contentOffset.x + collection.bounds.width \u002F 2\n    let number = collection.numberOfItems(inSection: 0)\n    \n    for i in 0..&lt;number {\n      let attr = UICollectionViewLayoutAttributes(forCellWith: IndexPath(row: i, section: 0))\n      attr.frame = CGRect(\n        x: Constants.itemInset + CGFloat(i) * (itemSize.width + Constants.distance),\n        y: collection.bounds.height \u002F 2 - Constants.itemHeight \u002F 2,\n        width: itemSize.width,\n        height: itemSize.height\n      )\n      \n      attr.zIndex = -i\n\n      if attr.center.x \u003E screenCenterX {\n        let distance = attr.center.x  - screenCenterX\n        let maxDistance = CGFloat(number - 1) * (itemSize.width + Constants.distance)\n        let scale = Constants.minScale + abs(1 - distance \u002F maxDistance) * (1 - Constants.minScale)\n\n        attr.transform = CGAffineTransform(scaleX: scale, y: scale)\n        attr.center.x = screenCenterX\n        attr.center.y += itemSize.height * (1 - scale)\n      }\n      \n      attrs.append(attr)\n    }\n  }\n  \n  override var collectionViewContentSize: CGSize {\n    guard let collection = collectionView,\n          collection.numberOfSections \u003E 0 else { return .zero }\n    let number = collection.numberOfItems(inSection: 0)\n    let itemWidth = collection.bounds.width - 2 * Constants.itemInset\n    let resultWidth = Constants.itemInset + CGFloat(number) * (Constants.distance + itemWidth)\n      - Constants.distance\n      + Constants.itemInset\n    return CGSize(\n      width: resultWidth,\n      height: collection.bounds.height\n    )\n  }\n  \n  override func layoutAttributesForElements(\n    in rect: CGRect\n  ) -\u003E [UICollectionViewLayoutAttributes]? {\n    return attrs.filter { $0.frame.intersects(rect) }\n  }\n  \n  override func layoutAttributesForItem(\n    at indexPath: IndexPath\n  ) -\u003E UICollectionViewLayoutAttributes? {\n    return attrs[indexPath.row]\n  }\n  \n  override func targetContentOffset(\n    forProposedContentOffset proposedContentOffset: CGPoint,\n    withScrollingVelocity velocity: CGPoint\n  ) -\u003E CGPoint {\n    guard let collection = collectionView else { return proposedContentOffset }\n    \n    let itemSize = CGSize(\n      width: collection.bounds.width - 2 * Constants.itemInset,\n      height: Constants.itemHeight\n    )\n\n    let diff = (Constants.distance \u002F 2 - Constants.itemInset)\n    let screenCenterX = proposedContentOffset.x + collection.bounds.width \u002F 2 + diff\n    let imaginaryItemWidth = itemSize.width + Constants.distance\n\n    let index = Int(screenCenterX \u002F imaginaryItemWidth)\n\n    return CGPoint(\n      x: CGFloat(index) * imaginaryItemWidth,\n      y: proposedContentOffset.y\n    )\n  }\n  \n  override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -\u003E Bool { true }\n  \n  \u002F\u002F MARK: Constants\n  \n  \u002F\u002F Every cell has length = collection's bounds minus itemInsets\n  private enum Constants {\n    static let itemHeight: CGFloat = 200\n    static let itemInset: CGFloat = 36\n    static let distance: CGFloat = 50\n    \n    static let minScale: CGFloat = 0.4\n    static let itemYOffset: CGFloat = 20\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ch3\u003EСелектор-барабан с зумом выбираемого элемента\u003C\u002Fh3\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"При скролле ближайший к центру элемент автоматически выравнивается и увеличивается\" title=\"При скролле ближайший к центру элемент автоматически выравнивается и увеличивается\" height=\"409\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F41f\u002F202\u002F3da\u002F41f2023da20f55351cc704cbc4053685.png\" data-width=\"800\"\u002F\u003E\u003Cfigcaption\u003EПри скролле ближайший к центру элемент автоматически выравнивается и увеличивается\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЗдесь пользователь буквально вращает барабан, и элемент по центру является выбираемым. Так же, как и в предыдущих примерах, в промежуточных состояниях коллекция не \"останавливается\" - в итоге всё время какой-то из элементов находится ровно посередине.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EПожалуй, это самый интересный пример с точки зрения разработки. Дальнейшее объяснение условно разобью на три этапа: сначала про радиус барабана и размеры item-ов; затем про contentSize, расположение элементов и их форму; под конец про зум выбираемого элемента.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EИтак, первое - внешняя окружность и размеры item-ов. На картинке выше расположена ровно половина круга, потому что высота коллекции это позволяет. Вообще говоря, могло бы быть иначе (как некогда и произошло в моём случае), т.е. высота коллекции ниже, и половина круга не вписывается в рамки collection:\u003C\u002Fp\u003E\u003Cfigure class=\"float \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"265\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F5a9\u002Fca3\u002Fd35\u002F5a9ca3d3568da0421a0d9e648b55eaec.png\" data-width=\"449\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВ целом это не влияет на механику барабана, только внешний вид немного меняется. Как, имея рамки коллекции, посчитать внешнюю окружность барабана? Обозначим высоту коллекции как \u003Cstrong\u003Eh\u003C\u002Fstrong\u003E, половину ширины как \u003Cstrong\u003Ew\u003C\u002Fstrong\u003E, радиус внешней окружности как \u003Cstrong\u003ER\u003C\u002Fstrong\u003E и нарисуем картинку, попутно вспоминая пару фактов из школьной геометрии:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"491\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fdde\u002F9f5\u002Fc9a\u002Fdde9f5c9afc19df68bed0afc128a88b7.png\" data-width=\"1228\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПожалуй, сложнее всего вспомнить то, что центральный угол в два раза больше вписанного угла, если они опираются на одну и ту же дугу. А тригонометрические формулы можно подсмотреть в википедии. \u003Cbr\u002F\u003E\u003Cbr\u002F\u003EИз формул получаем радиус внешней окружности:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet radius = h \u003E w ? w : (w * w + h * h) \u002F (2 * h)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗаодно мы можем получить угол, в котором заключены видимые элементы коллекции:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet angle = h \u003E w ? .pi : 4 * atan(h \u002F w)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТакже, взяв количество видимых на экране элементов за константу numberOfVisibleItems, получаем угол, соответствующий каждому item-у:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet anglePerItem = ange \u002F numberOfVisibleItems\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EДля расчёта размера item-а проделаем примерно то же самое, что и для расчёта радиуса внешней окружности, но в каком-то смысле в обратную сторону:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"729\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd4e\u002F5ba\u002F9f6\u002Fd4e5ba9f65210135180f2d671ceeb9c1.png\" data-width=\"1621\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EЗдесь мы взяли высоту каждой ячейки как константу, и из уравнений на картинке в результате получаем ширину item-а и радиус внутренней окружности:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet width = 2 * radius * sin(anglePerItem \u002F 2)\nlet innerRadius = (radius - itemHeight) \u002F cos(anglePerItem \u002F 2)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТакже, поскольку все элементы имеют одинаковый размер, и их верхние границы имеют одну и ту же форму в виде дуги окружности, можно легко получить длину этой дуги:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet lengthPerItem = radius * anglePerItem\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЭто пригодится для дальнейших расчётов.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EТеперь перейдем к contentSize и расположению ячеек. Школьная задачка: на какой угол повернётся колесо радиусом R вокруг своей оси, если проедет расстояние L по ровной поверхности без проскальзывания? Ответ простой на самом деле - L \u002F R. Понимание этого, возможно, требует некоторой интуиции и воображения. Если x1 - точка поверхности колеса, касающаяся пола до начала движения, x2 - точка касания пола в конце движения, то расстояние вдоль поверхности колеса между x1 и x2 будет равно в точности L, потому что колесо катится без проскальзывания и в каждый момент времени касается поверхности. Длина дуги окружности равна радиусу, умноженному на величину центрального угла, высекающего эту дугу - снова школа.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EК чему это всё? А к тому, что в нашем случае есть практически то же самое колесо, только касается оно не пола, а \"потолка\" - воображаемой горизонтальной линии, касающейся внешней окружности барабана в верхней точке. Чтобы промотать всё содержимое коллекции до конца, нужно сдвинуть bounds примерно на сумму длин всех дуг, являющихся верхними гранями элементов коллекции. И, поскольку изначально первый и последний item-ы располагаются посередине экрана, получаем, что ширина всего содержимого collection равна:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet width = collection.width + (number - 1) * lengthPerItem\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗдесь number - число элементов в коллекции. По краям добавляем по половине ширины collection, чтобы была возможность доскроллить контент до крайних item-ов.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EИз рассуждений про колесо также следует, что расстояние вдоль поверхности барабана от его верхней точки в изначальном положении (contentOffset = 0) до середины верхней грани каждой ячейки равно:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet absX = lengthPerItem * index\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОднако для вычисления угла поворота нам нужно расстояние до центра экрана, который, как мы уже выяснили, перемещается с изменением collection.bounds. В итоге отрезок, соединяющий центр барабана и центр item-а с индексом index, равен:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Evar angle = (absX - collection.width \u002F 2) \u002F radius\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EА теперь, впоминая формулы перехода от полярных координат к декартовым, мы можем вычислить положение центра item-а:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet itemCenterRadius = radius - itemHeight \u002F 2\nattr.center = CGPoint(\n  x: contentCenter.x + itemCenterRadius * sin(angle),\n  y: contentCenter.y - itemCenterRadius * cos(angle)\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EИ тут сразу возникает пара нюансов. Во-первых, если все расчёты так и оставить, то при достаточно большом количестве элементов в коллекции они начнут наслаиваться друг на друга по кругу, потому что углы, скажем, в 30 градусов и 360 + 30 градусов ничем не будут отличаться с точки зрения вычислений. Эту проблему можно убрать следующим образом:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eif abs(angle) \u003E CGFloat.pi \u002F 2 + anglePerItem {\n\tangle = CGFloat.pi\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EТ.е. мы по сути все ячейки, которые не должны быть видны в конкретный момент времени, складываем в одно и то же место где-то за пределами видимой части коллекции.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EВо-вторых, когда мы проматываем collection в самое начало, мы хотим также видеть и последние элементы левее самого первого, чтобы в барабане не было \"дырок\". Оказалось довольно удобно решать это на уровне индексов элементов, в каком-то смысле обманывая вычисления: последнему элементу будем приписывать индекс, равный минус единице, предпоследнему - минус двойке и т.д. При таком подходе для последних item-ов будут получены правильные углы, и они встанут туда, куда нужно. Функцию можно будет посмотреть в полном коде для всего layout-а.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EДо сих пор мы рассматривали общие вещи, связанные с положением элементов, contentSize и прочее. А как же насчёт самой формы ячеек? Тут какие-то полуокружности... В этом нам помогут кастомные layout attributes! \u003Cbr\u002F\u003E\u003Cbr\u002F\u003EОпять же напомню, что если мы хотим использовать класс, производный от UICollectionViewLayoutAttributes, в layout-е нужно переопределить свойство \u003Cstrong\u003ElayoutAttributesClass\u003C\u002Fstrong\u003E, возвращая в нём соответствующий тип, а также создавать экземпляры этого класса внутри функции prepare для каждого элемента. Для придания нужной формы достаточно знать внешний радиус, внутренний радиус и угол:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Efinal class CarouselLayoutAttributes: UICollectionViewLayoutAttributes {\n  var angle: CGFloat = 0\n  var outerRadius: CGFloat = 0\n  var innerRadius: CGFloat = 0\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНе забудьте переопределить \u003Cstrong\u003Ecopy(with:) \u003C\u002Fstrong\u003Eи\u003Cstrong\u003E isEqual(_:)\u003C\u002Fstrong\u003E! Коллекция что-то там делает с атрибутами у себя внутри - копирует их, сравнивает. Без этих методов что-то может не работать. \u003Cbr\u002F\u003E\u003Cbr\u002F\u003EНаверное, вы уже встречали на stackoverflow, что у класса UICollectionReusableView есть метод \u003Cstrong\u003Eapply(_ layoutAttributes:)\u003C\u002Fstrong\u003E. В принципе его название говорит само за себя - метод даёт возможность применить  какие-то параметры, насчитанные в функции prepare, уже внутри UICollectionViewCell. Я бы даже сказал, это удобный способ передачи меняющихся параметров в каждую ячейку. Внутри ячейки, зная радиусы и угол, мы просто создаём слой-маску и задаём у него path вдоль дуг окружностей, образуемых поворотом имеющихся радиусов на имеющийся угол. Если кто не помнит, как задавать маски у слоёв, прошу \u003Ca href=\"http:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F549300\u002F\" rel=\"noopener noreferrer nofollow\"\u003Eсюда\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EПолный код ячейки из примера 3\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eimport UIKit\n\nfinal class Cell: UICollectionViewCell {\n  \n  var title: String? {\n    get { titleLabel.text }\n    set { titleLabel.text = newValue }\n  }\n  \n  var color: UIColor = .white {\n    didSet { contentView.backgroundColor = color }\n  }\n  \n  private var titleLabel: UILabel = {\n    let label = UILabel()\n    label.font = .systemFont(ofSize: 30, weight: .bold)\n    return label\n  }()\n  \n  private var angle: CGFloat = 0\n  private var outerRadius: CGFloat = 0\n  private var innerRadius: CGFloat = 0\n  \n  \u002F\u002F MARK: Override\n  \n  override init(frame: CGRect) {\n    super.init(frame: frame)\n    setup()\n  }\n  \n  required init?(coder: NSCoder) {\n    super.init(coder: coder)\n    setup()\n  }\n  \n  override func layoutSubviews() {\n    super.layoutSubviews()\n    \n    let path = UIBezierPath()\n    path.addArc(withCenter: CGPoint(x: bounds.width \u002F 2, y: outerRadius),\n                radius: outerRadius,\n                startAngle: -CGFloat.pi \u002F 2 - angle \u002F 2,\n                endAngle: -CGFloat.pi \u002F 2 + angle \u002F 2,\n                clockwise: true)\n    path.addArc(withCenter: CGPoint(x: bounds.width \u002F 2, y: outerRadius),\n                radius: innerRadius,\n                startAngle: -CGFloat.pi \u002F 2 + angle \u002F 2,\n                endAngle: -CGFloat.pi \u002F 2 - angle \u002F 2,\n                clockwise: false)\n    path.close()\n\n    (layer.mask as? CAShapeLayer)?.path = path.cgPath\n  }\n  \n  override func apply(_ layoutAttributes: UICollectionViewLayoutAttributes) {\n    guard let attr = layoutAttributes as? CarouselLayoutAttributes else { return }\n    angle = attr.angle\n    outerRadius = attr.outerRadius\n    innerRadius = attr.innerRadius\n  }\n  \n  \u002F\u002F MARK: Setup\n  \n  private func setup() {\n    contentView.backgroundColor = color\n    layer.mask = CAShapeLayer()\n    \n    contentView.addSubview(titleLabel)\n    titleLabel.translatesAutoresizingMaskIntoConstraints = false\n    NSLayoutConstraint.activate([\n      titleLabel.centerXAnchor.constraint(equalTo: contentView.centerXAnchor),\n      titleLabel.centerYAnchor.constraint(equalTo: contentView.centerYAnchor)\n    ])\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Cp\u003EНаконец, остался зум центрального элемента. С величиной зума всё довольно просто: максимальное значение достигается тогда, когда элемент находится ровно по центру (т.е. angle = 0), и по мере удаления от центра по окружности item уменьшается до первоначальных размеров. Причём уменьшается очень быстро - после того, как angle превысит anglePerItem, величина зума становится равной единице. Учитывая, что всё это изменяется линейно, получаем что-то вроде:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet scale = max(Constants.maxScale - abs(angle) \u002F anglePerItem, 1)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОсталось только скорректировать форму ячейки во время зума. Дамы и господа, должен признать, что примерно в этом месте у меня уже поехала крыша, и радиусы подбирались мной чисто эмпирическим путём. В результате нескольких попыток получилось такое:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet heightDiff = itemSizeHeight * (scale - 1)\nattr.outerRadius = (radius + heightDiff \u002F 2) \u002F scale\nattr.innerRadius = innerRadius \u002F scale\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОбъяснение этому примерно следующее. Зум физически осуществляется с помощью transform, при котором все расстояния в собственной плоскости item-а пропорционально увеличиваются относительно координат коллекции; мне хотелось сделать так, чтобы после зума центр окружности в \"растянутой\" плоскости ячейки, из которого рисуются дуги, совпал с центром окружности барабана в системе координат коллекции. Такой подход позволяет линиям, образующим боковые стороны секторов окружности, в которых по сути и находятся ячейки, как бы накладываться друг на друга, хоть они и находятся в разных системах координат. Визуально это выражается в том, что при зуме элементы \"урезаются\" по краям так, что не наезжают друг на друга, сохраняя изначальную ширину.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003EПосчитать, какими должны быть радиусы в старой системе координат после зума, несложно: внешний равен текущему + величина, на которую увеличенный item \"вылезает\" над оригинальным (itemHeight * scale - itemHeight) \u002F 2; внутренний же радиус должен остаться без изменений, чтобы нижние грани ячеек образовывали сплошную гладкую линию без изломов. Но, поскольку мы находимся в другой системе координат, где всё растянуто, нужно итоговые величины разделить на scale.  \u003C\u002Fp\u003E\u003Cdetails class=\"spoiler\"\u003E\u003Csummary\u003EПолный код для layout-а из примера 3\u003C\u002Fsummary\u003E\u003Cdiv class=\"spoiler__content\"\u003E\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eimport UIKit\n\nfinal class CarouselLayout: UICollectionViewFlowLayout {\n  \n  private var attrs: [UICollectionViewLayoutAttributes] = []\n  \n  \u002F\u002F MARK: Override\n  \n  override static var layoutAttributesClass: AnyClass { CarouselLayoutAttributes.self }\n  \n  override var collectionViewContentSize: CGSize {\n    guard let collection = collectionView,\n          collection.numberOfSections \u003E 0 else { return .zero }\n    \n    let radius = getRadius()\n    let angle = getAngle()\n    let anglePerItem = angle \u002F CGFloat(Constants.numberOfVisibleItems)\n    let lengthPerItem = anglePerItem * radius\n    \n    let width = collection.bounds.width + CGFloat(collection.numberOfItems(inSection: 0) - 1) * lengthPerItem \n    \n    return CGSize(width: width, height: collection.bounds.height)\n  }\n  \n  override func prepare() {\n    super.prepare()\n    \n    attrs = []\n    \n    guard let collection = collectionView else { return }\n    \n    let radius = getRadius()\n    let angle = getAngle()\n    let anglePerItem = angle \u002F CGFloat(Constants.numberOfVisibleItems)\n    let lengthPerItem = anglePerItem * radius\n    \n    let itemSize = getItemSize(radius: radius, anglePerItem: anglePerItem)\n    let contentCenter = getContentCenter(radius: radius)\n    let itemCenterRadius = radius - itemSize.height \u002F 2\n    let innerRadius = (radius - itemSize.height) \u002F cos(anglePerItem \u002F 2)\n    \n    let numberOfItems = collection.numberOfItems(inSection: 0)\n    let centerItemIndex = Int(collection.contentOffset.x \u002F lengthPerItem)\n    \n    for i in 0..&lt;numberOfItems {\n      let attr = CarouselLayoutAttributes(forCellWith: IndexPath(row: i, section: 0))\n      attr.angle = anglePerItem\n      \n      let index = fakeItemIndexFor(itemIndex: i, centerItemIndex: centerItemIndex, numberOfItems: numberOfItems)\n      \n      let absX = lengthPerItem * CGFloat(index)\n      let relativeX = absX - collection.contentOffset.x\n      var angle = relativeX \u002F radius\n      \n      if abs(angle) \u003E CGFloat.pi \u002F 2 + anglePerItem {\n        angle = CGFloat.pi\n      }\n      \n      let scale = max(Constants.maxScale - abs(angle) \u002F anglePerItem, 1)\n      \n      attr.size = itemSize\n      attr.center = CGPoint(x: contentCenter.x + itemCenterRadius * sin(angle),\n                            y: contentCenter.y - itemCenterRadius * cos(angle))\n      attr.transform = CGAffineTransform(rotationAngle: angle).scaledBy(x: scale, y: scale)\n      attr.zIndex = Int(scale * 10) \u002F\u002F just in caseй\n      \n      let heightDiff = itemSize.height * (scale - 1)\n      attr.outerRadius = (radius + heightDiff \u002F 2) \u002F scale\n      attr.innerRadius = innerRadius \u002F scale\n            \n      attrs.append(attr)\n    }\n  }\n  \n  override func layoutAttributesForElements(\n    in rect: CGRect\n  ) -\u003E [UICollectionViewLayoutAttributes]? {\n    attrs\n  }\n  \n  override func layoutAttributesForItem(\n    at indexPath: IndexPath\n  ) -\u003E UICollectionViewLayoutAttributes? {\n    attrs[indexPath.row]\n  }\n  \n  override func targetContentOffset(\n    forProposedContentOffset proposedContentOffset: CGPoint,\n    withScrollingVelocity velocity: CGPoint\n  ) -\u003E CGPoint {\n    let radius = getRadius()\n    let angle = getAngle()\n    let anglePerItem = angle \u002F CGFloat(Constants.numberOfVisibleItems)\n    let lengthPerItem = anglePerItem * radius\n    \n    let floatIndex = floor((proposedContentOffset.x + lengthPerItem \u002F 2) \u002F lengthPerItem)\n\n    let x = floatIndex * lengthPerItem\n\n    return CGPoint(x: x, y: proposedContentOffset.y)\n  }\n  \n  override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -\u003E Bool { true }\n  \n  \u002F\u002F MARK: Helpers\n  \n  private func getRadius() -\u003E CGFloat {\n    guard let bounds = collectionView?.bounds else { return 0 }\n    \n    let w = bounds.width \u002F 2\n    let h = bounds.height\n    \n    return h \u003E w ? w : (w * w + h * h) \u002F (2 * h)\n  }\n  \n  private func getAngle() -\u003E CGFloat {\n    guard let bounds = collectionView?.bounds else { return 0 }\n    \n    let w = bounds.width \u002F 2\n    let h = bounds.height\n    \n    return h \u003E w ? .pi : 4 * atan(h \u002F w)\n  }\n  \n  func getContentCenter(radius: CGFloat) -\u003E CGPoint {\n    guard let collection = collectionView else { return .zero }\n    \n    let w = collection.bounds.width \u002F 2\n    let h = collection.bounds.height\n    let offset = collection.contentOffset.x\n    \n    return h \u003E w ? .init(x: w + offset, y: h) : .init(x: w + offset, y: radius)\n  }\n  \n  private func getItemSize(radius: CGFloat, anglePerItem: CGFloat) -\u003E CGSize {\n    let width = 2 * radius * sin(anglePerItem \u002F 2)\n    return CGSize(width: width, height: Constants.itemHeight)\n  }\n  \n  private func fakeItemIndexFor(itemIndex: Int, centerItemIndex: Int, numberOfItems: Int) -\u003E Int {\n    if centerItemIndex &lt; Constants.numberOfVisibleItems {\n      return itemIndex \u003E= numberOfItems - Constants.numberOfVisibleItems ? itemIndex - numberOfItems : itemIndex\n    } else if centerItemIndex \u003E= numberOfItems - Constants.numberOfVisibleItems {\n      return itemIndex &lt; Constants.numberOfVisibleItems ? numberOfItems + itemIndex : itemIndex\n    } else {\n      return itemIndex\n    }\n  }\n  \n  \u002F\u002F MARK: Constants\n  \n  private enum Constants {\n    static let numberOfVisibleItems = 5\n    static let itemHeight: CGFloat = 70\n    static let maxScale: CGFloat = 1.7\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdetails\u003E\u003Ch3\u003EЗаключение\u003C\u002Fh3\u003E\u003Cp\u003EНа этих трёх примерах пытался показать, что можно делать с помощью коллекций, layout-ов и капли воображения. Копируйте код, играйтесь с параметрами, используйте у себя в проектах! Надеюсь, было интересно.\u003Cbr\u002F\u003E\u003Cbr\u002F\u003E\u003Cstrong\u003EThings to remember:\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EcontentSize\u003C\u002Fstrong\u003E - пожалуй первое, с чего надо начать, если хотите \"поиздеваться\" над ячейками коллекции;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EtargetContentOffset \u003C\u002Fstrong\u003E- можно повлиять на момент остановки скролла\u003Cstrong\u003E;\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EshouldInvalidateLayout \u003C\u002Fstrong\u003E- можно переопределять, если необходимы частые обновления атрибутов ячеек при скролле;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ElayoutAttributesClass + apply(_ layoutAttributes:) \u003C\u002Fstrong\u003E- возможность передать дополнительные атрибуты в каждую из ячеек;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003Eшкольная математика\u003C\u002Fstrong\u003E не так уж и бесполезна.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВсем добра, пишите классные приложения и делайте красоту в интерфейсах!\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"switch"},{"titleHtml":"ios"},{"titleHtml":"ios development"},{"titleHtml":"ui"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8ee\u002F77d\u002F287\u002F8ee77d287a1e0e62a7cecbc9fa11687a.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8ee\u002F77d\u002F287\u002F8ee77d287a1e0e62a7cecbc9fa11687a.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F583368\\\u002F\"},\"headline\":\"iOS. UI. Приёмы. Часть 2\",\"datePublished\":\"2021-10-14T00:15:34+03:00\",\"dateModified\":\"2021-10-14T02:03:03+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"kostyanoy\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными l...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F583368\\\u002F#post-content-body\",\"about\":[\"h_ios_dev\",\"h_mobile_dev\",\"h_swift\",\"h_apps_design\",\"f_develop\",\"f_design\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F583368\\\u002F50b18302ec03744723a49b9164e43340\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F703\\\u002F52c\\\u002Fe03\\\u002F70352ce03294ec837efd2c5caabb299a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Ffd6\\\u002F61b\\\u002F9f5\\\u002Ffd661b9f5487355a25140b28ba52cf36.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fcf5\\\u002F58f\\\u002F006\\\u002Fcf558f0065cf4eac4422b1f70b03ee08.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Faca\\\u002F268\\\u002F6bd\\\u002Faca2686bdd1536e11cdf97edbd6b6992.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F41f\\\u002F202\\\u002F3da\\\u002F41f2023da20f55351cc704cbc4053685.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F5a9\\\u002Fca3\\\u002Fd35\\\u002F5a9ca3d3568da0421a0d9e648b55eaec.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fdde\\\u002F9f5\\\u002Fc9a\\\u002Fdde9f5c9afc19df68bed0afc128a88b7.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd4e\\\u002F5ba\\\u002F9f6\\\u002Fd4e5ba9f65210135180f2d671ceeb9c1.png\"]}","metaDescription":"Привет читателям хабра! В прошлой статье рассказывал про тени и маски у CALayer-ов. В этой расскажу про некоторые подходы при работе с коллекциями и кастомными layout-ами, опять же демонстрируя всё на...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"ios_dev,mobile_dev,swift,apps_design"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
