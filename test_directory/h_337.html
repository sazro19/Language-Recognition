<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Error Boundaries в React: препарируем лягушку / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/2gis\/blog\/583894\/"},"headline":"Error Boundaries в React: препарируем лягушку","datePublished":"2021-10-19T06:58:09+03:00","dateModified":"2021-10-19T06:58:09+03:00","author":{"@type":"Person","name":"Artem Malko"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку &laquo;Написать...","url":"https:\/\/habr.com\/ru\/company\/2gis\/blog\/583894\/#post-content-body","about":["c_2gis","h_javascript","h_programming","h_reactjs","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/583894\/e1001b884b99b4a6876c78cb262ab78f\/","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/2c4\/0e9\/9b9\/2c40e99b907564bb9fb134e3096af71f.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/6a3\/dca\/216\/6a3dca216722c37b019353c9314f1703.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/d09\/955\/a4e\/d09955a4e2a712a1987feb6fff65d7d2.png","https:\/\/habrastorage.org\/getpro\/habr\/upload_files\/a94\/9e6\/3b4\/a949e63b46ce1a51f9f0803a2e945efd.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Error Boundaries в React: препарируем лягушку" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Error Boundaries в React: препарируем лягушку" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Error Boundaries в React: препарируем лягушку" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habrastorage.org/getpro/habr/upload_files/2c4/0e9/9b9/2c40e99b907564bb9fb134e3096af71f.png" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habrastorage.org/getpro/habr/upload_files/2c4/0e9/9b9/2c40e99b907564bb9fb134e3096af71f.png" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habrastorage.org/getpro/habr/upload_files/2c4/0e9/9b9/2c40e99b907564bb9fb134e3096af71f.png" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habrastorage.org/getpro/habr/upload_files/2c4/0e9/9b9/2c40e99b907564bb9fb134e3096af71f.png" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habrastorage.org/getpro/habr/upload_files/2c4/0e9/9b9/2c40e99b907564bb9fb134e3096af71f.png" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="583894" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-10-19T03:58:09.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/583894/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/company/2gis/blog/583894/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habrastorage.org/getpro/habr/upload_files/2c4/0e9/9b9/2c40e99b907564bb9fb134e3096af71f.png" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/583894/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="2gis" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/2gis/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/995/27f/562/99527f562a8700893d39f73e6d2e7e07.png" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">123.57</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/2gis/profile/" class="tm-company-card__name">
        2ГИС
      </a> <div class="tm-company-card__description">Главные по городской навигации</div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/artemmalko/" title="artemmalko" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/828/d02/79a/828d0279af2eea2e96c98ca583ad7ccd.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/artemmalko/" class="tm-user-info__username">
      artemmalko
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-10-19T03:58:09.000Z" title="2021-10-19, 06:58">19  октября   в 06:58</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Error Boundaries в React: препарируем лягушку</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/2gis/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании 2ГИС</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/javascript/" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/reactjs/" class="tm-article-snippet__hubs-item-link"><span>ReactJS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><figure class="full-width "><img src="/img/image-loader.svg" height="630" data-src="https://habrastorage.org/getpro/habr/upload_files/2c4/0e9/9b9/2c40e99b907564bb9fb134e3096af71f.png" data-width="1200"/><figcaption></figcaption></figure><p>Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва открывается в попапе, над списком. Пользователь начинает вводить текст, свой e-mail. Вдруг валидация почты срабатывает с ошибкой, которую разработчики забыли обработать. Результат — белый экран. React просто не смог ничего отрендерить из-за этой ошибки в каком-то попапе.</p><p>Первая же мысль — не надо было всё уничтожать, список же был не при делах. Чтобы обработать ошибку в render-фазе в React, необходимо использовать <a href="https://reactjs.org/docs/error-boundaries.html">Error Boundaries</a>. Почему именно так нужно обрабатывать ошибки — расскажу под катом.</p><h2>try/catch спешит на помощь</h2><p>Итак, начнём с простого. Если попросить вас обработать ошибки в JavaScript-коде, вы без сомнений обернете код в конструкцию try/catch:</p><pre><code class="javascript">try {
 throw new Error('Привет, Мир! Я ошибка!');
} catch (error) {
 console.error(error);
}</code></pre><p>Запустим его и, как ни удивительно, в консоли мы увидим текст ошибки и стек вызовов. Всем известная конструкция, на рынке JavaScript с 1995 года. Код достаточно прост в понимании. Всё работает идеально.</p><p>Теперь обратим свой взор на React. Разработчики данной библиотеки позиционируют её как простую функцию, которая принимает на вход любые данные и возвращает визуальное представление этих данных:</p><pre><code class="javascript">function React(data) {
  return UI;
}

const UI = React({ name: 'John' });</code></pre><p>Выглядит несколько абстрактно, но пока нам этого хватит. Кажется, тут можно применить паттерн обработки ошибок в JavaScript, к которому мы так уже привыкли:</p><pre><code class="javascript">try {
  const UI = React({ name: 'John' });
} catch (error) {
  console.error(error);
}</code></pre><p>Пока всё выглядит достаточно логично и просто. Попробуем реализовать подобный подход в реальном коде.</p><h2>Обернём все в try/catch</h2><p>Любое React-приложение начинается с того, что мы рендерим самый верхнеуровневый компонент — точку входа в приложение — в DOM-ноду:</p><pre><code class="javascript">ReactDOM.render(
  &lt;App />,
  document.getElementById("root")
);</code></pre><p>Старый добрый синхронный рендер &lt;App /> и всех компонентов внутри. Отличное место, чтобы обернуть приложение в try/catch:</p><pre><code class="javascript">try {
 ReactDOM.render(
  &lt;App />,
  document.getElementById("root")
 );
} catch (error) {
 console.error("React render error: ", error);
}</code></pre><p>Ошибки, которые будут брошены во время первого рендера, будут пойманы этим try/catch.</p><p>Но если ошибка будет происходить в результате, например, смены стейта какого-либо компонента внутри, то этот try/catch уже не сработает, так как свою функцию ReactDOM.render уже выполнит к тому моменту — то есть выполнит первоначальный рендер &lt;App /> в DOM. Всё, что будет происходить дальше, его не касается.</p><p>Вот есть <a href="https://codesandbox.io/s/nostalgic-newton-5b5el?file=/src/index.js">демо, где можно поиграться с таким try/catch</a>. В AppWithImmediateError.js находится компонент, который бросает ошибку при первом же рендере. В AppWithDeferredError.js — после изменения внутреннего стейта. Как видно, catch ловит ошибку только из AppWithImmediateError.js (см. консоль).</p><p>Что-то мы не видели, что так обрабатывают ошибки в компонентах в React. Этот пример я привёл просто для иллюстрации того, как работает первый рендер в браузере, когда мы только выполняем рендер приложения в реальный DOM. Дальше ещё будет несколько странных примеров, но они раскроют некоторые особенности в работе React.</p><p>Кстати, в новых методах первого рендера в React 18 не будет синхронной версии рендера всего приложения сразу. Поэтому такой подход с оборачиванием в try/catch не будет работать даже для первого рендера.</p><h2>try/catch внутри компонента</h2><p>Просто сделать глобальный try/catch — интересная затея. Только вот она не работает. Может тогда просто внутри рендера в &lt;App /> сделать try/catch? Прям в рендер запихать. И ведь нет никаких запретов на это. Опустим тут вопрос про декларативность, чистоту функций. Не будем разбрасываться терминами — всё же синтаксис позволяет такой пируэт:</p><pre><code class="javascript">// Можно и классовый компонент взять 
// и внутри render() try/catch написать. 
// Разницы нет
const App = () => {
 try {
  return (
   &lt;div>
    &lt;ChildWithError />
   &lt;/div>
  );
 } catch (error) {
  console.error('App error handler: ', error);  
  return &lt;FallbackUI/>;
 }
}</code></pre><p>Сделал <a href="https://codesandbox.io/s/optimistic-antonelli-sbsyz?file=/src/App.js">демку</a> для такого варианта. Открываем, тыкаем в кнопку <em>Increase value</em>. Когда value достигнет значения 4, &lt;ChildWithError/> кинет ошибку в render-функции. Но ни сообщения в консоли, ни FallbackUI нет. Как же так? Мы же знаем, что</p><pre><code class="javascript">&lt;div>
 &lt;ChildWithError />
&lt;/div></code></pre><p>в результате транспиляции (babel’ем, typescript’ом, кем-то ещё, кого вы выбрали) превращается в</p><pre><code class="javascript">React.createElement(
  'div', 
  null, 
  React.createElement(ChildWithError, null)
)</code></pre><p>Вот <a href="https://bit.ly/2VwSt23">тут можно поиграться с babel’ем</a>, например. </p><p>То есть весь наш JSX превращается в вызовы функций. Таким образом, try/catch должен был отловить ошибку. В чём тут подвох? Неужели React умеет останавливать вызов функции?</p><h2>С чем на самом деле работает React</h2><p>Если приглядеться, то мы видим, что в React.createElement(ChildWithError, null) нет вызова рендера ChildWithError. Погодите, а что вообще возвращает вызов React.createElement? Если кому-то интересно прям source потыкать, то вот <a href="https://github.com/facebook/react/blob/a724a3b578dce77d427bef313102a4d0e978d9b4/packages/react/src/ReactElement.js#L148">ссылка на то место, где создаётся элемент</a>. В общем виде возвращается вот такой объект:</p><pre><code class="javascript">// Исходник: https://github.com/facebook/react/blob/main/packages/react/src/ReactElement.js#L148
const element = {
 // This tag allows us to uniquely identify this as a React Element
 $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element
 type: type,
 key: key,
 ref: ref,
 props: props, // Record the component responsible for creating this element.
 _owner: owner,
};</code></pre><p>На выходе render-функции мы получаем объекты, которые вложены в другие объекты. Для нашего примера мы получим объект, который описывает &lt;div>, у которого в props.children будет лежать объект, который описывает &lt;ChildWithError />. Попробуйте сами вывести в консоль результат вызова render-функции.</p><p>Прямого вызова render-функции ChildWithError мы не видим внутри &lt;App />. Мы лишь создали схему, по которой в дальнейшем будет рендерится &lt;App />. </p><p>Render выполняется от родителей к детям. После рендера &lt;App />  внутри &lt;ChildWithError /> тоже создаётся объект, который описывает все элементы, возвращаемые render-функцией компонента &lt;ChildWithError />. Мы как бы говорим React’у: если отренедрился &lt;App />, то внутри него потом надо отрендерить &lt;ChildWithError />. </p><p>Кстати, в этом и заключается декларативность React’а. А не в том, что мы цикл for написать в теле render-функции не можем.</p><p>И тут вы можете воскликнуть — чтобы объект такой собрать, нужно же функцию ChildWithError вызвать? Всё верно, только вызов функции ChildWithError происходит не внутри &lt;App />. Он происходит совсем в другом месте. Пока что можно ограничиться таким объяснением — React сам вызывает render-функции компонентов в каком-то своём контексте. Позже я раскрою эту мысль глубже. В конкурентом режиме (он ждёт нас во всей красе в React 18) React ещё и во времени может эти вызовы раскидать так, как сам посчитает нужным.</p><p>Приведу аналогию такую: componentDidUpdate не происходит же в контексте рендера, он просто запускается React’ом после того, как компонент перерендерился. Либо вот такая аналогия (которая даже ближе к истине):</p><pre><code class="javascript">try {
 Promise.resolve().then(() => {
  throw new Error('wow!');
 });
} catch (error) {
 console.log('Error from catch: ', error);
}</code></pre><p>Ошибка из промиса никогда не будет поймана в catch, так как происходит в другом месте Event-loop’а. Catch — синхронный callstack задач, промис — микротаска.</p><p>В том, что React сам вызывает render-функции компонентов, легко убедиться. Достаточно в <a href="https://codesandbox.io/s/optimistic-antonelli-sbsyz?file=/src/App.js">демке</a> поменять &lt;ChildWithError /> на {ChildWithError()}<strong> </strong>внутри &lt;App />. Мы прям руками сами вызовем render-функцию компонента ChildWithError внутри рендера &lt;App />. Ошибка начнёт обрабатываться с помощью try/catch. Увидим сообщение в консоли и даже fallback UI отрендерится! </p><p>И почему бы везде так не писать? Просто делать вызов функции-компонента. Должно же и работать быстрее, не придётся ждать, когда там и где React запустит рендер детей.</p><p>Тут я сразу отправлю читать замечательную статью Дэна Абрамова <a href="https://overreacted.io/react-as-a-ui-runtime/">React as a UI Runtime</a>.  Конкретно про вызов компонента внутри рендера другого компонента можно прочитать в разделе <a href="https://overreacted.io/react-as-a-ui-runtime/#inversion-of-control">Inversion of Control</a> и далее <a href="https://overreacted.io/react-as-a-ui-runtime/#lazy-evaluation">Lazy Evaluation</a>. </p><p>Забавно, но какое-то время назад ручной вызов рендера компонентов предлагался как паттерн по ускорению работы React-приложений. Вот пример, когда такой вызов может даже в ногу выстрелить:</p><pre><code class="javascript">function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(c => c + 1)
  return &lt;button onClick={increment}>{count}&lt;/button>
}

function App() {
  const [items, setItems] = React.useState([])
  const addItem = () => setItems(i => [...i, {id: i.length}])
  return (
    &lt;div>
      &lt;button onClick={addItem}>Add Item&lt;/button>
      &lt;div>{items.map(Counter)}&lt;/div>
    &lt;/div>
  )
}</code></pre><p>Попробуйте поиграться с этим примером в <a href="https://codesandbox.io/s/empty-morning-x104i">codesandbox</a>. Уже после первого нажатия на <em>AddItem</em> мы получим ошибку, что в разных рендерах были вызваны разные хуки. А это нарушает правило использования хуков в React. Оставлю <a href="https://kentcdodds.com/blog/dont-call-a-react-function-component">ссылочку на статью Kent C. Dodds</a> про этот пример.</p><p>Хорошо, что ребята из Facebook занимаются просветительской деятельностью. И тут не только про Дэна речь. у них есть замечательный канал на YouTube — <a href="https://www.youtube.com/channel/UCCQY962PmHabTjaHv2wJzfQ">Facebook Open Source</a>. Особенно нравятся их ролики в формате Explain Like I'm 5. Крайне рекомендую, чтобы самому научиться просто объяснять сложные штуки. Вот один из таких примеров:</p><div class="tm-iframe_temp" data-src="https://embedd.srv.habr.com/iframe/616bf155abb378f6450d1a30" data-style="" id="616bf155abb378f6450d1a30" width=""></div><p>Но у нас тут не такой формат — чуть более многословный. </p><p>Вернёмся к обработке ошибок. Простого try/catch внутри render() {} будет мало! А как же componentDidUpdate<strong> </strong>и другие lifecycle-методы? Да-да, классовые компоненты ещё поддерживаются в React. Если в функциональном компоненте мы просто вообще всё обернули бы в try/catch (опустим вопрос здравого смысла такого подхода), то в классовом компоненте придётся в каждый lifecycle-метод пихать try/catch. Не очень изящно, да... Какой вывод? Правильно, переходим на функциональные компоненты! Там try/catch юзать проще =)</p><p>Ладно, закончим играться с try/catch. Кажется, мы поняли, что в React мы не достигнем успеха с ним. Но, прежде чем переходить к <strong>Error Boundaries,</strong> я покажу ещё <a href="https://codesandbox.io/s/intelligent-beaver-zyujd?file=/src/App.js">одну демку</a>, которая точно отобьёт любое желание использовать try/catch для отлова ошибок рендера.</p><h2>Сферический пример в вакууме</h2><p>Что тут у нас есть: функциональный компонент &lt;App />, у которого определён внутренний стейт. Значение из этого стейта шарится по всему дочернему дереву через React.context. &lt;App /><strong> </strong>рендерит внутри себя компонент &lt;Child />. &lt;Child /> обернут в HOC memo,  внутри себя рендерит компонент &lt;GrandChild />.</p><p>Внутри &lt;Child /> я использовал классический try/catch, чтобы поймать все ошибки в рендере ниже по дереву. Внутри &lt;GrandChild /><strong> </strong>есть логика, что если значение из контекста будет больше 3, то бросается ошибка в рендере. Схематично это всё выглядит примерно так:</p><figure class="full-width "><img src="/img/image-loader.svg" height="429" data-src="https://habrastorage.org/getpro/habr/upload_files/6a3/dca/216/6a3dca216722c37b019353c9314f1703.png" data-width="936"/><figcaption></figcaption></figure><p>В &lt;App /><strong> </strong>используются getDerivedStateFromError, чтобы обновить стейт компонента &lt;App /><strong> </strong>в случае ошибки в дочернем дереве. Также есть componentDidCatch, в котором можно выполнить любой side effect в случае ошибки в дочернем дереве. То есть &lt;App /><strong> </strong>выступает в этом приложении как <strong>Error Boundary </strong>— именно он является той самой границей, за которую ошибка из дочернего дерева не пролезет дальше, вверх по дереву.</p><p>Зачем всё так сложно? Да потому что! </p><p>Берём и тыкаем в кнопку. Как видим, после первого клика перендерился только &lt;App /><strong> </strong>и &lt;GrandChild />. &lt;App /><strong> </strong>— потому что у него стейт поменялся, <strong>&lt;GrandChild /> </strong>— потому что поменялось значение в контексте. &lt;Child /><strong> </strong>же вообще никак не участвовал в этом процессе, так как он обернут в HOC memo. Как будто его и нет, хотя он находится, если так можно сказать, между &lt;App /><strong> </strong>и &lt;GrandChild />. Подсветим зелёным тех ребят, кто перерендерился в этой ситуации.</p><figure class="full-width "><img src="/img/image-loader.svg" height="429" data-src="https://habrastorage.org/getpro/habr/upload_files/d09/955/a4e/d09955a4e2a712a1987feb6fff65d7d2.png" data-width="936"/><figcaption></figcaption></figure><p>Продолжая увеличивать счётчик в &lt;App>, мы дойдём до ошибки в &lt;GrandChild /><strong>. </strong>Как и в прошлые разы, при увеличении счётчика &lt;Child /><strong> </strong>вновь не будет участвовать, а значит try/catch внутри него тоже не сработает. </p><p>Эта демка — простая модель, которая отражает, что React сам решает, когда и что отрендерить и в каком контексте.</p><p>Вот мы и увидели, как работает <strong>Error Boundaries</strong>. Как пользоваться <strong>Error Boundaries и </strong>какие у него есть ограничения, я описывать не буду. Есть <a href="https://reactjs.org/docs/error-boundaries.html">ссылка на доку на </a><a href="http://reactjs.org/">Reactjs.org</a>, там всё достаточно подробно описали. Кстати, там указано, а когда всё же try/catch можно использовать. Да, мы от него полностью не отказываемся :)</p><p>Но куда интереснее понять, как именно это работает в React. Это что, какой-то особый try/catch?</p><h2>try/catch по-React'овски</h2><p>В игру вступает магический React Fiber. Это и название архитектуры, и название сущности из внутренностей React. Информация об этой сущности открывается для широкой общественности с приходом React 16. Вот, даже <a href="https://reactjs.org/docs/faq-internals.html">в официальной доке засветился</a>. </p><p>Кто смотрел результат вызова React.createElement в консоль, тот видел, что там выводится гораздо больше информации, нежели чем ожидается. На скрине можно увидеть только часть из того, что React туда кладёт:</p><figure class="full-width "><img src="/img/image-loader.svg" height="550" data-src="https://habrastorage.org/getpro/habr/upload_files/a94/9e6/3b4/a949e63b46ce1a51f9f0803a2e945efd.png" data-width="1224"/><figcaption></figcaption></figure><p>Суть вот в чём: помимо дерева React-элементов/компонентов, существует ещё и набор неких Fiber-нод, которые к этим элементам/компонентам привязаны. В этих нодах содержится внутреннее состояние (полезное только для React) React-элемента/компонента: какие были пропсы ранее, какой следующий effect запустить, нужно ли рендерить компонент сейчас и т. д. </p><p>Подробно про Fiber-архитектуру можно почитать в блоге <a href="https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react">inDepth.dev</a> или в статье от одного из ключевых разработчиков из React-core — <a href="https://github.com/acdlite/react-fiber-architecture">acdlite</a>.</p><p>Имея это внутреннее представление, React уже знает, что делать с ошибкой, которая случилась во время фазы рендера конкретного компонента. То есть React может остановить рендер текущего дерева компонентов, отыскать ближайший сверху компонент, в котором есть или getDerivedStateFromError, или componentDidCatch — хотя бы кто-то один. Имея ссылки на родителей в FiberNode (<a href="https://indepth.dev/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree">там в связном списке всё лежит</a>), сделать это проще простого. Вот есть <a href="https://github.com/facebook/react/blob/bc9bb87c2b01bff8a15e02c8416addf6177e9055/packages/react-reconciler/src/ReactFiberThrow.new.js">source-код</a>, в котором можно посмотреть, как это примерно работает.  </p><p>Например, вот <a href="https://github.com/facebook/react/blob/bc9bb87c2b01bff8a15e02c8416addf6177e9055/packages/react-reconciler/src/ReactFiberThrow.new.js#L460">функция</a>, в которой определяется, имеет ли компонент методы <strong>Error Boundaries</strong>. А вот <a href="https://github.com/facebook/react/blob/bc9bb87c2b01bff8a15e02c8416addf6177e9055/packages/react-reconciler/src/ReactFiberWorkLoop.new.js">исходник</a> того, как организован внутренний так называемый workLoop в React. Тут же можно понять, что никакой магии в React нет — внутри всё же <a href="https://github.com/facebook/react/blob/bc9bb87c2b01bff8a15e02c8416addf6177e9055/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1582">используется старый добрый try/catch</a> для отлова ошибок. Почти как в нашем абстрактном примере, который я привел в начале статьи.</p><p>Для классического React с синхронным рендером используется <a href="https://github.com/facebook/react/blob/bc9bb87c2b01bff8a15e02c8416addf6177e9055/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1496">тот же подход</a>. Просто функция для workLoop используется другая. Впрочем, конкурентый React (18 версия и более новые) — это совсем другая история. Рекомендую открыть ссылки и поизучать их отдельно после прочтения этой статьи.</p><p>В общем виде это выглядит так:</p><ul><li><p>Запускаем рендер компонента.</p></li><li><p>Если во время workLoop была ошибка, она будет поймана в try/catch и обработана.</p></li><li><p>В списке FiberNode ищем компонент-родитель с необходимыми методами (getDerivedStateFromError или componentDidCatch).</p></li><li><p>Нашли — React считает ошибку обработанной.</p></li><li><p>Все ветки отрендеренного дерева можно не выбрасывать. Отбросим только ту ветку, где была ошибка — ровно до того места, где мы определили <strong>Error Boundaries,</strong> границы распространения этой ошибки.</p></li></ul><p>Если можно было бы представить работу с React, как с живым человеком, то общение с ним выглядело бы как-то так (своего рода объяснение в стиле Explain Like I'm 5):</p><pre><code class="javascript">Привет, я — React. 
Спасибо за инструкции в JSX о том, что куда рендерить.
Дальше я сам все буду делать. Можешь расслабиться) 

try {
  *React изображает бурную деятельность*
} catch (error) {
  Ну вот, опять ошибка. 
  Пойду искать родителей этого негодяя, который ошибку бросил.
  Может они хоть что-то с ошибкой этой сделают.
  Ну а то, что я уже сделал у других родителей — выбрасывать не буду.
  Зря работал что ли?
}</code></pre><h2>The message</h2><p>Такое копание в реализации какой-либо фичи порой дает интересные результаты. Можно иначе взглянуть на давно уже знакомую библиотеку/фреймворк. Или просто лучше понять, как использовать свой инструмент по-максимуму. Рекомендую всем иногда погружаться в какой-либо аспект в реализации вашего любимого JS-решения. Я точно уверен, что это путешествие окупится.</p><h2>Список литературы</h2><p>Да-да, прям как в рефератах) Ссылок много, хочется, чтобы к ним легко можно было вернуться:</p><ul><li><p><a href="https://reactjs.org/docs/error-boundaries.html">Error Boundaries, документация React</a>. Описание того, как обработать ошибки у вас в приложении</p></li><li><p>Статья Дэна Абрамова <a href="https://overreacted.io/react-as-a-ui-runtime/">React as a UI Runtime</a>. Дэн достаточно глубоко описывает то, как работает React.</p></li><li><p>Статья Kent C. Dodds <a href="https://kentcdodds.com/blog/dont-call-a-react-function-component">Don't call a React function component</a>. Наглядное объяснение, почему не стоит самому вызывать render-компоненты.</p></li><li><p><a href="https://www.youtube.com/channel/UCCQY962PmHabTjaHv2wJzfQ">Facebook Open Source</a>. Youtube-канал разработчиков из Facebook.</p></li><li><p><a href="https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a>. Достаточно хардкорная статья про новую архитектуру React. На этом же ресурсе есть еще одна замечательная статья: <a href="https://indepth.dev/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree">The how and why on React’s usage of linked list in Fiber to walk the component’s tree</a>. В общем, это для тех, кто хочет прям глубже погрузиться в то, как устроен React изнутри.</p></li><li><p><a href="https://github.com/acdlite/react-fiber-architecture">React Fiber Architecture</a>. Чуть менее хардкорное описание Fiber-архитектуры. </p></li></ul></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Breact%5D" class="tm-tags-list__link">react</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bjavascript%5D" class="tm-tags-list__link">javascript</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%B0%D0%BA%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82%5D" class="tm-tags-list__link">как работает</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Breact.js%5D" class="tm-tags-list__link">react.js</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Breactjs%5D" class="tm-tags-list__link">reactjs</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/2gis/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании 2ГИС
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/javascript/" class="tm-hubs-list__link">
    JavaScript
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/reactjs/" class="tm-hubs-list__link">
    ReactJS
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 14: ↑13 и ↓1</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 14: ↑13 и ↓1" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+12</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">2.7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    19
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/2gis/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/995/27f/562/99527f562a8700893d39f73e6d2e7e07.png" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/2gis/profile/" class="tm-company-snippet__title">2ГИС</a> <div class="tm-company-snippet__description">Главные по городской навигации</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <!----> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/artemmalko/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/828/d02/79a/828d0279af2eea2e96c98ca583ad7ccd.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 34 голоса " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    9.7
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">12</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Artem Malko</span> <a href="/ru/users/artemmalko/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @artemmalko
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/2gis/blog/583894/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 2 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="1999-04-24T20:00:00.000Z" title="1999-04-25, 00:00">25  апреля  1999</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://2gis.ru/" target="_blank" class="tm-company-basic-info__link">
      2gis.ru
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    1 001–5 000 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2008-08-09T07:43:03.000Z" title="2008-08-09, 11:43">9  августа  2008</time></dd></dl> <!----></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/2gis/blog/583894/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/2gis/blog/583894/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"583894":{"id":"583894","timePublished":"2021-10-19T03:58:09+00:00","isCorporative":true,"lang":"ru","titleHtml":"Error Boundaries в React: препарируем лягушку","leadData":{"textHtml":"\u003Cp\u003EПредставим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва открывается в попапе. Пользователь начинает вводить текст, свой email. Вдруг валидация почты срабатывает с ошибкой, которую разработчики забыли обработать. Результат — белый экран. React просто не смог ничего отрендерить из-за этой ошибки в каком-то попапе.\u003C\u002Fp\u003E\u003Cp\u003EПервая же мысль — не надо было всё уничтожать, список же был не при делах. Чтобы обработать ошибку в render-фазе в React, необходимо использовать&nbsp;\u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Ferror-boundaries.html\"\u003EError Boundaries\u003C\u002Fa\u003E. Почему именно так нужно обрабатывать ошибки — расскажу под катом.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2c4\u002F0e9\u002F9b9\u002F2c40e99b907564bb9fb134e3096af71f.png","buttonTextHtml":"Читать далее","image":{"url":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2c4\u002F0e9\u002F9b9\u002F2c40e99b907564bb9fb134e3096af71f.png","fit":"cover","positionY":0,"positionX":0}},"editorVersion":"2.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":9.7,"votesCount":34},"rating":12,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"966500","alias":"artemmalko","fullname":"Artem Malko","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F828\u002Fd02\u002F79a\u002F828d0279af2eea2e96c98ca583ad7ccd.jpg","speciality":null},"statistics":{"commentsCount":2,"favoritesCount":19,"readingCount":2716,"score":12,"votesCount":14},"hubs":[{"relatedData":null,"id":"5374","alias":"2gis","type":"corporative","title":"Блог компании 2ГИС","titleHtml":"Блог компании 2ГИС","isProfiled":false},{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"19327","alias":"reactjs","type":"collective","title":"ReactJS","titleHtml":"ReactJS","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"630\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2c4\u002F0e9\u002F9b9\u002F2c40e99b907564bb9fb134e3096af71f.png\" data-width=\"1200\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПредставим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва открывается в попапе, над списком. Пользователь начинает вводить текст, свой e-mail. Вдруг валидация почты срабатывает с ошибкой, которую разработчики забыли обработать. Результат — белый экран. React просто не смог ничего отрендерить из-за этой ошибки в каком-то попапе.\u003C\u002Fp\u003E\u003Cp\u003EПервая же мысль — не надо было всё уничтожать, список же был не при делах. Чтобы обработать ошибку в render-фазе в React, необходимо использовать \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Ferror-boundaries.html\"\u003EError Boundaries\u003C\u002Fa\u003E. Почему именно так нужно обрабатывать ошибки — расскажу под катом.\u003C\u002Fp\u003E\u003Ch2\u003Etry\u002Fcatch спешит на помощь\u003C\u002Fh2\u003E\u003Cp\u003EИтак, начнём с простого. Если попросить вас обработать ошибки в JavaScript-коде, вы без сомнений обернете код в конструкцию try\u002Fcatch:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Etry {\n throw new Error('Привет, Мир! Я ошибка!');\n} catch (error) {\n console.error(error);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EЗапустим его и, как ни удивительно, в консоли мы увидим текст ошибки и стек вызовов. Всем известная конструкция, на рынке JavaScript с 1995 года. Код достаточно прост в понимании. Всё работает идеально.\u003C\u002Fp\u003E\u003Cp\u003EТеперь обратим свой взор на React. Разработчики данной библиотеки позиционируют её как простую функцию, которая принимает на вход любые данные и возвращает визуальное представление этих данных:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction React(data) {\n  return UI;\n}\n\nconst UI = React({ name: 'John' });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВыглядит несколько абстрактно, но пока нам этого хватит. Кажется, тут можно применить паттерн обработки ошибок в JavaScript, к которому мы так уже привыкли:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Etry {\n  const UI = React({ name: 'John' });\n} catch (error) {\n  console.error(error);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПока всё выглядит достаточно логично и просто. Попробуем реализовать подобный подход в реальном коде.\u003C\u002Fp\u003E\u003Ch2\u003EОбернём все в try\u002Fcatch\u003C\u002Fh2\u003E\u003Cp\u003EЛюбое React-приложение начинается с того, что мы рендерим самый верхнеуровневый компонент — точку входа в приложение — в DOM-ноду:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EReactDOM.render(\n  &lt;App \u002F\u003E,\n  document.getElementById(\"root\")\n);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EСтарый добрый синхронный рендер &lt;App \u002F\u003E и всех компонентов внутри. Отличное место, чтобы обернуть приложение в try\u002Fcatch:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Etry {\n ReactDOM.render(\n  &lt;App \u002F\u003E,\n  document.getElementById(\"root\")\n );\n} catch (error) {\n console.error(\"React render error: \", error);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОшибки, которые будут брошены во время первого рендера, будут пойманы этим try\u002Fcatch.\u003C\u002Fp\u003E\u003Cp\u003EНо если ошибка будет происходить в результате, например, смены стейта какого-либо компонента внутри, то этот try\u002Fcatch уже не сработает, так как свою функцию ReactDOM.render уже выполнит к тому моменту — то есть выполнит первоначальный рендер &lt;App \u002F\u003E в DOM. Всё, что будет происходить дальше, его не касается.\u003C\u002Fp\u003E\u003Cp\u003EВот есть \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Fnostalgic-newton-5b5el?file=\u002Fsrc\u002Findex.js\"\u003Eдемо, где можно поиграться с таким try\u002Fcatch\u003C\u002Fa\u003E. В AppWithImmediateError.js находится компонент, который бросает ошибку при первом же рендере. В AppWithDeferredError.js — после изменения внутреннего стейта. Как видно, catch ловит ошибку только из AppWithImmediateError.js (см. консоль).\u003C\u002Fp\u003E\u003Cp\u003EЧто-то мы не видели, что так обрабатывают ошибки в компонентах в React. Этот пример я привёл просто для иллюстрации того, как работает первый рендер в браузере, когда мы только выполняем рендер приложения в реальный DOM. Дальше ещё будет несколько странных примеров, но они раскроют некоторые особенности в работе React.\u003C\u002Fp\u003E\u003Cp\u003EКстати, в новых методах первого рендера в React 18 не будет синхронной версии рендера всего приложения сразу. Поэтому такой подход с оборачиванием в try\u002Fcatch не будет работать даже для первого рендера.\u003C\u002Fp\u003E\u003Ch2\u003Etry\u002Fcatch внутри компонента\u003C\u002Fh2\u003E\u003Cp\u003EПросто сделать глобальный try\u002Fcatch — интересная затея. Только вот она не работает. Может тогда просто внутри рендера в &lt;App \u002F\u003E сделать try\u002Fcatch? Прям в рендер запихать. И ведь нет никаких запретов на это. Опустим тут вопрос про декларативность, чистоту функций. Не будем разбрасываться терминами — всё же синтаксис позволяет такой пируэт:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Можно и классовый компонент взять \n\u002F\u002F и внутри render() try\u002Fcatch написать. \n\u002F\u002F Разницы нет\nconst App = () =\u003E {\n try {\n  return (\n   &lt;div\u003E\n    &lt;ChildWithError \u002F\u003E\n   &lt;\u002Fdiv\u003E\n  );\n } catch (error) {\n  console.error('App error handler: ', error);  \n  return &lt;FallbackUI\u002F\u003E;\n }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EСделал \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Foptimistic-antonelli-sbsyz?file=\u002Fsrc\u002FApp.js\"\u003Eдемку\u003C\u002Fa\u003E для такого варианта. Открываем, тыкаем в кнопку \u003Cem\u003EIncrease value\u003C\u002Fem\u003E. Когда value достигнет значения 4, &lt;ChildWithError\u002F\u003E кинет ошибку в render-функции. Но ни сообщения в консоли, ни FallbackUI нет. Как же так? Мы же знаем, что\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E&lt;div\u003E\n &lt;ChildWithError \u002F\u003E\n&lt;\u002Fdiv\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eв результате транспиляции (babel’ем, typescript’ом, кем-то ещё, кого вы выбрали) превращается в\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EReact.createElement(\n  'div', \n  null, \n  React.createElement(ChildWithError, null)\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EВот \u003Ca href=\"https:\u002F\u002Fbit.ly\u002F2VwSt23\"\u003Eтут можно поиграться с babel’ем\u003C\u002Fa\u003E, например. \u003C\u002Fp\u003E\u003Cp\u003EТо есть весь наш JSX превращается в вызовы функций. Таким образом, try\u002Fcatch должен был отловить ошибку. В чём тут подвох? Неужели React умеет останавливать вызов функции?\u003C\u002Fp\u003E\u003Ch2\u003EС чем на самом деле работает React\u003C\u002Fh2\u003E\u003Cp\u003EЕсли приглядеться, то мы видим, что в React.createElement(ChildWithError, null) нет вызова рендера ChildWithError. Погодите, а что вообще возвращает вызов React.createElement? Если кому-то интересно прям source потыкать, то вот \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002Fa724a3b578dce77d427bef313102a4d0e978d9b4\u002Fpackages\u002Freact\u002Fsrc\u002FReactElement.js#L148\"\u003Eссылка на то место, где создаётся элемент\u003C\u002Fa\u003E. В общем виде возвращается вот такой объект:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Исходник: https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002Fmain\u002Fpackages\u002Freact\u002Fsrc\u002FReactElement.js#L148\nconst element = {\n \u002F\u002F This tag allows us to uniquely identify this as a React Element\n $$typeof: REACT_ELEMENT_TYPE, \u002F\u002F Built-in properties that belong on the element\n type: type,\n key: key,\n ref: ref,\n props: props, \u002F\u002F Record the component responsible for creating this element.\n _owner: owner,\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EНа выходе render-функции мы получаем объекты, которые вложены в другие объекты. Для нашего примера мы получим объект, который описывает &lt;div\u003E, у которого в props.children будет лежать объект, который описывает &lt;ChildWithError \u002F\u003E. Попробуйте сами вывести в консоль результат вызова render-функции.\u003C\u002Fp\u003E\u003Cp\u003EПрямого вызова render-функции ChildWithError мы не видим внутри &lt;App \u002F\u003E. Мы лишь создали схему, по которой в дальнейшем будет рендерится &lt;App \u002F\u003E. \u003C\u002Fp\u003E\u003Cp\u003ERender выполняется от родителей к детям. После рендера &lt;App \u002F\u003E  внутри &lt;ChildWithError \u002F\u003E тоже создаётся объект, который описывает все элементы, возвращаемые render-функцией компонента &lt;ChildWithError \u002F\u003E. Мы как бы говорим React’у: если отренедрился &lt;App \u002F\u003E, то внутри него потом надо отрендерить &lt;ChildWithError \u002F\u003E. \u003C\u002Fp\u003E\u003Cp\u003EКстати, в этом и заключается декларативность React’а. А не в том, что мы цикл for написать в теле render-функции не можем.\u003C\u002Fp\u003E\u003Cp\u003EИ тут вы можете воскликнуть — чтобы объект такой собрать, нужно же функцию ChildWithError вызвать? Всё верно, только вызов функции ChildWithError происходит не внутри &lt;App \u002F\u003E. Он происходит совсем в другом месте. Пока что можно ограничиться таким объяснением — React сам вызывает render-функции компонентов в каком-то своём контексте. Позже я раскрою эту мысль глубже. В конкурентом режиме (он ждёт нас во всей красе в React 18) React ещё и во времени может эти вызовы раскидать так, как сам посчитает нужным.\u003C\u002Fp\u003E\u003Cp\u003EПриведу аналогию такую: componentDidUpdate не происходит же в контексте рендера, он просто запускается React’ом после того, как компонент перерендерился. Либо вот такая аналогия (которая даже ближе к истине):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Etry {\n Promise.resolve().then(() =\u003E {\n  throw new Error('wow!');\n });\n} catch (error) {\n console.log('Error from catch: ', error);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EОшибка из промиса никогда не будет поймана в catch, так как происходит в другом месте Event-loop’а. Catch — синхронный callstack задач, промис — микротаска.\u003C\u002Fp\u003E\u003Cp\u003EВ том, что React сам вызывает render-функции компонентов, легко убедиться. Достаточно в \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Foptimistic-antonelli-sbsyz?file=\u002Fsrc\u002FApp.js\"\u003Eдемке\u003C\u002Fa\u003E поменять &lt;ChildWithError \u002F\u003E на {ChildWithError()}\u003Cstrong\u003E \u003C\u002Fstrong\u003Eвнутри &lt;App \u002F\u003E. Мы прям руками сами вызовем render-функцию компонента ChildWithError внутри рендера &lt;App \u002F\u003E. Ошибка начнёт обрабатываться с помощью try\u002Fcatch. Увидим сообщение в консоли и даже fallback UI отрендерится! \u003C\u002Fp\u003E\u003Cp\u003EИ почему бы везде так не писать? Просто делать вызов функции-компонента. Должно же и работать быстрее, не придётся ждать, когда там и где React запустит рендер детей.\u003C\u002Fp\u003E\u003Cp\u003EТут я сразу отправлю читать замечательную статью Дэна Абрамова \u003Ca href=\"https:\u002F\u002Foverreacted.io\u002Freact-as-a-ui-runtime\u002F\"\u003EReact as a UI Runtime\u003C\u002Fa\u003E.  Конкретно про вызов компонента внутри рендера другого компонента можно прочитать в разделе \u003Ca href=\"https:\u002F\u002Foverreacted.io\u002Freact-as-a-ui-runtime\u002F#inversion-of-control\"\u003EInversion of Control\u003C\u002Fa\u003E и далее \u003Ca href=\"https:\u002F\u002Foverreacted.io\u002Freact-as-a-ui-runtime\u002F#lazy-evaluation\"\u003ELazy Evaluation\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cp\u003EЗабавно, но какое-то время назад ручной вызов рендера компонентов предлагался как паттерн по ускорению работы React-приложений. Вот пример, когда такой вызов может даже в ногу выстрелить:\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction Counter() {\n  const [count, setCount] = React.useState(0)\n  const increment = () =\u003E setCount(c =\u003E c + 1)\n  return &lt;button onClick={increment}\u003E{count}&lt;\u002Fbutton\u003E\n}\n\nfunction App() {\n  const [items, setItems] = React.useState([])\n  const addItem = () =\u003E setItems(i =\u003E [...i, {id: i.length}])\n  return (\n    &lt;div\u003E\n      &lt;button onClick={addItem}\u003EAdd Item&lt;\u002Fbutton\u003E\n      &lt;div\u003E{items.map(Counter)}&lt;\u002Fdiv\u003E\n    &lt;\u002Fdiv\u003E\n  )\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EПопробуйте поиграться с этим примером в \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Fempty-morning-x104i\"\u003Ecodesandbox\u003C\u002Fa\u003E. Уже после первого нажатия на \u003Cem\u003EAddItem\u003C\u002Fem\u003E мы получим ошибку, что в разных рендерах были вызваны разные хуки. А это нарушает правило использования хуков в React. Оставлю \u003Ca href=\"https:\u002F\u002Fkentcdodds.com\u002Fblog\u002Fdont-call-a-react-function-component\"\u003Eссылочку на статью Kent C. Dodds\u003C\u002Fa\u003E про этот пример.\u003C\u002Fp\u003E\u003Cp\u003EХорошо, что ребята из Facebook занимаются просветительской деятельностью. И тут не только про Дэна речь. у них есть замечательный канал на YouTube — \u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fchannel\u002FUCCQY962PmHabTjaHv2wJzfQ\"\u003EFacebook Open Source\u003C\u002Fa\u003E. Особенно нравятся их ролики в формате Explain Like I'm 5. Крайне рекомендую, чтобы самому научиться просто объяснять сложные штуки. Вот один из таких примеров:\u003C\u002Fp\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fembedd.srv.habr.com\u002Fiframe\u002F616bf155abb378f6450d1a30\" data-style=\"\" id=\"616bf155abb378f6450d1a30\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003Cp\u003EНо у нас тут не такой формат — чуть более многословный. \u003C\u002Fp\u003E\u003Cp\u003EВернёмся к обработке ошибок. Простого try\u002Fcatch внутри render() {} будет мало! А как же componentDidUpdate\u003Cstrong\u003E \u003C\u002Fstrong\u003Eи другие lifecycle-методы? Да-да, классовые компоненты ещё поддерживаются в React. Если в функциональном компоненте мы просто вообще всё обернули бы в try\u002Fcatch (опустим вопрос здравого смысла такого подхода), то в классовом компоненте придётся в каждый lifecycle-метод пихать try\u002Fcatch. Не очень изящно, да... Какой вывод? Правильно, переходим на функциональные компоненты! Там try\u002Fcatch юзать проще =)\u003C\u002Fp\u003E\u003Cp\u003EЛадно, закончим играться с try\u002Fcatch. Кажется, мы поняли, что в React мы не достигнем успеха с ним. Но, прежде чем переходить к \u003Cstrong\u003EError Boundaries,\u003C\u002Fstrong\u003E я покажу ещё \u003Ca href=\"https:\u002F\u002Fcodesandbox.io\u002Fs\u002Fintelligent-beaver-zyujd?file=\u002Fsrc\u002FApp.js\"\u003Eодну демку\u003C\u002Fa\u003E, которая точно отобьёт любое желание использовать try\u002Fcatch для отлова ошибок рендера.\u003C\u002Fp\u003E\u003Ch2\u003EСферический пример в вакууме\u003C\u002Fh2\u003E\u003Cp\u003EЧто тут у нас есть: функциональный компонент &lt;App \u002F\u003E, у которого определён внутренний стейт. Значение из этого стейта шарится по всему дочернему дереву через React.context. &lt;App \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eрендерит внутри себя компонент &lt;Child \u002F\u003E. &lt;Child \u002F\u003E обернут в HOC memo,  внутри себя рендерит компонент &lt;GrandChild \u002F\u003E.\u003C\u002Fp\u003E\u003Cp\u003EВнутри &lt;Child \u002F\u003E я использовал классический try\u002Fcatch, чтобы поймать все ошибки в рендере ниже по дереву. Внутри &lt;GrandChild \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eесть логика, что если значение из контекста будет больше 3, то бросается ошибка в рендере. Схематично это всё выглядит примерно так:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"429\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F6a3\u002Fdca\u002F216\u002F6a3dca216722c37b019353c9314f1703.png\" data-width=\"936\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EВ &lt;App \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eиспользуются getDerivedStateFromError, чтобы обновить стейт компонента &lt;App \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eв случае ошибки в дочернем дереве. Также есть componentDidCatch, в котором можно выполнить любой side effect в случае ошибки в дочернем дереве. То есть &lt;App \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eвыступает в этом приложении как \u003Cstrong\u003EError Boundary \u003C\u002Fstrong\u003E— именно он является той самой границей, за которую ошибка из дочернего дерева не пролезет дальше, вверх по дереву.\u003C\u002Fp\u003E\u003Cp\u003EЗачем всё так сложно? Да потому что! \u003C\u002Fp\u003E\u003Cp\u003EБерём и тыкаем в кнопку. Как видим, после первого клика перендерился только &lt;App \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eи &lt;GrandChild \u002F\u003E. &lt;App \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003E— потому что у него стейт поменялся, \u003Cstrong\u003E&lt;GrandChild \u002F\u003E \u003C\u002Fstrong\u003E— потому что поменялось значение в контексте. &lt;Child \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eже вообще никак не участвовал в этом процессе, так как он обернут в HOC memo. Как будто его и нет, хотя он находится, если так можно сказать, между &lt;App \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eи &lt;GrandChild \u002F\u003E. Подсветим зелёным тех ребят, кто перерендерился в этой ситуации.\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"429\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd09\u002F955\u002Fa4e\u002Fd09955a4e2a712a1987feb6fff65d7d2.png\" data-width=\"936\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EПродолжая увеличивать счётчик в &lt;App\u003E, мы дойдём до ошибки в &lt;GrandChild \u002F\u003E\u003Cstrong\u003E. \u003C\u002Fstrong\u003EКак и в прошлые разы, при увеличении счётчика &lt;Child \u002F\u003E\u003Cstrong\u003E \u003C\u002Fstrong\u003Eвновь не будет участвовать, а значит try\u002Fcatch внутри него тоже не сработает. \u003C\u002Fp\u003E\u003Cp\u003EЭта демка — простая модель, которая отражает, что React сам решает, когда и что отрендерить и в каком контексте.\u003C\u002Fp\u003E\u003Cp\u003EВот мы и увидели, как работает \u003Cstrong\u003EError Boundaries\u003C\u002Fstrong\u003E. Как пользоваться \u003Cstrong\u003EError Boundaries и \u003C\u002Fstrong\u003Eкакие у него есть ограничения, я описывать не буду. Есть \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Ferror-boundaries.html\"\u003Eссылка на доку на \u003C\u002Fa\u003E\u003Ca href=\"http:\u002F\u002Freactjs.org\u002F\"\u003EReactjs.org\u003C\u002Fa\u003E, там всё достаточно подробно описали. Кстати, там указано, а когда всё же try\u002Fcatch можно использовать. Да, мы от него полностью не отказываемся :)\u003C\u002Fp\u003E\u003Cp\u003EНо куда интереснее понять, как именно это работает в React. Это что, какой-то особый try\u002Fcatch?\u003C\u002Fp\u003E\u003Ch2\u003Etry\u002Fcatch по-React'овски\u003C\u002Fh2\u003E\u003Cp\u003EВ игру вступает магический React Fiber. Это и название архитектуры, и название сущности из внутренностей React. Информация об этой сущности открывается для широкой общественности с приходом React 16. Вот, даже \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Ffaq-internals.html\"\u003Eв официальной доке засветился\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cp\u003EКто смотрел результат вызова React.createElement в консоль, тот видел, что там выводится гораздо больше информации, нежели чем ожидается. На скрине можно увидеть только часть из того, что React туда кладёт:\u003C\u002Fp\u003E\u003Cfigure class=\"full-width \"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"550\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fa94\u002F9e6\u002F3b4\u002Fa949e63b46ce1a51f9f0803a2e945efd.png\" data-width=\"1224\"\u002F\u003E\u003Cfigcaption\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EСуть вот в чём: помимо дерева React-элементов\u002Fкомпонентов, существует ещё и набор неких Fiber-нод, которые к этим элементам\u002Fкомпонентам привязаны. В этих нодах содержится внутреннее состояние (полезное только для React) React-элемента\u002Fкомпонента: какие были пропсы ранее, какой следующий effect запустить, нужно ли рендерить компонент сейчас и т. д. \u003C\u002Fp\u003E\u003Cp\u003EПодробно про Fiber-архитектуру можно почитать в блоге \u003Ca href=\"https:\u002F\u002Findepth.dev\u002Fposts\u002F1008\u002Finside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react\"\u003EinDepth.dev\u003C\u002Fa\u003E или в статье от одного из ключевых разработчиков из React-core — \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Facdlite\u002Freact-fiber-architecture\"\u003Eacdlite\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cp\u003EИмея это внутреннее представление, React уже знает, что делать с ошибкой, которая случилась во время фазы рендера конкретного компонента. То есть React может остановить рендер текущего дерева компонентов, отыскать ближайший сверху компонент, в котором есть или getDerivedStateFromError, или componentDidCatch — хотя бы кто-то один. Имея ссылки на родителей в FiberNode (\u003Ca href=\"https:\u002F\u002Findepth.dev\u002Fposts\u002F1007\u002Fthe-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree\"\u003Eтам в связном списке всё лежит\u003C\u002Fa\u003E), сделать это проще простого. Вот есть \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002Fbc9bb87c2b01bff8a15e02c8416addf6177e9055\u002Fpackages\u002Freact-reconciler\u002Fsrc\u002FReactFiberThrow.new.js\"\u003Esource-код\u003C\u002Fa\u003E, в котором можно посмотреть, как это примерно работает.  \u003C\u002Fp\u003E\u003Cp\u003EНапример, вот \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002Fbc9bb87c2b01bff8a15e02c8416addf6177e9055\u002Fpackages\u002Freact-reconciler\u002Fsrc\u002FReactFiberThrow.new.js#L460\"\u003Eфункция\u003C\u002Fa\u003E, в которой определяется, имеет ли компонент методы \u003Cstrong\u003EError Boundaries\u003C\u002Fstrong\u003E. А вот \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002Fbc9bb87c2b01bff8a15e02c8416addf6177e9055\u002Fpackages\u002Freact-reconciler\u002Fsrc\u002FReactFiberWorkLoop.new.js\"\u003Eисходник\u003C\u002Fa\u003E того, как организован внутренний так называемый workLoop в React. Тут же можно понять, что никакой магии в React нет — внутри всё же \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002Fbc9bb87c2b01bff8a15e02c8416addf6177e9055\u002Fpackages\u002Freact-reconciler\u002Fsrc\u002FReactFiberWorkLoop.new.js#L1582\"\u003Eиспользуется старый добрый try\u002Fcatch\u003C\u002Fa\u003E для отлова ошибок. Почти как в нашем абстрактном примере, который я привел в начале статьи.\u003C\u002Fp\u003E\u003Cp\u003EДля классического React с синхронным рендером используется \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Freact\u002Fblob\u002Fbc9bb87c2b01bff8a15e02c8416addf6177e9055\u002Fpackages\u002Freact-reconciler\u002Fsrc\u002FReactFiberWorkLoop.new.js#L1496\"\u003Eтот же подход\u003C\u002Fa\u003E. Просто функция для workLoop используется другая. Впрочем, конкурентый React (18 версия и более новые) — это совсем другая история. Рекомендую открыть ссылки и поизучать их отдельно после прочтения этой статьи.\u003C\u002Fp\u003E\u003Cp\u003EВ общем виде это выглядит так:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EЗапускаем рендер компонента.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EЕсли во время workLoop была ошибка, она будет поймана в try\u002Fcatch и обработана.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ списке FiberNode ищем компонент-родитель с необходимыми методами (getDerivedStateFromError или componentDidCatch).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EНашли — React считает ошибку обработанной.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВсе ветки отрендеренного дерева можно не выбрасывать. Отбросим только ту ветку, где была ошибка — ровно до того места, где мы определили \u003Cstrong\u003EError Boundaries,\u003C\u002Fstrong\u003E границы распространения этой ошибки.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EЕсли можно было бы представить работу с React, как с живым человеком, то общение с ним выглядело бы как-то так (своего рода объяснение в стиле Explain Like I'm 5):\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EПривет, я — React. \nСпасибо за инструкции в JSX о том, что куда рендерить.\nДальше я сам все буду делать. Можешь расслабиться) \n\ntry {\n  *React изображает бурную деятельность*\n} catch (error) {\n  Ну вот, опять ошибка. \n  Пойду искать родителей этого негодяя, который ошибку бросил.\n  Может они хоть что-то с ошибкой этой сделают.\n  Ну а то, что я уже сделал у других родителей — выбрасывать не буду.\n  Зря работал что ли?\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003EThe message\u003C\u002Fh2\u003E\u003Cp\u003EТакое копание в реализации какой-либо фичи порой дает интересные результаты. Можно иначе взглянуть на давно уже знакомую библиотеку\u002Fфреймворк. Или просто лучше понять, как использовать свой инструмент по-максимуму. Рекомендую всем иногда погружаться в какой-либо аспект в реализации вашего любимого JS-решения. Я точно уверен, что это путешествие окупится.\u003C\u002Fp\u003E\u003Ch2\u003EСписок литературы\u003C\u002Fh2\u003E\u003Cp\u003EДа-да, прям как в рефератах) Ссылок много, хочется, чтобы к ним легко можно было вернуться:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Ferror-boundaries.html\"\u003EError Boundaries, документация React\u003C\u002Fa\u003E. Описание того, как обработать ошибки у вас в приложении\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСтатья Дэна Абрамова \u003Ca href=\"https:\u002F\u002Foverreacted.io\u002Freact-as-a-ui-runtime\u002F\"\u003EReact as a UI Runtime\u003C\u002Fa\u003E. Дэн достаточно глубоко описывает то, как работает React.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСтатья Kent C. Dodds \u003Ca href=\"https:\u002F\u002Fkentcdodds.com\u002Fblog\u002Fdont-call-a-react-function-component\"\u003EDon't call a React function component\u003C\u002Fa\u003E. Наглядное объяснение, почему не стоит самому вызывать render-компоненты.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fchannel\u002FUCCQY962PmHabTjaHv2wJzfQ\"\u003EFacebook Open Source\u003C\u002Fa\u003E. Youtube-канал разработчиков из Facebook.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Findepth.dev\u002Fposts\u002F1008\u002Finside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react\"\u003EInside Fiber: in-depth overview of the new reconciliation algorithm in React\u003C\u002Fa\u003E. Достаточно хардкорная статья про новую архитектуру React. На этом же ресурсе есть еще одна замечательная статья: \u003Ca href=\"https:\u002F\u002Findepth.dev\u002Fposts\u002F1007\u002Fthe-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree\"\u003EThe how and why on React’s usage of linked list in Fiber to walk the component’s tree\u003C\u002Fa\u003E. В общем, это для тех, кто хочет прям глубже погрузиться в то, как устроен React изнутри.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Facdlite\u002Freact-fiber-architecture\"\u003EReact Fiber Architecture\u003C\u002Fa\u003E. Чуть менее хардкорное описание Fiber-архитектуры. \u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"react"},{"titleHtml":"javascript"},{"titleHtml":"как работает"},{"titleHtml":"react.js"},{"titleHtml":"reactjs"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2c4\u002F0e9\u002F9b9\u002F2c40e99b907564bb9fb134e3096af71f.png","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2c4\u002F0e9\u002F9b9\u002F2c40e99b907564bb9fb134e3096af71f.png","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002F2gis\\\u002Fblog\\\u002F583894\\\u002F\"},\"headline\":\"Error Boundaries в React: препарируем лягушку\",\"datePublished\":\"2021-10-19T06:58:09+03:00\",\"dateModified\":\"2021-10-19T06:58:09+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Artem Malko\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку &laquo;Написать...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002F2gis\\\u002Fblog\\\u002F583894\\\u002F#post-content-body\",\"about\":[\"c_2gis\",\"h_javascript\",\"h_programming\",\"h_reactjs\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F583894\\\u002Fe1001b884b99b4a6876c78cb262ab78f\\\u002F\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F2c4\\\u002F0e9\\\u002F9b9\\\u002F2c40e99b907564bb9fb134e3096af71f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002F6a3\\\u002Fdca\\\u002F216\\\u002F6a3dca216722c37b019353c9314f1703.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fd09\\\u002F955\\\u002Fa4e\\\u002Fd09955a4e2a712a1987feb6fff65d7d2.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fupload_files\\\u002Fa94\\\u002F9e6\\\u002F3b4\\\u002Fa949e63b46ce1a51f9f0803a2e945efd.png\"]}","metaDescription":"Представим, что у нас есть приложение на React, в котором можно читать и писать отзывы. Пользователь открыл список отзывов, пролистал его, нажал кнопку «Написать отзыв». Форма написания отзыва...","mainImageUrl":null,"amp":true},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"2gis":{"alias":"2gis","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F995\u002F27f\u002F562\u002F99527f562a8700893d39f73e6d2e7e07.png","titleHtml":"2ГИС","descriptionHtml":"Главные по городской навигации","relatedData":null,"statistics":{"postsCount":205,"newsCount":2,"vacanciesCount":29,"employeesCount":96,"careerRating":null,"subscribersCount":68303,"rating":123.57,"invest":null},"foundationDate":{"year":"1999","month":"04","day":"25"},"location":{"city":{"id":"447315","title":"Новосибирск"},"region":{"id":"1906","title":"Новосибирская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"http:\u002F\u002F2gis.ru\u002F","staffNumber":"1 001–5 000 человек","registrationDate":"2008-08-09T07:43:03+00:00","representativeUser":null,"contacts":[],"settings":{"analyticsSettings":[{"type":"ga","trackingId":"UA-107124300-1"}],"branding":null,"status":"active"},"metadata":{"titleHtml":"2ГИС, Новосибирск - Главные по городской навигации с 25 апреля 1999 г.","title":"2ГИС, Новосибирск - Главные по городской навигации с 25 апреля 1999 г.","keywords":["Разработка мобильных приложений","Геоинформационные сервисы","JavaScript","Разработка под iOS","Разработка под Android"],"descriptionHtml":"205 статей от авторов компании 2ГИС","description":"205 статей от авторов компании 2ГИС"},"aDeskSettings":null,"careerAlias":"2gis","maxCustomTrackerLinks":0}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
